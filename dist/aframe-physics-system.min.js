(()=>{var __webpack_modules__={10:(module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(421);\n__webpack_require__(854);\n__webpack_require__(938)\n__webpack_require__(592);\n__webpack_require__(855);\n\nmodule.exports = {\n  registerAll: function () {\n    console.warn('registerAll() is deprecated. Components are automatically registered.');\n  }\n};\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./index.js?")},261:()=>{eval("AFRAME.registerComponent('stats-panel', {\r\n  schema: {\r\n    merge: {type: 'boolean', default: true}\r\n  },\r\n\r\n  init() {\r\n\r\n    const container = document.querySelector('.rs-container')\r\n\r\n    if (container && this.data.merge) {\r\n      //stats panel exists, just merge into it.\r\n      this.container = container\r\n      return;\r\n    }\r\n\r\n    // if stats panel doesn't exist, add one to support our custom stats.\r\n    this.base = document.createElement('div')\r\n    this.base.classList.add('rs-base')\r\n    const body = document.body || document.getElementsByTagName('body')[0]\r\n\r\n    if (container && !this.data.merge) {\r\n      this.base.style.top = \"auto\"\r\n      this.base.style.bottom = \"20px\"\r\n    }\r\n\r\n    body.appendChild(this.base)\r\n\r\n    this.container = document.createElement('div')\r\n    this.container.classList.add('rs-container')\r\n    this.base.appendChild(this.container)\r\n  }\r\n});\r\n\r\nAFRAME.registerComponent('stats-group', {\r\n  multiple: true,\r\n  schema: {\r\n    label: {type: 'string'}\r\n  },\r\n\r\n  init() {\r\n\r\n    let container\r\n    const baseComponent = this.el.components['stats-panel']\r\n    if (baseComponent) {\r\n      container = baseComponent.container\r\n    }\r\n    else {\r\n      container = document.querySelector('.rs-container')\r\n    }\r\n\r\n    if (!container) {\r\n      console.warn(`Couldn't find stats container to add stats to.\r\n                    Add either stats or stats-panel component to a-scene`)\r\n      return;\r\n    }\r\n    \r\n    this.groupHeader = document.createElement('h1')\r\n    this.groupHeader.innerHTML = this.data.label\r\n    container.appendChild(this.groupHeader)\r\n\r\n    this.group = document.createElement('div')\r\n    this.group.classList.add('rs-group')\r\n    // rs-group hs style flex-direction of 'column-reverse'\r\n    // No idea why it's like that, but it's not what we want for our stats.\r\n    // We prefer them rendered in the order speified.\r\n    // So override this style.\r\n    this.group.style.flexDirection = 'column'\r\n    this.group.style.webKitFlexDirection = 'column'\r\n    container.appendChild(this.group)\r\n  }\r\n});\r\n\r\nAFRAME.registerComponent('stats-row', {\r\n  multiple: true,\r\n  schema: {\r\n    // name of the group to add the stats row to.\r\n    group: {type: 'string'},\r\n\r\n    // name of an event to listen for\r\n    event: {type: 'string'},\r\n\r\n    // property from event to output in stats panel\r\n    properties: {type: 'array'},\r\n\r\n    // label for the row in the stats panel\r\n    label: {type: 'string'}\r\n  },\r\n\r\n  init () {\r\n\r\n    const groupComponentName = \"stats-group__\" + this.data.group\r\n    const groupComponent = this.el.components[groupComponentName] ||\r\n                           this.el.sceneEl.components[groupComponentName] ||\r\n                           this.el.components[\"stats-group\"] ||\r\n                           this.el.sceneEl.components[\"stats-group\"]\r\n\r\n    if (!groupComponent) {\r\n      console.warn(`Couldn't find stats group ${groupComponentName}`)\r\n      return;\r\n    }\r\n  \r\n    this.counter = document.createElement('div')\r\n    this.counter.classList.add('rs-counter-base')\r\n    groupComponent.group.appendChild(this.counter)\r\n\r\n    this.counterId = document.createElement('div')\r\n    this.counterId.classList.add('rs-counter-id')\r\n    this.counterId.innerHTML = this.data.label\r\n    this.counter.appendChild(this.counterId)\r\n\r\n    this.counterValues = {}\r\n    this.data.properties.forEach((property) => {\r\n      const counterValue = document.createElement('div')\r\n      counterValue.classList.add('rs-counter-value')\r\n      counterValue.innerHTML = \"...\"\r\n      this.counter.appendChild(counterValue)\r\n      this.counterValues[property] = counterValue\r\n    })\r\n\r\n    this.updateData = this.updateData.bind(this)\r\n    this.el.addEventListener(this.data.event, this.updateData)\r\n\r\n    this.splitCache = {}\r\n  },\r\n\r\n  updateData(e) {\r\n    \r\n    this.data.properties.forEach((property) => {\r\n      const split = this.splitDot(property);\r\n      let value = e.detail;\r\n      for (i = 0; i < split.length; i++) {\r\n        value = value[split[i]];\r\n      }\r\n      this.counterValues[property].innerHTML = value\r\n    })\r\n  },\r\n\r\n  splitDot (path) {\r\n    if (path in this.splitCache) { return this.splitCache[path]; }\r\n    this.splitCache[path] = path.split('.');\r\n    return this.splitCache[path];\r\n  }\r\n\r\n});\r\n\r\nAFRAME.registerComponent('stats-collector', {\r\n  multiple: true,\r\n\r\n  schema: {\r\n    // name of an event to listen for\r\n    inEvent: {type: 'string'},\r\n\r\n    // property from event to output in stats panel\r\n    properties: {type: 'array'},\r\n\r\n    // frequency of output in terms of events received.\r\n    outputFrequency: {type: 'number', default: 100},\r\n\r\n    // name of event to emit\r\n    outEvent: {type: 'string'},\r\n    \r\n    // outputs (generated for each property)\r\n    // Combination of: mean, max, percentile__XX.X (where XX.X is a number)\r\n    outputs: {type: 'array'},\r\n\r\n    // Whether to output to console as well as generating events\r\n    // If a string is specified, this is output to console, together with the event data\r\n    // If no string is specified, nothing is output to console.\r\n    outputToConsole: {type: 'string'}\r\n  },\r\n\r\n  init() {\r\n    \r\n    this.statsData = {}\r\n    this.resetData()\r\n    this.outputDetail = {}\r\n    this.data.properties.forEach((property) => {\r\n      this.outputDetail[property] = {}\r\n    })\r\n\r\n    this.statsReceived = this.statsReceived.bind(this)\r\n    this.el.addEventListener(this.data.inEvent, this.statsReceived)\r\n  },\r\n  \r\n  resetData() {\r\n\r\n    this.counter = 0\r\n    this.data.properties.forEach((property) => {\r\n      \r\n      // For calculating percentiles like 0.01 and 99.9% we'll want to store\r\n      // additional data - something like this...\r\n      // Store off outliers, and discard data.\r\n      // const min = Math.min(...this.statsData[property])\r\n      // this.lowOutliers[property].push(min)\r\n      // const max = Math.max(...this.statsData[property])\r\n      // this.highOutliers[property].push(max)\r\n\r\n      this.statsData[property] = []\r\n    })\r\n  },\r\n\r\n  statsReceived(e) {\r\n\r\n    this.updateData(e.detail)\r\n\r\n    this.counter++ \r\n    if (this.counter === this.data.outputFrequency) {\r\n      this.outputData()\r\n      this.resetData()\r\n    }\r\n  },\r\n\r\n  updateData(detail) {\r\n\r\n    this.data.properties.forEach((property) => {\r\n      let value = detail;\r\n      value = value[property];\r\n      this.statsData[property].push(value)\r\n    })\r\n  },\r\n\r\n  outputData() {\r\n    this.data.properties.forEach((property) => {\r\n      this.data.outputs.forEach((output) => {\r\n        this.outputDetail[property][output] = this.computeOutput(output, this.statsData[property])\r\n      })\r\n    })\r\n\r\n    if (this.data.outEvent) {\r\n      this.el.emit(this.data.outEvent, this.outputDetail)\r\n    }\r\n\r\n    if (this.data.outputToConsole) {\r\n      console.log(this.data.outputToConsole, this.outputDetail)\r\n    }\r\n  },\r\n\r\n  computeOutput(outputInstruction, data) {\r\n\r\n    const outputInstructions = outputInstruction.split(\"__\")\r\n    const outputType = outputInstructions[0]\r\n    let output\r\n\r\n    switch (outputType) {\r\n      case \"mean\":\r\n        output = data.reduce((a, b) => a + b, 0) / data.length;\r\n        break;\r\n      \r\n      case \"max\":\r\n        output = Math.max(...data)\r\n        break;\r\n\r\n      case \"min\":\r\n        output = Math.min(...data)\r\n        break;\r\n\r\n      case \"percentile\":\r\n        const sorted = data.sort((a, b) => a - b)\r\n        // decimal percentiles encoded like 99+9 rather than 99.9 due to \".\" being used as a \r\n        // separator for nested properties.\r\n        const percentileString = outputInstructions[1].replace(\"_\", \".\")\r\n        const proportion = +percentileString / 100\r\n\r\n        // Note that this calculation of the percentile is inaccurate when there is insufficient data\r\n        // e.g. for 0.1th or 99.9th percentile when only 100 data points.\r\n        // Greater accuracy would require storing off more data (specifically outliers) and folding these\r\n        // into the computation.\r\n        const position = (data.length - 1) * proportion\r\n        const base = Math.floor(position)\r\n        const delta = position - base;\r\n        if (sorted[base + 1] !== undefined) {\r\n            output = sorted[base] + delta * (sorted[base + 1] - sorted[base]);\r\n        } else {\r\n            output = sorted[base];\r\n        }\r\n        break;\r\n    }\r\n    return output.toFixed(2)\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./node_modules/aframe-stats-panel/index.js?")},694:()=>{eval('/* global Ammo,THREE */\n\nTHREE.AmmoDebugConstants = {\n  NoDebug: 0,\n  DrawWireframe: 1,\n  DrawAabb: 2,\n  DrawFeaturesText: 4,\n  DrawContactPoints: 8,\n  NoDeactivation: 16,\n  NoHelpText: 32,\n  DrawText: 64,\n  ProfileTimings: 128,\n  EnableSatComparison: 256,\n  DisableBulletLCP: 512,\n  EnableCCD: 1024,\n  DrawConstraints: 1 << 11, //2048\n  DrawConstraintLimits: 1 << 12, //4096\n  FastWireframe: 1 << 13, //8192\n  DrawNormals: 1 << 14, //16384\n  DrawOnTop: 1 << 15, //32768\n  MAX_DEBUG_DRAW_MODE: 0xffffffff\n};\n\n/**\n * An implementation of the btIDebugDraw interface in Ammo.js, for debug rendering of Ammo shapes\n * @class AmmoDebugDrawer\n * @param {THREE.Scene} scene\n * @param {Ammo.btCollisionWorld} world\n * @param {object} [options]\n */\nTHREE.AmmoDebugDrawer = function(scene, world, options) {\n  this.scene = scene;\n  this.world = world;\n  options = options || {};\n\n  this.debugDrawMode = options.debugDrawMode || THREE.AmmoDebugConstants.DrawWireframe;\n  var drawOnTop = this.debugDrawMode & THREE.AmmoDebugConstants.DrawOnTop || false;\n  var maxBufferSize = options.maxBufferSize || 1000000;\n\n  this.geometry = new THREE.BufferGeometry();\n  var vertices = new Float32Array(maxBufferSize * 3);\n  var colors = new Float32Array(maxBufferSize * 3);\n\n  this.geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3).setUsage(THREE.DynamicDrawUsage));\n  this.geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));\n\n  this.index = 0;\n\n  var material = new THREE.LineBasicMaterial({\n    vertexColors: true,\n    depthTest: !drawOnTop\n  });\n\n  this.mesh = new THREE.LineSegments(this.geometry, material);\n  if (drawOnTop) this.mesh.renderOrder = 999;\n  this.mesh.frustumCulled = false;\n\n  this.enabled = false;\n\n  this.debugDrawer = new Ammo.DebugDrawer();\n  this.debugDrawer.drawLine = this.drawLine.bind(this);\n  this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this);\n  this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this);\n  this.debugDrawer.draw3dText = this.draw3dText.bind(this);\n  this.debugDrawer.setDebugMode = this.setDebugMode.bind(this);\n  this.debugDrawer.getDebugMode = this.getDebugMode.bind(this);\n  this.debugDrawer.enable = this.enable.bind(this);\n  this.debugDrawer.disable = this.disable.bind(this);\n  this.debugDrawer.update = this.update.bind(this);\n\n  this.world.setDebugDrawer(this.debugDrawer);\n};\n\nTHREE.AmmoDebugDrawer.prototype = function() {\n  return this.debugDrawer;\n};\n\nTHREE.AmmoDebugDrawer.prototype.enable = function() {\n  this.enabled = true;\n  this.scene.add(this.mesh);\n};\n\nTHREE.AmmoDebugDrawer.prototype.disable = function() {\n  this.enabled = false;\n  this.scene.remove(this.mesh);\n};\n\nTHREE.AmmoDebugDrawer.prototype.update = function() {\n  if (!this.enabled) {\n    return;\n  }\n\n  if (this.index != 0) {\n    this.geometry.attributes.position.needsUpdate = true;\n    this.geometry.attributes.color.needsUpdate = true;\n  }\n\n  this.index = 0;\n\n  this.world.debugDrawWorld();\n\n  this.geometry.setDrawRange(0, this.index);\n};\n\nTHREE.AmmoDebugDrawer.prototype.drawLine = function(from, to, color) {\n  const heap = Ammo.HEAPF32;\n  const r = heap[(color + 0) / 4];\n  const g = heap[(color + 4) / 4];\n  const b = heap[(color + 8) / 4];\n\n  const fromX = heap[(from + 0) / 4];\n  const fromY = heap[(from + 4) / 4];\n  const fromZ = heap[(from + 8) / 4];\n  this.geometry.attributes.position.setXYZ(this.index, fromX, fromY, fromZ);\n  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);\n\n  const toX = heap[(to + 0) / 4];\n  const toY = heap[(to + 4) / 4];\n  const toZ = heap[(to + 8) / 4];\n  this.geometry.attributes.position.setXYZ(this.index, toX, toY, toZ);\n  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);\n};\n\n//TODO: figure out how to make lifeTime work\nTHREE.AmmoDebugDrawer.prototype.drawContactPoint = function(pointOnB, normalOnB, distance, lifeTime, color) {\n  const heap = Ammo.HEAPF32;\n  const r = heap[(color + 0) / 4];\n  const g = heap[(color + 4) / 4];\n  const b = heap[(color + 8) / 4];\n\n  const x = heap[(pointOnB + 0) / 4];\n  const y = heap[(pointOnB + 4) / 4];\n  const z = heap[(pointOnB + 8) / 4];\n  this.geometry.attributes.position.setXYZ(this.index, x, y, z);\n  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);\n\n  const dx = heap[(normalOnB + 0) / 4] * distance;\n  const dy = heap[(normalOnB + 4) / 4] * distance;\n  const dz = heap[(normalOnB + 8) / 4] * distance;\n  this.geometry.attributes.position.setXYZ(this.index, x + dx, y + dy, z + dz);\n  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);\n};\n\nTHREE.AmmoDebugDrawer.prototype.reportErrorWarning = function(warningString) {\n  if (Ammo.hasOwnProperty("Pointer_stringify")) {\n    console.warn(Ammo.Pointer_stringify(warningString));\n  } else if (!this.warnedOnce) {\n    this.warnedOnce = true;\n    console.warn("Cannot print warningString, please rebuild Ammo.js using \'debug\' flag");\n  }\n};\n\nTHREE.AmmoDebugDrawer.prototype.draw3dText = function(location, textString) {\n  //TODO\n  console.warn("TODO: draw3dText");\n};\n\nTHREE.AmmoDebugDrawer.prototype.setDebugMode = function(debugMode) {\n  this.debugDrawMode = debugMode;\n};\n\nTHREE.AmmoDebugDrawer.prototype.getDebugMode = function() {\n  return this.debugDrawMode;\n};\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./node_modules/ammo-debug-drawer/AmmoDebugDrawer.js?')},812:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  FIT: () => (/* binding */ FIT),\n  HEIGHTFIELD_DATA_TYPE: () => (/* binding */ HEIGHTFIELD_DATA_TYPE),\n  TYPE: () => (/* binding */ TYPE),\n  createBoxShape: () => (/* binding */ createBoxShape),\n  createCapsuleShape: () => (/* binding */ createCapsuleShape),\n  createCollisionShapes: () => (/* binding */ createCollisionShapes),\n  createConeShape: () => (/* binding */ createConeShape),\n  createCylinderShape: () => (/* binding */ createCylinderShape),\n  createHACDShapes: () => (/* binding */ createHACDShapes),\n  createHeightfieldTerrainShape: () => (/* binding */ createHeightfieldTerrainShape),\n  createHullShape: () => (/* binding */ createHullShape),\n  createSphereShape: () => (/* binding */ createSphereShape),\n  createTriMeshShape: () => (/* binding */ createTriMeshShape),\n  createVHACDShapes: () => (/* binding */ createVHACDShapes),\n  iterateGeometries: () => (/* binding */ iterateGeometries)\n});\n\n;// CONCATENATED MODULE: external "THREE"\nconst external_THREE_namespaceObject = THREE;\n;// CONCATENATED MODULE: ./node_modules/three-to-ammo/index.js\n\n/* global Ammo */\n\n\nconst TYPE = {\n  BOX: "box",\n  CYLINDER: "cylinder",\n  SPHERE: "sphere",\n  CAPSULE: "capsule",\n  CONE: "cone",\n  HULL: "hull",\n  HACD: "hacd", //Hierarchical Approximate Convex Decomposition\n  VHACD: "vhacd", //Volumetric Hierarchical Approximate Convex Decomposition\n  MESH: "mesh",\n  HEIGHTFIELD: "heightfield"\n};\n\nconst FIT = {\n  ALL: "all", //A single shape is automatically sized to bound all meshes within the entity.\n  MANUAL: "manual" //A single shape is sized manually. Requires halfExtents or sphereRadius.\n};\n\nconst HEIGHTFIELD_DATA_TYPE = {\n  short: "short",\n  float: "float"\n};\n\nconst createCollisionShapes = function(vertices, matrices, indexes, matrixWorld, options = {}) {\n  switch (options.type) {\n    case TYPE.BOX:\n      return [createBoxShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.CYLINDER:\n      return [createCylinderShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.CAPSULE:\n      return [createCapsuleShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.CONE:\n      return [createConeShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.SPHERE:\n      return [createSphereShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.HULL:\n      return [createHullShape(vertices, matrices, matrixWorld, options)];\n    case TYPE.HACD:\n      return createHACDShapes(vertices, matrices, indexes, matrixWorld, options);\n    case TYPE.VHACD:\n      return createVHACDShapes(vertices, matrices, indexes, matrixWorld, options);\n    case TYPE.MESH:\n      return [createTriMeshShape(vertices, matrices, indexes, matrixWorld, options)];\n    case TYPE.HEIGHTFIELD:\n      return [createHeightfieldTerrainShape(options)];\n    default:\n      console.warn(options.type + " is not currently supported");\n      return [];\n  }\n};\n\n//TODO: support gimpact (dynamic trimesh) and heightmap\n\nconst createBoxShape = function(vertices, matrices, matrixWorld, options = {}) {\n  options.type = TYPE.BOX;\n  _setOptions(options);\n\n  if (options.fit === FIT.ALL) {\n    options.halfExtents = _computeHalfExtents(\n      _computeBounds(vertices, matrices),\n      options.minHalfExtent,\n      options.maxHalfExtent\n    );\n  }\n\n  const btHalfExtents = new Ammo.btVector3(options.halfExtents.x, options.halfExtents.y, options.halfExtents.z);\n  const collisionShape = new Ammo.btBoxShape(btHalfExtents);\n  Ammo.destroy(btHalfExtents);\n\n  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n  return collisionShape;\n};\n\nconst createCylinderShape = function(vertices, matrices, matrixWorld, options = {}) {\n  options.type = TYPE.CYLINDER;\n  _setOptions(options);\n\n  if (options.fit === FIT.ALL) {\n    options.halfExtents = _computeHalfExtents(\n      _computeBounds(vertices, matrices),\n      options.minHalfExtent,\n      options.maxHalfExtent\n    );\n  }\n\n  const btHalfExtents = new Ammo.btVector3(options.halfExtents.x, options.halfExtents.y, options.halfExtents.z);\n  const collisionShape = (() => {\n    switch (options.cylinderAxis) {\n      case "y":\n        return new Ammo.btCylinderShape(btHalfExtents);\n      case "x":\n        return new Ammo.btCylinderShapeX(btHalfExtents);\n      case "z":\n        return new Ammo.btCylinderShapeZ(btHalfExtents);\n    }\n    return null;\n  })();\n  Ammo.destroy(btHalfExtents);\n\n  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n  return collisionShape;\n};\n\nconst createCapsuleShape = function(vertices, matrices, matrixWorld, options = {}) {\n  options.type = TYPE.CAPSULE;\n  _setOptions(options);\n\n  if (options.fit === FIT.ALL) {\n    options.halfExtents = _computeHalfExtents(\n      _computeBounds(vertices, matrices),\n      options.minHalfExtent,\n      options.maxHalfExtent\n    );\n  }\n\n  const { x, y, z } = options.halfExtents;\n  const collisionShape = (() => {\n    switch (options.cylinderAxis) {\n      case "y":\n        return new Ammo.btCapsuleShape(Math.max(x, z), y * 2);\n      case "x":\n        return new Ammo.btCapsuleShapeX(Math.max(y, z), x * 2);\n      case "z":\n        return new Ammo.btCapsuleShapeZ(Math.max(x, y), z * 2);\n    }\n    return null;\n  })();\n\n  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n  return collisionShape;\n};\n\nconst createConeShape = function(vertices, matrices, matrixWorld, options = {}) {\n  options.type = TYPE.CONE;\n  _setOptions(options);\n\n  if (options.fit === FIT.ALL) {\n    options.halfExtents = _computeHalfExtents(\n      _computeBounds(vertices, matrices),\n      options.minHalfExtent,\n      options.maxHalfExtent\n    );\n  }\n\n  const { x, y, z } = options.halfExtents;\n  const collisionShape = (() => {\n    switch (options.cylinderAxis) {\n      case "y":\n        return new Ammo.btConeShape(Math.max(x, z), y * 2);\n      case "x":\n        return new Ammo.btConeShapeX(Math.max(y, z), x * 2);\n      case "z":\n        return new Ammo.btConeShapeZ(Math.max(x, y), z * 2);\n    }\n    return null;\n  })();\n\n  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n  return collisionShape;\n};\n\nconst createSphereShape = function(vertices, matrices, matrixWorld, options = {}) {\n  options.type = TYPE.SPHERE;\n  _setOptions(options);\n\n  let radius;\n  if (options.fit === FIT.MANUAL && !isNaN(options.sphereRadius)) {\n    radius = options.sphereRadius;\n  } else {\n    radius = _computeRadius(vertices, matrices, _computeBounds(vertices, matrices));\n  }\n\n  const collisionShape = new Ammo.btSphereShape(radius);\n  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n\n  return collisionShape;\n};\n\nconst createHullShape = (function() {\n  const vertex = new external_THREE_namespaceObject.Vector3();\n  const center = new external_THREE_namespaceObject.Vector3();\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(vertices, matrices, matrixWorld, options = {}) {\n    options.type = TYPE.HULL;\n    _setOptions(options);\n\n    if (options.fit === FIT.MANUAL) {\n      console.warn("cannot use fit: manual with type: hull");\n      return null;\n    }\n\n    const bounds = _computeBounds(vertices, matrices);\n\n    const btVertex = new Ammo.btVector3();\n    const originalHull = new Ammo.btConvexHullShape();\n    originalHull.setMargin(options.margin);\n    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);\n\n    let vertexCount = 0;\n    for (let i = 0; i < vertices.length; i++) {\n      vertexCount += vertices[i].length / 3;\n    }\n\n    const maxVertices = options.hullMaxVertices || 100000;\n    // todo: might want to implement this in a deterministic way that doesn\'t do O(verts) calls to Math.random\n    if (vertexCount > maxVertices) {\n      console.warn(`too many vertices for hull shape; sampling ~${maxVertices} from ~${vertexCount} vertices`);\n    }\n    const p = Math.min(1, maxVertices / vertexCount);\n\n    for (let i = 0; i < vertices.length; i++) {\n      const components = vertices[i];\n      matrix.fromArray(matrices[i]);\n      for (let j = 0; j < components.length; j += 3) {\n        const isLastVertex = i === vertices.length - 1 && j === components.length - 3;\n        if (Math.random() <= p || isLastVertex) {\n          // always include the last vertex\n          vertex\n            .set(components[j], components[j + 1], components[j + 2])\n            .applyMatrix4(matrix)\n            .sub(center);\n          btVertex.setValue(vertex.x, vertex.y, vertex.z);\n          originalHull.addPoint(btVertex, isLastVertex); // recalc AABB only on last geometry\n        }\n      }\n    }\n\n    let collisionShape = originalHull;\n    if (originalHull.getNumVertices() >= 100) {\n      //Bullet documentation says don\'t use convexHulls with 100 verts or more\n      const shapeHull = new Ammo.btShapeHull(originalHull);\n      shapeHull.buildHull(options.margin);\n      Ammo.destroy(originalHull);\n      collisionShape = new Ammo.btConvexHullShape(\n        Ammo.getPointer(shapeHull.getVertexPointer()),\n        shapeHull.numVertices()\n      );\n      Ammo.destroy(shapeHull); // btConvexHullShape makes a copy\n    }\n\n    Ammo.destroy(btVertex);\n\n    _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));\n    return collisionShape;\n  };\n})();\n\nconst createHACDShapes = (function() {\n  const vector = new external_THREE_namespaceObject.Vector3();\n  const center = new external_THREE_namespaceObject.Vector3();\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(vertices, matrices, indexes, matrixWorld, options = {}) {\n    options.type = TYPE.HACD;\n    _setOptions(options);\n\n    if (options.fit === FIT.MANUAL) {\n      console.warn("cannot use fit: manual with type: hacd");\n      return [];\n    }\n\n    if (!Ammo.hasOwnProperty("HACD")) {\n      console.warn(\n        "HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."\n      );\n      return [];\n    }\n\n    const bounds = _computeBounds(vertices, matrices);\n    const scale = _computeScale(matrixWorld, options);\n\n    let vertexCount = 0;\n    let triCount = 0;\n    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);\n\n    for (let i = 0; i < vertices.length; i++) {\n      vertexCount += vertices[i].length / 3;\n      if (indexes && indexes[i]) {\n        triCount += indexes[i].length / 3;\n      } else {\n        triCount += vertices[i].length / 9;\n      }\n    }\n\n    const hacd = new Ammo.HACD();\n    if (options.hasOwnProperty("compacityWeight")) hacd.SetCompacityWeight(options.compacityWeight);\n    if (options.hasOwnProperty("volumeWeight")) hacd.SetVolumeWeight(options.volumeWeight);\n    if (options.hasOwnProperty("nClusters")) hacd.SetNClusters(options.nClusters);\n    if (options.hasOwnProperty("nVerticesPerCH")) hacd.SetNVerticesPerCH(options.nVerticesPerCH);\n    if (options.hasOwnProperty("concavity")) hacd.SetConcavity(options.concavity);\n\n    const points = Ammo._malloc(vertexCount * 3 * 8);\n    const triangles = Ammo._malloc(triCount * 3 * 4);\n    hacd.SetPoints(points);\n    hacd.SetTriangles(triangles);\n    hacd.SetNPoints(vertexCount);\n    hacd.SetNTriangles(triCount);\n\n    let pptr = points / 8,\n      tptr = triangles / 4;\n\n    for (let i = 0; i < vertices.length; i++) {\n      const components = vertices[i];\n      matrix.fromArray(matrices[i]);\n      for (let j = 0; j < components.length; j += 3) {\n        vector\n          .set(components[j + 0], components[j + 1], components[j + 2])\n          .applyMatrix4(matrix)\n          .sub(center);\n        Ammo.HEAPF64[pptr + 0] = vector.x;\n        Ammo.HEAPF64[pptr + 1] = vector.y;\n        Ammo.HEAPF64[pptr + 2] = vector.z;\n        pptr += 3;\n      }\n      if (indexes[i]) {\n        const indices = indexes[i];\n        for (let j = 0; j < indices.length; j++) {\n          Ammo.HEAP32[tptr] = indices[j];\n          tptr++;\n        }\n      } else {\n        for (let j = 0; j < components.length / 3; j++) {\n          Ammo.HEAP32[tptr] = j;\n          tptr++;\n        }\n      }\n    }\n\n    hacd.Compute();\n    Ammo._free(points);\n    Ammo._free(triangles);\n    const nClusters = hacd.GetNClusters();\n\n    const shapes = [];\n    for (let i = 0; i < nClusters; i++) {\n      const hull = new Ammo.btConvexHullShape();\n      hull.setMargin(options.margin);\n      const nPoints = hacd.GetNPointsCH(i);\n      const nTriangles = hacd.GetNTrianglesCH(i);\n      const hullPoints = Ammo._malloc(nPoints * 3 * 8);\n      const hullTriangles = Ammo._malloc(nTriangles * 3 * 4);\n      hacd.GetCH(i, hullPoints, hullTriangles);\n\n      const pptr = hullPoints / 8;\n      for (let pi = 0; pi < nPoints; pi++) {\n        const btVertex = new Ammo.btVector3();\n        const px = Ammo.HEAPF64[pptr + pi * 3 + 0];\n        const py = Ammo.HEAPF64[pptr + pi * 3 + 1];\n        const pz = Ammo.HEAPF64[pptr + pi * 3 + 2];\n        btVertex.setValue(px, py, pz);\n        hull.addPoint(btVertex, pi === nPoints - 1);\n        Ammo.destroy(btVertex);\n      }\n\n      _finishCollisionShape(hull, options, scale);\n      shapes.push(hull);\n    }\n\n    return shapes;\n  };\n})();\n\nconst createVHACDShapes = (function() {\n  const vector = new external_THREE_namespaceObject.Vector3();\n  const center = new external_THREE_namespaceObject.Vector3();\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(vertices, matrices, indexes, matrixWorld, options = {}) {\n    options.type = TYPE.VHACD;\n    _setOptions(options);\n\n    if (options.fit === FIT.MANUAL) {\n      console.warn("cannot use fit: manual with type: vhacd");\n      return [];\n    }\n\n    if (!Ammo.hasOwnProperty("VHACD")) {\n      console.warn(\n        "VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."\n      );\n      return [];\n    }\n\n    const bounds = _computeBounds(vertices, matrices);\n    const scale = _computeScale(matrixWorld, options);\n\n    let vertexCount = 0;\n    let triCount = 0;\n    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);\n\n    for (let i = 0; i < vertices.length; i++) {\n      vertexCount += vertices[i].length / 3;\n      if (indexes && indexes[i]) {\n        triCount += indexes[i].length / 3;\n      } else {\n        triCount += vertices[i].length / 9;\n      }\n    }\n\n    const vhacd = new Ammo.VHACD();\n    const params = new Ammo.Parameters();\n    //https://kmamou.blogspot.com/2014/12/v-hacd-20-parameters-description.html\n    if (options.hasOwnProperty("resolution")) params.set_m_resolution(options.resolution);\n    if (options.hasOwnProperty("depth")) params.set_m_depth(options.depth);\n    if (options.hasOwnProperty("concavity")) params.set_m_concavity(options.concavity);\n    if (options.hasOwnProperty("planeDownsampling")) params.set_m_planeDownsampling(options.planeDownsampling);\n    if (options.hasOwnProperty("convexhullDownsampling"))\n      params.set_m_convexhullDownsampling(options.convexhullDownsampling);\n    if (options.hasOwnProperty("alpha")) params.set_m_alpha(options.alpha);\n    if (options.hasOwnProperty("beta")) params.set_m_beta(options.beta);\n    if (options.hasOwnProperty("gamma")) params.set_m_gamma(options.gamma);\n    if (options.hasOwnProperty("pca")) params.set_m_pca(options.pca);\n    if (options.hasOwnProperty("mode")) params.set_m_mode(options.mode);\n    if (options.hasOwnProperty("maxNumVerticesPerCH")) params.set_m_maxNumVerticesPerCH(options.maxNumVerticesPerCH);\n    if (options.hasOwnProperty("minVolumePerCH")) params.set_m_minVolumePerCH(options.minVolumePerCH);\n    if (options.hasOwnProperty("convexhullApproximation"))\n      params.set_m_convexhullApproximation(options.convexhullApproximation);\n    if (options.hasOwnProperty("oclAcceleration")) params.set_m_oclAcceleration(options.oclAcceleration);\n\n    const points = Ammo._malloc(vertexCount * 3 * 8 + 3);\n    const triangles = Ammo._malloc(triCount * 3 * 4);\n\n    let pptr = points / 8,\n      tptr = triangles / 4;\n\n    for (let i = 0; i < vertices.length; i++) {\n      const components = vertices[i];\n      matrix.fromArray(matrices[i]);\n      for (let j = 0; j < components.length; j += 3) {\n        vector\n          .set(components[j + 0], components[j + 1], components[j + 2])\n          .applyMatrix4(matrix)\n          .sub(center);\n        Ammo.HEAPF64[pptr + 0] = vector.x;\n        Ammo.HEAPF64[pptr + 1] = vector.y;\n        Ammo.HEAPF64[pptr + 2] = vector.z;\n        pptr += 3;\n      }\n      if (indexes[i]) {\n        const indices = indexes[i];\n        for (let j = 0; j < indices.length; j++) {\n          Ammo.HEAP32[tptr] = indices[j];\n          tptr++;\n        }\n      } else {\n        for (let j = 0; j < components.length / 3; j++) {\n          Ammo.HEAP32[tptr] = j;\n          tptr++;\n        }\n      }\n    }\n    vhacd.Compute(points, 3, vertexCount, triangles, 3, triCount, params);\n    Ammo._free(points);\n    Ammo._free(triangles);\n    const nHulls = vhacd.GetNConvexHulls();\n\n    const shapes = [];\n    const ch = new Ammo.ConvexHull();\n    for (let i = 0; i < nHulls; i++) {\n      vhacd.GetConvexHull(i, ch);\n      const nPoints = ch.get_m_nPoints();\n      const hullPoints = ch.get_m_points();\n\n      const hull = new Ammo.btConvexHullShape();\n      hull.setMargin(options.margin);\n\n      for (let pi = 0; pi < nPoints; pi++) {\n        const btVertex = new Ammo.btVector3();\n        const px = ch.get_m_points(pi * 3 + 0);\n        const py = ch.get_m_points(pi * 3 + 1);\n        const pz = ch.get_m_points(pi * 3 + 2);\n        btVertex.setValue(px, py, pz);\n        hull.addPoint(btVertex, pi === nPoints - 1);\n        Ammo.destroy(btVertex);\n      }\n\n      _finishCollisionShape(hull, options, scale);\n      shapes.push(hull);\n    }\n    Ammo.destroy(ch);\n    Ammo.destroy(vhacd);\n\n    return shapes;\n  };\n})();\n\nconst createTriMeshShape = (function() {\n  const va = new external_THREE_namespaceObject.Vector3();\n  const vb = new external_THREE_namespaceObject.Vector3();\n  const vc = new external_THREE_namespaceObject.Vector3();\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(vertices, matrices, indexes, matrixWorld, options = {}) {\n    options.type = TYPE.MESH;\n    _setOptions(options);\n\n    if (options.fit === FIT.MANUAL) {\n      console.warn("cannot use fit: manual with type: mesh");\n      return null;\n    }\n\n    const scale = _computeScale(matrixWorld, options);\n\n    const bta = new Ammo.btVector3();\n    const btb = new Ammo.btVector3();\n    const btc = new Ammo.btVector3();\n    const triMesh = new Ammo.btTriangleMesh(true, false);\n\n    for (let i = 0; i < vertices.length; i++) {\n      const components = vertices[i];\n      const index = indexes[i] ? indexes[i] : null;\n      matrix.fromArray(matrices[i]);\n      if (index) {\n        for (let j = 0; j < index.length; j += 3) {\n          const ai = index[j] * 3;\n          const bi = index[j + 1] * 3;\n          const ci = index[j + 2] * 3;\n          va.set(components[ai], components[ai + 1], components[ai + 2]).applyMatrix4(matrix);\n          vb.set(components[bi], components[bi + 1], components[bi + 2]).applyMatrix4(matrix);\n          vc.set(components[ci], components[ci + 1], components[ci + 2]).applyMatrix4(matrix);\n          bta.setValue(va.x, va.y, va.z);\n          btb.setValue(vb.x, vb.y, vb.z);\n          btc.setValue(vc.x, vc.y, vc.z);\n          triMesh.addTriangle(bta, btb, btc, false);\n        }\n      } else {\n        for (let j = 0; j < components.length; j += 9) {\n          va.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix);\n          vb.set(components[j + 3], components[j + 4], components[j + 5]).applyMatrix4(matrix);\n          vc.set(components[j + 6], components[j + 7], components[j + 8]).applyMatrix4(matrix);\n          bta.setValue(va.x, va.y, va.z);\n          btb.setValue(vb.x, vb.y, vb.z);\n          btc.setValue(vc.x, vc.y, vc.z);\n          triMesh.addTriangle(bta, btb, btc, false);\n        }\n      }\n    }\n\n    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);\n    triMesh.setScaling(localScale);\n    Ammo.destroy(localScale);\n\n    const collisionShape = new Ammo.btBvhTriangleMeshShape(triMesh, true, true);\n    collisionShape.resources = [triMesh];\n\n    Ammo.destroy(bta);\n    Ammo.destroy(btb);\n    Ammo.destroy(btc);\n\n    _finishCollisionShape(collisionShape, options);\n    return collisionShape;\n  };\n})();\n\nconst createHeightfieldTerrainShape = function(options = {}) {\n  _setOptions(options);\n\n  if (options.fit === FIT.ALL) {\n    console.warn("cannot use fit: all with type: heightfield");\n    return null;\n  }\n  const heightfieldDistance = options.heightfieldDistance || 1;\n  const heightfieldData = options.heightfieldData || [];\n  const heightScale = options.heightScale || 0;\n  const upAxis = options.hasOwnProperty("upAxis") ? options.upAxis : 1; // x = 0; y = 1; z = 2\n  const hdt = (() => {\n    switch (options.heightDataType) {\n      case "short":\n        return Ammo.PHY_SHORT;\n      case "float":\n        return Ammo.PHY_FLOAT;\n      default:\n        return Ammo.PHY_FLOAT;\n    }\n  })();\n  const flipQuadEdges = options.hasOwnProperty("flipQuadEdges") ? options.flipQuadEdges : true;\n\n  const heightStickLength = heightfieldData.length;\n  const heightStickWidth = heightStickLength > 0 ? heightfieldData[0].length : 0;\n\n  const data = Ammo._malloc(heightStickLength * heightStickWidth * 4);\n  const ptr = data / 4;\n\n  let minHeight = Number.POSITIVE_INFINITY;\n  let maxHeight = Number.NEGATIVE_INFINITY;\n  let index = 0;\n  for (let l = 0; l < heightStickLength; l++) {\n    for (let w = 0; w < heightStickWidth; w++) {\n      const height = heightfieldData[l][w];\n      Ammo.HEAPF32[ptr + index] = height;\n      index++;\n      minHeight = Math.min(minHeight, height);\n      maxHeight = Math.max(maxHeight, height);\n    }\n  }\n\n  const collisionShape = new Ammo.btHeightfieldTerrainShape(\n    heightStickWidth,\n    heightStickLength,\n    data,\n    heightScale,\n    minHeight,\n    maxHeight,\n    upAxis,\n    hdt,\n    flipQuadEdges\n  );\n\n  const scale = new Ammo.btVector3(heightfieldDistance, 1, heightfieldDistance);\n  collisionShape.setLocalScaling(scale);\n  Ammo.destroy(scale);\n\n  collisionShape.heightfieldData = data;\n\n  _finishCollisionShape(collisionShape, options);\n  return collisionShape;\n};\n\nfunction _setOptions(options) {\n  options.fit = options.hasOwnProperty("fit") ? options.fit : FIT.ALL;\n  options.type = options.type || TYPE.HULL;\n  options.minHalfExtent = options.hasOwnProperty("minHalfExtent") ? options.minHalfExtent : 0;\n  options.maxHalfExtent = options.hasOwnProperty("maxHalfExtent") ? options.maxHalfExtent : Number.POSITIVE_INFINITY;\n  options.cylinderAxis = options.cylinderAxis || "y";\n  options.margin = options.hasOwnProperty("margin") ? options.margin : 0.01;\n  options.includeInvisible = options.hasOwnProperty("includeInvisible") ? options.includeInvisible : false;\n\n  if (!options.offset) {\n    options.offset = new external_THREE_namespaceObject.Vector3();\n  }\n\n  if (!options.orientation) {\n    options.orientation = new external_THREE_namespaceObject.Quaternion();\n  }\n}\n\nconst _finishCollisionShape = function(collisionShape, options, scale) {\n  collisionShape.type = options.type;\n  collisionShape.setMargin(options.margin);\n  collisionShape.destroy = () => {\n    for (let res of collisionShape.resources || []) {\n      Ammo.destroy(res);\n    }\n    if (collisionShape.heightfieldData) {\n      Ammo._free(collisionShape.heightfieldData);\n    }\n    Ammo.destroy(collisionShape);\n  };\n\n  const localTransform = new Ammo.btTransform();\n  const rotation = new Ammo.btQuaternion();\n  localTransform.setIdentity();\n\n  localTransform.getOrigin().setValue(options.offset.x, options.offset.y, options.offset.z);\n  rotation.setValue(options.orientation.x, options.orientation.y, options.orientation.z, options.orientation.w);\n\n  localTransform.setRotation(rotation);\n  Ammo.destroy(rotation);\n\n  if (scale) {\n    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);\n    collisionShape.setLocalScaling(localScale);\n    Ammo.destroy(localScale);\n  }\n\n  collisionShape.localTransform = localTransform;\n};\n\nconst iterateGeometries = (function() {\n  const inverse = new external_THREE_namespaceObject.Matrix4();\n  return function(root, options, cb) {\n    inverse.copy(root.matrixWorld).invert();\n    const scale = new external_THREE_namespaceObject.Vector3();\n    scale.setFromMatrixScale(root.matrixWorld);\n    root.traverse(mesh => {\n      const transform = new external_THREE_namespaceObject.Matrix4();\n      if (\n        mesh.isMesh &&\n        mesh.name !== "Sky" &&\n        (options.includeInvisible || (mesh.el && mesh.el.object3D.visible) || mesh.visible)\n      ) {\n        if (mesh === root) {\n          transform.identity();\n        } else {\n          mesh.updateWorldMatrix(true);\n          transform.multiplyMatrices(inverse, mesh.matrixWorld);\n        }\n        // todo: might want to return null xform if this is the root so that callers can avoid multiplying\n        // things by the identity matrix\n\n        let vertices;\n        if (mesh.geometry.isBufferGeometry) {\n          const verticesAttribute = mesh.geometry.attributes.position;\n          if (verticesAttribute.isInterleavedBufferAttribute) {\n            //\n            // An interleaved buffer attribute shares the underlying\n            // array with other attributes. We translate it to a\n            // regular array here to not carry this logic around in\n            // the shape api.\n            //\n            vertices = [];\n            for (let i = 0; i < verticesAttribute.count; i += 3) {\n              vertices.push(verticesAttribute.getX(i));\n              vertices.push(verticesAttribute.getY(i));\n              vertices.push(verticesAttribute.getZ(i));\n            }\n          } else {\n            vertices = verticesAttribute.array;\n          }\n        } else {\n          vertices = mesh.geometry.vertices;\n        }\n\n        cb(\n          vertices,\n          transform.elements,\n          mesh.geometry.index ? mesh.geometry.index.array : null\n        );\n      }\n    });\n  };\n})();\n\nconst _computeScale = (function() {\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(matrixWorld, options = {}) {\n    const scale = new external_THREE_namespaceObject.Vector3(1, 1, 1);\n    if (options.fit === FIT.ALL) {\n      matrix.fromArray(matrixWorld);\n      scale.setFromMatrixScale(matrix);\n    }\n    return scale;\n  };\n})();\n\nconst _computeRadius = (function() {\n  const center = new external_THREE_namespaceObject.Vector3();\n  return function(vertices, matrices, bounds) {\n    let maxRadiusSq = 0;\n    let { x: cx, y: cy, z: cz } = bounds.getCenter(center);\n\n    _iterateVertices(vertices, matrices, v => {\n      const dx = cx - v.x;\n      const dy = cy - v.y;\n      const dz = cz - v.z;\n      maxRadiusSq = Math.max(maxRadiusSq, dx * dx + dy * dy + dz * dz);\n    });\n    return Math.sqrt(maxRadiusSq);\n  };\n})();\n\nconst _computeHalfExtents = function(bounds, minHalfExtent, maxHalfExtent) {\n  const halfExtents = new external_THREE_namespaceObject.Vector3();\n  return halfExtents\n    .subVectors(bounds.max, bounds.min)\n    .multiplyScalar(0.5)\n    .clampScalar(minHalfExtent, maxHalfExtent);\n};\n\nconst _computeLocalOffset = function(matrix, bounds, target) {\n  target\n    .addVectors(bounds.max, bounds.min)\n    .multiplyScalar(0.5)\n    .applyMatrix4(matrix);\n  return target;\n};\n\n// returns the bounding box for the geometries underneath `root`.\nconst _computeBounds = function(vertices, matrices) {\n  const bounds = new external_THREE_namespaceObject.Box3();\n  let minX = +Infinity;\n  let minY = +Infinity;\n  let minZ = +Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n  bounds.min.set(0, 0, 0);\n  bounds.max.set(0, 0, 0);\n\n  _iterateVertices(vertices, matrices, v => {\n    if (v.x < minX) minX = v.x;\n    if (v.y < minY) minY = v.y;\n    if (v.z < minZ) minZ = v.z;\n    if (v.x > maxX) maxX = v.x;\n    if (v.y > maxY) maxY = v.y;\n    if (v.z > maxZ) maxZ = v.z;\n  });\n\n  bounds.min.set(minX, minY, minZ);\n  bounds.max.set(maxX, maxY, maxZ);\n  return bounds;\n};\n\nconst _iterateVertices = (function() {\n  const vertex = new external_THREE_namespaceObject.Vector3();\n  const matrix = new external_THREE_namespaceObject.Matrix4();\n  return function(vertices, matrices, cb) {\n    for (let i = 0; i < vertices.length; i++) {\n      matrix.fromArray(matrices[i]);\n      for (let j = 0; j < vertices[i].length; j += 3) {\n        vertex.set(vertices[i][j], vertices[i][j + 1], vertices[i][j + 2]).applyMatrix4(matrix);\n        cb(vertex);\n      }\n    }\n  };\n})();\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./node_modules/three-to-ammo/index.js_+_1_modules?')},592:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* global Ammo */\nconst CONSTRAINT = (__webpack_require__(279).CONSTRAINT);\n\nmodule.exports = AFRAME.registerComponent("ammo-constraint", {\n  multiple: true,\n\n  schema: {\n    // Type of constraint.\n    type: {\n      default: CONSTRAINT.LOCK,\n      oneOf: [\n        CONSTRAINT.LOCK,\n        CONSTRAINT.FIXED,\n        CONSTRAINT.SPRING,\n        CONSTRAINT.SLIDER,\n        CONSTRAINT.HINGE,\n        CONSTRAINT.CONE_TWIST,\n        CONSTRAINT.POINT_TO_POINT\n      ]\n    },\n\n    // Target (other) body for the constraint.\n    target: { type: "selector" },\n\n    // Offset of the hinge or point-to-point constraint, defined locally in the body. Used for hinge, coneTwist pointToPoint constraints.\n    pivot: { type: "vec3" },\n    targetPivot: { type: "vec3" },\n\n    // An axis that each body can rotate around, defined locally to that body. Used for hinge constraints.\n    axis: { type: "vec3", default: { x: 0, y: 0, z: 1 } },\n    targetAxis: { type: "vec3", default: { x: 0, y: 0, z: 1 } },\n\n    // damping & stuffness - used for spring contraints only\n    damping: { type: "number", default: 1 },\n    stiffness: { type: "number", default: 100 },\n  },\n\n  init: function() {\n    this.system = this.el.sceneEl.systems.physics;\n    this.constraint = null;\n  },\n\n  remove: function() {\n    if (!this.constraint) return;\n\n    this.system.removeConstraint(this.constraint);\n    this.constraint = null;\n  },\n\n  update: function() {\n    const el = this.el,\n      data = this.data;\n\n    this.remove();\n\n    if (!el.body || !data.target.body) {\n      (el.body ? data.target : el).addEventListener("body-loaded", this.update.bind(this, {}), { once: true });\n      return;\n    }\n\n    this.constraint = this.createConstraint();\n    this.system.addConstraint(this.constraint);\n  },\n\n  /**\n   * @return {Ammo.btTypedConstraint}\n   */\n  createConstraint: function() {\n    let constraint;\n    const data = this.data,\n      body = this.el.body,\n      targetBody = data.target.body;\n\n    const bodyTransform = body\n      .getCenterOfMassTransform()\n      .inverse()\n      .op_mul(targetBody.getWorldTransform());\n    const targetTransform = new Ammo.btTransform();\n    targetTransform.setIdentity();\n\n    switch (data.type) {\n      case CONSTRAINT.LOCK: {\n        constraint = new Ammo.btGeneric6DofConstraint(body, targetBody, bodyTransform, targetTransform, true);\n        const zero = new Ammo.btVector3(0, 0, 0);\n        //TODO: allow these to be configurable\n        constraint.setLinearLowerLimit(zero);\n        constraint.setLinearUpperLimit(zero);\n        constraint.setAngularLowerLimit(zero);\n        constraint.setAngularUpperLimit(zero);\n        Ammo.destroy(zero);\n        break;\n      }\n      //TODO: test and verify all other constraint types\n      case CONSTRAINT.FIXED: {\n        //btFixedConstraint does not seem to debug render\n        bodyTransform.setRotation(body.getWorldTransform().getRotation());\n        targetTransform.setRotation(targetBody.getWorldTransform().getRotation());\n        constraint = new Ammo.btFixedConstraint(body, targetBody, bodyTransform, targetTransform);\n        break;\n      }\n      case CONSTRAINT.SPRING: {\n        constraint = new Ammo.btGeneric6DofSpringConstraint(body, targetBody, bodyTransform, targetTransform, true);\n\n        // Very limited initial implementation of spring constraint.\n        // See: https://github.com/n5ro/aframe-physics-system/issues/171\n        for (var i in [0,1,2,3,4,5]) {\n          constraint.enableSpring(1, true)\n          constraint.setStiffness(1, this.data.stiffness)\n          constraint.setDamping(1, this.data.damping)\n        }\n        const upper = new Ammo.btVector3(-1, -1, -1);\n        const lower = new Ammo.btVector3(1, 1, 1);\n        constraint.setLinearUpperLimit(upper);\n        constraint.setLinearLowerLimit(lower)\n        Ammo.destroy(upper);\n        Ammo.destroy(lower);\n        break;\n      }\n      case CONSTRAINT.SLIDER: {\n        //TODO: support setting linear and angular limits\n        constraint = new Ammo.btSliderConstraint(body, targetBody, bodyTransform, targetTransform, true);\n        constraint.setLowerLinLimit(-1);\n        constraint.setUpperLinLimit(1);\n        // constraint.setLowerAngLimit();\n        // constraint.setUpperAngLimit();\n        break;\n      }\n      case CONSTRAINT.HINGE: {\n        const pivot = new Ammo.btVector3(data.pivot.x, data.pivot.y, data.pivot.z);\n        const targetPivot = new Ammo.btVector3(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);\n\n        const axis = new Ammo.btVector3(data.axis.x, data.axis.y, data.axis.z);\n        const targetAxis = new Ammo.btVector3(data.targetAxis.x, data.targetAxis.y, data.targetAxis.z);\n\n        constraint = new Ammo.btHingeConstraint(body, targetBody, pivot, targetPivot, axis, targetAxis, true);\n\n        Ammo.destroy(pivot);\n        Ammo.destroy(targetPivot);\n        Ammo.destroy(axis);\n        Ammo.destroy(targetAxis);\n        break;\n      }\n      case CONSTRAINT.CONE_TWIST: {\n        const pivotTransform = new Ammo.btTransform();\n        pivotTransform.setIdentity();\n        pivotTransform.getOrigin().setValue(data.pivot.x, data.pivot.y, data.pivot.z);\n        const targetPivotTransform = new Ammo.btTransform();\n        targetPivotTransform.setIdentity();\n        targetPivotTransform.getOrigin().setValue(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);\n        constraint = new Ammo.btConeTwistConstraint(body, targetBody, pivotTransform, targetPivotTransform);\n        Ammo.destroy(pivotTransform);\n        Ammo.destroy(targetPivotTransform);\n        break;\n      }\n      case CONSTRAINT.POINT_TO_POINT: {\n        const pivot = new Ammo.btVector3(data.pivot.x, data.pivot.y, data.pivot.z);\n        const targetPivot = new Ammo.btVector3(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);\n\n        constraint = new Ammo.btPoint2PointConstraint(body, targetBody, pivot, targetPivot);\n\n        Ammo.destroy(pivot);\n        Ammo.destroy(targetPivot);\n        break;\n      }\n      default:\n        throw new Error("[constraint] Unexpected type: " + data.type);\n    }\n\n    Ammo.destroy(bodyTransform);\n    Ammo.destroy(targetTransform);\n\n    return constraint;\n  }\n});\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/components/ammo-constraint.js?')},854:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* global Ammo,THREE */\nconst AmmoDebugDrawer = __webpack_require__(694);\nconst threeToAmmo = __webpack_require__(812);\nconst CONSTANTS = __webpack_require__(279),\n  ACTIVATION_STATE = CONSTANTS.ACTIVATION_STATE,\n  COLLISION_FLAG = CONSTANTS.COLLISION_FLAG,\n  SHAPE = CONSTANTS.SHAPE,\n  TYPE = CONSTANTS.TYPE,\n  FIT = CONSTANTS.FIT;\n\nconst ACTIVATION_STATES = [\n  ACTIVATION_STATE.ACTIVE_TAG,\n  ACTIVATION_STATE.ISLAND_SLEEPING,\n  ACTIVATION_STATE.WANTS_DEACTIVATION,\n  ACTIVATION_STATE.DISABLE_DEACTIVATION,\n  ACTIVATION_STATE.DISABLE_SIMULATION\n];\n\nconst RIGID_BODY_FLAGS = {\n  NONE: 0,\n  DISABLE_WORLD_GRAVITY: 1\n};\n\nfunction almostEqualsVector3(epsilon, u, v) {\n  return Math.abs(u.x - v.x) < epsilon && Math.abs(u.y - v.y) < epsilon && Math.abs(u.z - v.z) < epsilon;\n}\n\nfunction almostEqualsBtVector3(epsilon, u, v) {\n  return Math.abs(u.x() - v.x()) < epsilon && Math.abs(u.y() - v.y()) < epsilon && Math.abs(u.z() - v.z()) < epsilon;\n}\n\nfunction almostEqualsQuaternion(epsilon, u, v) {\n  return (\n    (Math.abs(u.x - v.x) < epsilon &&\n      Math.abs(u.y - v.y) < epsilon &&\n      Math.abs(u.z - v.z) < epsilon &&\n      Math.abs(u.w - v.w) < epsilon) ||\n    (Math.abs(u.x + v.x) < epsilon &&\n      Math.abs(u.y + v.y) < epsilon &&\n      Math.abs(u.z + v.z) < epsilon &&\n      Math.abs(u.w + v.w) < epsilon)\n  );\n}\n\nlet AmmoBody = {\n  schema: {\n    loadedEvent: { default: "" },\n    mass: { default: 1 },\n    gravity: { type: "vec3", default: { x: undefined, y: undefined, z: undefined } },\n    linearDamping: { default: 0.01 },\n    angularDamping: { default: 0.01 },\n    linearSleepingThreshold: { default: 1.6 },\n    angularSleepingThreshold: { default: 2.5 },\n    angularFactor: { type: "vec3", default: { x: 1, y: 1, z: 1 } },\n    activationState: {\n      default: ACTIVATION_STATE.ACTIVE_TAG,\n      oneOf: ACTIVATION_STATES\n    },\n    type: { default: "dynamic", oneOf: [TYPE.STATIC, TYPE.DYNAMIC, TYPE.KINEMATIC] },\n    emitCollisionEvents: { default: false },\n    disableCollision: { default: false },\n    collisionFilterGroup: { default: 1 }, //32-bit mask,\n    collisionFilterMask: { default: 1 }, //32-bit mask\n    scaleAutoUpdate: { default: true },\n    restitution: {default: 0} // does not support updates\n  },\n\n  /**\n   * Initializes a body component, assigning it to the physics system and binding listeners for\n   * parsing the elements geometry.\n   */\n  init: function() {\n    this.system = this.el.sceneEl.systems.physics;\n    this.shapeComponents = [];\n\n    if (this.data.loadedEvent === "") {\n      this.loadedEventFired = true;\n    } else {\n      this.el.addEventListener(\n        this.data.loadedEvent,\n        () => {\n          this.loadedEventFired = true;\n        },\n        { once: true }\n      );\n    }\n\n    if (this.system.initialized && this.loadedEventFired) {\n      this.initBody();\n    }\n  },\n\n  /**\n   * Parses an element\'s geometry and component metadata to create an Ammo body instance for the\n   * component.\n   */\n  initBody: (function() {\n    const pos = new THREE.Vector3();\n    const quat = new THREE.Quaternion();\n    const boundingBox = new THREE.Box3();\n\n    return function() {\n      const el = this.el,\n        data = this.data;\n      const clamp = (num, min, max) => Math.min(Math.max(num, min), max)\n\n      this.localScaling = new Ammo.btVector3();\n\n      const obj = this.el.object3D;\n      obj.getWorldPosition(pos);\n      obj.getWorldQuaternion(quat);\n\n      this.prevScale = new THREE.Vector3(1, 1, 1);\n      this.prevNumChildShapes = 0;\n\n      this.msTransform = new Ammo.btTransform();\n      this.msTransform.setIdentity();\n      this.rotation = new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w);\n\n      this.msTransform.getOrigin().setValue(pos.x, pos.y, pos.z);\n      this.msTransform.setRotation(this.rotation);\n\n      this.motionState = new Ammo.btDefaultMotionState(this.msTransform);\n\n      this.localInertia = new Ammo.btVector3(0, 0, 0);\n\n      this.compoundShape = new Ammo.btCompoundShape(true);\n\n      this.rbInfo = new Ammo.btRigidBodyConstructionInfo(\n        data.mass,\n        this.motionState,\n        this.compoundShape,\n        this.localInertia\n      );\n      this.rbInfo.m_restitution = clamp(this.data.restitution, 0, 1);\n      this.body = new Ammo.btRigidBody(this.rbInfo);\n      this.body.setActivationState(ACTIVATION_STATES.indexOf(data.activationState) + 1);\n      this.body.setSleepingThresholds(data.linearSleepingThreshold, data.angularSleepingThreshold);\n\n      this.body.setDamping(data.linearDamping, data.angularDamping);\n\n      const angularFactor = new Ammo.btVector3(data.angularFactor.x, data.angularFactor.y, data.angularFactor.z);\n      this.body.setAngularFactor(angularFactor);\n      Ammo.destroy(angularFactor);\n\n      this._updateBodyGravity(data.gravity)\n\n      this.updateCollisionFlags();\n\n      this.el.body = this.body;\n      this.body.el = el;\n\n      this.isLoaded = true;\n\n      this.el.emit("body-loaded", { body: this.el.body });\n\n      this._addToSystem();\n    };\n  })(),\n\n  tick: function() {\n    if (this.system.initialized && !this.isLoaded && this.loadedEventFired) {\n      this.initBody();\n    }\n  },\n\n  _updateBodyGravity(gravity) {\n\n    if (gravity.x !== undefined &&\n        gravity.y !== undefined &&\n        gravity.z !== undefined) {\n      const gravityBtVec = new Ammo.btVector3(gravity.x, gravity.y, gravity.z);\n      if (!almostEqualsBtVector3(0.001, gravityBtVec, this.system.driver.physicsWorld.getGravity())) {\n        this.body.setFlags(RIGID_BODY_FLAGS.DISABLE_WORLD_GRAVITY);\n      } else {\n        this.body.setFlags(RIGID_BODY_FLAGS.NONE);\n      }\n      this.body.setGravity(gravityBtVec);\n      Ammo.destroy(gravityBtVec);\n    }\n    else {\n      // no per-body gravity specified - just use world gravity\n      this.body.setFlags(RIGID_BODY_FLAGS.NONE);\n    }\n  },\n\n  _updateShapes: (function() {\n    const needsPolyhedralInitialization = [SHAPE.HULL, SHAPE.HACD, SHAPE.VHACD];\n    return function() {\n      let updated = false;\n\n      const obj = this.el.object3D;\n      if (this.data.scaleAutoUpdate && this.prevScale && !almostEqualsVector3(0.001, obj.scale, this.prevScale)) {\n        this.prevScale.copy(obj.scale);\n        updated = true;\n\n        this.localScaling.setValue(this.prevScale.x, this.prevScale.y, this.prevScale.z);\n        this.compoundShape.setLocalScaling(this.localScaling);\n      }\n\n      if (this.shapeComponentsChanged) {\n        this.shapeComponentsChanged = false;\n        updated = true;\n        for (let i = 0; i < this.shapeComponents.length; i++) {\n          const shapeComponent = this.shapeComponents[i];\n          if (shapeComponent.getShapes().length === 0) {\n            this._createCollisionShape(shapeComponent);\n          }\n          const collisionShapes = shapeComponent.getShapes();\n          for (let j = 0; j < collisionShapes.length; j++) {\n            const collisionShape = collisionShapes[j];\n            if (!collisionShape.added) {\n              this.compoundShape.addChildShape(collisionShape.localTransform, collisionShape);\n              collisionShape.added = true;\n            }\n          }\n        }\n\n        if (this.data.type === TYPE.DYNAMIC) {\n          this.updateMass();\n        }\n\n        this.system.driver.updateBody(this.body);\n      }\n\n      //call initializePolyhedralFeatures for hull shapes if debug is turned on and/or scale changes\n      if (this.system.debug && (updated || !this.polyHedralFeaturesInitialized)) {\n        for (let i = 0; i < this.shapeComponents.length; i++) {\n          const collisionShapes = this.shapeComponents[i].getShapes();\n          for (let j = 0; j < collisionShapes.length; j++) {\n            const collisionShape = collisionShapes[j];\n            if (needsPolyhedralInitialization.indexOf(collisionShape.type) !== -1) {\n              collisionShape.initializePolyhedralFeatures(0);\n            }\n          }\n        }\n        this.polyHedralFeaturesInitialized = true;\n      }\n    };\n  })(),\n\n  _createCollisionShape: function(shapeComponent) {\n    const data = shapeComponent.data;\n    const vertices = [];\n    const matrices = [];\n    const indexes = [];\n\n    const root = shapeComponent.el.object3D;\n    const matrixWorld = root.matrixWorld;\n\n    threeToAmmo.iterateGeometries(root, data, (vertexArray, matrixArray, indexArray) => {\n      vertices.push(vertexArray);\n      matrices.push(matrixArray);\n      indexes.push(indexArray);\n    });\n\n    const collisionShapes = threeToAmmo.createCollisionShapes(vertices, matrices, indexes, matrixWorld.elements, data);\n    shapeComponent.addShapes(collisionShapes);\n    return;\n  },\n\n  /**\n   * Registers the component with the physics system.\n   */\n  play: function() {\n    if (this.isLoaded) {\n      this._addToSystem();\n    }\n  },\n\n  _addToSystem: function() {\n    if (!this.addedToSystem) {\n      this.system.addBody(this.body, this.data.collisionFilterGroup, this.data.collisionFilterMask);\n\n      if (this.data.emitCollisionEvents) {\n        this.system.driver.addEventListener(this.body);\n      }\n\n      this.system.addComponent(this);\n      this.addedToSystem = true;\n    }\n  },\n\n  /**\n   * Unregisters the component with the physics system.\n   */\n  pause: function() {\n    if (this.addedToSystem) {\n      this.system.removeComponent(this);\n      this.system.removeBody(this.body);\n      this.addedToSystem = false;\n    }\n  },\n\n  /**\n   * Updates the rigid body instance, where possible.\n   */\n  update: function(prevData) {\n    if (this.isLoaded) {\n      if (!this.hasUpdated) {\n        //skip the first update\n        this.hasUpdated = true;\n        return;\n      }\n\n      const data = this.data;\n\n      if (prevData.type !== data.type || prevData.disableCollision !== data.disableCollision) {\n        this.updateCollisionFlags();\n      }\n\n      if (prevData.activationState !== data.activationState) {\n        this.body.forceActivationState(ACTIVATION_STATES.indexOf(data.activationState) + 1);\n        if (data.activationState === ACTIVATION_STATE.ACTIVE_TAG) {\n          this.body.activate(true);\n        }\n      }\n\n      if (\n        prevData.collisionFilterGroup !== data.collisionFilterGroup ||\n        prevData.collisionFilterMask !== data.collisionFilterMask\n      ) {\n        const broadphaseProxy = this.body.getBroadphaseProxy();\n        broadphaseProxy.set_m_collisionFilterGroup(data.collisionFilterGroup);\n        broadphaseProxy.set_m_collisionFilterMask(data.collisionFilterMask);\n        this.system.driver.broadphase\n          .getOverlappingPairCache()\n          .removeOverlappingPairsContainingProxy(broadphaseProxy, this.system.driver.dispatcher);\n      }\n\n      if (prevData.linearDamping != data.linearDamping || prevData.angularDamping != data.angularDamping) {\n        this.body.setDamping(data.linearDamping, data.angularDamping);\n      }\n\n      if (!almostEqualsVector3(0.001, prevData.gravity, data.gravity)) {\n        this._updateBodyGravity(data.gravity)\n      }\n\n      if (\n        prevData.linearSleepingThreshold != data.linearSleepingThreshold ||\n        prevData.angularSleepingThreshold != data.angularSleepingThreshold\n      ) {\n        this.body.setSleepingThresholds(data.linearSleepingThreshold, data.angularSleepingThreshold);\n      }\n\n      if (!almostEqualsVector3(0.001, prevData.angularFactor, data.angularFactor)) {\n        const angularFactor = new Ammo.btVector3(data.angularFactor.x, data.angularFactor.y, data.angularFactor.z);\n        this.body.setAngularFactor(angularFactor);\n        Ammo.destroy(angularFactor);\n      }\n\n      if (prevData.restitution != data.restitution ) {\n        console.warn("ammo-body restitution cannot be updated from its initial value.")\n      }\n\n      //TODO: support dynamic update for other properties\n    }\n  },\n\n  /**\n   * Removes the component and all physics and scene side effects.\n   */\n  remove: function() {\n    if (this.triMesh) Ammo.destroy(this.triMesh);\n    if (this.localScaling) Ammo.destroy(this.localScaling);\n    if (this.compoundShape) Ammo.destroy(this.compoundShape);\n    if (this.body) {\n      Ammo.destroy(this.body);\n      delete this.body;\n    }\n    Ammo.destroy(this.rbInfo);\n    Ammo.destroy(this.msTransform);\n    Ammo.destroy(this.motionState);\n    Ammo.destroy(this.localInertia);\n    Ammo.destroy(this.rotation);\n  },\n\n  beforeStep: function() {\n    this._updateShapes();\n    // Note that since static objects don\'t move,\n    // we don\'t sync them to physics on a routine basis.\n    if (this.data.type === TYPE.KINEMATIC) {\n      this.syncToPhysics();\n    }\n  },\n\n  step: function() {\n    if (this.data.type === TYPE.DYNAMIC) {\n      this.syncFromPhysics();\n    }\n  },\n\n  /**\n   * Updates the rigid body\'s position, velocity, and rotation, based on the scene.\n   */\n  syncToPhysics: (function() {\n    const q = new THREE.Quaternion();\n    const v = new THREE.Vector3();\n    const q2 = new THREE.Vector3();\n    const v2 = new THREE.Vector3();\n    return function() {\n      const el = this.el,\n        parentEl = el.parentEl,\n        body = this.body;\n\n      if (!body) return;\n\n      this.motionState.getWorldTransform(this.msTransform);\n\n      if (parentEl.isScene) {\n        v.copy(el.object3D.position);\n        q.copy(el.object3D.quaternion);\n      } else {\n        el.object3D.getWorldPosition(v);\n        el.object3D.getWorldQuaternion(q);\n      }\n\n      const position = this.msTransform.getOrigin();\n      v2.set(position.x(), position.y(), position.z());\n\n      const quaternion = this.msTransform.getRotation();\n      q2.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());\n\n      if (!almostEqualsVector3(0.001, v, v2) || !almostEqualsQuaternion(0.001, q, q2)) {\n        if (!this.body.isActive()) {\n          this.body.activate(true);\n        }\n        this.msTransform.getOrigin().setValue(v.x, v.y, v.z);\n        this.rotation.setValue(q.x, q.y, q.z, q.w);\n        this.msTransform.setRotation(this.rotation);\n        this.motionState.setWorldTransform(this.msTransform);\n\n        if (this.data.type === TYPE.STATIC) {\n          this.body.setCenterOfMassTransform(this.msTransform);\n        }\n      }\n    };\n  })(),\n\n  /**\n   * Updates the scene object\'s position and rotation, based on the physics simulation.\n   */\n  syncFromPhysics: (function() {\n    const v = new THREE.Vector3(),\n      q1 = new THREE.Quaternion(),\n      q2 = new THREE.Quaternion();\n    return function() {\n      this.motionState.getWorldTransform(this.msTransform);\n      const position = this.msTransform.getOrigin();\n      const quaternion = this.msTransform.getRotation();\n\n      const el = this.el,\n        body = this.body;\n\n      // For the parent, prefer to use the THHREE.js scene graph parent (if it can be determined)\n      // and only use the HTML scene graph parent as a fallback.\n      // Usually these are the same, but there are various cases where it\'s useful to modify the THREE.js\n      // scene graph so that it deviates from the HTML.\n      // In these cases the THREE.js scene graph should be considered the definitive reference in terms\n      // of object positioning etc.\n      // For specific examples, and more discussion, see:\n      // https://github.com/c-frame/aframe-physics-system/pull/1#issuecomment-1264686433\n      const parentEl = el.object3D.parent.el ? el.object3D.parent.el : el.parentEl;\n\n      if (!body) return;\n      if (!parentEl) return;\n\n      if (parentEl.isScene) {\n        el.object3D.position.set(position.x(), position.y(), position.z());\n        el.object3D.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());\n      } else {\n        q1.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());\n        parentEl.object3D.getWorldQuaternion(q2);\n        q1.multiply(q2.invert());\n        el.object3D.quaternion.copy(q1);\n\n        v.set(position.x(), position.y(), position.z());\n        parentEl.object3D.worldToLocal(v);\n        el.object3D.position.copy(v);\n      }\n    };\n  })(),\n\n  addShapeComponent: function(shapeComponent) {\n    if (shapeComponent.data.type === SHAPE.MESH && this.data.type !== TYPE.STATIC) {\n      console.warn("non-static mesh colliders not supported");\n      return;\n    }\n\n    this.shapeComponents.push(shapeComponent);\n    this.shapeComponentsChanged = true;\n  },\n\n  removeShapeComponent: function(shapeComponent) {\n    const index = this.shapeComponents.indexOf(shapeComponent);\n    if (this.compoundShape && index !== -1 && this.body) {\n      const shapes = shapeComponent.getShapes();\n      for (var i = 0; i < shapes.length; i++) {\n        this.compoundShape.removeChildShape(shapes[i]);\n      }\n      this.shapeComponentsChanged = true;\n      this.shapeComponents.splice(index, 1);\n    }\n  },\n\n  updateMass: function() {\n    const shape = this.body.getCollisionShape();\n    const mass = this.data.type === TYPE.DYNAMIC ? this.data.mass : 0;\n    shape.calculateLocalInertia(mass, this.localInertia);\n    this.body.setMassProps(mass, this.localInertia);\n    this.body.updateInertiaTensor();\n  },\n\n  updateCollisionFlags: function() {\n    let flags = this.data.disableCollision ? 4 : 0;\n    switch (this.data.type) {\n      case TYPE.STATIC:\n        flags |= COLLISION_FLAG.STATIC_OBJECT;\n        break;\n      case TYPE.KINEMATIC:\n        flags |= COLLISION_FLAG.KINEMATIC_OBJECT;\n        break;\n      default:\n        this.body.applyGravity();\n        break;\n    }\n    this.body.setCollisionFlags(flags);\n\n    this.updateMass();\n\n    // TODO: enable CCD if dynamic?\n    // this.body.setCcdMotionThreshold(0.001);\n    // this.body.setCcdSweptSphereRadius(0.001);\n\n    this.system.driver.updateBody(this.body);\n  },\n\n  getVelocity: function() {\n    return this.body.getLinearVelocity();\n  }\n};\n\nmodule.exports.definition = AmmoBody;\nmodule.exports.Component = AFRAME.registerComponent("ammo-body", AmmoBody);\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/components/body/ammo-body.js?')},421:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = {\n  'velocity':   __webpack_require__(496),\n\n  registerAll: function (AFRAME) {\n    if (this._registered) return;\n\n    AFRAME = AFRAME || window.AFRAME;\n\n    if (!AFRAME.components['velocity'])    AFRAME.registerComponent('velocity',   this.velocity);\n\n    this._registered = true;\n  }\n};\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/components/math/index.js?")},496:module=>{eval("/**\n * Velocity, in m/s.\n */\nmodule.exports = AFRAME.registerComponent('velocity', {\n  schema: {type: 'vec3'},\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n\n    if (this.system) {\n      this.system.addComponent(this);\n    }\n  },\n\n  remove: function () {\n    if (this.system) {\n      this.system.removeComponent(this);\n    }\n  },\n\n  tick: function (t, dt) {\n    if (!dt) return;\n    if (this.system) return;\n    this.afterStep(t, dt);\n  },\n\n  afterStep: function (t, dt) {\n    if (!dt) return;\n\n    var physics = this.el.sceneEl.systems.physics || {data: {maxInterval: 1 / 60}},\n\n    // TODO - There's definitely a bug with getComputedAttribute and el.data.\n    velocity = this.el.getAttribute('velocity') || {x: 0, y: 0, z: 0},\n    position = this.el.object3D.position || {x: 0, y: 0, z: 0};\n\n    dt = Math.min(dt, physics.data.maxInterval * 1000);\n\n    this.el.object3D.position.set(\n      position.x + velocity.x * dt / 1000,\n      position.y + velocity.y * dt / 1000,\n      position.z + velocity.z * dt / 1000\n    );\n  }\n});\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/components/math/velocity.js?")},938:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* global Ammo,THREE */\nconst threeToAmmo = __webpack_require__(812);\nconst CONSTANTS = __webpack_require__(279),\n  SHAPE = CONSTANTS.SHAPE,\n  FIT = CONSTANTS.FIT;\n\nvar AmmoShape = {\n  schema: {\n    type: {\n      default: SHAPE.HULL,\n      oneOf: [\n        SHAPE.BOX,\n        SHAPE.CYLINDER,\n        SHAPE.SPHERE,\n        SHAPE.CAPSULE,\n        SHAPE.CONE,\n        SHAPE.HULL,\n        SHAPE.HACD,\n        SHAPE.VHACD,\n        SHAPE.MESH,\n        SHAPE.HEIGHTFIELD\n      ]\n    },\n    fit: { default: FIT.ALL, oneOf: [FIT.ALL, FIT.MANUAL] },\n    halfExtents: { type: "vec3", default: { x: 1, y: 1, z: 1 } },\n    minHalfExtent: { default: 0 },\n    maxHalfExtent: { default: Number.POSITIVE_INFINITY },\n    sphereRadius: { default: NaN },\n    cylinderAxis: { default: "y", oneOf: ["x", "y", "z"] },\n    margin: { default: 0.01 },\n    offset: { type: "vec3", default: { x: 0, y: 0, z: 0 } },\n    orientation: { type: "vec4", default: { x: 0, y: 0, z: 0, w: 1 } },\n    heightfieldData: { default: [] },\n    heightfieldDistance: { default: 1 },\n    includeInvisible: { default: false }\n  },\n\n  multiple: true,\n\n  init: function() {\n    if (this.data.fit !== FIT.MANUAL) {\n      if (this.el.object3DMap.mesh) {\n\tthis.mesh = this.el.object3DMap.mesh;\n      } else {\n\tconst self = this;\n\tthis.el.addEventListener("object3dset", function (e) {\n\t  if (e.detail.type === "mesh") {\n\t    self.init();\n\t  }\n\t});\n\tconsole.log("Cannot use FIT.ALL without object3DMap.mesh. Waiting for it to be set.");\n        return;\n      }\n    }\n\n    this.system = this.el.sceneEl.systems.physics;\n    this.collisionShapes = [];\n\n    let bodyEl = this.el;\n    this.body = bodyEl.components["ammo-body"] || null;\n    while (!this.body && bodyEl.parentNode != this.el.sceneEl) {\n      bodyEl = bodyEl.parentNode;\n      if (bodyEl.components["ammo-body"]) {\n        this.body = bodyEl.components["ammo-body"];\n      }\n    }\n    if (!this.body) {\n      console.warn("body not found");\n      return;\n    }\n    this.body.addShapeComponent(this);\n  },\n\n  getMesh: function() {\n    return this.mesh || null;\n  },\n\n  addShapes: function(collisionShapes) {\n    this.collisionShapes = collisionShapes;\n  },\n\n  getShapes: function() {\n    return this.collisionShapes;\n  },\n\n  remove: function() {\n    if (!this.body) {\n      return;\n    }\n\n    this.body.removeShapeComponent(this);\n\n    while (this.collisionShapes.length > 0) {\n      const collisionShape = this.collisionShapes.pop();\n      collisionShape.destroy();\n      Ammo.destroy(collisionShape.localTransform);\n    }\n  }\n};\n\nmodule.exports.definition = AmmoShape;\nmodule.exports.Component = AFRAME.registerComponent("ammo-shape", AmmoShape);\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/components/shape/ammo-shape.js?')},279:module=>{eval('module.exports = {\n  GRAVITY: -9.8,\n  MAX_INTERVAL: 4 / 60,\n  ITERATIONS: 10,\n  CONTACT_MATERIAL: {\n    friction: 0.01,\n    restitution: 0.3,\n    contactEquationStiffness: 1e8,\n    contactEquationRelaxation: 3,\n    frictionEquationStiffness: 1e8,\n    frictionEquationRegularization: 3\n  },\n  ACTIVATION_STATE: {\n    ACTIVE_TAG: "active",\n    ISLAND_SLEEPING: "islandSleeping",\n    WANTS_DEACTIVATION: "wantsDeactivation",\n    DISABLE_DEACTIVATION: "disableDeactivation",\n    DISABLE_SIMULATION: "disableSimulation"\n  },\n  COLLISION_FLAG: {\n    STATIC_OBJECT: 1,\n    KINEMATIC_OBJECT: 2,\n    NO_CONTACT_RESPONSE: 4,\n    CUSTOM_MATERIAL_CALLBACK: 8, //this allows per-triangle material (friction/restitution)\n    CHARACTER_OBJECT: 16,\n    DISABLE_VISUALIZE_OBJECT: 32, //disable debug drawing\n    DISABLE_SPU_COLLISION_PROCESSING: 64 //disable parallel/SPU processing\n  },\n  TYPE: {\n    STATIC: "static",\n    DYNAMIC: "dynamic",\n    KINEMATIC: "kinematic"\n  },\n  SHAPE: {\n    BOX: "box",\n    CYLINDER: "cylinder",\n    SPHERE: "sphere",\n    CAPSULE: "capsule",\n    CONE: "cone",\n    HULL: "hull",\n    HACD: "hacd",\n    VHACD: "vhacd",\n    MESH: "mesh",\n    HEIGHTFIELD: "heightfield"\n  },\n  FIT: {\n    ALL: "all",\n    MANUAL: "manual"\n  },\n  CONSTRAINT: {\n    LOCK: "lock",\n    FIXED: "fixed",\n    SPRING: "spring",\n    SLIDER: "slider",\n    HINGE: "hinge",\n    CONE_TWIST: "coneTwist",\n    POINT_TO_POINT: "pointToPoint"\n  }\n};\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/constants.js?')},589:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* global THREE */\nconst Driver = __webpack_require__(766);\n\nif (typeof window !== \'undefined\') {\n  window.AmmoModule = window.Ammo;\n  window.Ammo = null;\n}\n\nconst EPS = 10e-6;\n\nfunction AmmoDriver() {\n  this.collisionConfiguration = null;\n  this.dispatcher = null;\n  this.broadphase = null;\n  this.solver = null;\n  this.physicsWorld = null;\n  this.debugDrawer = null;\n\n  this.els = new Map();\n  this.eventListeners = [];\n  this.collisions = new Map();\n  this.collisionKeys = [];\n  this.currentCollisions = new Map();\n}\n\nAmmoDriver.prototype = new Driver();\nAmmoDriver.prototype.constructor = AmmoDriver;\n\nmodule.exports = AmmoDriver;\n\n/* @param {object} worldConfig */\nAmmoDriver.prototype.init = function(worldConfig) {\n  //Emscripten doesn\'t use real promises, just a .then() callback, so it necessary to wrap in a real promise.\n  return new Promise(resolve => {\n    AmmoModule().then(result => {\n      Ammo = result;\n      this.epsilon = worldConfig.epsilon || EPS;\n      this.debugDrawMode = worldConfig.debugDrawMode || THREE.AmmoDebugConstants.NoDebug;\n      this.maxSubSteps = worldConfig.maxSubSteps || 4;\n      this.fixedTimeStep = worldConfig.fixedTimeStep || 1 / 60;\n      this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n      this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n      this.broadphase = new Ammo.btDbvtBroadphase();\n      this.solver = new Ammo.btSequentialImpulseConstraintSolver();\n      this.physicsWorld = new Ammo.btDiscreteDynamicsWorld(\n        this.dispatcher,\n        this.broadphase,\n        this.solver,\n        this.collisionConfiguration\n      );\n      this.physicsWorld.setForceUpdateAllAabbs(false);\n      this.physicsWorld.setGravity(\n        new Ammo.btVector3(0, worldConfig.hasOwnProperty("gravity") ? worldConfig.gravity : -9.8, 0)\n      );\n      this.physicsWorld.getSolverInfo().set_m_numIterations(worldConfig.solverIterations);\n      resolve();\n    });\n  });\n};\n\n/* @param {Ammo.btCollisionObject} body */\nAmmoDriver.prototype.addBody = function(body, group, mask) {\n  this.physicsWorld.addRigidBody(body, group, mask);\n  this.els.set(Ammo.getPointer(body), body.el);\n};\n\n/* @param {Ammo.btCollisionObject} body */\nAmmoDriver.prototype.removeBody = function(body) {\n  this.physicsWorld.removeRigidBody(body);\n  this.removeEventListener(body);\n  const bodyptr = Ammo.getPointer(body);\n  this.els.delete(bodyptr);\n  this.collisions.delete(bodyptr);\n  this.collisionKeys.splice(this.collisionKeys.indexOf(bodyptr), 1);\n  this.currentCollisions.delete(bodyptr);\n};\n\nAmmoDriver.prototype.updateBody = function(body) {\n  if (this.els.has(Ammo.getPointer(body))) {\n    this.physicsWorld.updateSingleAabb(body);\n  }\n};\n\n/* @param {number} deltaTime */\nAmmoDriver.prototype.step = function(deltaTime) {\n  this.physicsWorld.stepSimulation(deltaTime, this.maxSubSteps, this.fixedTimeStep);\n\n  const numManifolds = this.dispatcher.getNumManifolds();\n  for (let i = 0; i < numManifolds; i++) {\n    const persistentManifold = this.dispatcher.getManifoldByIndexInternal(i);\n    const numContacts = persistentManifold.getNumContacts();\n    const body0ptr = Ammo.getPointer(persistentManifold.getBody0());\n    const body1ptr = Ammo.getPointer(persistentManifold.getBody1());\n    let collided = false;\n\n    for (let j = 0; j < numContacts; j++) {\n      const manifoldPoint = persistentManifold.getContactPoint(j);\n      const distance = manifoldPoint.getDistance();\n      if (distance <= this.epsilon) {\n        collided = true;\n        break;\n      }\n    }\n\n    if (collided) {\n      if (!this.collisions.has(body0ptr)) {\n        this.collisions.set(body0ptr, []);\n        this.collisionKeys.push(body0ptr);\n      }\n      if (this.collisions.get(body0ptr).indexOf(body1ptr) === -1) {\n        this.collisions.get(body0ptr).push(body1ptr);\n        if (this.eventListeners.indexOf(body0ptr) !== -1) {\n          this.els.get(body0ptr).emit("collidestart", { targetEl: this.els.get(body1ptr) });\n        }\n        if (this.eventListeners.indexOf(body1ptr) !== -1) {\n          this.els.get(body1ptr).emit("collidestart", { targetEl: this.els.get(body0ptr) });\n        }\n      }\n      if (!this.currentCollisions.has(body0ptr)) {\n        this.currentCollisions.set(body0ptr, new Set());\n      }\n      this.currentCollisions.get(body0ptr).add(body1ptr);\n    }\n  }\n\n  for (let i = 0; i < this.collisionKeys.length; i++) {\n    const body0ptr = this.collisionKeys[i];\n    const body1ptrs = this.collisions.get(body0ptr);\n    for (let j = body1ptrs.length - 1; j >= 0; j--) {\n      const body1ptr = body1ptrs[j];\n      if (this.currentCollisions.get(body0ptr).has(body1ptr)) {\n        continue;\n      }\n      if (this.eventListeners.indexOf(body0ptr) !== -1) {\n        this.els.get(body0ptr).emit("collideend", { targetEl: this.els.get(body1ptr) });\n      }\n      if (this.eventListeners.indexOf(body1ptr) !== -1) {\n        this.els.get(body1ptr).emit("collideend", { targetEl: this.els.get(body0ptr) });\n      }\n      body1ptrs.splice(j, 1);\n    }\n    this.currentCollisions.get(body0ptr).clear();\n  }\n\n  if (this.debugDrawer) {\n    this.debugDrawer.update();\n  }\n};\n\n/* @param {?} constraint */\nAmmoDriver.prototype.addConstraint = function(constraint) {\n  this.physicsWorld.addConstraint(constraint, false);\n};\n\n/* @param {?} constraint */\nAmmoDriver.prototype.removeConstraint = function(constraint) {\n  this.physicsWorld.removeConstraint(constraint);\n};\n\n/* @param {Ammo.btCollisionObject} body */\nAmmoDriver.prototype.addEventListener = function(body) {\n  this.eventListeners.push(Ammo.getPointer(body));\n};\n\n/* @param {Ammo.btCollisionObject} body */\nAmmoDriver.prototype.removeEventListener = function(body) {\n  const ptr = Ammo.getPointer(body);\n  if (this.eventListeners.indexOf(ptr) !== -1) {\n    this.eventListeners.splice(this.eventListeners.indexOf(ptr), 1);\n  }\n};\n\nAmmoDriver.prototype.destroy = function() {\n  Ammo.destroy(this.collisionConfiguration);\n  Ammo.destroy(this.dispatcher);\n  Ammo.destroy(this.broadphase);\n  Ammo.destroy(this.solver);\n  Ammo.destroy(this.physicsWorld);\n  Ammo.destroy(this.debugDrawer);\n};\n\n/**\n * @param {THREE.Scene} scene\n * @param {object} options\n */\nAmmoDriver.prototype.getDebugDrawer = function(scene, options) {\n  if (!this.debugDrawer) {\n    options = options || {};\n    options.debugDrawMode = options.debugDrawMode || this.debugDrawMode;\n    this.debugDrawer = new THREE.AmmoDebugDrawer(scene, this.physicsWorld, options);\n  }\n  return this.debugDrawer;\n};\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/drivers/ammo-driver.js?')},766:module=>{eval("/**\n * Driver - defines limited API to local and remote physics controllers.\n */\n\nfunction Driver () {}\n\nmodule.exports = Driver;\n\n/******************************************************************************\n * Lifecycle\n */\n\n/* @param {object} worldConfig */\nDriver.prototype.init = abstractMethod;\n\n/* @param {number} deltaMS */\nDriver.prototype.step = abstractMethod;\n\nDriver.prototype.destroy = abstractMethod;\n\n/******************************************************************************\n * Bodies\n */\n\n/* @param {CANNON.Body} body */\nDriver.prototype.addBody = abstractMethod;\n\n/* @param {CANNON.Body} body */\nDriver.prototype.removeBody = abstractMethod;\n\n/**\n * @param {CANNON.Body} body\n * @param {string} methodName\n * @param {Array} args\n */\nDriver.prototype.applyBodyMethod = abstractMethod;\n\n/** @param {CANNON.Body} body */\nDriver.prototype.updateBodyProperties = abstractMethod;\n\n/******************************************************************************\n * Materials\n */\n\n/** @param {object} materialConfig */\nDriver.prototype.addMaterial = abstractMethod;\n\n/**\n * @param {string} materialName1\n * @param {string} materialName2\n * @param {object} contactMaterialConfig\n */\nDriver.prototype.addContactMaterial = abstractMethod;\n\n/******************************************************************************\n * Constraints\n */\n\n/* @param {CANNON.Constraint} constraint */\nDriver.prototype.addConstraint = abstractMethod;\n\n/* @param {CANNON.Constraint} constraint */\nDriver.prototype.removeConstraint = abstractMethod;\n\n/******************************************************************************\n * Contacts\n */\n\n/** @return {Array<object>} */\nDriver.prototype.getContacts = abstractMethod;\n\n/*****************************************************************************/\n\nfunction abstractMethod () {\n  throw new Error('Method not implemented.');\n}\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/drivers/driver.js?")},855:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* global THREE */\nvar CONSTANTS = __webpack_require__(279),\n    C_GRAV = CONSTANTS.GRAVITY,\n    C_MAT = CONSTANTS.CONTACT_MATERIAL;\n\nconst { TYPE } = __webpack_require__(279);\nvar AmmoDriver = __webpack_require__(589);\n__webpack_require__(261)\n\n/**\n * Physics system.\n */\nmodule.exports = AFRAME.registerSystem(\'physics\', {\n  schema: {\n    driver:                         { default: \'ammo\', oneOf: [\'ammo\'] },\n    networkUrl:                     { default: \'\', if: {driver: \'network\'} },\n\n    gravity:                        { default: C_GRAV },\n    iterations:                     { default: CONSTANTS.ITERATIONS },\n    friction:                       { default: C_MAT.friction },\n    restitution:                    { default: C_MAT.restitution },\n    contactEquationStiffness:       { default: C_MAT.contactEquationStiffness },\n    contactEquationRelaxation:      { default: C_MAT.contactEquationRelaxation },\n    frictionEquationStiffness:      { default: C_MAT.frictionEquationStiffness },\n    frictionEquationRegularization: { default: C_MAT.frictionEquationRegularization },\n\n    // Never step more than four frames at once. Effectively pauses the scene\n    // when out of focus, and prevents weird "jumps" when focus returns.\n    maxInterval:                    { default: 4 / 60 },\n\n    // If true, show wireframes around physics bodies.\n    debug:                          { default: false },\n\n    // If using ammo, set the default rendering mode for debug\n    debugDrawMode: { default: THREE.AmmoDebugConstants.NoDebug },\n    // If using ammo, set the max number of steps per frame \n    maxSubSteps: { default: 4 },\n    // If using ammo, set the framerate of the simulation\n    fixedTimeStep: { default: 1 / 60 },\n    // Whether to output stats, and how to output them.  One or more of "console", "events", "panel"\n    stats: {type: \'array\', default: []}\n  },\n\n  /**\n   * Initializes the physics system.\n   */\n  async init() {\n    var data = this.data;\n\n    // If true, show wireframes around physics bodies.\n    this.debug = data.debug;\n    this.initStats();\n\n    this.callbacks = {beforeStep: [], step: [], afterStep: []};\n\n    this.listeners = {};\n\n    this.driver = new AmmoDriver();\n\n    await this.driver.init({\n      gravity: data.gravity,\n      debugDrawMode: data.debugDrawMode,\n      solverIterations: data.iterations,\n      maxSubSteps: data.maxSubSteps,\n      fixedTimeStep: data.fixedTimeStep\n    });\n\n    this.initialized = true;\n\n    if (this.debug) {\n      this.setDebug(true);\n    }\n  },\n\n  initStats() {\n    // Data used for performance monitoring.\n    this.statsToConsole = this.data.stats.includes("console")\n    this.statsToEvents = this.data.stats.includes("events")\n    this.statsToPanel = this.data.stats.includes("panel")\n\n    if (this.statsToConsole || this.statsToEvents || this.statsToPanel) {\n      this.trackPerf = true;\n      this.tickCounter = 0;\n      \n      this.statsTickData = {};\n      this.statsBodyData = {};\n\n      this.countBodies = {\n        "ammo": () => this.countBodiesAmmo(),\n      }\n\n      this.bodyTypeToStatsPropertyMap = {\n        "ammo": {\n          [TYPE.STATIC] : "staticBodies",\n          [TYPE.KINEMATIC] : "kinematicBodies",\n          [TYPE.DYNAMIC] : "dynamicBodies",\n        }, \n      }\n      \n      const scene = this.el.sceneEl;\n      scene.setAttribute("stats-collector", `inEvent: physics-tick-data;\n                                             properties: before, after, engine, total;\n                                             outputFrequency: 100;\n                                             outEvent: physics-tick-summary;\n                                             outputs: percentile__50, percentile__90, max`);\n    }\n\n    if (this.statsToPanel) {\n      const scene = this.el.sceneEl;\n      const space = "&nbsp&nbsp&nbsp"\n    \n      scene.setAttribute("stats-panel", "")\n      scene.setAttribute("stats-group__bodies", `label: Physics Bodies`)\n      scene.setAttribute("stats-row__b1", `group: bodies;\n                                           event:physics-body-data;\n                                           properties: staticBodies;\n                                           label: Static`)\n      scene.setAttribute("stats-row__b2", `group: bodies;\n                                           event:physics-body-data;\n                                           properties: dynamicBodies;\n                                           label: Dynamic`)\n\n      scene.setAttribute("stats-row__b3", `group: bodies;\n                                             event:physics-body-data;\n                                             properties: kinematicBodies;\n                                             label: Kinematic`)\n      scene.setAttribute("stats-row__b4", `group: bodies;\n                                             event: physics-body-data;\n                                             properties: manifolds;\n                                             label: Manifolds`)\n      scene.setAttribute("stats-row__b5", `group: bodies;\n                                             event: physics-body-data;\n                                             properties: manifoldContacts;\n                                             label: Contacts`)\n      scene.setAttribute("stats-row__b6", `group: bodies;\n                                             event: physics-body-data;\n                                             properties: collisions;\n                                             label: Collisions`)\n      scene.setAttribute("stats-row__b7", `group: bodies;\n                                             event: physics-body-data;\n                                             properties: collisionKeys;\n                                             label: Coll Keys`)\n\n      scene.setAttribute("stats-group__tick", `label: Physics Ticks: Median${space}90th%${space}99th%`)\n      scene.setAttribute("stats-row__1", `group: tick;\n                                          event:physics-tick-summary;\n                                          properties: before.percentile__50, \n                                                      before.percentile__90, \n                                                      before.max;\n                                          label: Before`)\n      scene.setAttribute("stats-row__2", `group: tick;\n                                          event:physics-tick-summary;\n                                          properties: after.percentile__50, \n                                                      after.percentile__90, \n                                                      after.max; \n                                          label: After`)\n      scene.setAttribute("stats-row__3", `group: tick; \n                                          event:physics-tick-summary; \n                                          properties: engine.percentile__50, \n                                                      engine.percentile__90, \n                                                      engine.max;\n                                          label: Engine`)\n      scene.setAttribute("stats-row__4", `group: tick;\n                                          event:physics-tick-summary;\n                                          properties: total.percentile__50, \n                                                      total.percentile__90, \n                                                      total.max;\n                                          label: Total`)\n    }\n  },\n\n  /**\n   * Updates the physics world on each tick of the A-Frame scene. It would be\n   * entirely possible to separate the two – updating physics more or less\n   * frequently than the scene – if greater precision or performance were\n   * necessary.\n   * @param  {number} t\n   * @param  {number} dt\n   */\n  tick: function (t, dt) {\n    if (!this.initialized || !dt) return;\n\n    const beforeStartTime = performance.now();\n\n    var i;\n    var callbacks = this.callbacks;\n\n    for (i = 0; i < this.callbacks.beforeStep.length; i++) {\n      this.callbacks.beforeStep[i].beforeStep(t, dt);\n    }\n\n    const engineStartTime = performance.now();\n\n    this.driver.step(Math.min(dt / 1000, this.data.maxInterval));\n\n    const engineEndTime = performance.now();\n\n    for (i = 0; i < callbacks.step.length; i++) {\n      callbacks.step[i].step(t, dt);\n    }\n\n    for (i = 0; i < callbacks.afterStep.length; i++) {\n      callbacks.afterStep[i].afterStep(t, dt);\n    }\n\n    if (this.trackPerf) {\n      const afterEndTime = performance.now();\n\n      this.statsTickData.before = engineStartTime - beforeStartTime\n      this.statsTickData.engine = engineEndTime - engineStartTime\n      this.statsTickData.after = afterEndTime - engineEndTime\n      this.statsTickData.total = afterEndTime - beforeStartTime\n\n      this.el.emit("physics-tick-data", this.statsTickData)\n\n      this.tickCounter++;\n\n      if (this.tickCounter === 100) {\n\n        this.countBodies[this.data.driver]()\n\n        if (this.statsToConsole) {\n          console.log("Physics body stats:", this.statsBodyData)\n        }\n\n        if (this.statsToEvents  || this.statsToPanel) {\n          this.el.emit("physics-body-data", this.statsBodyData)\n        }\n        this.tickCounter = 0;\n      }\n    }\n  },\n\n  countBodiesAmmo() {\n\n    const statsData = this.statsBodyData\n    statsData.manifolds = this.driver.dispatcher.getNumManifolds();\n    statsData.manifoldContacts = 0;\n    for (let i = 0; i < statsData.manifolds; i++) {\n      const manifold = this.driver.dispatcher.getManifoldByIndexInternal(i);\n      statsData.manifoldContacts += manifold.getNumContacts();\n    }\n    statsData.collisions = this.driver.collisions.size;\n    statsData.collisionKeys = this.driver.collisionKeys.length;\n    statsData.staticBodies = 0\n    statsData.kinematicBodies = 0\n    statsData.dynamicBodies = 0\n    \n    function type(el) {\n      return el.components[\'ammo-body\'].data.type\n    }\n\n    this.driver.els.forEach((el) => {\n      const property = this.bodyTypeToStatsPropertyMap["ammo"][type(el)]\n      statsData[property]++\n    })\n  },\n\n  setDebug: function(debug) {\n    this.debug = debug;\n    if (this.data.driver === \'ammo\' && this.initialized) {\n      if (debug && !this.debugDrawer) {\n        this.debugDrawer = this.driver.getDebugDrawer(this.el.object3D);\n        this.debugDrawer.enable();\n      } else if (this.debugDrawer) {\n        this.debugDrawer.disable();\n        this.debugDrawer = null;\n      }\n    }\n  },\n\n  /**\n   * Adds a body to the scene, and binds proxied methods to the driver.\n   */\n  addBody: function (body, group, mask) {\n    var driver = this.driver;\n\n    this.driver.addBody(body, group, mask);\n  },\n\n  /**\n   * Removes a body and its proxied methods.\n   */\n  removeBody: function (body) {\n    this.driver.removeBody(body);\n  },\n\n  /** @param {Ammo.btTypedConstraint} constraint */\n  addConstraint: function (constraint) {\n    this.driver.addConstraint(constraint);\n  },\n\n  /** @param {Ammo.btTypedConstraint} constraint */\n  removeConstraint: function (constraint) {\n    this.driver.removeConstraint(constraint);\n  },\n\n  /**\n   * Adds a component instance to the system and schedules its update methods to be called\n   * the given phase.\n   * @param {Component} component\n   * @param {string} phase\n   */\n  addComponent: function (component) {\n    var callbacks = this.callbacks;\n    if (component.beforeStep) callbacks.beforeStep.push(component);\n    if (component.step)       callbacks.step.push(component);\n    if (component.afterStep)  callbacks.afterStep.push(component);\n  },\n\n  /**\n   * Removes a component instance from the system.\n   * @param {Component} component\n   * @param {string} phase\n   */\n  removeComponent: function (component) {\n    var callbacks = this.callbacks;\n    if (component.beforeStep) {\n      callbacks.beforeStep.splice(callbacks.beforeStep.indexOf(component), 1);\n    }\n    if (component.step) {\n      callbacks.step.splice(callbacks.step.indexOf(component), 1);\n    }\n    if (component.afterStep) {\n      callbacks.afterStep.splice(callbacks.afterStep.indexOf(component), 1);\n    }\n  },\n\n  /** @return {Array<object>} */\n  getContacts: function () {\n    return this.driver.getContacts();\n  },\n\n  getMaterial: function (name) {\n    return this.driver.getMaterial(name);\n  }\n});\n\n\n//# sourceURL=webpack://@Elettrotecnica/aframe-physics-system/./src/system.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(10)})();