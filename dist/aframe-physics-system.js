/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");

__webpack_require__(/*! ./src/components/math */ "./src/components/math/index.js");
__webpack_require__(/*! ./src/components/body/ammo-body */ "./src/components/body/ammo-body.js");
__webpack_require__(/*! ./src/components/body/body */ "./src/components/body/body.js");
__webpack_require__(/*! ./src/components/body/dynamic-body */ "./src/components/body/dynamic-body.js");
__webpack_require__(/*! ./src/components/body/static-body */ "./src/components/body/static-body.js");
__webpack_require__(/*! ./src/components/shape/shape */ "./src/components/shape/shape.js");
__webpack_require__(/*! ./src/components/shape/ammo-shape */ "./src/components/shape/ammo-shape.js")
__webpack_require__(/*! ./src/components/ammo-constraint */ "./src/components/ammo-constraint.js");
__webpack_require__(/*! ./src/components/constraint */ "./src/components/constraint.js");
__webpack_require__(/*! ./src/components/spring */ "./src/components/spring.js");
__webpack_require__(/*! ./src/system */ "./src/system.js");

module.exports = {
  registerAll: function () {
    console.warn('registerAll() is deprecated. Components are automatically registered.');
  }
};

// Export CANNON.js.
window.CANNON = window.CANNON || CANNON;


/***/ }),

/***/ "./lib/CANNON-shape2mesh.js":
/*!**********************************!*\
  !*** ./lib/CANNON-shape2mesh.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * CANNON.shape2mesh
 *
 * Source: https://schteppe.github.io/cannon.js/build/cannon.demo.js
 * Author: @schteppe
 */
var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");

CANNON.shape2mesh = function(body){
    var obj = new THREE.Object3D();

    function createBufferGeometry(positions, faces) {

      var geometry = new THREE.BufferGeometry();
      geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
      geometry.setIndex(faces);
      geometry.computeBoundingSphere();
      return geometry;
    }

    for (var l = 0; l < body.shapes.length; l++) {
        var shape = body.shapes[l];

        var mesh;

        switch(shape.type){

        case CANNON.Shape.types.SPHERE:
            var sphere_geometry = new THREE.SphereGeometry( shape.radius, 8, 8);
            mesh = new THREE.Mesh( sphere_geometry, this.currentMaterial );
            break;

        case CANNON.Shape.types.PARTICLE:
            mesh = new THREE.Mesh( this.particleGeo, this.particleMaterial );
            var s = this.settings;
            mesh.scale.set(s.particleSize,s.particleSize,s.particleSize);
            break;

        case CANNON.Shape.types.PLANE:
            var geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
            mesh = new THREE.Object3D();
            var submesh = new THREE.Object3D();
            var ground = new THREE.Mesh( geometry, this.currentMaterial );
            ground.scale.set(100, 100, 100);
            submesh.add(ground);

            ground.castShadow = true;
            ground.receiveShadow = true;

            mesh.add(submesh);
            break;

        case CANNON.Shape.types.BOX:
            var box_geometry = new THREE.BoxGeometry(  shape.halfExtents.x*2,
                                                        shape.halfExtents.y*2,
                                                        shape.halfExtents.z*2 );
            mesh = new THREE.Mesh( box_geometry, this.currentMaterial );
            break;

        case CANNON.Shape.types.CONVEXPOLYHEDRON:

            // Add vertices
            var positions = []
            for (var i = 0; i < shape.vertices.length; i++) {
                var v = shape.vertices[i];
                positions.push(v.x, v.y, v.z);
            }

            var faces = []
            for(var i=0; i < shape.faces.length; i++){
                var face = shape.faces[i];

                // add triangles
                var a = face[0];
                for (var j = 1; j < face.length - 1; j++) {
                    var b = face[j];
                    var c = face[j + 1];
                    faces.push(a, b, c);
                }
            }

            var geo = createBufferGeometry(positions, faces);
            mesh = new THREE.Mesh( geo, this.currentMaterial );
            break;

        case CANNON.Shape.types.HEIGHTFIELD:

            var v0 = new CANNON.Vec3();
            var v1 = new CANNON.Vec3();
            var v2 = new CANNON.Vec3();
            var positions = [];
            var faces = [];
            for (var xi = 0; xi < shape.data.length - 1; xi++) {
                for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                    for (var k = 0; k < 2; k++) {
                        shape.getConvexTrianglePillar(xi, yi, k===0);
                        v0.copy(shape.pillarConvex.vertices[0]);
                        v1.copy(shape.pillarConvex.vertices[1]);
                        v2.copy(shape.pillarConvex.vertices[2]);
                        v0.vadd(shape.pillarOffset, v0);
                        v1.vadd(shape.pillarOffset, v1);
                        v2.vadd(shape.pillarOffset, v2);
                        positions.push(
                            v0.x, v0.y, v0.z,
                            v1.x, v1.y, v1.z,
                            v2.x, v2.y, v2.z
                        );
                        var i = positions.length / 3 - 3;
                        faces.push(i, i+1, i+2);
                    }
                }
            }
            var geometry = createBufferGeometry(positions, faces);
            mesh = new THREE.Mesh(geometry, this.currentMaterial);
            break;

        case CANNON.Shape.types.TRIMESH:
            var geometry = new THREE.BufferGeometry();

            var v0 = new CANNON.Vec3();
            var v1 = new CANNON.Vec3();
            var v2 = new CANNON.Vec3();
            var positions = [];
            var faces = [];
            for (var i = 0; i < shape.indices.length / 3; i++) {
                shape.getTriangleVertices(i, v0, v1, v2);
                positions.push(
                    v0.x, v0.y, v0.z,
                    v1.x, v1.y, v1.z,
                    v2.x, v2.y, v2.z
                );
                var j = positions.length / 3 - 3;
                faces.push(j, j+1, j+2);
            }
            var geometry = createBufferGeometry(positions, faces);
            mesh = new THREE.Mesh(geometry, this.currentMaterial);
            break;

        default:
            throw "Visual type not recognized: "+shape.type;
        }

        mesh.receiveShadow = true;
        mesh.castShadow = true;
        if(mesh.children){
            for(var i=0; i<mesh.children.length; i++){
                mesh.children[i].castShadow = true;
                mesh.children[i].receiveShadow = true;
                if(mesh.children[i]){
                    for(var j=0; j<mesh.children[i].length; j++){
                        mesh.children[i].children[j].castShadow = true;
                        mesh.children[i].children[j].receiveShadow = true;
                    }
                }
            }
        }

        var o = body.shapeOffsets[l];
        var q = body.shapeOrientations[l];
        mesh.position.set(o.x, o.y, o.z);
        mesh.quaternion.set(q.x, q.y, q.z, q.w);

        obj.add(mesh);
    }

    return obj;
};

module.exports = CANNON.shape2mesh;


/***/ }),

/***/ "./node_modules/aframe-stats-panel/index.js":
/*!**************************************************!*\
  !*** ./node_modules/aframe-stats-panel/index.js ***!
  \**************************************************/
/***/ (() => {

AFRAME.registerComponent('stats-panel', {
  schema: {
    merge: {type: 'boolean', default: true}
  },

  init() {

    const container = document.querySelector('.rs-container')

    if (container && this.data.merge) {
      //stats panel exists, just merge into it.
      this.container = container
      return;
    }

    // if stats panel doesn't exist, add one to support our custom stats.
    this.base = document.createElement('div')
    this.base.classList.add('rs-base')
    const body = document.body || document.getElementsByTagName('body')[0]

    if (container && !this.data.merge) {
      this.base.style.top = "auto"
      this.base.style.bottom = "20px"
    }

    body.appendChild(this.base)

    this.container = document.createElement('div')
    this.container.classList.add('rs-container')
    this.base.appendChild(this.container)
  }
});

AFRAME.registerComponent('stats-group', {
  multiple: true,
  schema: {
    label: {type: 'string'}
  },

  init() {

    let container
    const baseComponent = this.el.components['stats-panel']
    if (baseComponent) {
      container = baseComponent.container
    }
    else {
      container = document.querySelector('.rs-container')
    }

    if (!container) {
      console.warn(`Couldn't find stats container to add stats to.
                    Add either stats or stats-panel component to a-scene`)
      return;
    }
    
    this.groupHeader = document.createElement('h1')
    this.groupHeader.innerHTML = this.data.label
    container.appendChild(this.groupHeader)

    this.group = document.createElement('div')
    this.group.classList.add('rs-group')
    // rs-group hs style flex-direction of 'column-reverse'
    // No idea why it's like that, but it's not what we want for our stats.
    // We prefer them rendered in the order speified.
    // So override this style.
    this.group.style.flexDirection = 'column'
    this.group.style.webKitFlexDirection = 'column'
    container.appendChild(this.group)
  }
});

AFRAME.registerComponent('stats-row', {
  multiple: true,
  schema: {
    // name of the group to add the stats row to.
    group: {type: 'string'},

    // name of an event to listen for
    event: {type: 'string'},

    // property from event to output in stats panel
    properties: {type: 'array'},

    // label for the row in the stats panel
    label: {type: 'string'}
  },

  init () {

    const groupComponentName = "stats-group__" + this.data.group
    const groupComponent = this.el.components[groupComponentName] ||
                           this.el.sceneEl.components[groupComponentName] ||
                           this.el.components["stats-group"] ||
                           this.el.sceneEl.components["stats-group"]

    if (!groupComponent) {
      console.warn(`Couldn't find stats group ${groupComponentName}`)
      return;
    }
  
    this.counter = document.createElement('div')
    this.counter.classList.add('rs-counter-base')
    groupComponent.group.appendChild(this.counter)

    this.counterId = document.createElement('div')
    this.counterId.classList.add('rs-counter-id')
    this.counterId.innerHTML = this.data.label
    this.counter.appendChild(this.counterId)

    this.counterValues = {}
    this.data.properties.forEach((property) => {
      const counterValue = document.createElement('div')
      counterValue.classList.add('rs-counter-value')
      counterValue.innerHTML = "..."
      this.counter.appendChild(counterValue)
      this.counterValues[property] = counterValue
    })

    this.updateData = this.updateData.bind(this)
    this.el.addEventListener(this.data.event, this.updateData)

    this.splitCache = {}
  },

  updateData(e) {
    
    this.data.properties.forEach((property) => {
      const split = this.splitDot(property);
      let value = e.detail;
      for (i = 0; i < split.length; i++) {
        value = value[split[i]];
      }
      this.counterValues[property].innerHTML = value
    })
  },

  splitDot (path) {
    if (path in this.splitCache) { return this.splitCache[path]; }
    this.splitCache[path] = path.split('.');
    return this.splitCache[path];
  }

});

AFRAME.registerComponent('stats-collector', {
  multiple: true,

  schema: {
    // name of an event to listen for
    inEvent: {type: 'string'},

    // property from event to output in stats panel
    properties: {type: 'array'},

    // frequency of output in terms of events received.
    outputFrequency: {type: 'number', default: 100},

    // name of event to emit
    outEvent: {type: 'string'},
    
    // outputs (generated for each property)
    // Combination of: mean, max, percentile__XX.X (where XX.X is a number)
    outputs: {type: 'array'},

    // Whether to output to console as well as generating events
    // If a string is specified, this is output to console, together with the event data
    // If no string is specified, nothing is output to console.
    outputToConsole: {type: 'string'}
  },

  init() {
    
    this.statsData = {}
    this.resetData()
    this.outputDetail = {}
    this.data.properties.forEach((property) => {
      this.outputDetail[property] = {}
    })

    this.statsReceived = this.statsReceived.bind(this)
    this.el.addEventListener(this.data.inEvent, this.statsReceived)
  },
  
  resetData() {

    this.counter = 0
    this.data.properties.forEach((property) => {
      
      // For calculating percentiles like 0.01 and 99.9% we'll want to store
      // additional data - something like this...
      // Store off outliers, and discard data.
      // const min = Math.min(...this.statsData[property])
      // this.lowOutliers[property].push(min)
      // const max = Math.max(...this.statsData[property])
      // this.highOutliers[property].push(max)

      this.statsData[property] = []
    })
  },

  statsReceived(e) {

    this.updateData(e.detail)

    this.counter++ 
    if (this.counter === this.data.outputFrequency) {
      this.outputData()
      this.resetData()
    }
  },

  updateData(detail) {

    this.data.properties.forEach((property) => {
      let value = detail;
      value = value[property];
      this.statsData[property].push(value)
    })
  },

  outputData() {
    this.data.properties.forEach((property) => {
      this.data.outputs.forEach((output) => {
        this.outputDetail[property][output] = this.computeOutput(output, this.statsData[property])
      })
    })

    if (this.data.outEvent) {
      this.el.emit(this.data.outEvent, this.outputDetail)
    }

    if (this.data.outputToConsole) {
      console.log(this.data.outputToConsole, this.outputDetail)
    }
  },

  computeOutput(outputInstruction, data) {

    const outputInstructions = outputInstruction.split("__")
    const outputType = outputInstructions[0]
    let output

    switch (outputType) {
      case "mean":
        output = data.reduce((a, b) => a + b, 0) / data.length;
        break;
      
      case "max":
        output = Math.max(...data)
        break;

      case "min":
        output = Math.min(...data)
        break;

      case "percentile":
        const sorted = data.sort((a, b) => a - b)
        // decimal percentiles encoded like 99+9 rather than 99.9 due to "." being used as a 
        // separator for nested properties.
        const percentileString = outputInstructions[1].replace("_", ".")
        const proportion = +percentileString / 100

        // Note that this calculation of the percentile is inaccurate when there is insufficient data
        // e.g. for 0.1th or 99.9th percentile when only 100 data points.
        // Greater accuracy would require storing off more data (specifically outliers) and folding these
        // into the computation.
        const position = (data.length - 1) * proportion
        const base = Math.floor(position)
        const delta = position - base;
        if (sorted[base + 1] !== undefined) {
            output = sorted[base] + delta * (sorted[base + 1] - sorted[base]);
        } else {
            output = sorted[base];
        }
        break;
    }
    return output.toFixed(2)
  }
});


/***/ }),

/***/ "./node_modules/ammo-debug-drawer/AmmoDebugDrawer.js":
/*!***********************************************************!*\
  !*** ./node_modules/ammo-debug-drawer/AmmoDebugDrawer.js ***!
  \***********************************************************/
/***/ (() => {

/* global Ammo,THREE */

THREE.AmmoDebugConstants = {
  NoDebug: 0,
  DrawWireframe: 1,
  DrawAabb: 2,
  DrawFeaturesText: 4,
  DrawContactPoints: 8,
  NoDeactivation: 16,
  NoHelpText: 32,
  DrawText: 64,
  ProfileTimings: 128,
  EnableSatComparison: 256,
  DisableBulletLCP: 512,
  EnableCCD: 1024,
  DrawConstraints: 1 << 11, //2048
  DrawConstraintLimits: 1 << 12, //4096
  FastWireframe: 1 << 13, //8192
  DrawNormals: 1 << 14, //16384
  DrawOnTop: 1 << 15, //32768
  MAX_DEBUG_DRAW_MODE: 0xffffffff
};

/**
 * An implementation of the btIDebugDraw interface in Ammo.js, for debug rendering of Ammo shapes
 * @class AmmoDebugDrawer
 * @param {THREE.Scene} scene
 * @param {Ammo.btCollisionWorld} world
 * @param {object} [options]
 */
THREE.AmmoDebugDrawer = function(scene, world, options) {
  this.scene = scene;
  this.world = world;
  options = options || {};

  this.debugDrawMode = options.debugDrawMode || THREE.AmmoDebugConstants.DrawWireframe;
  var drawOnTop = this.debugDrawMode & THREE.AmmoDebugConstants.DrawOnTop || false;
  var maxBufferSize = options.maxBufferSize || 1000000;

  this.geometry = new THREE.BufferGeometry();
  var vertices = new Float32Array(maxBufferSize * 3);
  var colors = new Float32Array(maxBufferSize * 3);

  this.geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3).setUsage(THREE.DynamicDrawUsage));
  this.geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));

  this.index = 0;

  var material = new THREE.LineBasicMaterial({
    vertexColors: true,
    depthTest: !drawOnTop
  });

  this.mesh = new THREE.LineSegments(this.geometry, material);
  if (drawOnTop) this.mesh.renderOrder = 999;
  this.mesh.frustumCulled = false;

  this.enabled = false;

  this.debugDrawer = new Ammo.DebugDrawer();
  this.debugDrawer.drawLine = this.drawLine.bind(this);
  this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this);
  this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this);
  this.debugDrawer.draw3dText = this.draw3dText.bind(this);
  this.debugDrawer.setDebugMode = this.setDebugMode.bind(this);
  this.debugDrawer.getDebugMode = this.getDebugMode.bind(this);
  this.debugDrawer.enable = this.enable.bind(this);
  this.debugDrawer.disable = this.disable.bind(this);
  this.debugDrawer.update = this.update.bind(this);

  this.world.setDebugDrawer(this.debugDrawer);
};

THREE.AmmoDebugDrawer.prototype = function() {
  return this.debugDrawer;
};

THREE.AmmoDebugDrawer.prototype.enable = function() {
  this.enabled = true;
  this.scene.add(this.mesh);
};

THREE.AmmoDebugDrawer.prototype.disable = function() {
  this.enabled = false;
  this.scene.remove(this.mesh);
};

THREE.AmmoDebugDrawer.prototype.update = function() {
  if (!this.enabled) {
    return;
  }

  if (this.index != 0) {
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
  }

  this.index = 0;

  this.world.debugDrawWorld();

  this.geometry.setDrawRange(0, this.index);
};

THREE.AmmoDebugDrawer.prototype.drawLine = function(from, to, color) {
  const heap = Ammo.HEAPF32;
  const r = heap[(color + 0) / 4];
  const g = heap[(color + 4) / 4];
  const b = heap[(color + 8) / 4];

  const fromX = heap[(from + 0) / 4];
  const fromY = heap[(from + 4) / 4];
  const fromZ = heap[(from + 8) / 4];
  this.geometry.attributes.position.setXYZ(this.index, fromX, fromY, fromZ);
  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);

  const toX = heap[(to + 0) / 4];
  const toY = heap[(to + 4) / 4];
  const toZ = heap[(to + 8) / 4];
  this.geometry.attributes.position.setXYZ(this.index, toX, toY, toZ);
  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
};

//TODO: figure out how to make lifeTime work
THREE.AmmoDebugDrawer.prototype.drawContactPoint = function(pointOnB, normalOnB, distance, lifeTime, color) {
  const heap = Ammo.HEAPF32;
  const r = heap[(color + 0) / 4];
  const g = heap[(color + 4) / 4];
  const b = heap[(color + 8) / 4];

  const x = heap[(pointOnB + 0) / 4];
  const y = heap[(pointOnB + 4) / 4];
  const z = heap[(pointOnB + 8) / 4];
  this.geometry.attributes.position.setXYZ(this.index, x, y, z);
  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);

  const dx = heap[(normalOnB + 0) / 4] * distance;
  const dy = heap[(normalOnB + 4) / 4] * distance;
  const dz = heap[(normalOnB + 8) / 4] * distance;
  this.geometry.attributes.position.setXYZ(this.index, x + dx, y + dy, z + dz);
  this.geometry.attributes.color.setXYZ(this.index++, r, g, b);
};

THREE.AmmoDebugDrawer.prototype.reportErrorWarning = function(warningString) {
  if (Ammo.hasOwnProperty("Pointer_stringify")) {
    console.warn(Ammo.Pointer_stringify(warningString));
  } else if (!this.warnedOnce) {
    this.warnedOnce = true;
    console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag");
  }
};

THREE.AmmoDebugDrawer.prototype.draw3dText = function(location, textString) {
  //TODO
  console.warn("TODO: draw3dText");
};

THREE.AmmoDebugDrawer.prototype.setDebugMode = function(debugMode) {
  this.debugDrawMode = debugMode;
};

THREE.AmmoDebugDrawer.prototype.getDebugMode = function() {
  return this.debugDrawMode;
};


/***/ }),

/***/ "./node_modules/cannon-es/dist/cannon-es.js":
/*!**************************************************!*\
  !*** ./node_modules/cannon-es/dist/cannon-es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AABB: () => (/* binding */ AABB),
/* harmony export */   ArrayCollisionMatrix: () => (/* binding */ ArrayCollisionMatrix),
/* harmony export */   BODY_SLEEP_STATES: () => (/* binding */ BODY_SLEEP_STATES),
/* harmony export */   BODY_TYPES: () => (/* binding */ BODY_TYPES),
/* harmony export */   Body: () => (/* binding */ Body),
/* harmony export */   Box: () => (/* binding */ Box),
/* harmony export */   Broadphase: () => (/* binding */ Broadphase),
/* harmony export */   COLLISION_TYPES: () => (/* binding */ COLLISION_TYPES),
/* harmony export */   ConeTwistConstraint: () => (/* binding */ ConeTwistConstraint),
/* harmony export */   Constraint: () => (/* binding */ Constraint),
/* harmony export */   ContactEquation: () => (/* binding */ ContactEquation),
/* harmony export */   ContactMaterial: () => (/* binding */ ContactMaterial),
/* harmony export */   ConvexPolyhedron: () => (/* binding */ ConvexPolyhedron),
/* harmony export */   Cylinder: () => (/* binding */ Cylinder),
/* harmony export */   DistanceConstraint: () => (/* binding */ DistanceConstraint),
/* harmony export */   Equation: () => (/* binding */ Equation),
/* harmony export */   EventTarget: () => (/* binding */ EventTarget),
/* harmony export */   FrictionEquation: () => (/* binding */ FrictionEquation),
/* harmony export */   GSSolver: () => (/* binding */ GSSolver),
/* harmony export */   GridBroadphase: () => (/* binding */ GridBroadphase),
/* harmony export */   Heightfield: () => (/* binding */ Heightfield),
/* harmony export */   HingeConstraint: () => (/* binding */ HingeConstraint),
/* harmony export */   JacobianElement: () => (/* binding */ JacobianElement),
/* harmony export */   LockConstraint: () => (/* binding */ LockConstraint),
/* harmony export */   Mat3: () => (/* binding */ Mat3),
/* harmony export */   Material: () => (/* binding */ Material),
/* harmony export */   NaiveBroadphase: () => (/* binding */ NaiveBroadphase),
/* harmony export */   Narrowphase: () => (/* binding */ Narrowphase),
/* harmony export */   ObjectCollisionMatrix: () => (/* binding */ ObjectCollisionMatrix),
/* harmony export */   Particle: () => (/* binding */ Particle),
/* harmony export */   Plane: () => (/* binding */ Plane),
/* harmony export */   PointToPointConstraint: () => (/* binding */ PointToPointConstraint),
/* harmony export */   Pool: () => (/* binding */ Pool),
/* harmony export */   Quaternion: () => (/* binding */ Quaternion),
/* harmony export */   RAY_MODES: () => (/* binding */ RAY_MODES),
/* harmony export */   Ray: () => (/* binding */ Ray),
/* harmony export */   RaycastResult: () => (/* binding */ RaycastResult),
/* harmony export */   RaycastVehicle: () => (/* binding */ RaycastVehicle),
/* harmony export */   RigidVehicle: () => (/* binding */ RigidVehicle),
/* harmony export */   RotationalEquation: () => (/* binding */ RotationalEquation),
/* harmony export */   RotationalMotorEquation: () => (/* binding */ RotationalMotorEquation),
/* harmony export */   SAPBroadphase: () => (/* binding */ SAPBroadphase),
/* harmony export */   SHAPE_TYPES: () => (/* binding */ SHAPE_TYPES),
/* harmony export */   SPHSystem: () => (/* binding */ SPHSystem),
/* harmony export */   Shape: () => (/* binding */ Shape),
/* harmony export */   Solver: () => (/* binding */ Solver),
/* harmony export */   Sphere: () => (/* binding */ Sphere),
/* harmony export */   SplitSolver: () => (/* binding */ SplitSolver),
/* harmony export */   Spring: () => (/* binding */ Spring),
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   Trimesh: () => (/* binding */ Trimesh),
/* harmony export */   Vec3: () => (/* binding */ Vec3),
/* harmony export */   Vec3Pool: () => (/* binding */ Vec3Pool),
/* harmony export */   World: () => (/* binding */ World)
/* harmony export */ });
/**
 * Records what objects are colliding with each other
 * @class ObjectCollisionMatrix
 * @constructor
 */
class ObjectCollisionMatrix {
  // The matrix storage.
  constructor() {
    this.matrix = {};
  }
  /**
   * @method get
   * @param  {Body} i
   * @param  {Body} j
   * @return {boolean}
   */


  get(bi, bj) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return i + "-" + j in this.matrix;
  }
  /**
   * @method set
   * @param  {Body} i
   * @param  {Body} j
   * @param {boolean} value
   */


  set(bi, bj, value) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    if (value) {
      this.matrix[i + "-" + j] = true;
    } else {
      delete this.matrix[i + "-" + j];
    }
  }
  /**
   * Empty the matrix
   * @method reset
   */


  reset() {
    this.matrix = {};
  }
  /**
   * Set max number of objects
   * @method setNumObjects
   * @param {Number} n
   */


  setNumObjects(n) {}

}

/**
 * A 3x3 matrix.
 * @class Mat3
 * @constructor
 * @param {Array} elements A vector of length 9, containing all matrix elements. Optional.
 * @author schteppe / http://github.com/schteppe
 */
class Mat3 {
  constructor(elements = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.elements = elements;
  }
  /**
   * Sets the matrix to identity
   * @method identity
   * @todo Should perhaps be renamed to setIdentity() to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. eye()
   */


  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
  }
  /**
   * Set all elements to zero
   * @method setZero
   */


  setZero() {
    const e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   * @method setTrace
   * @param {Vec3} vec3
   */


  setTrace(vector) {
    const e = this.elements;
    e[0] = vector.x;
    e[4] = vector.y;
    e[8] = vector.z;
  }
  /**
   * Gets the matrix diagonal elements
   * @method getTrace
   * @return {Vec3}
   */


  getTrace(target = new Vec3()) {
    const e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
  }
  /**
   * Matrix-Vector multiplication
   * @method vmult
   * @param {Vec3} v The vector to multiply with
   * @param {Vec3} target Optional, target to save the result in.
   */


  vmult(v, target = new Vec3()) {
    const e = this.elements;
    const x = v.x;
    const y = v.y;
    const z = v.z;
    target.x = e[0] * x + e[1] * y + e[2] * z;
    target.y = e[3] * x + e[4] * y + e[5] * z;
    target.z = e[6] * x + e[7] * y + e[8] * z;
    return target;
  }
  /**
   * Matrix-scalar multiplication
   * @method smult
   * @param {Number} s
   */


  smult(s) {
    for (let i = 0; i < this.elements.length; i++) {
      this.elements[i] *= s;
    }
  }
  /**
   * Matrix multiplication
   * @method mmult
   * @param {Mat3} matrix Matrix to multiply with from left side.
   * @return {Mat3} The result.
   */


  mmult(matrix, target = new Mat3()) {
    const {
      elements
    } = matrix;

    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        let sum = 0.0;

        for (let k = 0; k < 3; k++) {
          sum += elements[i + k * 3] * this.elements[k + j * 3];
        }

        target.elements[i + j * 3] = sum;
      }
    }

    return target;
  }
  /**
   * Scale each column of the matrix
   * @method scale
   * @param {Vec3} v
   * @return {Mat3} The result.
   */


  scale(vector, target = new Mat3()) {
    const e = this.elements;
    const t = target.elements;

    for (let i = 0; i !== 3; i++) {
      t[3 * i + 0] = vector.x * e[3 * i + 0];
      t[3 * i + 1] = vector.y * e[3 * i + 1];
      t[3 * i + 2] = vector.z * e[3 * i + 2];
    }

    return target;
  }
  /**
   * Solve Ax=b
   * @method solve
   * @param {Vec3} b The right hand side
   * @param {Vec3} target Optional. Target vector to save in.
   * @return {Vec3} The solution x
   * @todo should reuse arrays
   */


  solve(b, target = new Vec3()) {
    // Construct equations
    const nr = 3; // num rows

    const nc = 4; // num cols

    const eqns = [];
    let i;
    let j;

    for (i = 0; i < nr * nc; i++) {
      eqns.push(0);
    }

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 4 * 0] = b.x;
    eqns[3 + 4 * 1] = b.y;
    eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = 4; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do ligne( i ) = ligne( i ) + ligne( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // Get the solution


    target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
    target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
    target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

    if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
      throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
    }

    return target;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @method e
   * @param {Number} row
   * @param {Number} column
   * @param {Number} value Optional. If provided, the matrix element will be set to this value.
   * @return {Number}
   */


  e(row, column, value) {
    if (value === undefined) {
      return this.elements[column + 3 * row];
    } else {
      // Set value
      this.elements[column + 3 * row] = value;
    }
  }
  /**
   * Copy another matrix into this matrix object.
   * @method copy
   * @param {Mat3} source
   * @return {Mat3} this
   */


  copy(matrix) {
    for (let i = 0; i < matrix.elements.length; i++) {
      this.elements[i] = matrix.elements[i];
    }

    return this;
  }
  /**
   * Returns a string representation of the matrix.
   * @method toString
   * @return string
   */


  toString() {
    let r = '';
    const sep = ',';

    for (let i = 0; i < 9; i++) {
      r += this.elements[i] + sep;
    }

    return r;
  }
  /**
   * reverse the matrix
   * @method reverse
   * @param {Mat3} target Optional. Target matrix to save in.
   * @return {Mat3} The solution x
   */


  reverse(target = new Mat3()) {
    // Construct equations
    const nr = 3; // num rows

    const nc = 6; // num cols

    const eqns = [];
    let i;
    let j;

    for (i = 0; i < nr * nc; i++) {
      eqns.push(0);
    }

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 6 * 0] = 1;
    eqns[3 + 6 * 1] = 0;
    eqns[3 + 6 * 2] = 0;
    eqns[4 + 6 * 0] = 0;
    eqns[4 + 6 * 1] = 1;
    eqns[4 + 6 * 2] = 0;
    eqns[5 + 6 * 0] = 0;
    eqns[5 + 6 * 1] = 0;
    eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = nc; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do line( i ) = line( i ) + line( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do line( k ) = line( k ) - multiplier * line( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // eliminate the upper left triangle of the matrix


    i = 2;

    do {
      j = i - 1;

      do {
        const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
        np = nc;

        do {
          p = nc - np;
          eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
        } while (--np);
      } while (j--);
    } while (--i); // operations on the diagonal


    i = 2;

    do {
      const multiplier = 1 / eqns[i + nc * i];
      np = nc;

      do {
        p = nc - np;
        eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
      } while (--np);
    } while (i--);

    i = 2;

    do {
      j = 2;

      do {
        p = eqns[nr + j + nc * i];

        if (isNaN(p) || p === Infinity) {
          throw "Could not reverse! A=[" + this.toString() + "]";
        }

        target.e(i, j, p);
      } while (j--);
    } while (i--);

    return target;
  }
  /**
   * Set the matrix from a quaterion
   * @method setRotationFromQuaternion
   * @param {Quaternion} q
   */


  setRotationFromQuaternion(q) {
    const x = q.x;
    const y = q.y;
    const z = q.z;
    const w = q.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const e = this.elements;
    e[3 * 0 + 0] = 1 - (yy + zz);
    e[3 * 0 + 1] = xy - wz;
    e[3 * 0 + 2] = xz + wy;
    e[3 * 1 + 0] = xy + wz;
    e[3 * 1 + 1] = 1 - (xx + zz);
    e[3 * 1 + 2] = yz - wx;
    e[3 * 2 + 0] = xz - wy;
    e[3 * 2 + 1] = yz + wx;
    e[3 * 2 + 2] = 1 - (xx + yy);
    return this;
  }
  /**
   * Transpose the matrix
   * @method transpose
   * @param  {Mat3} target Optional. Where to store the result.
   * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
   */


  transpose(target = new Mat3()) {
    const Mt = target.elements;
    const M = this.elements;

    for (let i = 0; i !== 3; i++) {
      for (let j = 0; j !== 3; j++) {
        Mt[3 * i + j] = M[3 * j + i];
      }
    }

    return target;
  }

}

/**
 * 3-dimensional vector
 * @class Vec3
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @author schteppe
 * @example
 *     const v = new Vec3(1, 2, 3);
 *     console.log('x=' + v.x); // x=1
 */

class Vec3 {
  constructor(x = 0.0, y = 0.0, z = 0.0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Vector cross product
   * @method cross
   * @param {Vec3} v
   * @param {Vec3} target Optional. Target to save in.
   * @return {Vec3}
   */


  cross(vector, target = new Vec3()) {
    const vx = vector.x;
    const vy = vector.y;
    const vz = vector.z;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = y * vz - z * vy;
    target.y = z * vx - x * vz;
    target.z = x * vy - y * vx;
    return target;
  }
  /**
   * Set the vectors' 3 elements
   * @method set
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   * @return Vec3
   */


  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Set all components of the vector to zero.
   * @method setZero
   */


  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   * @method vadd
   * @param {Vec3} v
   * @param {Vec3} target Optional.
   * @return {Vec3}
   */


  vadd(vector, target) {
    if (target) {
      target.x = vector.x + this.x;
      target.y = vector.y + this.y;
      target.z = vector.z + this.z;
    } else {
      return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    }
  }
  /**
   * Vector subtraction
   * @method vsub
   * @param {Vec3} v
   * @param {Vec3} target Optional. Target to save in.
   * @return {Vec3}
   */


  vsub(vector, target) {
    if (target) {
      target.x = this.x - vector.x;
      target.y = this.y - vector.y;
      target.z = this.z - vector.z;
    } else {
      return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
    }
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   * @method crossmat
   * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
   * @return {Mat3}
   */


  crossmat() {
    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
   * @method normalize
   * @return {Number} Returns the norm of the vector
   */


  normalize() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const n = Math.sqrt(x * x + y * y + z * z);

    if (n > 0.0) {
      const invN = 1 / n;
      this.x *= invN;
      this.y *= invN;
      this.z *= invN;
    } else {
      // Make something up
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return n;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @method unit
   * @param {Vec3} target Optional target to save in
   * @return {Vec3} Returns the unit vector
   */


  unit(target = new Vec3()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    let ninv = Math.sqrt(x * x + y * y + z * z);

    if (ninv > 0.0) {
      ninv = 1.0 / ninv;
      target.x = x * ninv;
      target.y = y * ninv;
      target.z = z * ninv;
    } else {
      target.x = 1;
      target.y = 0;
      target.z = 0;
    }

    return target;
  }
  /**
   * Get the length of the vector
   * @method length
   * @return {Number}
   */


  length() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Get the squared length of the vector.
   * @method lengthSquared
   * @return {Number}
   */


  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   * @method distanceTo
   * @param  {Vec3} p
   * @return {Number}
   */


  distanceTo(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
  }
  /**
   * Get squared distance from this point to another point
   * @method distanceSquared
   * @param  {Vec3} p
   * @return {Number}
   */


  distanceSquared(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @method scale
   * @param {Number} scalar
   * @param {Vec3} target The vector to save the result in.
   * @return {Vec3}
   */


  scale(scalar, target = new Vec3()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @method vmult
   * @param {Number} vector
   * @param {Vec3} target The vector to save the result in.
   * @return {Vec3}
   */


  vmul(vector, target = new Vec3()) {
    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @method addScaledVector
   * @param {Number} scalar
   * @param {Vec3} vector
   * @param {Vec3} target The vector to save the result in.
   * @return {Vec3}
   */


  addScaledVector(scalar, vector, target = new Vec3()) {
    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
  }
  /**
   * Calculate dot product
   * @method dot
   * @param {Vec3} v
   * @return {Number}
   */


  dot(vector) {
    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
  }
  /**
   * @method isZero
   * @return bool
   */


  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @method negate
   * @param {Vec3} target Optional target to save in
   * @return {Vec3}
   */


  negate(target = new Vec3()) {
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
  }
  /**
   * Compute two artificial tangents to the vector
   * @method tangents
   * @param {Vec3} t1 Vector object to save the first tangent in
   * @param {Vec3} t2 Vector object to save the second tangent in
   */


  tangents(t1, t2) {
    const norm = this.length();

    if (norm > 0.0) {
      const n = Vec3_tangents_n;
      const inorm = 1 / norm;
      n.set(this.x * inorm, this.y * inorm, this.z * inorm);
      const randVec = Vec3_tangents_randVec;

      if (Math.abs(n.x) < 0.9) {
        randVec.set(1, 0, 0);
        n.cross(randVec, t1);
      } else {
        randVec.set(0, 1, 0);
        n.cross(randVec, t1);
      }

      n.cross(t1, t2);
    } else {
      // The normal length is zero, make something up
      t1.set(1, 0, 0);
      t2.set(0, 1, 0);
    }
  }
  /**
   * Converts to a more readable format
   * @method toString
   * @return string
   */


  toString() {
    return this.x + "," + this.y + "," + this.z;
  }
  /**
   * Converts to an array
   * @method toArray
   * @return Array
   */


  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   * @method copy
   * @param {Vec3} source
   * @return {Vec3} this
   */


  copy(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @method lerp
   * @param {Vec3} v
   * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   * @param {Vec3} target
   */


  lerp(vector, t, target) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = x + (vector.x - x) * t;
    target.y = y + (vector.y - y) * t;
    target.z = z + (vector.z - z) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   * @method almostEquals
   * @param {Vec3} v
   * @param {Number} precision
   * @return bool
   */


  almostEquals(vector, precision = 1e-6) {
    if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if a vector is almost zero
   * @method almostZero
   * @param {Number} precision
   */


  almostZero(precision = 1e-6) {
    if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @method isAntiparallelTo
   * @param  {Vec3}  v
   * @param  {Number}  precision Set to zero for exact comparisons
   * @return {Boolean}
   */


  isAntiparallelTo(vector, precision) {
    this.negate(antip_neg);
    return antip_neg.almostEquals(vector, precision);
  }
  /**
   * Clone the vector
   * @method clone
   * @return {Vec3}
   */


  clone() {
    return new Vec3(this.x, this.y, this.z);
  }

}
Vec3.ZERO = new Vec3(0, 0, 0);
Vec3.UNIT_X = new Vec3(1, 0, 0);
Vec3.UNIT_Y = new Vec3(0, 1, 0);
Vec3.UNIT_Z = new Vec3(0, 0, 1);
/**
 * Compute two artificial tangents to the vector
 * @method tangents
 * @param {Vec3} t1 Vector object to save the first tangent in
 * @param {Vec3} t2 Vector object to save the second tangent in
 */

const Vec3_tangents_n = new Vec3();
const Vec3_tangents_randVec = new Vec3();
const antip_neg = new Vec3();

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object} [options]
 * @param {Vec3}   [options.upperBound] The upper bound of the bounding box.
 * @param {Vec3}   [options.lowerBound] The lower bound of the bounding box
 */
class AABB {
  // The lower bound of the bounding box
  // The upper bound of the bounding box
  constructor(options = {}) {
    this.lowerBound = new Vec3();
    this.upperBound = new Vec3();

    if (options.lowerBound) {
      this.lowerBound.copy(options.lowerBound);
    }

    if (options.upperBound) {
      this.upperBound.copy(options.upperBound);
    }
  }
  /**
   * Set the AABB bounds from a set of points.
   * @method setFromPoints
   * @param {Array} points An array of Vec3's.
   * @param {Vec3} position Optional.
   * @param {Quaternion} quaternion Optional.
   * @param {number} skinSize Optional.
   * @return {AABB} The self object
   */


  setFromPoints(points, position, quaternion, skinSize) {
    const l = this.lowerBound;
    const u = this.upperBound;
    const q = quaternion; // Set to the first point

    l.copy(points[0]);

    if (q) {
      q.vmult(l, l);
    }

    u.copy(l);

    for (let i = 1; i < points.length; i++) {
      let p = points[i];

      if (q) {
        q.vmult(p, tmp);
        p = tmp;
      }

      if (p.x > u.x) {
        u.x = p.x;
      }

      if (p.x < l.x) {
        l.x = p.x;
      }

      if (p.y > u.y) {
        u.y = p.y;
      }

      if (p.y < l.y) {
        l.y = p.y;
      }

      if (p.z > u.z) {
        u.z = p.z;
      }

      if (p.z < l.z) {
        l.z = p.z;
      }
    } // Add offset


    if (position) {
      position.vadd(l, l);
      position.vadd(u, u);
    }

    if (skinSize) {
      l.x -= skinSize;
      l.y -= skinSize;
      l.z -= skinSize;
      u.x += skinSize;
      u.y += skinSize;
      u.z += skinSize;
    }

    return this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @method copy
   * @param  {AABB} aabb Source to copy from
   * @return {AABB} The this object, for chainability
   */


  copy(aabb) {
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
  }
  /**
   * Clone an AABB
   * @method clone
   */


  clone() {
    return new AABB().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   * @method extend
   * @param  {AABB} aabb
   */


  extend(aabb) {
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   * @method overlaps
   * @param  {AABB} aabb
   * @return {Boolean}
   */


  overlaps(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    const overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
    const overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
    const overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
    return overlapsX && overlapsY && overlapsZ;
  } // Mostly for debugging


  volume() {
    const l = this.lowerBound;
    const u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   * @method contains
   * @param {AABB} aabb
   * @return {Boolean}
   */


  contains(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
  }
  /**
   * @method getCorners
   * @param {Vec3} a
   * @param {Vec3} b
   * @param {Vec3} c
   * @param {Vec3} d
   * @param {Vec3} e
   * @param {Vec3} f
   * @param {Vec3} g
   * @param {Vec3} h
   */


  getCorners(a, b, c, d, e, f, g, h) {
    const l = this.lowerBound;
    const u = this.upperBound;
    a.copy(l);
    b.set(u.x, l.y, l.z);
    c.set(u.x, u.y, l.z);
    d.set(l.x, u.y, u.z);
    e.set(u.x, l.y, u.z);
    f.set(l.x, u.y, l.z);
    g.set(l.x, l.y, u.z);
    h.copy(u);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @method toLocalFrame
   * @param  {Transform} frame
   * @param  {AABB} target
   * @return {AABB} The "target" AABB object.
   */


  toLocalFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @method toWorldFrame
   * @param  {Transform} frame
   * @param  {AABB} target
   * @return {AABB} The "target" AABB object.
   */


  toWorldFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Check if the AABB is hit by a ray.
   * @param  {Ray} ray
   * @return {Boolean}
   */


  overlapsRay(ray) {
    const {
      direction,
      from
    } = ray;

    const dirFracX = 1 / direction.x;
    const dirFracY = 1 / direction.y;
    const dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

    const t1 = (this.lowerBound.x - from.x) * dirFracX;
    const t2 = (this.upperBound.x - from.x) * dirFracX;
    const t3 = (this.lowerBound.y - from.y) * dirFracY;
    const t4 = (this.upperBound.y - from.y) * dirFracY;
    const t5 = (this.lowerBound.z - from.z) * dirFracZ;
    const t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

    if (tmax < 0) {
      //t = tmax;
      return false;
    } // if tmin > tmax, ray doesn't intersect AABB


    if (tmin > tmax) {
      //t = tmax;
      return false;
    }

    return true;
  }

}
const tmp = new Vec3();
const transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

/**
 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 * @class ArrayCollisionMatrix
 * @constructor
 */
class ArrayCollisionMatrix {
  // The matrix storage.
  constructor() {
    this.matrix = [];
  }
  /**
   * Get an element
   * @method get
   * @param  {Body} i
   * @param  {Body} j
   * @return {Number}
   */


  get(bi, bj) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return this.matrix[(i * (i + 1) >> 1) + j - 1];
  }
  /**
   * Set an element
   * @method set
   * @param {Body} i
   * @param {Body} j
   * @param {boolean} value
   */


  set(bi, bj, value) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
  }
  /**
   * Sets all elements to zero
   * @method reset
   */


  reset() {
    for (let i = 0, l = this.matrix.length; i !== l; i++) {
      this.matrix[i] = 0;
    }
  }
  /**
   * Sets the max number of objects
   * @method setNumObjects
   * @param {Number} n
   */


  setNumObjects(n) {
    this.matrix.length = n * (n - 1) >> 1;
  }

}

/**
 * Base class for objects that dispatches events.
 * @class EventTarget
 * @constructor
 */
class EventTarget {
  constructor() {}
  /**
   * Add an event listener
   * @method addEventListener
   * @param  {String} type
   * @param  {Function} listener
   * @return {EventTarget} The self object, for chainability.
   */


  addEventListener(type, listener) {
    if (this._listeners === undefined) {
      this._listeners = {};
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }

    return this;
  }
  /**
   * Check if an event listener is added
   * @method hasEventListener
   * @param  {String} type
   * @param  {Function} listener
   * @return {Boolean}
   */


  hasEventListener(type, listener) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;

    if (listeners[type] !== undefined && listeners[type].includes(listener)) {
      return true;
    }

    return false;
  }
  /**
   * Check if any event listener of the given type is added
   * @method hasAnyEventListener
   * @param  {String} type
   * @return {Boolean}
   */


  hasAnyEventListener(type) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;
    return listeners[type] !== undefined;
  }
  /**
   * Remove an event listener
   * @method removeEventListener
   * @param  {String} type
   * @param  {Function} listener
   * @return {EventTarget} The self object, for chainability.
   */


  removeEventListener(type, listener) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      return this;
    }

    const index = listeners[type].indexOf(listener);

    if (index !== -1) {
      listeners[type].splice(index, 1);
    }

    return this;
  }
  /**
   * Emit an event.
   * @method dispatchEvent
   * @param  {Object} event
   * @param  {String} event.type
   * @return {EventTarget} The self object, for chainability.
   */


  dispatchEvent(event) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;

      for (let i = 0, l = listenerArray.length; i < l; i++) {
        listenerArray[i].call(this, event);
      }
    }

    return this;
  }

}

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @param {Number} x Multiplier of the imaginary basis vector i.
 * @param {Number} y Multiplier of the imaginary basis vector j.
 * @param {Number} z Multiplier of the imaginary basis vector k.
 * @param {Number} w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Set the value of the quaternion.
   */


  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Convert to a readable format
   * @return {String} "x,y,z,w"
   */


  toString() {
    return this.x + "," + this.y + "," + this.z + "," + this.w;
  }
  /**
   * Convert to an Array
   * @return {Array} [x, y, z, w]
   */


  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */


  setFromAxisAngle(vector, angle) {
    const s = Math.sin(angle * 0.5);
    this.x = vector.x * s;
    this.y = vector.y * s;
    this.z = vector.z * s;
    this.w = Math.cos(angle * 0.5);
    return this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param {Vec3} [targetAxis] A vector object to reuse for storing the axis.
   * @return {Array} An array, first element is the axis and the second is the angle in radians.
   */


  toAxisAngle(targetAxis = new Vec3()) {
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

    const angle = 2 * Math.acos(this.w);
    const s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

    if (s < 0.001) {
      // test to avoid divide by zero, s is always positive due to sqrt
      // if s close to zero then direction of axis not important
      targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

      targetAxis.y = this.y;
      targetAxis.z = this.z;
    } else {
      targetAxis.x = this.x / s; // normalise axis

      targetAxis.y = this.y / s;
      targetAxis.z = this.z / s;
    }

    return [targetAxis, angle];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */


  setFromVectors(u, v) {
    if (u.isAntiparallelTo(v)) {
      const t1 = sfv_t1;
      const t2 = sfv_t2;
      u.tangents(t1, t2);
      this.setFromAxisAngle(t1, Math.PI);
    } else {
      const a = u.cross(v);
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
      this.normalize();
    }

    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */


  mult(quat, target = new Quaternion()) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bx = quat.x;
    const by = quat.y;
    const bz = quat.z;
    const bw = quat.w;
    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;
    return target;
  }
  /**
   * Get the inverse quaternion rotation.
   */


  inverse(target = new Quaternion()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    this.conjugate(target);
    const inorm2 = 1 / (x * x + y * y + z * z + w * w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;
    return target;
  }
  /**
   * Get the quaternion conjugate
   */


  conjugate(target = new Quaternion()) {
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;
    return target;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   * @method normalize
   */


  normalize() {
    let l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      l = 1 / l;
      this.x *= l;
      this.y *= l;
      this.z *= l;
      this.w *= l;
    }

    return this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @see http://jsperf.com/fast-quaternion-normalization
   * @author unphased, https://github.com/unphased
   */


  normalizeFast() {
    const f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

    if (f === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      this.x *= f;
      this.y *= f;
      this.z *= f;
      this.w *= f;
    }

    return this;
  }
  /**
   * Multiply the quaternion by a vector
   */


  vmult(v, target = new Vec3()) {
    const x = v.x;
    const y = v.y;
    const z = v.z;
    const qx = this.x;
    const qy = this.y;
    const qz = this.z;
    const qw = this.w; // q*v

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return target;
  }
  /**
   * Copies value of source to this quaternion.
   * @method copy
   * @param {Quaternion} source
   * @return {Quaternion} this
   */


  copy(quat) {
    this.x = quat.x;
    this.y = quat.y;
    this.z = quat.z;
    this.w = quat.w;
    return this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
   * @method toEuler
   * @param {Vec3} target
   * @param {String} order Three-character string, defaults to "YZX"
   */


  toEuler(target, order = 'YZX') {
    let heading;
    let attitude;
    let bank;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;

    switch (order) {
      case 'YZX':
        const test = x * y + z * w;

        if (test > 0.499) {
          // singularity at north pole
          heading = 2 * Math.atan2(x, w);
          attitude = Math.PI / 2;
          bank = 0;
        }

        if (test < -0.499) {
          // singularity at south pole
          heading = -2 * Math.atan2(x, w);
          attitude = -Math.PI / 2;
          bank = 0;
        }

        if (heading === undefined) {
          const sqx = x * x;
          const sqy = y * y;
          const sqz = z * z;
          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

          attitude = Math.asin(2 * test); // attitude

          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
        }

        break;

      default:
        throw new Error("Euler order " + order + " not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
  }
  /**
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
   * @see http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
   */


  setFromEuler(x, y, z, order = 'XYZ') {
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);

    if (order === 'XYZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    return this;
  }
  /**
   * @method clone
   * @return {Quaternion}
   */


  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {Quaternion} toQuat second operand
   * @param {Number} t interpolation amount between the self quaternion and toQuat
   * @param {Quaternion} [target] A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */


  slerp(toQuat, t, target = new Quaternion()) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    let bx = toQuat.x;
    let by = toQuat.y;
    let bz = toQuat.z;
    let bw = toQuat.w;
    let omega;
    let cosom;
    let sinom;
    let scale0;
    let scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > 0.000001) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;
    return target;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */


  integrate(angularVelocity, dt, angularFactor, target = new Quaternion()) {
    const ax = angularVelocity.x * angularFactor.x,
          ay = angularVelocity.y * angularFactor.y,
          az = angularVelocity.z * angularFactor.z,
          bx = this.x,
          by = this.y,
          bz = this.z,
          bw = this.w;
    const half_dt = dt * 0.5;
    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (-ax * bx - ay * by - az * bz);
    return target;
  }

}
const sfv_t1 = new Vec3();
const sfv_t2 = new Vec3();

const SHAPE_TYPES = {
  SPHERE: 1,
  PLANE: 2,
  BOX: 4,
  COMPOUND: 8,
  CONVEXPOLYHEDRON: 16,
  HEIGHTFIELD: 32,
  PARTICLE: 64,
  CYLINDER: 128,
  TRIMESH: 256
};

/**
 * Base class for shapes
 * @class Shape
 * @constructor
 * @param {object} [options]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=-1]
 * @param {number} [options.collisionResponse=true]
 * @param {number} [options.material=null]
 * @author schteppe
 */
class Shape {
  // Identifyer of the Shape.
  // The type of this shape. Must be set to an int > 0 by subclasses.
  // The local bounding sphere radius of this shape.
  // Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
  constructor(options = {}) {
    this.id = Shape.idCounter++;
    this.type = options.type || 0;
    this.boundingSphereRadius = 0;
    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
    this.material = options.material ? options.material : null;
    this.body = null;
  }
  /**
   * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
   * @method updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
  }
  /**
   * Get the volume of this shape
   * @method volume
   * @return {Number}
   */


  volume() {
    throw "volume() not implemented for shape type " + this.type;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @method calculateLocalInertia
   * @param {Number} mass
   * @param {Vec3} target
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */


  calculateLocalInertia(mass, target) {
    throw "calculateLocalInertia() not implemented for shape type " + this.type;
  }

  calculateWorldAABB(pos, quat, min, max) {
    throw "calculateWorldAABB() not implemented for shape type " + this.type;
  }

}
Shape.idCounter = 0;
/**
 * The available shape types.
 * @static
 * @property types
 * @type {Object}
 */

Shape.types = SHAPE_TYPES;

class Transform {
  constructor(options = {}) {
    this.position = new Vec3();
    this.quaternion = new Quaternion();

    if (options.position) {
      this.position.copy(options.position);
    }

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
    }
  }
  /**
   * Get a global point in local transform coordinates.
   */


  pointToLocal(worldPoint, result) {
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
  }
  /**
   * Get a local point in global transform coordinates.
   */


  pointToWorld(localPoint, result) {
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
  }

  vectorToWorldFrame(localVector, result = new Vec3()) {
    this.quaternion.vmult(localVector, result);
    return result;
  }

  static pointToLocalFrame(position, quaternion, worldPoint, result = new Vec3()) {
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat);
    tmpQuat.vmult(result, result);
    return result;
  }

  static pointToWorldFrame(position, quaternion, localPoint, result = new Vec3()) {
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
  }

  static vectorToWorldFrame(quaternion, localVector, result = new Vec3()) {
    quaternion.vmult(localVector, result);
    return result;
  }

  static vectorToLocalFrame(position, quaternion, worldVector, result = new Vec3()) {
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
  }

}
const tmpQuat = new Quaternion();

/**
 * A set of polygons describing a convex shape.
 * @class ConvexPolyhedron
 * @constructor
 * @extends Shape
 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @param {array} points An array of Vec3's
 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 */
class ConvexPolyhedron extends Shape {
  // Array of integer arrays, indicating which vertices each face consists of
  // If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
  constructor(props = {}) {
    const {
      vertices = [],
      faces = [],
      normals = [],
      axes,
      boundingSphereRadius
    } = props;
    super({
      type: Shape.types.CONVEXPOLYHEDRON
    });
    this.vertices = vertices;
    this.faces = faces;
    this.faceNormals = normals;

    if (this.faceNormals.length === 0) {
      this.computeNormals();
    }

    if (!boundingSphereRadius) {
      this.updateBoundingSphereRadius();
    } else {
      this.boundingSphereRadius = boundingSphereRadius;
    }

    this.worldVertices = []; // World transformed version of .vertices

    this.worldVerticesNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    this.worldFaceNormalsNeedsUpdate = true;
    this.uniqueAxes = axes ? axes.slice() : null;
    this.uniqueEdges = [];
    this.computeEdges();
  }
  /**
   * Computes uniqueEdges
   * @method computeEdges
   */


  computeEdges() {
    const faces = this.faces;
    const vertices = this.vertices;
    const edges = this.uniqueEdges;
    edges.length = 0;
    const edge = new Vec3();

    for (let i = 0; i !== faces.length; i++) {
      const face = faces[i];
      const numVertices = face.length;

      for (let j = 0; j !== numVertices; j++) {
        const k = (j + 1) % numVertices;
        vertices[face[j]].vsub(vertices[face[k]], edge);
        edge.normalize();
        let found = false;

        for (let p = 0; p !== edges.length; p++) {
          if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
            found = true;
            break;
          }
        }

        if (!found) {
          edges.push(edge.clone());
        }
      }
    }
  }
  /**
   * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
   * @method computeNormals
   */


  computeNormals() {
    this.faceNormals.length = this.faces.length; // Generate normals

    for (let i = 0; i < this.faces.length; i++) {
      // Check so all vertices exists for this face
      for (let j = 0; j < this.faces[i].length; j++) {
        if (!this.vertices[this.faces[i][j]]) {
          throw new Error("Vertex " + this.faces[i][j] + " not found!");
        }
      }

      const n = this.faceNormals[i] || new Vec3();
      this.getFaceNormal(i, n);
      n.negate(n);
      this.faceNormals[i] = n;
      const vertex = this.vertices[this.faces[i][0]];

      if (n.dot(vertex) < 0) {
        console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");

        for (let j = 0; j < this.faces[i].length; j++) {
          console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
        }
      }
    }
  }
  /**
   * Compute the normal of a face from its vertices
   * @method getFaceNormal
   * @param  {Number} i
   * @param  {Vec3} target
   */


  getFaceNormal(i, target) {
    const f = this.faces[i];
    const va = this.vertices[f[0]];
    const vb = this.vertices[f[1]];
    const vc = this.vertices[f[2]];
    ConvexPolyhedron.computeNormal(va, vb, vc, target);
  }
  /**
   * @method clipAgainstHull
   * @param {Vec3} posA
   * @param {Quaternion} quatA
   * @param {ConvexPolyhedron} hullB
   * @param {Vec3} posB
   * @param {Quaternion} quatB
   * @param {Vec3} separatingNormal
   * @param {Number} minDist Clamp distance
   * @param {Number} maxDist
   * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
   */


  clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
    const WorldNormal = new Vec3();
    let closestFaceB = -1;
    let dmax = -Number.MAX_VALUE;

    for (let face = 0; face < hullB.faces.length; face++) {
      WorldNormal.copy(hullB.faceNormals[face]);
      quatB.vmult(WorldNormal, WorldNormal);
      const d = WorldNormal.dot(separatingNormal);

      if (d > dmax) {
        dmax = d;
        closestFaceB = face;
      }
    }

    const worldVertsB1 = [];

    for (let i = 0; i < hullB.faces[closestFaceB].length; i++) {
      const b = hullB.vertices[hullB.faces[closestFaceB][i]];
      const worldb = new Vec3();
      worldb.copy(b);
      quatB.vmult(worldb, worldb);
      posB.vadd(worldb, worldb);
      worldVertsB1.push(worldb);
    }

    if (closestFaceB >= 0) {
      this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
    }
  }
  /**
   * Find the separating axis between this hull and another
   * @method findSeparatingAxis
   * @param {ConvexPolyhedron} hullB
   * @param {Vec3} posA
   * @param {Quaternion} quatA
   * @param {Vec3} posB
   * @param {Quaternion} quatB
   * @param {Vec3} target The target vector to save the axis in
   * @return {bool} Returns false if a separation is found, else true
   */


  findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
    const faceANormalWS3 = new Vec3();
    const Worldnormal1 = new Vec3();
    const deltaC = new Vec3();
    const worldEdge0 = new Vec3();
    const worldEdge1 = new Vec3();
    const Cross = new Vec3();
    let dmin = Number.MAX_VALUE;
    const hullA = this;

    if (!hullA.uniqueAxes) {
      const numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

      for (let i = 0; i < numFacesA; i++) {
        const fi = faceListA ? faceListA[i] : i; // Get world face normal

        faceANormalWS3.copy(hullA.faceNormals[fi]);
        quatA.vmult(faceANormalWS3, faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    } else {
      // Test unique axes
      for (let i = 0; i !== hullA.uniqueAxes.length; i++) {
        // Get world axis
        quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    }

    if (!hullB.uniqueAxes) {
      // Test face normals from hullB
      const numFacesB = faceListB ? faceListB.length : hullB.faces.length;

      for (let i = 0; i < numFacesB; i++) {
        const fi = faceListB ? faceListB[i] : i;
        Worldnormal1.copy(hullB.faceNormals[fi]);
        quatB.vmult(Worldnormal1, Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } else {
      // Test unique axes in B
      for (let i = 0; i !== hullB.uniqueAxes.length; i++) {
        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } // Test edges


    for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
      // Get world edge
      quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

      for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
        // Get world edge 2
        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
        worldEdge0.cross(worldEdge1, Cross);

        if (!Cross.almostZero()) {
          Cross.normalize();
          const dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

          if (dist === false) {
            return false;
          }

          if (dist < dmin) {
            dmin = dist;
            target.copy(Cross);
          }
        }
      }
    }

    posB.vsub(posA, deltaC);

    if (deltaC.dot(target) > 0.0) {
      target.negate(target);
    }

    return true;
  }
  /**
   * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
   * @method testSepAxis
   * @param {Vec3} axis
   * @param {ConvexPolyhedron} hullB
   * @param {Vec3} posA
   * @param {Quaternion} quatA
   * @param {Vec3} posB
   * @param {Quaternion} quatB
   * @return {number} The overlap depth, or FALSE if no penetration.
   */


  testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
    const hullA = this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    const maxA = maxminA[0];
    const minA = maxminA[1];
    const maxB = maxminB[0];
    const minB = maxminB[1];

    if (maxA < minB || maxB < minA) {
      return false; // Separated
    }

    const d0 = maxA - minB;
    const d1 = maxB - minA;
    const depth = d0 < d1 ? d0 : d1;
    return depth;
  }
  /**
   * @method calculateLocalInertia
   * @param  {Number} mass
   * @param  {Vec3} target
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    const aabbmax = new Vec3();
    const aabbmin = new Vec3();
    this.computeLocalAABB(aabbmin, aabbmax);
    const x = aabbmax.x - aabbmin.x;
    const y = aabbmax.y - aabbmin.y;
    const z = aabbmax.z - aabbmin.z;
    target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
    target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
    target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
  }
  /**
   * @method getPlaneConstantOfFace
   * @param  {Number} face_i Index of the face
   * @return {Number}
   */


  getPlaneConstantOfFace(face_i) {
    const f = this.faces[face_i];
    const n = this.faceNormals[face_i];
    const v = this.vertices[f[0]];
    const c = -n.dot(v);
    return c;
  }
  /**
   * Clip a face against a hull.
   * @method clipFaceAgainstHull
   * @param {Vec3} separatingNormal
   * @param {Vec3} posA
   * @param {Quaternion} quatA
   * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
   * @param {Number} minDist Distance clamping
   * @param {Number} maxDist
   * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
   */


  clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
    const faceANormalWS = new Vec3();
    const edge0 = new Vec3();
    const WorldEdge0 = new Vec3();
    const worldPlaneAnormal1 = new Vec3();
    const planeNormalWS1 = new Vec3();
    const worldA1 = new Vec3();
    const localPlaneNormal = new Vec3();
    const planeNormalWS = new Vec3();
    const hullA = this;
    const worldVertsB2 = [];
    const pVtxIn = worldVertsB1;
    const pVtxOut = worldVertsB2;
    let closestFaceA = -1;
    let dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis

    for (let face = 0; face < hullA.faces.length; face++) {
      faceANormalWS.copy(hullA.faceNormals[face]);
      quatA.vmult(faceANormalWS, faceANormalWS);
      const d = faceANormalWS.dot(separatingNormal);

      if (d < dmin) {
        dmin = d;
        closestFaceA = face;
      }
    }

    if (closestFaceA < 0) {
      return;
    } // Get the face and construct connected faces


    const polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];

    for (let i = 0; i < hullA.faces.length; i++) {
      for (let j = 0; j < hullA.faces[i].length; j++) {
        if (
        /* Sharing a vertex*/
        polyA.indexOf(hullA.faces[i][j]) !== -1 &&
        /* Not the one we are looking for connections from */
        i !== closestFaceA &&
        /* Not already added */
        polyA.connectedFaces.indexOf(i) === -1) {
          polyA.connectedFaces.push(i);
        }
      }
    } // Clip the polygon to the back of the planes of all faces of hull A,
    // that are adjacent to the witness face


    const numVerticesA = polyA.length;

    for (let i = 0; i < numVerticesA; i++) {
      const a = hullA.vertices[polyA[i]];
      const b = hullA.vertices[polyA[(i + 1) % numVerticesA]];
      a.vsub(b, edge0);
      WorldEdge0.copy(edge0);
      quatA.vmult(WorldEdge0, WorldEdge0);
      posA.vadd(WorldEdge0, WorldEdge0);
      worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
      quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
      posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
      WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
      planeNormalWS1.negate(planeNormalWS1);
      worldA1.copy(a);
      quatA.vmult(worldA1, worldA1);
      posA.vadd(worldA1, worldA1);
      const otherFace = polyA.connectedFaces[i];
      localPlaneNormal.copy(this.faceNormals[otherFace]);
      const localPlaneEq = this.getPlaneConstantOfFace(otherFace);
      planeNormalWS.copy(localPlaneNormal);
      quatA.vmult(planeNormalWS, planeNormalWS);
      const planeEqWS = localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane

      this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the remaining until next clip

      while (pVtxIn.length) {
        pVtxIn.shift();
      }

      while (pVtxOut.length) {
        pVtxIn.push(pVtxOut.shift());
      }
    } // only keep contact points that are behind the witness face


    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
    const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS, planeNormalWS);
    const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

    for (let i = 0; i < pVtxIn.length; i++) {
      let depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; // ???

      if (depth <= minDist) {
        console.log("clamped: depth=" + depth + " to minDist=" + minDist);
        depth = minDist;
      }

      if (depth <= maxDist) {
        const point = pVtxIn[i];

        if (depth <= 1e-6) {
          const p = {
            point,
            normal: planeNormalWS,
            depth
          };
          result.push(p);
        }
      }
    }
  }
  /**
   * Clip a face in a hull against the back of a plane.
   * @method clipFaceAgainstPlane
   * @param {Array} inVertices
   * @param {Array} outVertices
   * @param {Vec3} planeNormal
   * @param {Number} planeConstant The constant in the mathematical plane equation
   */


  clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {
    let n_dot_first;
    let n_dot_last;
    const numVerts = inVertices.length;

    if (numVerts < 2) {
      return outVertices;
    }

    let firstVertex = inVertices[inVertices.length - 1];
    let lastVertex = inVertices[0];
    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for (let vi = 0; vi < numVerts; vi++) {
      lastVertex = inVertices[vi];
      n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

      if (n_dot_first < 0) {
        if (n_dot_last < 0) {
          // Start < 0, end < 0, so output lastVertex
          const newv = new Vec3();
          newv.copy(lastVertex);
          outVertices.push(newv);
        } else {
          // Start < 0, end >= 0, so output intersection
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
        }
      } else {
        if (n_dot_last < 0) {
          // Start >= 0, end < 0 so output intersection and end
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
          outVertices.push(lastVertex);
        }
      }

      firstVertex = lastVertex;
      n_dot_first = n_dot_last;
    }

    return outVertices;
  } // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.


  computeWorldVertices(position, quat) {
    while (this.worldVertices.length < this.vertices.length) {
      this.worldVertices.push(new Vec3());
    }

    const verts = this.vertices;
    const worldVerts = this.worldVertices;

    for (let i = 0; i !== this.vertices.length; i++) {
      quat.vmult(verts[i], worldVerts[i]);
      position.vadd(worldVerts[i], worldVerts[i]);
    }

    this.worldVerticesNeedsUpdate = false;
  }

  computeLocalAABB(aabbmin, aabbmax) {
    const vertices = this.vertices;
    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for (let i = 0; i < this.vertices.length; i++) {
      const v = vertices[i];

      if (v.x < aabbmin.x) {
        aabbmin.x = v.x;
      } else if (v.x > aabbmax.x) {
        aabbmax.x = v.x;
      }

      if (v.y < aabbmin.y) {
        aabbmin.y = v.y;
      } else if (v.y > aabbmax.y) {
        aabbmax.y = v.y;
      }

      if (v.z < aabbmin.z) {
        aabbmin.z = v.z;
      } else if (v.z > aabbmax.z) {
        aabbmax.z = v.z;
      }
    }
  }
  /**
   * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
   * @method computeWorldFaceNormals
   * @param  {Quaternion} quat
   */


  computeWorldFaceNormals(quat) {
    const N = this.faceNormals.length;

    while (this.worldFaceNormals.length < N) {
      this.worldFaceNormals.push(new Vec3());
    }

    const normals = this.faceNormals;
    const worldNormals = this.worldFaceNormals;

    for (let i = 0; i !== N; i++) {
      quat.vmult(normals[i], worldNormals[i]);
    }

    this.worldFaceNormalsNeedsUpdate = false;
  }
  /**
   * @method updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const verts = this.vertices;

    for (let i = 0; i !== verts.length; i++) {
      const norm2 = verts[i].lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * @method calculateWorldAABB
   * @param {Vec3}        pos
   * @param {Quaternion}  quat
   * @param {Vec3}        min
   * @param {Vec3}        max
   */


  calculateWorldAABB(pos, quat, min, max) {
    const verts = this.vertices;
    let minx;
    let miny;
    let minz;
    let maxx;
    let maxy;
    let maxz;
    let tempWorldVertex = new Vec3();

    for (let i = 0; i < verts.length; i++) {
      tempWorldVertex.copy(verts[i]);
      quat.vmult(tempWorldVertex, tempWorldVertex);
      pos.vadd(tempWorldVertex, tempWorldVertex);
      const v = tempWorldVertex;

      if (minx === undefined || v.x < minx) {
        minx = v.x;
      }

      if (maxx === undefined || v.x > maxx) {
        maxx = v.x;
      }

      if (miny === undefined || v.y < miny) {
        miny = v.y;
      }

      if (maxy === undefined || v.y > maxy) {
        maxy = v.y;
      }

      if (minz === undefined || v.z < minz) {
        minz = v.z;
      }

      if (maxz === undefined || v.z > maxz) {
        maxz = v.z;
      }
    }

    min.set(minx, miny, minz);
    max.set(maxx, maxy, maxz);
  }
  /**
   * Get approximate convex volume
   * @method volume
   * @return {Number}
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }
  /**
   * Get an average of all the vertices positions
   * @method getAveragePointLocal
   * @param  {Vec3} target
   * @return {Vec3}
   */


  getAveragePointLocal(target = new Vec3()) {
    const verts = this.vertices;

    for (let i = 0; i < verts.length; i++) {
      target.vadd(verts[i], target);
    }

    target.scale(1 / verts.length, target);
    return target;
  }
  /**
   * Transform all local points. Will change the .vertices
   * @method transformAllPoints
   * @param  {Vec3} offset
   * @param  {Quaternion} quat
   */


  transformAllPoints(offset, quat) {
    const n = this.vertices.length;
    const verts = this.vertices; // Apply rotation

    if (quat) {
      // Rotate vertices
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        quat.vmult(v, v);
      } // Rotate face normals


      for (let i = 0; i < this.faceNormals.length; i++) {
        const v = this.faceNormals[i];
        quat.vmult(v, v);
      }
      /*
            // Rotate edges
            for(let i=0; i<this.uniqueEdges.length; i++){
                const v = this.uniqueEdges[i];
                quat.vmult(v,v);
            }*/

    } // Apply offset


    if (offset) {
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        v.vadd(offset, v);
      }
    }
  }
  /**
   * Checks whether p is inside the polyhedra. Must be in local coords.
   * The point lies outside of the convex hull of the other points if and only if the direction
   * of all the vectors from it to those other points are on less than one half of a sphere around it.
   * @method pointIsInside
   * @param  {Vec3} p      A point given in local coordinates
   * @return {Boolean}
   */


  pointIsInside(p) {
    const verts = this.vertices;
    const faces = this.faces;
    const normals = this.faceNormals;
    const pointInside = new Vec3();
    this.getAveragePointLocal(pointInside);

    for (let i = 0; i < this.faces.length; i++) {
      let n = normals[i];
      const v = verts[faces[i][0]]; // We only need one point in the face
      // This dot product determines which side of the edge the point is

      const vToP = new Vec3();
      p.vsub(v, vToP);
      const r1 = n.dot(vToP);
      const vToPointInside = new Vec3();
      pointInside.vsub(v, vToPointInside);
      const r2 = n.dot(vToPointInside);

      if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
        return false; // Encountered some other sign. Exit.
      }
    } // If we got here, all dot products were of the same sign.


    return  -1;
  }

}
/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */

ConvexPolyhedron.computeNormal = (va, vb, vc, target) => {
  const cb = new Vec3();
  const ab = new Vec3();
  vb.vsub(va, ab);
  vc.vsub(vb, cb);
  cb.cross(ab, target);

  if (!target.isZero()) {
    target.normalize();
  }
};

const maxminA = [];
const maxminB = [];
/**
 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
 * Results are saved in the array maxmin.
 * @static
 * @method project
 * @param {ConvexPolyhedron} hull
 * @param {Vec3} axis
 * @param {Vec3} pos
 * @param {Quaternion} quat
 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
 */

ConvexPolyhedron.project = (shape, axis, pos, quat, result) => {
  const n = shape.vertices.length;
  const localAxis = new Vec3();
  let max = 0;
  let min = 0;
  const localOrigin = new Vec3();
  const vs = shape.vertices;
  localOrigin.setZero(); // Transform the axis to local

  Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
  Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
  const add = localOrigin.dot(localAxis);
  min = max = vs[0].dot(localAxis);

  for (let i = 1; i < n; i++) {
    const val = vs[i].dot(localAxis);

    if (val > max) {
      max = val;
    }

    if (val < min) {
      min = val;
    }
  }

  min -= add;
  max -= add;

  if (min > max) {
    // Inconsistent - swap
    const temp = min;
    min = max;
    max = temp;
  } // Output


  result[0] = max;
  result[1] = min;
};

/**
 * A 3d box shape.
 * @class Box
 * @constructor
 * @param {Vec3} halfExtents
 * @author schteppe
 * @extends Shape
 */
class Box extends Shape {
  // Used by the contact generator to make contacts with other convex polyhedra for example.
  constructor(halfExtents) {
    super({
      type: Shape.types.BOX
    });
    this.halfExtents = halfExtents;
    this.convexPolyhedronRepresentation = null;
    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
  }
  /**
   * Updates the local convex polyhedron representation used for some collisions.
   * @method updateConvexPolyhedronRepresentation
   */


  updateConvexPolyhedronRepresentation() {
    const sx = this.halfExtents.x;
    const sy = this.halfExtents.y;
    const sz = this.halfExtents.z;
    const V = Vec3;
    const vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
    const faces = [[3, 2, 1, 0], // -z
    [4, 5, 6, 7], // +z
    [5, 4, 0, 1], // -y
    [2, 3, 7, 6], // +y
    [0, 4, 7, 3], // -x
    [1, 2, 6, 5] // +x
    ];
    const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
    const h = new ConvexPolyhedron({
      vertices,
      faces,
      axes
    });
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
  }
  /**
   * @method calculateLocalInertia
   * @param  {Number} mass
   * @param  {Vec3} target
   * @return {Vec3}
   */


  calculateLocalInertia(mass, target = new Vec3()) {
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
  }
  /**
   * Get the box 6 side normals
   * @method getSideNormals
   * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
   * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
   * @return {array}
   */


  getSideNormals(sixTargetVectors, quat) {
    const sides = sixTargetVectors;
    const ex = this.halfExtents;
    sides[0].set(ex.x, 0, 0);
    sides[1].set(0, ex.y, 0);
    sides[2].set(0, 0, ex.z);
    sides[3].set(-ex.x, 0, 0);
    sides[4].set(0, -ex.y, 0);
    sides[5].set(0, 0, -ex.z);

    if (quat !== undefined) {
      for (let i = 0; i !== sides.length; i++) {
        quat.vmult(sides[i], sides[i]);
      }
    }

    return sides;
  }

  volume() {
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }

  forEachWorldCorner(pos, quat, callback) {
    const e = this.halfExtents;
    const corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

    for (let i = 0; i < corners.length; i++) {
      worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
      quat.vmult(worldCornerTempPos, worldCornerTempPos);
      pos.vadd(worldCornerTempPos, worldCornerTempPos);
      callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
    }
  }

  calculateWorldAABB(pos, quat, min, max) {
    const e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x, e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x, e.y, -e.z);
    worldCornersTemp[6].set(-e.x, e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y, e.z);
    const wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);

    for (let i = 1; i < 8; i++) {
      const wc = worldCornersTemp[i];
      quat.vmult(wc, wc);
      pos.vadd(wc, wc);
      const x = wc.x;
      const y = wc.y;
      const z = wc.z;

      if (x > max.x) {
        max.x = x;
      }

      if (y > max.y) {
        max.y = y;
      }

      if (z > max.z) {
        max.z = z;
      }

      if (x < min.x) {
        min.x = x;
      }

      if (y < min.y) {
        min.y = y;
      }

      if (z < min.z) {
        min.z = z;
      }
    } // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }
    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });

  }

}

Box.calculateInertia = (halfExtents, mass, target) => {
  const e = halfExtents;
  target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
  target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
  target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
};

const worldCornerTempPos = new Vec3();
const worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

const BODY_TYPES = {
  DYNAMIC: 1,
  STATIC: 2,
  KINEMATIC: 4
};
const BODY_SLEEP_STATES = {
  AWAKE: 0,
  SLEEPY: 1,
  SLEEPING: 2
};

/**
 * Base class for all body types.
 * @class Body
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.position]
 * @param {Vec3} [options.velocity]
 * @param {Vec3} [options.angularVelocity]
 * @param {Quaternion} [options.quaternion]
 * @param {number} [options.mass]
 * @param {Material} [options.material]
 * @param {number} [options.type]
 * @param {number} [options.linearDamping=0.01]
 * @param {number} [options.angularDamping=0.01]
 * @param {boolean} [options.allowSleep=true]
 * @param {number} [options.sleepSpeedLimit=0.1]
 * @param {number} [options.sleepTimeLimit=1]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=-1]
 * @param {boolean} [options.fixedRotation=false]
 * @param {Vec3} [options.linearFactor]
 * @param {Vec3} [options.angularFactor]
 * @param {Shape} [options.shape]
 * @example
 *     const body = new Body({
 *         mass: 1
 *     });
 *     const shape = new Sphere(1);
 *     body.addShape(shape);
 *     world.addBody(body);
 */
class Body extends EventTarget {
  // Position of body in World.bodies. Updated by World and used in ArrayCollisionMatrix.
  // Reference to the world the body is living in.
  // Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
  // Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
  // Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
  // World space position of the body.
  // Interpolated position of the body.
  // Initial position of the body.
  // World space velocity of the body.
  // Linear force on the body in world space.
  // One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
  // If true, the body will automatically fall to sleep.
  // Current sleep state.
  // If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
  // If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
  // World space rotational force on the body, around center of mass.
  // World space orientation of the body.
  // Interpolated orientation of the body.
  // Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
  // Position of each Shape in the body, given in local Body space.
  // Orientation of each Shape, given in local Body space.
  // Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
  // Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
  // Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
  // World space bounding box of the body and its shapes.
  // Indicates if the AABB needs to be updated before use.
  // Total bounding radius of the Body including its shapes, relative to body.position.
  constructor(options = {}) {
    super();
    this.id = Body.idCounter++;
    this.index = -1;
    this.world = null;
    this.preStep = null;
    this.postStep = null;
    this.vlambda = new Vec3();
    this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
    this.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;
    this.position = new Vec3();
    this.previousPosition = new Vec3();
    this.interpolatedPosition = new Vec3();
    this.initPosition = new Vec3();

    if (options.position) {
      this.position.copy(options.position);
      this.previousPosition.copy(options.position);
      this.interpolatedPosition.copy(options.position);
      this.initPosition.copy(options.position);
    }

    this.velocity = new Vec3();

    if (options.velocity) {
      this.velocity.copy(options.velocity);
    }

    this.initVelocity = new Vec3();
    this.force = new Vec3();
    const mass = typeof options.mass === 'number' ? options.mass : 0;
    this.mass = mass;
    this.invMass = mass > 0 ? 1.0 / mass : 0;
    this.material = options.material || null;
    this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
    this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

    if (typeof options.type === typeof Body.STATIC) {
      this.type = options.type;
    }

    this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
    this.sleepState = 0;
    this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
    this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
    this.timeLastSleepy = 0;
    this.wakeUpAfterNarrowphase = false;
    this.torque = new Vec3();
    this.quaternion = new Quaternion();
    this.initQuaternion = new Quaternion();
    this.previousQuaternion = new Quaternion();
    this.interpolatedQuaternion = new Quaternion();

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
      this.initQuaternion.copy(options.quaternion);
      this.previousQuaternion.copy(options.quaternion);
      this.interpolatedQuaternion.copy(options.quaternion);
    }

    this.angularVelocity = new Vec3();

    if (options.angularVelocity) {
      this.angularVelocity.copy(options.angularVelocity);
    }

    this.initAngularVelocity = new Vec3();
    this.shapes = [];
    this.shapeOffsets = [];
    this.shapeOrientations = [];
    this.inertia = new Vec3();
    this.invInertia = new Vec3();
    this.invInertiaWorld = new Mat3();
    this.invMassSolve = 0;
    this.invInertiaSolve = new Vec3();
    this.invInertiaWorldSolve = new Mat3();
    this.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;
    this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
    this.linearFactor = new Vec3(1, 1, 1);

    if (options.linearFactor) {
      this.linearFactor.copy(options.linearFactor);
    }

    this.angularFactor = new Vec3(1, 1, 1);

    if (options.angularFactor) {
      this.angularFactor.copy(options.angularFactor);
    }

    this.aabb = new AABB();
    this.aabbNeedsUpdate = true;
    this.boundingRadius = 0;
    this.wlambda = new Vec3();

    if (options.shape) {
      this.addShape(options.shape);
    }

    this.updateMassProperties();
  }
  /**
   * Wake the body up.
   * @method wakeUp
   */


  wakeUp() {
    const prevState = this.sleepState;
    this.sleepState = 0;
    this.wakeUpAfterNarrowphase = false;

    if (prevState === Body.SLEEPING) {
      this.dispatchEvent(Body.wakeupEvent);
    }
  }
  /**
   * Force body sleep
   * @method sleep
   */


  sleep() {
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0, 0, 0);
    this.angularVelocity.set(0, 0, 0);
    this.wakeUpAfterNarrowphase = false;
  }
  /**
   * Called every timestep to update internal sleep timer and change sleep state if needed.
   * @method sleepTick
   * @param {Number} time The world time in seconds
   */


  sleepTick(time) {
    if (this.allowSleep) {
      const sleepState = this.sleepState;
      const speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();
      const speedLimitSquared = this.sleepSpeedLimit ** 2;

      if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
        this.sleepState = Body.SLEEPY; // Sleepy

        this.timeLastSleepy = time;
        this.dispatchEvent(Body.sleepyEvent);
      } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
        this.wakeUp(); // Wake up
      } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
        this.sleep(); // Sleeping

        this.dispatchEvent(Body.sleepEvent);
      }
    }
  }
  /**
   * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
   * @method updateSolveMassProperties
   */


  updateSolveMassProperties() {
    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
      this.invMassSolve = 0;
      this.invInertiaSolve.setZero();
      this.invInertiaWorldSolve.setZero();
    } else {
      this.invMassSolve = this.invMass;
      this.invInertiaSolve.copy(this.invInertia);
      this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
  }
  /**
   * Convert a world point to local body frame.
   * @method pointToLocalFrame
   * @param  {Vec3} worldPoint
   * @param  {Vec3} result
   * @return {Vec3}
   */


  pointToLocalFrame(worldPoint, result = new Vec3()) {
    worldPoint.vsub(this.position, result);
    this.quaternion.conjugate().vmult(result, result);
    return result;
  }
  /**
   * Convert a world vector to local body frame.
   * @method vectorToLocalFrame
   * @param  {Vec3} worldPoint
   * @param  {Vec3} result
   * @return {Vec3}
   */


  vectorToLocalFrame(worldVector, result = new Vec3()) {
    this.quaternion.conjugate().vmult(worldVector, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   * @method pointToWorldFrame
   * @param  {Vec3} localPoint
   * @param  {Vec3} result
   * @return {Vec3}
   */


  pointToWorldFrame(localPoint, result = new Vec3()) {
    this.quaternion.vmult(localPoint, result);
    result.vadd(this.position, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   * @method vectorToWorldFrame
   * @param  {Vec3} localVector
   * @param  {Vec3} result
   * @return {Vec3}
   */


  vectorToWorldFrame(localVector, result = new Vec3()) {
    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * Add a shape to the body with a local offset and orientation.
   * @method addShape
   * @param {Shape} shape
   * @param {Vec3} [_offset]
   * @param {Quaternion} [_orientation]
   * @return {Body} The body object, for chainability.
   */


  addShape(shape, _offset, _orientation) {
    const offset = new Vec3();
    const orientation = new Quaternion();

    if (_offset) {
      offset.copy(_offset);
    }

    if (_orientation) {
      orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = this;
    return this;
  }
  /**
   * Update the bounding radius of the body. Should be done if any of the shapes are changed.
   * @method updateBoundingRadius
   */


  updateBoundingRadius() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const N = shapes.length;
    let radius = 0;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i];
      shape.updateBoundingSphereRadius();
      const offset = shapeOffsets[i].length();
      const r = shape.boundingSphereRadius;

      if (offset + r > radius) {
        radius = offset + r;
      }
    }

    this.boundingRadius = radius;
  }
  /**
   * Updates the .aabb
   * @method computeAABB
   * @todo rename to updateAABB()
   */


  computeAABB() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const shapeOrientations = this.shapeOrientations;
    const N = shapes.length;
    const offset = tmpVec;
    const orientation = tmpQuat$1;
    const bodyQuat = this.quaternion;
    const aabb = this.aabb;
    const shapeAABB = computeAABB_shapeAABB;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i]; // Get shape world position

      bodyQuat.vmult(shapeOffsets[i], offset);
      offset.vadd(this.position, offset); // Get shape world quaternion

      bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB

      shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

      if (i === 0) {
        aabb.copy(shapeAABB);
      } else {
        aabb.extend(shapeAABB);
      }
    }

    this.aabbNeedsUpdate = false;
  }
  /**
   * Update .inertiaWorld and .invInertiaWorld
   * @method updateInertiaWorld
   */


  updateInertiaWorld(force) {
    const I = this.invInertia;

    if (I.x === I.y && I.y === I.z && !force) ; else {
      const m1 = uiw_m1;
      const m2 = uiw_m2;
      m1.setRotationFromQuaternion(this.quaternion);
      m1.transpose(m2);
      m1.scale(I, m1);
      m1.mmult(m2, this.invInertiaWorld);
    }
  }

  applyForce(force, relativePoint) {
    if (this.type !== Body.DYNAMIC) {
      // Needed?
      return;
    } // Compute produced rotational force


    const rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force, rotForce); // Add linear force

    this.force.vadd(force, this.force); // Add rotational force

    this.torque.vadd(rotForce, this.torque);
  }

  applyLocalForce(localForce, localPoint) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldForce = Body_applyLocalForce_worldForce;
    const relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyForce(worldForce, relativePointWorld);
  }

  applyImpulse(impulse, relativePoint) {
    if (this.type !== Body.DYNAMIC) {
      return;
    } // Compute point position relative to the body center


    const r = relativePoint; // Compute produced central impulse velocity

    const velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.scale(this.invMass, velo); // Add linear impulse

    this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

    const rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse, rotVelo);
    /*
     rotVelo.x *= this.invInertia.x;
     rotVelo.y *= this.invInertia.y;
     rotVelo.z *= this.invInertia.z;
     */

    this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
  }

  applyLocalImpulse(localImpulse, localPoint) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldImpulse = Body_applyLocalImpulse_worldImpulse;
    const relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyImpulse(worldImpulse, relativePointWorld);
  }
  /**
   * Should be called whenever you change the body shape or mass.
   * @method updateMassProperties
   */


  updateMassProperties() {
    const halfExtents = Body_updateMassProperties_halfExtents;
    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    const I = this.inertia;
    const fixed = this.fixedRotation; // Approximate with AABB box

    this.computeAABB();
    halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
    Box.calculateInertia(halfExtents, this.mass, I);
    this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
    this.updateInertiaWorld(true);
  }
  /**
   * Get world velocity of a point in the body.
   * @method getVelocityAtWorldPoint
   * @param  {Vec3} worldPoint
   * @param  {Vec3} result
   * @return {Vec3} The result vector.
   */


  getVelocityAtWorldPoint(worldPoint, result) {
    const r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
  }
  /**
   * Move the body forward in time.
   * @param {number} dt Time step
   * @param {boolean} quatNormalize Set to true to normalize the body quaternion
   * @param {boolean} quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
   */


  integrate(dt, quatNormalize, quatNormalizeFast) {
    // Save previous position
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);

    if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
      // Only for dynamic
      return;
    }

    const velo = this.velocity;
    const angularVelo = this.angularVelocity;
    const pos = this.position;
    const force = this.force;
    const torque = this.torque;
    const quat = this.quaternion;
    const invMass = this.invMass;
    const invInertia = this.invInertiaWorld;
    const linearFactor = this.linearFactor;
    const iMdt = invMass * dt;
    velo.x += force.x * iMdt * linearFactor.x;
    velo.y += force.y * iMdt * linearFactor.y;
    velo.z += force.z * iMdt * linearFactor.z;
    const e = invInertia.elements;
    const angularFactor = this.angularFactor;
    const tx = torque.x * angularFactor.x;
    const ty = torque.y * angularFactor.y;
    const tz = torque.z * angularFactor.z;
    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;
    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

    if (quatNormalize) {
      if (quatNormalizeFast) {
        quat.normalizeFast();
      } else {
        quat.normalize();
      }
    }

    this.aabbNeedsUpdate = true; // Update world inertia

    this.updateInertiaWorld();
  }

}
/**
 * Dispatched after two bodies collide. This event is dispatched on each
 * of the two bodies involved in the collision.
 * @event collide
 * @param {Body} body The body that was involved in the collision.
 * @param {ContactEquation} contact The details of the collision.
 */

Body.COLLIDE_EVENT_NAME = 'collide';
/**
 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
 * @static
 * @property DYNAMIC
 * @type {Number}
 */

Body.DYNAMIC = 1;
/**
 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
 * @static
 * @property STATIC
 * @type {Number}
 */

Body.STATIC = 2;
/**
 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
 * @static
 * @property KINEMATIC
 * @type {Number}
 */

Body.KINEMATIC = 4;
/**
 * @static
 * @property AWAKE
 * @type {number}
 */

Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
Body.idCounter = 0;
/**
 * Dispatched after a sleeping body has woken up.
 * @event wakeup
 */

Body.wakeupEvent = {
  type: 'wakeup'
};
/**
 * Dispatched after a body has gone in to the sleepy state.
 * @event sleepy
 */

Body.sleepyEvent = {
  type: 'sleepy'
};
/**
 * Dispatched after a body has fallen asleep.
 * @event sleep
 */

Body.sleepEvent = {
  type: 'sleep'
};
const tmpVec = new Vec3();
const tmpQuat$1 = new Quaternion();
const computeAABB_shapeAABB = new AABB();
const uiw_m1 = new Mat3();
const uiw_m2 = new Mat3();
/**
 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
 * @method applyForce
 * @param  {Vec3} force The amount of force to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */

const Body_applyForce_rotForce = new Vec3();
/**
 * Apply force to a local point in the body.
 * @method applyLocalForce
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */

const Body_applyLocalForce_worldForce = new Vec3();
const Body_applyLocalForce_relativePointWorld = new Vec3();
/**
 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Vec3} impulse The amount of impulse to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */

const Body_applyImpulse_velo = new Vec3();
const Body_applyImpulse_rotVelo = new Vec3();
/**
 * Apply locally-defined impulse to a local point in the body.
 * @method applyLocalImpulse
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */

const Body_applyLocalImpulse_worldImpulse = new Vec3();
const Body_applyLocalImpulse_relativePoint = new Vec3();
const Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Base class for broadphase implementations
 * @class Broadphase
 * @constructor
 * @author schteppe
 */
class Broadphase {
  // The world to search for collisions in.
  // If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
  // Set to true if the objects in the world moved.
  constructor() {
    this.world = null;
    this.useBoundingBoxes = false;
    this.dirty = true;
  }
  /**
   * Get the collision pairs from the world
   * @method collisionPairs
   * @param {World} world The world to search in
   * @param {Array} p1 Empty array to be filled with body objects
   * @param {Array} p2 Empty array to be filled with body objects
   */


  collisionPairs(world, p1, p2) {
    throw new Error('collisionPairs not implemented for this BroadPhase class!');
  }
  /**
   * Check if a body pair needs to be intersection tested at all.
   * @method needBroadphaseCollision
   * @param {Body} bodyA
   * @param {Body} bodyB
   * @return {bool}
   */


  needBroadphaseCollision(bodyA, bodyB) {
    // Check collision filter masks
    if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
      return false;
    } // Check types


    if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
      // Both bodies are static or sleeping. Skip.
      return false;
    }

    return true;
  }
  /**
   * Check if the bounding volumes of two bodies intersect.
   * @method intersectionTest
   * @param {Body} bodyA
   * @param {Body} bodyB
   * @param {array} pairs1
   * @param {array} pairs2
   */


  intersectionTest(bodyA, bodyB, pairs1, pairs2) {
    if (this.useBoundingBoxes) {
      this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
    } else {
      this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
    }
  }

  doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
    const r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position, r);
    const boundingRadiusSum2 = (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
    const norm2 = r.lengthSquared();

    if (norm2 < boundingRadiusSum2) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Check if the bounding boxes of two bodies are intersecting.
   * @method doBoundingBoxBroadphase
   * @param {Body} bodyA
   * @param {Body} bodyB
   * @param {Array} pairs1
   * @param {Array} pairs2
   */


  doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
    if (bodyA.aabbNeedsUpdate) {
      bodyA.computeAABB();
    }

    if (bodyB.aabbNeedsUpdate) {
      bodyB.computeAABB();
    } // Check AABB / AABB


    if (bodyA.aabb.overlaps(bodyB.aabb)) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }

  makePairsUnique(pairs1, pairs2) {
    const t = Broadphase_makePairsUnique_temp;
    const p1 = Broadphase_makePairsUnique_p1;
    const p2 = Broadphase_makePairsUnique_p2;
    const N = pairs1.length;

    for (let i = 0; i !== N; i++) {
      p1[i] = pairs1[i];
      p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for (let i = 0; i !== N; i++) {
      const id1 = p1[i].id;
      const id2 = p2[i].id;
      const key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
      t[key] = i;
      t.keys.push(key);
    }

    for (let i = 0; i !== t.keys.length; i++) {
      const key = t.keys.pop();
      const pairIndex = t[key];
      pairs1.push(p1[pairIndex]);
      pairs2.push(p2[pairIndex]);
      delete t[key];
    }
  }
  /**
   * To be implemented by subcasses
   * @method setWorld
   * @param {World} world
   */


  setWorld(world) {}
  /**
   * Returns all the bodies within the AABB.
   * @method aabbQuery
   * @param  {World} world
   * @param  {AABB} aabb
   * @param  {array} result An array to store resulting bodies in.
   * @return {array}
   */


  aabbQuery(world, aabb, result) {
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
  }

}
/**
 * Check if the bounding spheres of two bodies are intersecting.
 * @method doBoundingSphereBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1 bodyA is appended to this array if intersection
 * @param {Array} pairs2 bodyB is appended to this array if intersection
 */

const // Temp objects
Broadphase_collisionPairs_r = new Vec3();
/**
 * Removes duplicate pairs from the pair arrays.
 * @method makePairsUnique
 * @param {Array} pairs1
 * @param {Array} pairs2
 */

const Broadphase_makePairsUnique_temp = {
  keys: []
};
const Broadphase_makePairsUnique_p1 = [];
const Broadphase_makePairsUnique_p2 = [];

Broadphase.boundingSphereCheck = (bodyA, bodyB) => {
  const dist = new Vec3(); // bsc_dist;

  bodyA.position.vsub(bodyB.position, dist);
  const sa = bodyA.shapes[0];
  const sb = bodyB.shapes[0];
  return Math.pow(sa.boundingSphereRadius + sb.boundingSphereRadius, 2) > dist.lengthSquared();
};

/**
 * Axis aligned uniform grid broadphase.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @todo Needs support for more than just planes and spheres.
 * @param {Vec3} aabbMin
 * @param {Vec3} aabbMax
 * @param {Number} nx Number of boxes along x
 * @param {Number} ny Number of boxes along y
 * @param {Number} nz Number of boxes along z
 */
class GridBroadphase extends Broadphase {
  constructor(aabbMin = new Vec3(100, 100, 100), aabbMax = new Vec3(-100, -100, -100), nx = 10, ny = 10, nz = 10) {
    super();
    this.nx = nx;
    this.ny = ny;
    this.nz = nz;
    this.aabbMin = aabbMin;
    this.aabbMax = aabbMax;
    const nbins = this.nx * this.ny * this.nz;

    if (nbins <= 0) {
      throw "GridBroadphase: Each dimension's n must be >0";
    }

    this.bins = [];
    this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

    this.bins.length = nbins;
    this.binLengths.length = nbins;

    for (let i = 0; i < nbins; i++) {
      this.bins[i] = [];
      this.binLengths[i] = 0;
    }
  }

  collisionPairs(world, pairs1, pairs2) {
    const N = world.numObjects();
    const bodies = world.bodies;
    const max = this.aabbMax;
    const min = this.aabbMin;
    const nx = this.nx;
    const ny = this.ny;
    const nz = this.nz;
    const xstep = ny * nz;
    const ystep = nz;
    const zstep = 1;
    const xmax = max.x;
    const ymax = max.y;
    const zmax = max.z;
    const xmin = min.x;
    const ymin = min.y;
    const zmin = min.z;
    const xmult = nx / (xmax - xmin);
    const ymult = ny / (ymax - ymin);
    const zmult = nz / (zmax - zmin);
    const binsizeX = (xmax - xmin) / nx;
    const binsizeY = (ymax - ymin) / ny;
    const binsizeZ = (zmax - zmin) / nz;
    const binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
    const types = Shape.types;
    const SPHERE = types.SPHERE;
    const PLANE = types.PLANE;
    const BOX = types.BOX;
    const COMPOUND = types.COMPOUND;
    const CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;
    const bins = this.bins;
    const binLengths = this.binLengths;
    const Nbins = this.bins.length; // Reset bins

    for (let i = 0; i !== Nbins; i++) {
      binLengths[i] = 0;
    }

    const ceil = Math.ceil;

    function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
      let xoff0 = (x0 - xmin) * xmult | 0;
      let yoff0 = (y0 - ymin) * ymult | 0;
      let zoff0 = (z0 - zmin) * zmult | 0;
      let xoff1 = ceil((x1 - xmin) * xmult);
      let yoff1 = ceil((y1 - ymin) * ymult);
      let zoff1 = ceil((z1 - zmin) * zmult);

      if (xoff0 < 0) {
        xoff0 = 0;
      } else if (xoff0 >= nx) {
        xoff0 = nx - 1;
      }

      if (yoff0 < 0) {
        yoff0 = 0;
      } else if (yoff0 >= ny) {
        yoff0 = ny - 1;
      }

      if (zoff0 < 0) {
        zoff0 = 0;
      } else if (zoff0 >= nz) {
        zoff0 = nz - 1;
      }

      if (xoff1 < 0) {
        xoff1 = 0;
      } else if (xoff1 >= nx) {
        xoff1 = nx - 1;
      }

      if (yoff1 < 0) {
        yoff1 = 0;
      } else if (yoff1 >= ny) {
        yoff1 = ny - 1;
      }

      if (zoff1 < 0) {
        zoff1 = 0;
      } else if (zoff1 >= nz) {
        zoff1 = nz - 1;
      }

      xoff0 *= xstep;
      yoff0 *= ystep;
      zoff0 *= zstep;
      xoff1 *= xstep;
      yoff1 *= ystep;
      zoff1 *= zstep;

      for (let xoff = xoff0; xoff <= xoff1; xoff += xstep) {
        for (let yoff = yoff0; yoff <= yoff1; yoff += ystep) {
          for (let zoff = zoff0; zoff <= zoff1; zoff += zstep) {
            const idx = xoff + yoff + zoff;
            bins[idx][binLengths[idx]++] = bi;
          }
        }
      }
    } // Put all bodies into the bins


    for (let i = 0; i !== N; i++) {
      const bi = bodies[i];
      const si = bi.shapes[0];

      switch (si.type) {
        case SPHERE:
          {
            const shape = si; // Put in bin
            // check if overlap with other bins

            const x = bi.position.x;
            const y = bi.position.y;
            const z = bi.position.z;
            const r = shape.radius;
            addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
            break;
          }

        case PLANE:
          {
            const shape = si;

            if (shape.worldNormalNeedsUpdate) {
              shape.computeWorldNormal(bi.quaternion);
            }

            const planeNormal = shape.worldNormal; //Relative position from origin of plane object to the first bin
            //Incremented as we iterate through the bins

            const xreset = xmin + binsizeX * 0.5 - bi.position.x;
            const yreset = ymin + binsizeY * 0.5 - bi.position.y;
            const zreset = zmin + binsizeZ * 0.5 - bi.position.z;
            const d = GridBroadphase_collisionPairs_d;
            d.set(xreset, yreset, zreset);

            for (let xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
              for (let yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                for (let zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                  if (d.dot(planeNormal) < binRadius) {
                    const idx = xoff + yoff + zoff;
                    bins[idx][binLengths[idx]++] = bi;
                  }
                }
              }
            }

            break;
          }

        default:
          {
            if (bi.aabbNeedsUpdate) {
              bi.computeAABB();
            }

            addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
            break;
          }
      }
    } // Check each bin


    for (let i = 0; i !== Nbins; i++) {
      const binLength = binLengths[i]; //Skip bins with no potential collisions

      if (binLength > 1) {
        const bin = bins[i]; // Do N^2 broadphase inside

        for (let xi = 0; xi !== binLength; xi++) {
          const bi = bin[xi];

          for (let yi = 0; yi !== xi; yi++) {
            const bj = bin[yi];

            if (this.needBroadphaseCollision(bi, bj)) {
              this.intersectionTest(bi, bj, pairs1, pairs2);
            }
          }
        }
      }
    } //	for (let zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
    //		console.log("layer "+zi);
    //		for (let yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
    //			const row = '';
    //			for (let xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
    //				const idx = xoff + yoff + zoff;
    //				row += ' ' + binLengths[idx];
    //			}
    //			console.log(row);
    //		}
    //	}


    this.makePairsUnique(pairs1, pairs2);
  }

}
/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */

const GridBroadphase_collisionPairs_d = new Vec3();

/**
 * Naive broadphase implementation, used in lack of better ones.
 * @class NaiveBroadphase
 * @constructor
 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
 * @extends Broadphase
 */
class NaiveBroadphase extends Broadphase {
  constructor() {
    super();
  }
  /**
   * Get all the collision pairs in the physics world
   * @method collisionPairs
   * @param {World} world
   * @param {Array} pairs1
   * @param {Array} pairs2
   */


  collisionPairs(world, pairs1, pairs2) {
    const bodies = world.bodies;
    const n = bodies.length;
    let bi;
    let bj; // Naive N^2 ftw!

    for (let i = 0; i !== n; i++) {
      for (let j = 0; j !== i; j++) {
        bi = bodies[i];
        bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        this.intersectionTest(bi, bj, pairs1, pairs2);
      }
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @method aabbQuery
   * @param  {World} world
   * @param  {AABB} aabb
   * @param {array} result An array to store resulting bodies in.
   * @return {array}
   */


  aabbQuery(world, aabb, result = []) {
    for (let i = 0; i < world.bodies.length; i++) {
      const b = world.bodies[i];

      if (b.aabbNeedsUpdate) {
        b.computeAABB();
      } // Ugly hack until Body gets aabb


      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
class RaycastResult {
  // The index of the hit triangle, if the hit shape was a trimesh.
  // Distance to the hit. Will be set to -1 if there was no hit.
  // If the ray should stop traversing the bodies.
  constructor() {
    this.rayFromWorld = new Vec3();
    this.rayToWorld = new Vec3();
    this.hitNormalWorld = new Vec3();
    this.hitPointWorld = new Vec3();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * Reset all result data.
   * @method reset
   */


  reset() {
    this.rayFromWorld.setZero();
    this.rayToWorld.setZero();
    this.hitNormalWorld.setZero();
    this.hitPointWorld.setZero();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * @method abort
   */


  abort() {
    this.shouldStop = true;
  }
  /**
   * @method set
   * @param {Vec3} rayFromWorld
   * @param {Vec3} rayToWorld
   * @param {Vec3} hitNormalWorld
   * @param {Vec3} hitPointWorld
   * @param {Shape} shape
   * @param {Body} body
   * @param {number} distance
   */


  set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
    this.rayFromWorld.copy(rayFromWorld);
    this.rayToWorld.copy(rayToWorld);
    this.hitNormalWorld.copy(hitNormalWorld);
    this.hitPointWorld.copy(hitPointWorld);
    this.shape = shape;
    this.body = body;
    this.distance = distance;
  }

}

const RAY_MODES = {
  CLOSEST: 1,
  ANY: 2,
  ALL: 4
};

/**
 * A line in 3D space that intersects bodies and return points.
 * @class Ray
 * @constructor
 * @param {Vec3} from
 * @param {Vec3} to
 */
class Ray {
  // The precision of the ray. Used when checking parallelity etc.
  // Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
  // If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
  // The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
  // Current result object.
  // Will be set to true during intersectWorld() if the ray hit anything.
  // User-provided result callback. Will be used if mode is Ray.ALL.
  constructor(from = new Vec3(), to = new Vec3()) {
    this.from = from.clone();
    this.to = to.clone();
    this.direction = new Vec3();
    this.precision = 0.0001;
    this.checkCollisionResponse = true;
    this.skipBackfaces = false;
    this.collisionFilterMask = -1;
    this.collisionFilterGroup = -1;
    this.mode = Ray.ANY;
    this.result = new RaycastResult();
    this.hasHit = false;

    this.callback = result => {};
  }
  /**
   * Do itersection against all bodies in the given World.
   * @method intersectWorld
   * @param  {World} world
   * @param  {object} options
   * @return {Boolean} True if the ray hit anything, otherwise false.
   */


  intersectWorld(world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;
    this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;

    if (options.from) {
      this.from.copy(options.from);
    }

    if (options.to) {
      this.to.copy(options.to);
    }

    this.callback = options.callback || (() => {});

    this.hasHit = false;
    this.result.reset();
    this.updateDirection();
    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);
    return this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @param {Body} body
   * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
   */


  intersectBody(body, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    const checkCollisionResponse = this.checkCollisionResponse;

    if (checkCollisionResponse && !body.collisionResponse) {
      return;
    }

    if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
      return;
    }

    const xi = intersectBody_xi;
    const qi = intersectBody_qi;

    for (let i = 0, N = body.shapes.length; i < N; i++) {
      const shape = body.shapes[i];

      if (checkCollisionResponse && !shape.collisionResponse) {
        continue; // Skip
      }

      body.quaternion.mult(body.shapeOrientations[i], qi);
      body.quaternion.vmult(body.shapeOffsets[i], xi);
      xi.vadd(body.position, xi);
      this.intersectShape(shape, qi, xi, body);

      if (this.result.shouldStop) {
        break;
      }
    }
  }
  /**
   * @method intersectBodies
   * @param {Array} bodies An array of Body objects.
   * @param {RaycastResult} [result] Deprecated
   */


  intersectBodies(bodies, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    for (let i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {
      this.intersectBody(bodies[i]);
    }
  }
  /**
   * Updates the direction vector.
   */


  updateDirection() {
    this.to.vsub(this.from, this.direction);
    this.direction.normalize();
  }

  intersectShape(shape, quat, position, body) {
    const from = this.from; // Checking boundingSphere

    const distance = distanceFromIntersection(from, this.direction, position);

    if (distance > shape.boundingSphereRadius) {
      return;
    }

    const intersectMethod = this[shape.type];

    if (intersectMethod) {
      intersectMethod.call(this, shape, quat, position, body, shape);
    }
  }

  _intersectBox(box, quat, position, body, reportedShape) {
    return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);
  }

  _intersectPlane(shape, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const direction = this.direction; // Get plane normal

    const worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);
    const len = new Vec3();
    from.vsub(position, len);
    const planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    const planeToTo = len.dot(worldNormal);

    if (planeToFrom * planeToTo > 0) {
      // "from" and "to" are on the same side of the plane... bail out
      return;
    }

    if (from.distanceTo(to) < planeToFrom) {
      return;
    }

    const n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
      // No intersection
      return;
    }

    const planePointToFrom = new Vec3();
    const dir_scaled_with_t = new Vec3();
    const hitPointWorld = new Vec3();
    from.vsub(position, planePointToFrom);
    const t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);
    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
  }
  /**
   * Get the world AABB of the ray.
   */


  getAABB(aabb) {
    const {
      lowerBound,
      upperBound
    } = aabb;
    const to = this.to;
    const from = this.from;
    lowerBound.x = Math.min(to.x, from.x);
    lowerBound.y = Math.min(to.y, from.y);
    lowerBound.z = Math.min(to.z, from.z);
    upperBound.x = Math.max(to.x, from.x);
    upperBound.y = Math.max(to.y, from.y);
    upperBound.z = Math.max(to.z, from.z);
  }

  _intersectHeightfield(shape, quat, position, body, reportedShape) {
    const data = shape.data;
    const w = shape.elementSize; // Convert the ray to local heightfield coordinates

    const localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

    localRay.from.copy(this.from);
    localRay.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
    localRay.updateDirection(); // Get the index of the data points to test against

    const index = intersectHeightfield_index;
    let iMinX;
    let iMinY;
    let iMaxX;
    let iMaxY; // Set to max

    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;
    const aabb = new AABB();
    localRay.getAABB(aabb);
    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        if (this.result.shouldStop) {
          return;
        }

        shape.getAabbAtIndex(i, j, aabb);

        if (!aabb.overlapsRay(localRay)) {
          continue;
        } // Lower triangle


        shape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

        if (this.result.shouldStop) {
          return;
        } // Upper triangle


        shape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
      }
    }
  }

  _intersectSphere(sphere, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const r = sphere.radius;
    const a = (to.x - from.x) ** 2 + (to.y - from.y) ** 2 + (to.z - from.z) ** 2;
    const b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    const c = (from.x - position.x) ** 2 + (from.y - position.y) ** 2 + (from.z - position.z) ** 2 - r ** 2;
    const delta = b ** 2 - 4 * a * c;
    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
    const normal = Ray_intersectSphere_normal;

    if (delta < 0) {
      // No intersection
      return;
    } else if (delta === 0) {
      // single intersection point
      from.lerp(to, delta, intersectionPoint);
      intersectionPoint.vsub(position, normal);
      normal.normalize();
      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
    } else {
      const d1 = (-b - Math.sqrt(delta)) / (2 * a);
      const d2 = (-b + Math.sqrt(delta)) / (2 * a);

      if (d1 >= 0 && d1 <= 1) {
        from.lerp(to, d1, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }

      if (this.result.shouldStop) {
        return;
      }

      if (d2 >= 0 && d2 <= 1) {
        from.lerp(to, d2, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }
    }
  }

  _intersectConvex(shape, quat, position, body, reportedShape, options) {
    const normal = intersectConvex_normal;
    const vector = intersectConvex_vector;
    const faceList = options && options.faceList || null; // Checking faces

    const faces = shape.faces;
    const vertices = shape.vertices;
    const normals = shape.faceNormals;
    const direction = this.direction;
    const from = this.from;
    const to = this.to;
    const fromToDistance = from.distanceTo(to);
    const Nfaces = faceList ? faceList.length : faces.length;
    const result = this.result;

    for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
      const fi = faceList ? faceList[j] : j;
      const face = faces[fi];
      const faceNormal = normals[fi];
      const q = quat;
      const x = position; // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      vector.copy(vertices[face[0]]);
      q.vmult(vector, vector);
      vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

      vector.vsub(from, vector); // Get plane normal

      q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

      const dot = direction.dot(normal); // Bail out if ray and plane are parallel

      if (Math.abs(dot) < this.precision) {
        continue;
      } // calc distance to plane


      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // if (dot < 0) {
      // Intersection point is from + direction * scalar


      direction.scale(scalar, intersectPoint);
      intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

      a.copy(vertices[face[0]]);
      q.vmult(a, a);
      x.vadd(a, a);

      for (let i = 1; !result.shouldStop && i < face.length - 1; i++) {
        // Transform 3 vertices to world coords
        b.copy(vertices[face[i]]);
        c.copy(vertices[face[i + 1]]);
        q.vmult(b, b);
        q.vmult(c, c);
        x.vadd(b, b);
        x.vadd(c, c);
        const distance = intersectPoint.distanceTo(from);

        if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
          continue;
        }

        this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
      } // }

    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */


  _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
    const normal = intersectTrimesh_normal;
    const triangles = intersectTrimesh_triangles;
    const treeTransform = intersectTrimesh_treeTransform;
    const vector = intersectConvex_vector;
    const localDirection = intersectTrimesh_localDirection;
    const localFrom = intersectTrimesh_localFrom;
    const localTo = intersectTrimesh_localTo;
    const worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    const worldNormal = intersectTrimesh_worldNormal;
    const faceList = options && options.faceList || null; // Checking faces

    const indices = mesh.indices;
    const vertices = mesh.vertices; // const normals = mesh.faceNormals

    const from = this.from;
    const to = this.to;
    const direction = this.direction;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat); // Transform ray to local space!

    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;
    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();
    const fromToDistanceSquared = localFrom.distanceSquared(localTo);
    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (let i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {
      const trianglesIndex = triangles[i];
      mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

      a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

      const dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
      // if (Math.abs( dot ) < this.precision){
      //     continue;
      // }
      // calc distance to plane

      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // Intersection point is from + direction * scalar


      localDirection.scale(scalar, intersectPoint);
      intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

      mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
      mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
      const squaredDistance = intersectPoint.distanceSquared(localFrom);

      if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
        continue;
      } // transform intersectpoint and normal to world


      Transform.vectorToWorldFrame(quat, normal, worldNormal);
      Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
      this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }

    triangles.length = 0;
  }
  /**
   * @return {boolean} True if the intersections should continue
   */


  reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {
    const from = this.from;
    const to = this.to;
    const distance = from.distanceTo(hitPointWorld);
    const result = this.result; // Skip back faces?

    if (this.skipBackfaces && normal.dot(this.direction) > 0) {
      return;
    }

    result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

    switch (this.mode) {
      case Ray.ALL:
        this.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.hasHit = true;
        this.callback(result);
        break;

      case Ray.CLOSEST:
        // Store if closer than current closest
        if (distance < result.distance || !result.hasHit) {
          this.hasHit = true;
          result.hasHit = true;
          result.set(from, to, normal, hitPointWorld, shape, body, distance);
        }

        break;

      case Ray.ANY:
        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.shouldStop = true;
        break;
    }
  }

}
Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;
const tmpAABB = new AABB();
const tmpArray = [];
const v1 = new Vec3();
const v2 = new Vec3();
/*
 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
 */

Ray.pointInTriangle = pointInTriangle;

function pointInTriangle(p, a, b, c) {
  c.vsub(a, v0);
  b.vsub(a, v1);
  p.vsub(a, v2);
  const dot00 = v0.dot(v0);
  const dot01 = v0.dot(v1);
  const dot02 = v0.dot(v2);
  const dot11 = v1.dot(v1);
  const dot12 = v1.dot(v2);
  let u;
  let v;
  return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
}

const intersectBody_xi = new Vec3();
const intersectBody_qi = new Quaternion();
const intersectPoint = new Vec3();
const a = new Vec3();
const b = new Vec3();
const c = new Vec3();
Ray.prototype[Shape.types.BOX] = Ray.prototype._intersectBox;
Ray.prototype[Shape.types.PLANE] = Ray.prototype._intersectPlane;
const intersectConvexOptions = {
  faceList: [0]
};
const worldPillarOffset = new Vec3();
const intersectHeightfield_localRay = new Ray();
const intersectHeightfield_index = [];
Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype._intersectHeightfield;
const Ray_intersectSphere_intersectionPoint = new Vec3();
const Ray_intersectSphere_normal = new Vec3();
Ray.prototype[Shape.types.SPHERE] = Ray.prototype._intersectSphere;
const intersectConvex_normal = new Vec3();
const intersectConvex_vector = new Vec3();
Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype._intersectConvex;
const intersectTrimesh_normal = new Vec3();
const intersectTrimesh_localDirection = new Vec3();
const intersectTrimesh_localFrom = new Vec3();
const intersectTrimesh_localTo = new Vec3();
const intersectTrimesh_worldNormal = new Vec3();
const intersectTrimesh_worldIntersectPoint = new Vec3();
const intersectTrimesh_localAABB = new AABB();
const intersectTrimesh_triangles = [];
const intersectTrimesh_treeTransform = new Transform();
Ray.prototype[Shape.types.TRIMESH] = Ray.prototype._intersectTrimesh;
const v0 = new Vec3();
const intersect = new Vec3();

function distanceFromIntersection(from, direction, position) {
  // v0 is vector from from to position
  position.vsub(from, v0);
  const dot = v0.dot(direction); // intersect = direction*dot + from

  direction.scale(dot, intersect);
  intersect.vadd(from, intersect);
  const distance = position.distanceTo(intersect);
  return distance;
}

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @param {World} [world]
 * @extends Broadphase
 */
class SAPBroadphase extends Broadphase {
  // List of bodies currently in the broadphase.
  // The world to search in.
  // Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
  constructor(world) {
    super();
    this.axisList = [];
    this.world = null;
    this.axisIndex = 0;
    const axisList = this.axisList;

    this._addBodyHandler = event => {
      axisList.push(event.body);
    };

    this._removeBodyHandler = event => {
      const idx = axisList.indexOf(event.body);

      if (idx !== -1) {
        axisList.splice(idx, 1);
      }
    };

    if (world) {
      this.setWorld(world);
    }
  }
  /**
   * Change the world
   * @method setWorld
   * @param  {World} world
   */


  setWorld(world) {
    // Clear the old axis array
    this.axisList.length = 0; // Add all bodies from the new world

    for (let i = 0; i < world.bodies.length; i++) {
      this.axisList.push(world.bodies[i]);
    } // Remove old handlers, if any


    world.removeEventListener('addBody', this._addBodyHandler);
    world.removeEventListener('removeBody', this._removeBodyHandler); // Add handlers to update the list of bodies.

    world.addEventListener('addBody', this._addBodyHandler);
    world.addEventListener('removeBody', this._removeBodyHandler);
    this.world = world;
    this.dirty = true;
  }
  /**
   * Collect all collision pairs
   * @method collisionPairs
   * @param  {World} world
   * @param  {Array} p1
   * @param  {Array} p2
   */


  collisionPairs(world, p1, p2) {
    const bodies = this.axisList;
    const N = bodies.length;
    const axisIndex = this.axisIndex;
    let i;
    let j;

    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    } // Look through the list


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      for (j = i + 1; j < N; j++) {
        const bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
          break;
        }

        this.intersectionTest(bi, bj, p1, p2);
      }
    }
  }

  sortList() {
    const axisList = this.axisList;
    const axisIndex = this.axisIndex;
    const N = axisList.length; // Update AABBs

    for (let i = 0; i !== N; i++) {
      const bi = axisList[i];

      if (bi.aabbNeedsUpdate) {
        bi.computeAABB();
      }
    } // Sort the list


    if (axisIndex === 0) {
      SAPBroadphase.insertionSortX(axisList);
    } else if (axisIndex === 1) {
      SAPBroadphase.insertionSortY(axisList);
    } else if (axisIndex === 2) {
      SAPBroadphase.insertionSortZ(axisList);
    }
  }
  /**
   * Computes the variance of the body positions and estimates the best
   * axis to use. Will automatically set property .axisIndex.
   * @method autoDetectAxis
   */


  autoDetectAxis() {
    let sumX = 0;
    let sumX2 = 0;
    let sumY = 0;
    let sumY2 = 0;
    let sumZ = 0;
    let sumZ2 = 0;
    const bodies = this.axisList;
    const N = bodies.length;
    const invN = 1 / N;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      const centerX = b.position.x;
      sumX += centerX;
      sumX2 += centerX * centerX;
      const centerY = b.position.y;
      sumY += centerY;
      sumY2 += centerY * centerY;
      const centerZ = b.position.z;
      sumZ += centerZ;
      sumZ2 += centerZ * centerZ;
    }

    const varianceX = sumX2 - sumX * sumX * invN;
    const varianceY = sumY2 - sumY * sumY * invN;
    const varianceZ = sumZ2 - sumZ * sumZ * invN;

    if (varianceX > varianceY) {
      if (varianceX > varianceZ) {
        this.axisIndex = 0;
      } else {
        this.axisIndex = 2;
      }
    } else if (varianceY > varianceZ) {
      this.axisIndex = 1;
    } else {
      this.axisIndex = 2;
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @method aabbQuery
   * @param  {World} world
   * @param  {AABB} aabb
   * @param {array} result An array to store resulting bodies in.
   * @return {array}
   */


  aabbQuery(world, aabb, result = []) {
    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    }

    const axisIndex = this.axisIndex;
    let axis = 'x';

    if (axisIndex === 1) {
      axis = 'y';
    }

    if (axisIndex === 2) {
      axis = 'z';
    }

    const axisList = this.axisList;
    const lower = aabb.lowerBound[axis];
    const upper = aabb.upperBound[axis];

    for (let i = 0; i < axisList.length; i++) {
      const b = axisList[i];

      if (b.aabbNeedsUpdate) {
        b.computeAABB();
      }

      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}
/**
 * @static
 * @method insertionSortX
 * @param  {Array} a
 * @return {Array}
 */

SAPBroadphase.insertionSortX = a => {
  for (let i = 1, l = a.length; i < l; i++) {
    const v = a[i];
    let j;

    for (j = i - 1; j >= 0; j--) {
      if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
        break;
      }

      a[j + 1] = a[j];
    }

    a[j + 1] = v;
  }

  return a;
};
/**
 * @static
 * @method insertionSortY
 * @param  {Array} a
 * @return {Array}
 */


SAPBroadphase.insertionSortY = a => {
  for (let i = 1, l = a.length; i < l; i++) {
    const v = a[i];
    let j;

    for (j = i - 1; j >= 0; j--) {
      if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
        break;
      }

      a[j + 1] = a[j];
    }

    a[j + 1] = v;
  }

  return a;
};
/**
 * @static
 * @method insertionSortZ
 * @param  {Array} a
 * @return {Array}
 */


SAPBroadphase.insertionSortZ = a => {
  for (let i = 1, l = a.length; i < l; i++) {
    const v = a[i];
    let j;

    for (j = i - 1; j >= 0; j--) {
      if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
        break;
      }

      a[j + 1] = a[j];
    }

    a[j + 1] = v;
  }

  return a;
};
/**
 * Check if the bounds of two bodies overlap, along the given SAP axis.
 * @static
 * @method checkBounds
 * @param  {Body} bi
 * @param  {Body} bj
 * @param  {Number} axisIndex
 * @return {Boolean}
 */


SAPBroadphase.checkBounds = (bi, bj, axisIndex) => {
  let biPos;
  let bjPos;

  if (axisIndex === 0) {
    biPos = bi.position.x;
    bjPos = bj.position.x;
  } else if (axisIndex === 1) {
    biPos = bi.position.y;
    bjPos = bj.position.y;
  } else if (axisIndex === 2) {
    biPos = bi.position.z;
    bjPos = bj.position.z;
  }

  const ri = bi.boundingRadius,
        rj = bj.boundingRadius,
        // boundA1 = biPos - ri,
  boundA2 = biPos + ri,
        boundB1 = bjPos - rj; // boundB2 = bjPos + rj;

  return boundB1 < boundA2;
};

function Utils() {}
/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */

Utils.defaults = (options = {}, defaults) => {
  for (let key in defaults) {
    if (!(key in options)) {
      options[key] = defaults[key];
    }
  }

  return options;
};

/**
 * Constraint base class
 * @class Constraint
 * @author schteppe
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {boolean} [options.collideConnected=true]
 * @param {boolean} [options.wakeUpBodies=true]
 */
class Constraint {
  // Equations to be solved in this constraint.
  // Set to true if you want the bodies to collide when they are connected.
  constructor(bodyA, bodyB, options = {}) {
    options = Utils.defaults(options, {
      collideConnected: true,
      wakeUpBodies: true
    });
    this.equations = [];
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.id = Constraint.idCounter++;
    this.collideConnected = options.collideConnected;

    if (options.wakeUpBodies) {
      if (bodyA) {
        bodyA.wakeUp();
      }

      if (bodyB) {
        bodyB.wakeUp();
      }
    }
  }
  /**
   * Update all the equations with data.
   * @method update
   */


  update() {
    throw new Error('method update() not implmemented in this Constraint subclass!');
  }
  /**
   * Enables all equations in the constraint.
   * @method enable
   */


  enable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = true;
    }
  }
  /**
   * Disables all equations in the constraint.
   * @method disable
   */


  disable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = false;
    }
  }

}
Constraint.idCounter = 0;

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 */

class JacobianElement {
  constructor() {
    this.spatial = new Vec3();
    this.rotational = new Vec3();
  }
  /**
   * Multiply with other JacobianElement
   */


  multiplyElement(element) {
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
  }
  /**
   * Multiply with two vectors
   */


  multiplyVectors(spatial, rotational) {
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
  }

}

/**
 * Equation base class
 * @class Equation
 * @constructor
 * @author schteppe
 * @param {Body} bi
 * @param {Body} bj
 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
 */
class Equation {
  // SPOOK parameter
  // SPOOK parameter
  // SPOOK parameter
  // A number, proportional to the force added to the bodies.
  constructor(bi, bj, minForce = -1e6, maxForce = 1e6) {
    this.id = Equation.id++;
    this.minForce = minForce;
    this.maxForce = maxForce;
    this.bi = bi;
    this.bj = bj;
    this.a = 0.0; // SPOOK parameter

    this.b = 0.0; // SPOOK parameter

    this.eps = 0.0; // SPOOK parameter

    this.jacobianElementA = new JacobianElement();
    this.jacobianElementB = new JacobianElement();
    this.enabled = true;
    this.multiplier = 0;
    this.setSpookParams(1e7, 4, 1 / 60); // Set typical spook params
  }
  /**
   * Recalculates a,b,eps.
   * @method setSpookParams
   */


  setSpookParams(stiffness, relaxation, timeStep) {
    const d = relaxation;
    const k = stiffness;
    const h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = 4.0 * d / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
  }
  /**
   * Computes the right hand side of the SPOOK equation
   * @method computeB
   * @return {Number}
   */


  computeB(a, b, h) {
    const GW = this.computeGW();
    const Gq = this.computeGq();
    const GiMf = this.computeGiMf();
    return -Gq * a - GW * b - GiMf * h;
  }
  /**
   * Computes G*q, where q are the generalized body coordinates
   * @method computeGq
   * @return {Number}
   */


  computeGq() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const xi = bi.position;
    const xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
  }
  /**
   * Computes G*W, where W are the body velocities
   * @method computeGW
   * @return {Number}
   */


  computeGW() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.velocity;
    const vj = bj.velocity;
    const wi = bi.angularVelocity;
    const wj = bj.angularVelocity;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*Wlambda, where W are the body velocities
   * @method computeGWlambda
   * @return {Number}
   */


  computeGWlambda() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.vlambda;
    const vj = bj.vlambda;
    const wi = bi.wlambda;
    const wj = bj.wlambda;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }

  computeGiMf() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const fi = bi.force;
    const ti = bi.torque;
    const fj = bj.force;
    const tj = bj.torque;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    fi.scale(invMassi, iMfi);
    fj.scale(invMassj, iMfj);
    bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
    return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
  }

  computeGiMGt() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    const invIi = bi.invInertiaWorldSolve;
    const invIj = bj.invInertiaWorldSolve;
    let result = invMassi + invMassj;
    invIi.vmult(GA.rotational, tmp$1);
    result += tmp$1.dot(GA.rotational);
    invIj.vmult(GB.rotational, tmp$1);
    result += tmp$1.dot(GB.rotational);
    return result;
  }
  /**
   * Add constraint velocity to the bodies.
   * @method addToWlambda
   * @param {Number} deltalambda
   */


  addToWlambda(deltalambda) {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const temp = addToWlambda_temp; // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G

    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
  }
  /**
   * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
   * @method computeInvC
   * @param  {Number} eps
   * @return {Number}
   */


  computeC() {
    return this.computeGiMGt() + this.eps;
  }

}
Equation.id = 0;
/**
 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */

const iMfi = new Vec3();
const iMfj = new Vec3();
const invIi_vmult_taui = new Vec3();
const invIj_vmult_tauj = new Vec3();
/**
 * Computes G*inv(M)*G'
 * @method computeGiMGt
 * @return {Number}
 */

const tmp$1 = new Vec3();
const addToWlambda_temp = new Vec3();

/**
 * Contact/non-penetration constraint equation
 * @class ContactEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @extends Equation
 */
class ContactEquation extends Equation {
  // "bounciness": u1 = -e*u0
  // World-oriented vector that goes from the center of bi to the contact point.
  // World-oriented vector that starts in body j position and goes to the contact point.
  // Contact normal, pointing out of body i.
  constructor(bodyA, bodyB, maxForce = 1e6) {
    super(bodyA, bodyB, 0, maxForce);
    this.restitution = 0.0;
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.ni = new Vec3();
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixn = ContactEquation_computeB_temp1;
    const rjxn = ContactEquation_computeB_temp2;
    const vi = bi.velocity;
    const wi = bi.angularVelocity;
    const fi = bi.force;
    const taui = bi.torque;
    const vj = bj.velocity;
    const wj = bj.angularVelocity;
    const fj = bj.force;
    const tauj = bj.torque;
    const penetrationVec = ContactEquation_computeB_temp3;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const n = this.ni; // Caluclate cross products

    ri.cross(n, rixn);
    rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]

    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn); // Calculate the penetration vector

    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj, penetrationVec);
    penetrationVec.vsub(bi.position, penetrationVec);
    penetrationVec.vsub(ri, penetrationVec);
    const g = n.dot(penetrationVec); // Compute iteration

    const ePlusOne = this.restitution + 1;
    const GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }
  /**
   * Get the current relative velocity in the contact point.
   * @method getImpactVelocityAlongNormal
   * @return {number}
   */


  getImpactVelocityAlongNormal() {
    const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    const relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);
    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);
    vi.vsub(vj, relVel);
    return this.ni.dot(relVel);
  }

}
const ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

const ContactEquation_computeB_temp2 = new Vec3();
const ContactEquation_computeB_temp3 = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Connects two bodies at given offset points.
 * @class PointToPointConstraint
 * @extends Constraint
 * @constructor
 * @param {Body} bodyA
 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
 * @param {Vec3} pivotB See pivotA.
 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
 *
 * @example
 *     const bodyA = new Body({ mass: 1 });
 *     const bodyB = new Body({ mass: 1 });
 *     bodyA.position.set(-1, 0, 0);
 *     bodyB.position.set(1, 0, 0);
 *     bodyA.addShape(shapeA);
 *     bodyB.addShape(shapeB);
 *     world.addBody(bodyA);
 *     world.addBody(bodyB);
 *     const localPivotA = new Vec3(1, 0, 0);
 *     const localPivotB = new Vec3(-1, 0, 0);
 *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
 *     world.addConstraint(constraint);
 */
class PointToPointConstraint extends Constraint {
  // Pivot, defined locally in bodyA.
  // Pivot, defined locally in bodyB.
  constructor(bodyA, pivotA = new Vec3(), bodyB, pivotB = new Vec3(), maxForce = 1e6) {
    super(bodyA, bodyB);
    this.pivotA = pivotA.clone();
    this.pivotB = pivotB.clone();
    const x = this.equationX = new ContactEquation(bodyA, bodyB);
    const y = this.equationY = new ContactEquation(bodyA, bodyB);
    const z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver

    this.equations.push(x, y, z); // Make the equations bidirectional

    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce = maxForce;
    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const x = this.equationX;
    const y = this.equationY;
    const z = this.equationZ; // Rotate the pivots to world space

    bodyA.quaternion.vmult(this.pivotA, x.ri);
    bodyB.quaternion.vmult(this.pivotB, x.rj);
    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
  }

}

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 * @class ConeEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA] Local axis in A
 * @param {Vec3} [options.axisB] Local axis in B
 * @param {Vec3} [options.angle] The "cone angle" to keep
 * @param {number} [options.maxForce=1e6]
 * @extends Equation
 */
class ConeEquation extends Equation {
  // The cone angle to keep.
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1;
    const njxni = tmpVec2;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.angle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1 = new Vec3();
const tmpVec2 = new Vec3();

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 * @class RotationalEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {number} [options.maxForce]
 * @extends Equation
 */
class RotationalEquation extends Equation {
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.maxAngle = Math.PI / 2;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1$1;
    const njxni = tmpVec2$1;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.maxAngle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1$1 = new Vec3();
const tmpVec2$1 = new Vec3();

/**
 * @class ConeTwistConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA]
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
class ConeTwistConstraint extends PointToPointConstraint {
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
    this.collideConnected = !!options.collideConnected;
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
    const c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
    const t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
    this.twistAngle = typeof options.twistAngle !== 'undefined' ? options.twistAngle : 0; // Make the cone equation push the bodies toward the cone axis, not outward

    c.maxForce = 0;
    c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

    t.maxForce = 0;
    t.minForce = -maxForce;
    this.equations.push(c, t);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const cone = this.coneEquation;
    const twist = this.twistEquation;
    super.update(); // Update the axes to the cone constraint

    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
  }

}

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
 * @param {Number} [maxForce=1e6]
 * @extends Constraint
 */
class DistanceConstraint extends Constraint {
  constructor(bodyA, bodyB, distance, maxForce = 1e6) {
    super(bodyA, bodyB);

    if (typeof distance === 'undefined') {
      distance = bodyA.position.distanceTo(bodyB.position);
    }

    this.distance = distance;
    const eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq); // Make it bidirectional

    eq.minForce = -maxForce;
    eq.maxForce = maxForce;
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const eq = this.distanceEquation;
    const halfDist = this.distance * 0.5;
    const normal = eq.ni;
    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.scale(halfDist, eq.ri);
    normal.scale(-halfDist, eq.rj);
  }

}

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
class LockConstraint extends PointToPointConstraint {
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = new Vec3();
    const pivotB = new Vec3();
    const halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

    super(bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

    const r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
    this.equations.push(r1, r2, r3);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const motor = this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const r3 = this.rotationalEquation3;
    super.update(); // These vector pairs must be orthogonal

    bodyA.vectorToWorldFrame(this.xA, r1.axisA);
    bodyB.vectorToWorldFrame(this.yB, r1.axisB);
    bodyA.vectorToWorldFrame(this.yA, r2.axisA);
    bodyB.vectorToWorldFrame(this.zB, r2.axisB);
    bodyA.vectorToWorldFrame(this.zA, r3.axisA);
    bodyB.vectorToWorldFrame(this.xB, r3.axisB);
  }

}

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 * @class RotationalMotorEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} maxForce
 * @extends Equation
 */
class RotationalMotorEquation extends Equation {
  // World oriented rotational axis.
  // World oriented rotational axis.
  // Motor velocity.
  constructor(bodyA, bodyB, maxForce = 1e6) {
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = new Vec3();
    this.axisB = new Vec3();
    this.targetVelocity = 0;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const axisA = this.axisA;
    const axisB = this.axisB;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);
    const GW = this.computeGW() - this.targetVelocity;
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 * @class HingeConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
class HingeConstraint extends PointToPointConstraint {
  // Rotation axis, defined locally in bodyA.
  // Rotation axis, defined locally in bodyB.
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    const axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    axisA.normalize();
    const axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
    axisB.normalize();
    this.collideConnected = !!options.collideConnected;
    const rotational1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const rotational2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
    motor.enabled = false; // Not enabled by default
    // Equations to be fed to the solver

    this.equations.push(rotational1, rotational2, motor);
  }
  /**
   * @method enableMotor
   */


  enableMotor() {
    this.motorEquation.enabled = true;
  }
  /**
   * @method disableMotor
   */


  disableMotor() {
    this.motorEquation.enabled = false;
  }
  /**
   * @method setMotorSpeed
   * @param {number} speed
   */


  setMotorSpeed(speed) {
    this.motorEquation.targetVelocity = speed;
  }
  /**
   * @method setMotorMaxForce
   * @param {number} maxForce
   */


  setMotorMaxForce(maxForce) {
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const motor = this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const worldAxisA = HingeConstraint_update_tmpVec1;
    const worldAxisB = HingeConstraint_update_tmpVec2;
    const axisA = this.axisA;
    const axisB = this.axisB;
    super.update(); // Get world axes

    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);
    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if (this.motorEquation.enabled) {
      bodyA.quaternion.vmult(this.axisA, motor.axisA);
      bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
  }

}
const HingeConstraint_update_tmpVec1 = new Vec3();
const HingeConstraint_update_tmpVec2 = new Vec3();

/**
 * Constrains the slipping in a contact along a tangent
 * @class FrictionEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
 * @extends Equation
 */
class FrictionEquation extends Equation {
  // Tangent.
  constructor(bodyA, bodyB, slipForce) {
    super(bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3();
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixt = FrictionEquation_computeB_temp1;
    const rjxt = FrictionEquation_computeB_temp2;
    const t = this.t; // Caluclate cross products

    ri.cross(t, rixt);
    rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!

    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}
const FrictionEquation_computeB_temp1 = new Vec3();
const FrictionEquation_computeB_temp2 = new Vec3();

/**
 * Defines what happens when two materials meet.
 * @class ContactMaterial
 * @constructor
 * @param {Material} m1
 * @param {Material} m2
 * @param {object} [options]
 * @param {Number} [options.friction=0.3]
 * @param {Number} [options.restitution=0.3]
 * @param {number} [options.contactEquationStiffness=1e7]
 * @param {number} [options.contactEquationRelaxation=3]
 * @param {number} [options.frictionEquationStiffness=1e7]
 * @param {Number} [options.frictionEquationRelaxation=3]
 * @todo Refactor materials to materialA and materialB
 */
class ContactMaterial {
  // Identifier of this material.
  // Participating materials.
  // Friction coefficient.
  // Restitution coefficient.
  // Stiffness of the produced contact equations.
  // Relaxation time of the produced contact equations.
  // Stiffness of the produced friction equations.
  // Relaxation time of the produced friction equations
  constructor(m1, m2, options) {
    options = Utils.defaults(options, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    });
    this.id = ContactMaterial.idCounter++;
    this.materials = [m1, m2];
    this.friction = options.friction;
    this.restitution = options.restitution;
    this.contactEquationStiffness = options.contactEquationStiffness;
    this.contactEquationRelaxation = options.contactEquationRelaxation;
    this.frictionEquationStiffness = options.frictionEquationStiffness;
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
  }

}
ContactMaterial.idCounter = 0;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {object} [options]
 * @author schteppe
 */
class Material {
  // Material name.
  // Material id.
  // Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
  // Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
  constructor(options = {}) {
    let name = ''; // Backwards compatibility fix

    if (typeof options === 'string') {
      name = options;
      options = {};
    }

    this.name = name;
    this.id = Material.idCounter++;
    this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
    this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
  }

}
Material.idCounter = 0;

/**
 * A spring, connecting two bodies.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default: 1
 * @param {number} [options.stiffness]    A number >= 0. Default: 100
 * @param {number} [options.damping]      A number >= 0. Default: 1
 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
 * @param {Vec3}  [options.worldAnchorB]
 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
 * @param {Vec3}  [options.localAnchorB]
 */
class Spring {
  // Rest length of the spring.
  // Stiffness of the spring.
  // Damping of the spring.
  // First connected body.
  // Second connected body.
  // Anchor for bodyA in local bodyA coordinates.
  // Anchor for bodyB in local bodyB coordinates.
  constructor(bodyA, bodyB, options = {}) {
    this.restLength = typeof options.restLength === 'number' ? options.restLength : 1;
    this.stiffness = options.stiffness || 100;
    this.damping = options.damping || 1;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.localAnchorA = new Vec3();
    this.localAnchorB = new Vec3();

    if (options.localAnchorA) {
      this.localAnchorA.copy(options.localAnchorA);
    }

    if (options.localAnchorB) {
      this.localAnchorB.copy(options.localAnchorB);
    }

    if (options.worldAnchorA) {
      this.setWorldAnchorA(options.worldAnchorA);
    }

    if (options.worldAnchorB) {
      this.setWorldAnchorB(options.worldAnchorB);
    }
  }
  /**
   * Set the anchor point on body A, using world coordinates.
   * @method setWorldAnchorA
   * @param {Vec3} worldAnchorA
   */


  setWorldAnchorA(worldAnchorA) {
    this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
  }
  /**
   * Set the anchor point on body B, using world coordinates.
   * @method setWorldAnchorB
   * @param {Vec3} worldAnchorB
   */


  setWorldAnchorB(worldAnchorB) {
    this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
  }
  /**
   * Get the anchor point on body A, in world coordinates.
   * @method getWorldAnchorA
   * @param {Vec3} result The vector to store the result in.
   */


  getWorldAnchorA(result) {
    this.bodyA.pointToWorldFrame(this.localAnchorA, result);
  }
  /**
   * Get the anchor point on body B, in world coordinates.
   * @method getWorldAnchorB
   * @param {Vec3} result The vector to store the result in.
   */


  getWorldAnchorB(result) {
    this.bodyB.pointToWorldFrame(this.localAnchorB, result);
  }
  /**
   * Apply the spring force to the connected bodies.
   * @method applyForce
   */


  applyForce() {
    const k = this.stiffness;
    const d = this.damping;
    const l = this.restLength;
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const r = applyForce_r;
    const r_unit = applyForce_r_unit;
    const u = applyForce_u;
    const f = applyForce_f;
    const tmp = applyForce_tmp;
    const worldAnchorA = applyForce_worldAnchorA;
    const worldAnchorB = applyForce_worldAnchorB;
    const ri = applyForce_ri;
    const rj = applyForce_rj;
    const ri_x_f = applyForce_ri_x_f;
    const rj_x_f = applyForce_rj_x_f; // Get world anchors

    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB); // Get offset points

    worldAnchorA.vsub(bodyA.position, ri);
    worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

    worldAnchorB.vsub(worldAnchorA, r);
    const rlen = r.length();
    r_unit.copy(r);
    r_unit.normalize(); // Compute relative velocity of the anchor points, u

    bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

    bodyB.angularVelocity.cross(rj, tmp);
    u.vadd(tmp, u);
    bodyA.angularVelocity.cross(ri, tmp);
    u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

    r_unit.scale(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

    bodyA.force.vsub(f, bodyA.force);
    bodyB.force.vadd(f, bodyB.force); // Angular force

    ri.cross(f, ri_x_f);
    rj.cross(f, rj_x_f);
    bodyA.torque.vsub(ri_x_f, bodyA.torque);
    bodyB.torque.vadd(rj_x_f, bodyB.torque);
  }

}
const applyForce_r = new Vec3();
const applyForce_r_unit = new Vec3();
const applyForce_u = new Vec3();
const applyForce_f = new Vec3();
const applyForce_worldAnchorA = new Vec3();
const applyForce_worldAnchorB = new Vec3();
const applyForce_ri = new Vec3();
const applyForce_rj = new Vec3();
const applyForce_ri_x_f = new Vec3();
const applyForce_rj_x_f = new Vec3();
const applyForce_tmp = new Vec3();

/**
 * @class WheelInfo
 * @constructor
 * @param {Object} [options]
 *
 * @param {Vec3} [options.chassisConnectionPointLocal]
 * @param {Vec3} [options.chassisConnectionPointWorld]
 * @param {Vec3} [options.directionLocal]
 * @param {Vec3} [options.directionWorld]
 * @param {Vec3} [options.axleLocal]
 * @param {Vec3} [options.axleWorld]
 * @param {number} [options.suspensionRestLength=1]
 * @param {number} [options.suspensionMaxLength=2]
 * @param {number} [options.radius=1]
 * @param {number} [options.suspensionStiffness=100]
 * @param {number} [options.dampingCompression=10]
 * @param {number} [options.dampingRelaxation=10]
 * @param {number} [options.frictionSlip=10000]
 * @param {number} [options.steering=0]
 * @param {number} [options.rotation=0]
 * @param {number} [options.deltaRotation=0]
 * @param {number} [options.rollInfluence=0.01]
 * @param {number} [options.maxSuspensionForce]
 * @param {boolean} [options.isFrontWheel=true]
 * @param {number} [options.clippedInvContactDotSuspension=1]
 * @param {number} [options.suspensionRelativeVelocity=0]
 * @param {number} [options.suspensionForce=0]
 * @param {number} [options.skidInfo=0]
 * @param {number} [options.suspensionLength=0]
 * @param {number} [options.maxSuspensionTravel=1]
 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
 */
class WheelInfo {
  // Max travel distance of the suspension, in meters.
  // Speed to apply to the wheel rotation when the wheel is sliding.
  // If the customSlidingRotationalSpeed should be used.
  // Connection point, defined locally in the chassis body frame.
  // Rotation value, in radians.
  // The result from raycasting.
  // Wheel world transform.
  constructor(options = {}) {
    options = Utils.defaults(options, {
      chassisConnectionPointLocal: new Vec3(),
      chassisConnectionPointWorld: new Vec3(),
      directionLocal: new Vec3(),
      directionWorld: new Vec3(),
      axleLocal: new Vec3(),
      axleWorld: new Vec3(),
      suspensionRestLength: 1,
      suspensionMaxLength: 2,
      radius: 1,
      suspensionStiffness: 100,
      dampingCompression: 10,
      dampingRelaxation: 10,
      frictionSlip: 10000,
      steering: 0,
      rotation: 0,
      deltaRotation: 0,
      rollInfluence: 0.01,
      maxSuspensionForce: Number.MAX_VALUE,
      isFrontWheel: true,
      clippedInvContactDotSuspension: 1,
      suspensionRelativeVelocity: 0,
      suspensionForce: 0,
      slipInfo: 0,
      skidInfo: 0,
      suspensionLength: 0,
      maxSuspensionTravel: 1,
      useCustomSlidingRotationalSpeed: false,
      customSlidingRotationalSpeed: -0.1
    });
    this.maxSuspensionTravel = options.maxSuspensionTravel;
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
    this.sliding = false;
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
    this.directionLocal = options.directionLocal.clone();
    this.directionWorld = options.directionWorld.clone();
    this.axleLocal = options.axleLocal.clone();
    this.axleWorld = options.axleWorld.clone();
    this.suspensionRestLength = options.suspensionRestLength;
    this.suspensionMaxLength = options.suspensionMaxLength;
    this.radius = options.radius;
    this.suspensionStiffness = options.suspensionStiffness;
    this.dampingCompression = options.dampingCompression;
    this.dampingRelaxation = options.dampingRelaxation;
    this.frictionSlip = options.frictionSlip;
    this.steering = 0;
    this.rotation = 0;
    this.deltaRotation = 0;
    this.rollInfluence = options.rollInfluence;
    this.maxSuspensionForce = options.maxSuspensionForce;
    this.engineForce = 0;
    this.brake = 0;
    this.isFrontWheel = options.isFrontWheel;
    this.clippedInvContactDotSuspension = 1;
    this.suspensionRelativeVelocity = 0;
    this.suspensionForce = 0;
    this.slipInfo = 0;
    this.skidInfo = 0;
    this.suspensionLength = 0;
    this.sideImpulse = 0;
    this.forwardImpulse = 0;
    this.raycastResult = new RaycastResult();
    this.worldTransform = new Transform();
    this.isInContact = false;
  }

  updateWheel(chassis) {
    const raycastResult = this.raycastResult;

    if (this.isInContact) {
      const project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
      raycastResult.hitPointWorld.vsub(chassis.position, relpos);
      chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
      const projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (project >= -0.1) {
        this.suspensionRelativeVelocity = 0.0;
        this.clippedInvContactDotSuspension = 1.0 / 0.1;
      } else {
        const inv = -1 / project;
        this.suspensionRelativeVelocity = projVel * inv;
        this.clippedInvContactDotSuspension = inv;
      }
    } else {
      // Not in contact : position wheel in a nice (rest length) position
      raycastResult.suspensionLength = this.suspensionRestLength;
      this.suspensionRelativeVelocity = 0.0;
      raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
      this.clippedInvContactDotSuspension = 1.0;
    }
  }

}
const chassis_velocity_at_contactPoint = new Vec3();
const relpos = new Vec3();

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 * @class RaycastVehicle
 * @constructor
 * @param {object} [options]
 * @param {Body} [options.chassisBody] The car chassis body.
 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
 * @param {integer} [options.indexLeftAxis]
 * @param {integer} [options.indexUpAxis]
 */
class RaycastVehicle {
  // Will be set to true if the car is sliding.
  // Index of the right axis, 0=x, 1=y, 2=z
  // Index of the forward axis, 0=x, 1=y, 2=z
  // Index of the up axis, 0=x, 1=y, 2=z
  constructor(options) {
    this.chassisBody = options.chassisBody;
    this.wheelInfos = [];
    this.sliding = false;
    this.world = null;
    this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 1;
    this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;
    this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 2;
    this.constraints = [];

    this.preStepCallback = () => {};

    this.currentVehicleSpeedKmHour = 0;
  }
  /**
   * Add a wheel. For information about the options, see WheelInfo.
   * @method addWheel
   * @param {object} [options]
   */


  addWheel(options = {}) {
    const info = new WheelInfo(options);
    const index = this.wheelInfos.length;
    this.wheelInfos.push(info);
    return index;
  }
  /**
   * Set the steering value of a wheel.
   * @method setSteeringValue
   * @param {number} value
   * @param {integer} wheelIndex
   */


  setSteeringValue(value, wheelIndex) {
    const wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   * @method applyEngineForce
   * @param  {number} value
   * @param  {integer} wheelIndex
   */


  applyEngineForce(value, wheelIndex) {
    this.wheelInfos[wheelIndex].engineForce = value;
  }
  /**
   * Set the braking force of a wheel
   * @method setBrake
   * @param {number} brake
   * @param {integer} wheelIndex
   */


  setBrake(brake, wheelIndex) {
    this.wheelInfos[wheelIndex].brake = brake;
  }
  /**
   * Add the vehicle including its constraints to the world.
   * @method addToWorld
   * @param {World} world
   */


  addToWorld(world) {
    const constraints = this.constraints;
    world.addBody(this.chassisBody);
    const that = this;

    this.preStepCallback = () => {
      that.updateVehicle(world.dt);
    };

    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
  }
  /**
   * Get one of the wheel axles, world-oriented.
   * @private
   * @method getVehicleAxisWorld
   * @param  {integer} axisIndex
   * @param  {Vec3} result
   */


  getVehicleAxisWorld(axisIndex, result) {
    result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
    this.chassisBody.vectorToWorldFrame(result, result);
  }

  updateVehicle(timeStep) {
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;

    for (let i = 0; i < numWheels; i++) {
      this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.length();
    const forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0) {
      this.currentVehicleSpeedKmHour *= -1;
    } // simulate suspension


    for (let i = 0; i < numWheels; i++) {
      this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);
    const impulse = new Vec3();
    const relpos = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      //apply suspension force
      const wheel = wheelInfos[i];
      let suspensionForce = wheel.suspensionForce;

      if (suspensionForce > wheel.maxSuspensionForce) {
        suspensionForce = wheel.maxSuspensionForce;
      }

      wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
      chassisBody.applyImpulse(impulse, relpos);
    }

    this.updateFriction(timeStep);
    const hitNormalWorldScaledWithProj = new Vec3();
    const fwd = new Vec3();
    const vel = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i]; //const relpos = new Vec3();
      //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

      chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction

      let m = 1;

      switch (this.indexUpAxis) {
        case 1:
          m = -1;
          break;
      }

      if (wheel.isInContact) {
        this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
        const proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
        wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
        fwd.vsub(hitNormalWorldScaledWithProj, fwd);
        const proj2 = fwd.dot(vel);
        wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
      }

      if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
        // Apply custom rotation when accelerating and sliding
        wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
      } // Lock wheels


      if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
        wheel.deltaRotation = 0;
      }

      wheel.rotation += wheel.deltaRotation; // Use the old value

      wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
  }

  updateSuspension(deltaTime) {
    const chassisBody = this.chassisBody;
    const chassisMass = chassisBody.mass;
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;

    for (let w_it = 0; w_it < numWheels; w_it++) {
      const wheel = wheelInfos[w_it];

      if (wheel.isInContact) {
        let force; // Spring

        const susp_length = wheel.suspensionRestLength;
        const current_length = wheel.suspensionLength;
        const length_diff = susp_length - current_length;
        force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper

        const projected_rel_vel = wheel.suspensionRelativeVelocity;
        let susp_damping;

        if (projected_rel_vel < 0) {
          susp_damping = wheel.dampingCompression;
        } else {
          susp_damping = wheel.dampingRelaxation;
        }

        force -= susp_damping * projected_rel_vel;
        wheel.suspensionForce = force * chassisMass;

        if (wheel.suspensionForce < 0) {
          wheel.suspensionForce = 0;
        }
      } else {
        wheel.suspensionForce = 0;
      }
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   * @method removeFromWorld
   * @param {World} world
   */


  removeFromWorld(world) {
    const constraints = this.constraints;
    world.removeBody(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
  }

  castRay(wheel) {
    const rayvector = castRay_rayvector;
    const target = castRay_target;
    this.updateWheelTransformWorld(wheel);
    const chassisBody = this.chassisBody;
    let depth = -1;
    const raylen = wheel.suspensionRestLength + wheel.radius;
    wheel.directionWorld.scale(raylen, rayvector);
    const source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    const raycastResult = wheel.raycastResult;
    raycastResult.reset(); // Turn off ray collision with the chassis temporarily

    const oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false; // Cast ray against world

    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;
    const object = raycastResult.body;
    wheel.raycastResult.groundObject = 0;

    if (object) {
      depth = raycastResult.distance;
      wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
      wheel.isInContact = true;
      const hitDistance = raycastResult.distance;
      wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

      const minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
      const maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;

      if (wheel.suspensionLength < minSuspensionLength) {
        wheel.suspensionLength = minSuspensionLength;
      }

      if (wheel.suspensionLength > maxSuspensionLength) {
        wheel.suspensionLength = maxSuspensionLength;
        wheel.raycastResult.reset();
      }

      const denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
      const chassis_velocity_at_contactPoint = new Vec3();
      chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
      const projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (denominator >= -0.1) {
        wheel.suspensionRelativeVelocity = 0;
        wheel.clippedInvContactDotSuspension = 1 / 0.1;
      } else {
        const inv = -1 / denominator;
        wheel.suspensionRelativeVelocity = projVel * inv;
        wheel.clippedInvContactDotSuspension = inv;
      }
    } else {
      //put wheel info as in rest position
      wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
      wheel.suspensionRelativeVelocity = 0.0;
      wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
      wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
  }

  updateWheelTransformWorld(wheel) {
    wheel.isInContact = false;
    const chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
  }
  /**
   * Update one of the wheel transform.
   * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
   * @method updateWheelTransform
   * @param {integer} wheelIndex The wheel index to update.
   */


  updateWheelTransform(wheelIndex) {
    const up = tmpVec4;
    const right = tmpVec5;
    const fwd = tmpVec6;
    const wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);
    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize(); // Rotate around steering over the wheelAxle

    const steering = wheel.steering;
    const steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);
    const rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

    const q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);
    q.normalize(); // world position of the wheel

    const p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
  }
  /**
   * Get the world transform of one of the wheels
   * @method getWheelTransformWorld
   * @param  {integer} wheelIndex
   * @return {Transform}
   */


  getWheelTransformWorld(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
  }

  updateFriction(timeStep) {
    const surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;
    const forwardWS = updateFriction_forwardWS;
    const axle = updateFriction_axle;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      wheel.sideImpulse = 0;
      wheel.forwardImpulse = 0;

      if (!forwardWS[i]) {
        forwardWS[i] = new Vec3();
      }

      if (!axle[i]) {
        axle[i] = new Vec3();
      }
    }

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      if (groundObject) {
        const axlei = axle[i];
        const wheelTrans = this.getWheelTransformWorld(i); // Get world axle

        wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
        const surfNormalWS = wheel.raycastResult.hitNormalWorld;
        const proj = axlei.dot(surfNormalWS);
        surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
        axlei.vsub(surfNormalWS_scaled_proj, axlei);
        axlei.normalize();
        surfNormalWS.cross(axlei, forwardWS[i]);
        forwardWS[i].normalize();
        wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
        wheel.sideImpulse *= sideFrictionStiffness2;
      }
    }

    const sideFactor = 1;
    const fwdFactor = 0.5;
    this.sliding = false;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;
      let rollingFriction = 0;
      wheel.slipInfo = 1;

      if (groundObject) {
        const defaultRollingFrictionImpulse = 0;
        const maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
        // rollingFriction = calcRollingFriction(contactPt);

        rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
        rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

        const factor = maxImpulse / rollingFriction;
        wheel.slipInfo *= factor;
      } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)


      wheel.forwardImpulse = 0;
      wheel.skidInfo = 1;

      if (groundObject) {
        wheel.skidInfo = 1;
        const maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
        const maximpSide = maximp;
        const maximpSquared = maximp * maximpSide;
        wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

        const x = wheel.forwardImpulse * fwdFactor;
        const y = wheel.sideImpulse * sideFactor;
        const impulseSquared = x * x + y * y;
        wheel.sliding = false;

        if (impulseSquared > maximpSquared) {
          this.sliding = true;
          wheel.sliding = true;
          const factor = maximp / Math.sqrt(impulseSquared);
          wheel.skidInfo *= factor;
        }
      }
    }

    if (this.sliding) {
      for (let i = 0; i < numWheels; i++) {
        const wheel = wheelInfos[i];

        if (wheel.sideImpulse !== 0) {
          if (wheel.skidInfo < 1) {
            wheel.forwardImpulse *= wheel.skidInfo;
            wheel.sideImpulse *= wheel.skidInfo;
          }
        }
      }
    } // apply the impulses


    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const rel_pos = new Vec3();
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position
      //rel_pos.copy(wheel.raycastResult.hitPointWorld);

      if (wheel.forwardImpulse !== 0) {
        const impulse = new Vec3();
        forwardWS[i].scale(wheel.forwardImpulse, impulse);
        chassisBody.applyImpulse(impulse, rel_pos);
      }

      if (wheel.sideImpulse !== 0) {
        const groundObject = wheel.raycastResult.body;
        const rel_pos2 = new Vec3();
        wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

        const sideImp = new Vec3();
        axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
        // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

        chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
        rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
        chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
        chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

        sideImp.scale(-1, sideImp);
        groundObject.applyImpulse(sideImp, rel_pos2);
      }
    }
  }

}
const tmpVec4 = new Vec3();
const tmpVec5 = new Vec3();
const tmpVec6 = new Vec3();
const tmpRay = new Ray();
const castRay_rayvector = new Vec3();
const castRay_target = new Vec3();
const directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
const updateFriction_surfNormalWS_scaled_proj = new Vec3();
const updateFriction_axle = [];
const updateFriction_forwardWS = [];
const sideFrictionStiffness2 = 1;
const calcRollingFriction_vel1 = new Vec3();
const calcRollingFriction_vel2 = new Vec3();
const calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
  let j1 = 0;
  const contactPosWorld = frictionPosWorld; // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();

  const vel1 = calcRollingFriction_vel1;
  const vel2 = calcRollingFriction_vel2;
  const vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
  // contactPosWorld.vsub(body1.position, rel_pos2);

  body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
  body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
  vel1.vsub(vel2, vel);
  const vrel = frictionDirectionWorld.dot(vel);
  const denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
  const denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
  const relaxation = 1;
  const jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

  j1 = -vrel * jacDiagABInv;

  if (maxImpulse < j1) {
    j1 = maxImpulse;
  }

  if (j1 < -maxImpulse) {
    j1 = -maxImpulse;
  }

  return j1;
}

const computeImpulseDenominator_r0 = new Vec3();
const computeImpulseDenominator_c0 = new Vec3();
const computeImpulseDenominator_vec = new Vec3();
const computeImpulseDenominator_m = new Vec3();

function computeImpulseDenominator(body, pos, normal) {
  const r0 = computeImpulseDenominator_r0;
  const c0 = computeImpulseDenominator_c0;
  const vec = computeImpulseDenominator_vec;
  const m = computeImpulseDenominator_m;
  pos.vsub(body.position, r0);
  r0.cross(normal, c0);
  body.invInertiaWorld.vmult(c0, m);
  m.cross(r0, vec);
  return body.invMass + normal.dot(vec);
}

const resolveSingleBilateral_vel1 = new Vec3();
const resolveSingleBilateral_vel2 = new Vec3();
const resolveSingleBilateral_vel = new Vec3(); //bilateral constraint between two dynamic objects

function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
  const normalLenSqr = normal.lengthSquared();

  if (normalLenSqr > 1.1) {
    return 0; // no impulse
  } // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();
  // pos1.vsub(body1.position, rel_pos1);
  // pos2.vsub(body2.position, rel_pos2);


  const vel1 = resolveSingleBilateral_vel1;
  const vel2 = resolveSingleBilateral_vel2;
  const vel = resolveSingleBilateral_vel;
  body1.getVelocityAtWorldPoint(pos1, vel1);
  body2.getVelocityAtWorldPoint(pos2, vel2);
  vel1.vsub(vel2, vel);
  const rel_vel = normal.dot(vel);
  const contactDamping = 0.2;
  const massTerm = 1 / (body1.invMass + body2.invMass);
  const impulse = -contactDamping * rel_vel * massTerm;
  return impulse;
}

/**
 * Spherical shape
 * @class Sphere
 * @constructor
 * @extends Shape
 * @param {Number} radius The radius of the sphere, a non-negative number.
 * @author schteppe / http://github.com/schteppe
 */
class Sphere extends Shape {
  constructor(radius) {
    super({
      type: Shape.types.SPHERE
    });
    this.radius = radius !== undefined ? radius : 1.0;

    if (this.radius < 0) {
      throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
  }

  calculateLocalInertia(mass, target = new Vec3()) {
    const I = 2.0 * mass * this.radius * this.radius / 5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
  }

  volume() {
    return 4.0 * Math.PI * Math.pow(this.radius, 3) / 3.0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.radius;
  }

  calculateWorldAABB(pos, quat, min, max) {
    const r = this.radius;
    const axes = ['x', 'y', 'z'];

    for (let i = 0; i < axes.length; i++) {
      const ax = axes[i];
      min[ax] = pos[ax] - r;
      max[ax] = pos[ax] + r;
    }
  }

}

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 * @class RigidVehicle
 * @constructor
 * @param {Body} [options.chassisBody]
 */
class RigidVehicle {
  constructor(options = {}) {
    this.wheelBodies = [];
    this.coordinateSystem = typeof options.coordinateSystem !== 'undefined' ? options.coordinateSystem.clone() : new Vec3(1, 2, 3);

    if (options.chassisBody) {
      this.chassisBody = options.chassisBody;
    } else {
      // No chassis body given. Create it!
      this.chassisBody = new Body({
        mass: 1,
        shape: new Box(new Vec3(5, 2, 0.5))
      });
    }

    this.constraints = [];
    this.wheelAxes = [];
    this.wheelForces = [];
  }
  /**
   * Add a wheel
   * @method addWheel
   * @param {object} options
   * @param {boolean} [options.isFrontWheel]
   * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
   * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
   * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
   * @param {Body} [options.body] The wheel body.
   */


  addWheel(options = {}) {
    let wheelBody;

    if (options.body) {
      wheelBody = options.body;
    } else {
      // No wheel body given. Create it!
      wheelBody = new Body({
        mass: 1,
        shape: new Sphere(1.2)
      });
    }

    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0); // Position constrain wheels
    const position = typeof options.position !== 'undefined' ? options.position.clone() : new Vec3(); // Set position locally to the chassis

    const worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z); // Constrain wheel

    const axis = typeof options.axis !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
    this.wheelAxes.push(axis);
    const hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
      pivotA: position,
      axisA: axis,
      pivotB: Vec3.ZERO,
      axisB: axis,
      collideConnected: false
    });
    this.constraints.push(hingeConstraint);
    return this.wheelBodies.length - 1;
  }
  /**
   * Set the steering value of a wheel.
   * @method setSteeringValue
   * @param {number} value
   * @param {integer} wheelIndex
   * @todo check coordinateSystem
   */


  setSteeringValue(value, wheelIndex) {
    // Set angle of the hinge axis
    const axis = this.wheelAxes[wheelIndex];
    const c = Math.cos(value);
    const s = Math.sin(value);
    const x = axis.x;
    const y = axis.y;
    this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   * @method setMotorSpeed
   * @param {number} value
   * @param {integer} wheelIndex
   */


  setMotorSpeed(value, wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   * @method disableMotor
   * @param {number} value
   * @param {integer} wheelIndex
   */


  disableMotor(wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   * @method setWheelForce
   * @param  {number} value
   * @param  {integer} wheelIndex
   */


  setWheelForce(value, wheelIndex) {
    this.wheelForces[wheelIndex] = value;
  }
  /**
   * Apply a torque on one of the wheels.
   * @method applyWheelForce
   * @param  {number} value
   * @param  {integer} wheelIndex
   */


  applyWheelForce(value, wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const bodyTorque = wheelBody.torque;
    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
  }
  /**
   * Add the vehicle including its constraints to the world.
   * @method addToWorld
   * @param {World} world
   */


  addToWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.addBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
  }

  _update() {
    const wheelForces = this.wheelForces;

    for (let i = 0; i < wheelForces.length; i++) {
      this.applyWheelForce(wheelForces[i], i);
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   * @method removeFromWorld
   * @param {World} world
   */


  removeFromWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.removeBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.removeConstraint(constraints[i]);
    }
  }
  /**
   * Get current rotational velocity of a wheel
   * @method getWheelSpeed
   * @param {integer} wheelIndex
   */


  getWheelSpeed(wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
  }

}
const torque = new Vec3();
const worldAxis = new Vec3();

/**
 * Smoothed-particle hydrodynamics system
 * @class SPHSystem
 * @constructor
 */
class SPHSystem {
  // Density of the system (kg/m3).
  // Distance below which two particles are considered to be neighbors. It should be adjusted so there are about 15-20 neighbor particles within this radius.
  // Viscosity of the system.
  constructor() {
    this.particles = [];
    this.density = 1;
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
    this.viscosity = 0.01;
    this.eps = 0.000001; // Stuff Computed per particle

    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
  }
  /**
   * Add a particle to the system.
   * @method add
   * @param {Body} particle
   */


  add(particle) {
    this.particles.push(particle);

    if (this.neighbors.length < this.particles.length) {
      this.neighbors.push([]);
    }
  }
  /**
   * Remove a particle from the system.
   * @method remove
   * @param {Body} particle
   */


  remove(particle) {
    const idx = this.particles.indexOf(particle);

    if (idx !== -1) {
      this.particles.splice(idx, 1);

      if (this.neighbors.length > this.particles.length) {
        this.neighbors.pop();
      }
    }
  }

  getNeighbors(particle, neighbors) {
    const N = this.particles.length;
    const id = particle.id;
    const R2 = this.smoothingRadius * this.smoothingRadius;
    const dist = SPHSystem_getNeighbors_dist;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i];
      p.position.vsub(particle.position, dist);

      if (id !== p.id && dist.lengthSquared() < R2) {
        neighbors.push(p);
      }
    }
  }

  update() {
    const N = this.particles.length;
    const dist = SPHSystem_update_dist;
    const cs = this.speedOfSound;
    const eps = this.eps;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i]; // Current particle

      const neighbors = this.neighbors[i]; // Get neighbors

      neighbors.length = 0;
      this.getNeighbors(p, neighbors);
      neighbors.push(this.particles[i]); // Add current too

      const numNeighbors = neighbors.length; // Accumulate density for the particle

      let sum = 0.0;

      for (let j = 0; j !== numNeighbors; j++) {
        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
        p.position.vsub(neighbors[j].position, dist);
        const len = dist.length();
        const weight = this.w(len);
        sum += neighbors[j].mass * weight;
      } // Save


      this.densities[i] = sum;
      this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    } // Add forces
    // Sum to these accelerations


    const a_pressure = SPHSystem_update_a_pressure;
    const a_visc = SPHSystem_update_a_visc;
    const gradW = SPHSystem_update_gradW;
    const r_vec = SPHSystem_update_r_vec;
    const u = SPHSystem_update_u;

    for (let i = 0; i !== N; i++) {
      const particle = this.particles[i];
      a_pressure.set(0, 0, 0);
      a_visc.set(0, 0, 0); // Init vars

      let Pij;
      let nabla;

      const neighbors = this.neighbors[i];
      const numNeighbors = neighbors.length; //printf("Neighbors: ");

      for (let j = 0; j !== numNeighbors; j++) {
        const neighbor = neighbors[j]; //printf("%d ",nj);
        // Get r once for all..

        particle.position.vsub(neighbor.position, r_vec);
        const r = r_vec.length(); // Pressure contribution

        Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
        this.gradw(r_vec, gradW); // Add to pressure acceleration

        gradW.scale(Pij, gradW);
        a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

        neighbor.velocity.vsub(particle.velocity, u);
        u.scale(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
        nabla = this.nablaw(r);
        u.scale(nabla, u); // Add to viscosity acceleration

        a_visc.vadd(u, a_visc);
      } // Calculate force


      a_visc.scale(particle.mass, a_visc);
      a_pressure.scale(particle.mass, a_pressure); // Add force to particles

      particle.force.vadd(a_visc, particle.force);
      particle.force.vadd(a_pressure, particle.force);
    }
  } // Calculate the weight using the W(r) weightfunction


  w(r) {
    // 315
    const h = this.smoothingRadius;
    return 315.0 / (64.0 * Math.PI * h ** 9) * (h * h - r * r) ** 3;
  } // calculate gradient of the weight function


  gradw(rVec, resultVec) {
    const r = rVec.length();
    const h = this.smoothingRadius;
    rVec.scale(945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) ** 2, resultVec);
  } // Calculate nabla(W)


  nablaw(r) {
    const h = this.smoothingRadius;
    const nabla = 945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) * (7 * r * r - 3 * h * h);
    return nabla;
  }

}
/**
 * Get neighbors within smoothing volume, save in the array neighbors
 * @method getNeighbors
 * @param {Body} particle
 * @param {Array} neighbors
 */

const SPHSystem_getNeighbors_dist = new Vec3(); // Temp vectors for calculation

const SPHSystem_update_dist = new Vec3(); // Relative velocity

const SPHSystem_update_a_pressure = new Vec3();
const SPHSystem_update_a_visc = new Vec3();
const SPHSystem_update_gradW = new Vec3();
const SPHSystem_update_r_vec = new Vec3();
const SPHSystem_update_u = new Vec3();

/**
 * @class Cylinder
 * @constructor
 * @extends ConvexPolyhedron
 * @author schteppe / https://github.com/schteppe
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Number} numSegments The number of segments to build the cylinder out of
 */

class Cylinder extends ConvexPolyhedron {
  constructor(radiusTop, radiusBottom, height, numSegments) {
    const N = numSegments;
    const vertices = [];
    const axes = [];
    const faces = [];
    const bottomface = [];
    const topface = [];
    const cos = Math.cos;
    const sin = Math.sin; // First bottom point

    vertices.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), -height * 0.5));
    bottomface.push(0); // First top point

    vertices.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), height * 0.5));
    topface.push(1);

    for (let i = 0; i < N; i++) {
      const theta = 2 * Math.PI / N * (i + 1);
      const thetaN = 2 * Math.PI / N * (i + 0.5);

      if (i < N - 1) {
        // Bottom
        vertices.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), -height * 0.5));
        bottomface.push(2 * i + 2); // Top

        vertices.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), height * 0.5));
        topface.push(2 * i + 3); // Face

        faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
      } else {
        faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect
      } // Axis: we can cut off half of them if we have even number of segments


      if (N % 2 === 1 || i < N / 2) {
        axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
      }
    }

    faces.push(topface);
    axes.push(new Vec3(0, 0, 1)); // Reorder bottom face

    const temp = [];

    for (let i = 0; i < bottomface.length; i++) {
      temp.push(bottomface[bottomface.length - i - 1]);
    }

    faces.push(temp);
    super({
      vertices,
      faces,
      axes
    });
  }

}

/**
 * Particle shape.
 * @class Particle
 * @constructor
 * @author schteppe
 * @extends Shape
 */
class Particle extends Shape {
  constructor() {
    super({
      type: Shape.types.PARTICLE
    });
  }
  /**
   * @method calculateLocalInertia
   * @param  {Number} mass
   * @param  {Vec3} target
   * @return {Vec3}
   */


  calculateLocalInertia(mass, target = new Vec3()) {
    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return 0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = 0;
  }

  calculateWorldAABB(pos, quat, min, max) {
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
  }

}

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
 * @class Plane
 * @constructor
 * @extends Shape
 * @author schteppe
 */
class Plane extends Shape {
  constructor() {
    super({
      type: Shape.types.PLANE
    }); // World oriented normal

    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;
    this.boundingSphereRadius = Number.MAX_VALUE;
  }

  computeWorldNormal(quat) {
    const n = this.worldNormal;
    n.set(0, 0, 1);
    quat.vmult(n, n);
    this.worldNormalNeedsUpdate = false;
  }

  calculateLocalInertia(mass, target = new Vec3()) {
    return target;
  }

  volume() {
    return (// The plane is infinite...
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0, 0, 1); // Default plane normal is z

    quat.vmult(tempNormal, tempNormal);
    const maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if (tempNormal.x === 1) {
      max.x = pos.x;
    } else if (tempNormal.x === -1) {
      min.x = pos.x;
    }

    if (tempNormal.y === 1) {
      max.y = pos.y;
    } else if (tempNormal.y === -1) {
      min.y = pos.y;
    }

    if (tempNormal.z === 1) {
      max.z = pos.z;
    } else if (tempNormal.z === -1) {
      min.z = pos.z;
    }
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }

}
const tempNormal = new Vec3();

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 * @todo should be possible to scale along all axes
 * @todo Refactor elementSize to elementSizeX and elementSizeY
 *
 * @example
 *     // Generate some height data (y-values).
 *     const data = [];
 *     for(let i = 0; i < 1000; i++){
 *         const y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     const heightfieldShape = new Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     });
 *     const heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
class Heightfield extends Shape {
  // An array of numbers, or height values, that are spread out along the x axis.
  // Max value of the data.
  // Max value of the data.
  // The width of each element. To do: elementSizeX and Y
  constructor(data, options = {}) {
    options = Utils.defaults(options, {
      maxValue: null,
      minValue: null,
      elementSize: 1
    });
    super({
      type: Shape.types.HEIGHTFIELD
    });
    this.data = data;
    this.maxValue = options.maxValue;
    this.minValue = options.minValue;
    this.elementSize = options.elementSize;

    if (options.minValue === null) {
      this.updateMinValue();
    }

    if (options.maxValue === null) {
      this.updateMaxValue();
    }

    this.cacheEnabled = true;
    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();
    this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]

    this._cachedPillars = {};
  }
  /**
   * Call whenever you change the data array.
   * @method update
   */


  update() {
    this._cachedPillars = {};
  }
  /**
   * Update the .minValue property
   * @method updateMinValue
   */


  updateMinValue() {
    const data = this.data;
    let minValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v < minValue) {
          minValue = v;
        }
      }
    }

    this.minValue = minValue;
  }
  /**
   * Update the .maxValue property
   * @method updateMaxValue
   */


  updateMaxValue() {
    const data = this.data;
    let maxValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v > maxValue) {
          maxValue = v;
        }
      }
    }

    this.maxValue = maxValue;
  }
  /**
   * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
   * @method setHeightValueAtIndex
   * @param {integer} xi
   * @param {integer} yi
   * @param {number} value
   */


  setHeightValueAtIndex(xi, yi, value) {
    const data = this.data;
    data[xi][yi] = value; // Invalidate cache

    this.clearCachedConvexTrianglePillar(xi, yi, false);

    if (xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
      this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }

    if (yi > 0) {
      this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
      this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }

    if (yi > 0 && xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
  }
  /**
   * Get max/min in a rectangle in the matrix data
   * @method getRectMinMax
   * @param  {integer} iMinX
   * @param  {integer} iMinY
   * @param  {integer} iMaxX
   * @param  {integer} iMaxY
   * @param  {array} [result] An array to store the results in.
   * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
   */


  getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, result = []) {
    // Get max and min of the data
    const data = this.data; // Set first value

    let max = this.minValue;

    for (let i = iMinX; i <= iMaxX; i++) {
      for (let j = iMinY; j <= iMaxY; j++) {
        const height = data[i][j];

        if (height > max) {
          max = height;
        }
      }
    }

    result[0] = this.minValue;
    result[1] = max;
  }
  /**
   * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
   * @method getIndexOfPosition
   * @param  {number} x
   * @param  {number} y
   * @param  {array} result Two-element array
   * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
   * @return {boolean}
   */


  getIndexOfPosition(x, y, result, clamp) {
    // Get the index of the data points to test against
    const w = this.elementSize;
    const data = this.data;
    let xi = Math.floor(x / w);
    let yi = Math.floor(y / w);
    result[0] = xi;
    result[1] = yi;

    if (clamp) {
      // Clamp index to edges
      if (xi < 0) {
        xi = 0;
      }

      if (yi < 0) {
        yi = 0;
      }

      if (xi >= data.length - 1) {
        xi = data.length - 1;
      }

      if (yi >= data[0].length - 1) {
        yi = data[0].length - 1;
      }
    } // Bail out if we are out of the terrain


    if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
      return false;
    }

    return true;
  }

  getTriangleAt(x, y, edgeClamp, a, b, c) {
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];
    const data = this.data;

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const elementSize = this.elementSize;
    const lowerDist2 = (x / elementSize - xi) ** 2 + (y / elementSize - yi) ** 2;
    const upperDist2 = (x / elementSize - (xi + 1)) ** 2 + (y / elementSize - (yi + 1)) ** 2;
    const upper = lowerDist2 > upperDist2;
    this.getTriangle(xi, yi, upper, a, b, c);
    return upper;
  }

  getNormalAt(x, y, edgeClamp, result) {
    const a = getNormalAt_a;
    const b = getNormalAt_b;
    const c = getNormalAt_c;
    const e0 = getNormalAt_e0;
    const e1 = getNormalAt_e1;
    this.getTriangleAt(x, y, edgeClamp, a, b, c);
    b.vsub(a, e0);
    c.vsub(a, e1);
    e0.cross(e1, result);
    result.normalize();
  }
  /**
   * Get an AABB of a square in the heightfield
   * @param  {number} xi
   * @param  {number} yi
   * @param  {AABB} result
   */


  getAabbAtIndex(xi, yi, {
    lowerBound,
    upperBound
  }) {
    const data = this.data;
    const elementSize = this.elementSize;
    lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
    upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
  }
  /**
   * Get the height in the heightfield at a given position
   * @param  {number} x
   * @param  {number} y
   * @param  {boolean} edgeClamp
   * @return {number}
   */


  getHeightAt(x, y, edgeClamp) {
    const data = this.data;
    const a = getHeightAt_a;
    const b = getHeightAt_b;
    const c = getHeightAt_c;
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
    barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
    const w = getHeightAt_weights;

    if (upper) {
      // Top triangle verts
      return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
    } else {
      // Top triangle verts
      return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
    }
  }

  getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle) {
    return xi + "_" + yi + "_" + (getUpperTriangle ? 1 : 0);
  }

  getCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }

  setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, convex, offset) {
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
      convex,
      offset
    };
  }

  clearCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }
  /**
   * Get a triangle from the heightfield
   * @param  {number} xi
   * @param  {number} yi
   * @param  {boolean} upper
   * @param  {Vec3} a
   * @param  {Vec3} b
   * @param  {Vec3} c
   */


  getTriangle(xi, yi, upper, a, b, c) {
    const data = this.data;
    const elementSize = this.elementSize;

    if (upper) {
      // Top triangle verts
      a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
      b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
      c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
    } else {
      // Top triangle verts
      a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
      b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
      c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
    }
  }
  /**
   * Get a triangle in the terrain in the form of a triangular convex shape.
   * @method getConvexTrianglePillar
   * @param  {integer} i
   * @param  {integer} j
   * @param  {boolean} getUpperTriangle
   */


  getConvexTrianglePillar(xi, yi, getUpperTriangle) {
    let result = this.pillarConvex;
    let offsetResult = this.pillarOffset;

    if (this.cacheEnabled) {
      const data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);

      if (data) {
        this.pillarConvex = data.convex;
        this.pillarOffset = data.offset;
        return;
      }

      result = new ConvexPolyhedron();
      offsetResult = new Vec3();
      this.pillarConvex = result;
      this.pillarOffset = offsetResult;
    }

    const data = this.data;
    const elementSize = this.elementSize;
    const faces = result.faces; // Reuse verts if possible

    result.vertices.length = 6;

    for (let i = 0; i < 6; i++) {
      if (!result.vertices[i]) {
        result.vertices[i] = new Vec3();
      }
    } // Reuse faces if possible


    faces.length = 5;

    for (let i = 0; i < 5; i++) {
      if (!faces[i]) {
        faces[i] = [];
      }
    }

    const verts = result.vertices;
    const h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;

    if (!getUpperTriangle) {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
      (yi + 0.25) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
      verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
      verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts

      verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -h - 1);
      verts[4].set(0.75 * elementSize, -0.25 * elementSize, -h - 1);
      verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -h - 1); // top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // -x facing quad

      faces[2][0] = 0;
      faces[2][1] = 2;
      faces[2][2] = 5;
      faces[2][3] = 3; // -y facing quad

      faces[3][0] = 1;
      faces[3][1] = 0;
      faces[3][2] = 3;
      faces[3][3] = 4; // +xy facing quad

      faces[4][0] = 4;
      faces[4][1] = 5;
      faces[4][2] = 2;
      faces[4][3] = 1;
    } else {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
      (yi + 0.75) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
      verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
      verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts

      verts[3].set(0.25 * elementSize, 0.25 * elementSize, -h - 1);
      verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -h - 1);
      verts[5].set(0.25 * elementSize, -0.75 * elementSize, -h - 1); // Top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // +x facing quad

      faces[2][0] = 2;
      faces[2][1] = 5;
      faces[2][2] = 3;
      faces[2][3] = 0; // +y facing quad

      faces[3][0] = 3;
      faces[3][1] = 4;
      faces[3][2] = 1;
      faces[3][3] = 0; // -xy facing quad

      faces[4][0] = 1;
      faces[4][1] = 4;
      faces[4][2] = 5;
      faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();
    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
  }

  calculateLocalInertia(mass, target = new Vec3()) {
    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return (// The terrain is infinite
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    // TODO: do it properly
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }

  updateBoundingSphereRadius() {
    // Use the bounding box of the min/max values
    const data = this.data;
    const s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).length();
  }
  /**
   * Sets the height values from an image. Currently only supported in browser.
   * @method setHeightsFromImage
   * @param {Image} image
   * @param {Vec3} scale
   */


  setHeightsFromImage(image, scale) {
    const {
      x,
      z,
      y
    } = scale;
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    const imageData = context.getImageData(0, 0, image.width, image.height);
    const matrix = this.data;
    matrix.length = 0;
    this.elementSize = Math.abs(x) / imageData.width;

    for (let i = 0; i < imageData.height; i++) {
      const row = [];

      for (let j = 0; j < imageData.width; j++) {
        const a = imageData.data[(i * imageData.height + j) * 4];
        const b = imageData.data[(i * imageData.height + j) * 4 + 1];
        const c = imageData.data[(i * imageData.height + j) * 4 + 2];
        const height = (a + b + c) / 4 / 255 * z;

        if (x < 0) {
          row.push(height);
        } else {
          row.unshift(height);
        }
      }

      if (y < 0) {
        matrix.unshift(row);
      } else {
        matrix.push(row);
      }
    }

    this.updateMaxValue();
    this.updateMinValue();
    this.update();
  }

}
const getHeightAt_idx = [];
const getHeightAt_weights = new Vec3();
const getHeightAt_a = new Vec3();
const getHeightAt_b = new Vec3();
const getHeightAt_c = new Vec3();
const getNormalAt_a = new Vec3();
const getNormalAt_b = new Vec3();
const getNormalAt_c = new Vec3();
const getNormalAt_e0 = new Vec3();
const getNormalAt_e1 = new Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system

function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
  result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.z = 1 - result.x - result.y;
}

/**
 * @class OctreeNode
 * @constructor
 * @param {object} [options]
 * @param {Octree} [options.root]
 * @param {AABB} [options.aabb]
 */
class OctreeNode {
  // The root node
  // Boundary of this node
  // Contained data at the current node level
  // Children to this node
  constructor(options = {}) {
    this.root = options.root || null;
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();
    this.data = [];
    this.children = [];
  }

  reset() {
    this.children.length = this.data.length = 0;
  }
  /**
   * Insert data into this node
   * @method insert
   * @param  {AABB} aabb
   * @param  {object} elementData
   * @return {boolean} True if successful, otherwise false
   */


  insert(aabb, elementData, level = 0) {
    const nodeData = this.data; // Ignore objects that do not belong in this node

    if (!this.aabb.contains(aabb)) {
      return false; // object cannot be added
    }

    const children = this.children;
    const maxDepth = this.maxDepth || this.root.maxDepth;

    if (level < maxDepth) {
      // Subdivide if there are no children yet
      let subdivided = false;

      if (!children.length) {
        this.subdivide();
        subdivided = true;
      } // add to whichever node will accept it


      for (let i = 0; i !== 8; i++) {
        if (children[i].insert(aabb, elementData, level + 1)) {
          return true;
        }
      }

      if (subdivided) {
        // No children accepted! Might as well just remove em since they contain none
        children.length = 0;
      }
    } // Too deep, or children didnt want it. add it in current node


    nodeData.push(elementData);
    return true;
  }
  /**
   * Create 8 equally sized children nodes and put them in the .children array.
   * @method subdivide
   */


  subdivide() {
    const aabb = this.aabb;
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const children = this.children;
    children.push(new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 0)
      })
    }));
    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);
    const root = this.root || this;

    for (let i = 0; i !== 8; i++) {
      const child = children[i]; // Set current node as root

      child.root = root; // Compute bounds

      const lowerBound = child.aabb.lowerBound;
      lowerBound.x *= halfDiagonal.x;
      lowerBound.y *= halfDiagonal.y;
      lowerBound.z *= halfDiagonal.z;
      lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

      lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
  }
  /**
   * Get all data, potentially within an AABB
   * @method aabbQuery
   * @param  {AABB} aabb
   * @param  {array} result
   * @return {array} The "result" object
   */


  aabbQuery(aabb, result) {
    const nodeData = this.data; // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }
    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);
    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS

    const children = this.children; // for (let i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    const queue = [this];

    while (queue.length) {
      const node = queue.pop();

      if (node.aabb.overlaps(aabb)) {
        Array.prototype.push.apply(result, node.data);
      }

      Array.prototype.push.apply(queue, node.children);
    }

    return result;
  }
  /**
   * Get all data, potentially intersected by a ray.
   * @method rayQuery
   * @param  {Ray} ray
   * @param  {Transform} treeTransform
   * @param  {array} result
   * @return {array} The "result" object
   */


  rayQuery(ray, treeTransform, result) {
    // Use aabb query for now.
    // @todo implement real ray query which needs less lookups
    ray.getAABB(tmpAABB$1);
    tmpAABB$1.toLocalFrame(treeTransform, tmpAABB$1);
    this.aabbQuery(tmpAABB$1, result);
    return result;
  }
  /**
   * @method removeEmptyNodes
   */


  removeEmptyNodes() {
    for (let i = this.children.length - 1; i >= 0; i--) {
      this.children[i].removeEmptyNodes();

      if (!this.children[i].children.length && !this.children[i].data.length) {
        this.children.splice(i, 1);
      }
    }
  }

}
/**
 * @class Octree
 * @param {AABB} aabb The total AABB of the tree
 * @param {object} [options]
 * @param {number} [options.maxDepth=8] Maximum subdivision depth
 * @extends OctreeNode
 */


class Octree extends OctreeNode {
  // Maximum subdivision depth
  constructor(aabb, options = {}) {
    super({
      root: null,
      aabb
    });
    this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;
  }

}
const halfDiagonal = new Vec3();
const tmpAABB$1 = new AABB();

/**
 * @class Trimesh
 * @constructor
 * @param {array} vertices
 * @param {array} indices
 * @extends Shape
 * @example
 *     // How to make a mesh with a single triangle
 *     const vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ];
 *     const indices = [
 *         0, 1, 2  // triangle 0
 *     ];
 *     const trimeshShape = new Trimesh(vertices, indices);
 */
class Trimesh extends Shape {
  // Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
  // The normals data.
  // The local AABB of the mesh.
  // References to vertex pairs, making up all unique edges in the trimesh.
  // Local scaling of the mesh. Use .setScale() to set it.
  // The indexed triangles. Use .updateTree() to update it.
  constructor(vertices, indices) {
    super({
      type: Shape.types.TRIMESH
    });
    this.vertices = new Float32Array(vertices);
    this.indices = new Int16Array(indices);
    this.normals = new Float32Array(indices.length);
    this.aabb = new AABB();
    this.edges = null;
    this.scale = new Vec3(1, 1, 1);
    this.tree = new Octree();
    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
  }
  /**
   * @method updateTree
   */


  updateTree() {
    const tree = this.tree;
    tree.reset();
    tree.aabb.copy(this.aabb);
    const scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

    const triangleAABB = new AABB();
    const a = new Vec3();
    const b = new Vec3();
    const c = new Vec3();
    const points = [a, b, c];

    for (let i = 0; i < this.indices.length / 3; i++) {
      //this.getTriangleVertices(i, a, b, c);
      // Get unscaled triangle verts
      const i3 = i * 3;

      this._getUnscaledVertex(this.indices[i3], a);

      this._getUnscaledVertex(this.indices[i3 + 1], b);

      this._getUnscaledVertex(this.indices[i3 + 2], c);

      triangleAABB.setFromPoints(points);
      tree.insert(triangleAABB, i);
    }

    tree.removeEmptyNodes();
  }
  /**
   * Get triangles in a local AABB from the trimesh.
   * @method getTrianglesInAABB
   * @param  {AABB} aabb
   * @param  {array} result An array of integers, referencing the queried triangles.
   */


  getTrianglesInAABB(aabb, result) {
    unscaledAABB.copy(aabb); // Scale it to local

    const scale = this.scale;
    const isx = scale.x;
    const isy = scale.y;
    const isz = scale.z;
    const l = unscaledAABB.lowerBound;
    const u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;
    return this.tree.aabbQuery(unscaledAABB, result);
  }
  /**
   * @method setScale
   * @param {Vec3} scale
   */


  setScale(scale) {
    const wasUniform = this.scale.x === this.scale.y && this.scale.y === this.scale.z;
    const isUniform = scale.x === scale.y && scale.y === scale.z;

    if (!(wasUniform && isUniform)) {
      // Non-uniform scaling. Need to update normals.
      this.updateNormals();
    }

    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
  }
  /**
   * Compute the normals of the faces. Will save in the .normals array.
   * @method updateNormals
   */


  updateNormals() {
    const n = computeNormals_n; // Generate normals

    const normals = this.normals;

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      this.getVertex(a, va);
      this.getVertex(b, vb);
      this.getVertex(c, vc);
      Trimesh.computeNormal(vb, va, vc, n);
      normals[i3] = n.x;
      normals[i3 + 1] = n.y;
      normals[i3 + 2] = n.z;
    }
  }
  /**
   * Update the .edges property
   * @method updateEdges
   */


  updateEdges() {
    const edges = {};

    const add = (a, b) => {
      const key = a < b ? a + "_" + b : b + "_" + a;
      edges[key] = true;
    };

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      add(a, b);
      add(b, c);
      add(c, a);
    }

    const keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);

    for (let i = 0; i < keys.length; i++) {
      const indices = keys[i].split('_');
      this.edges[2 * i] = parseInt(indices[0], 10);
      this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
  }
  /**
   * Get an edge vertex
   * @method getEdgeVertex
   * @param  {number} edgeIndex
   * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
   * @param  {Vec3} vertexStore Where to store the result
   */


  getEdgeVertex(edgeIndex, firstOrSecond, vertexStore) {
    const vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
  }
  /**
   * Get a vector along an edge.
   * @method getEdgeVector
   * @param  {number} edgeIndex
   * @param  {Vec3} vectorStore
   */


  getEdgeVector(edgeIndex, vectorStore) {
    const va = getEdgeVector_va;
    const vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
  }
  /**
   * Get vertex i.
   * @method getVertex
   * @param  {number} i
   * @param  {Vec3} out
   * @return {Vec3} The "out" vector object
   */


  getVertex(i, out) {
    const scale = this.scale;

    this._getUnscaledVertex(i, out);

    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
  }
  /**
   * Get raw vertex i
   * @private
   * @method _getUnscaledVertex
   * @param  {number} i
   * @param  {Vec3} out
   * @return {Vec3} The "out" vector object
   */


  _getUnscaledVertex(i, out) {
    const i3 = i * 3;
    const vertices = this.vertices;
    return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
  }
  /**
   * Get a vertex from the trimesh,transformed by the given position and quaternion.
   * @method getWorldVertex
   * @param  {number} i
   * @param  {Vec3} pos
   * @param  {Quaternion} quat
   * @param  {Vec3} out
   * @return {Vec3} The "out" vector object
   */


  getWorldVertex(i, pos, quat, out) {
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
  }
  /**
   * Get the three vertices for triangle i.
   * @method getTriangleVertices
   * @param  {number} i
   * @param  {Vec3} a
   * @param  {Vec3} b
   * @param  {Vec3} c
   */


  getTriangleVertices(i, a, b, c) {
    const i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
  }
  /**
   * Compute the normal of triangle i.
   * @method getNormal
   * @param  {Number} i
   * @param  {Vec3} target
   * @return {Vec3} The "target" vector object
   */


  getNormal(i, target) {
    const i3 = i * 3;
    return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
  }
  /**
   * @method calculateLocalInertia
   * @param  {Number} mass
   * @param  {Vec3} target
   * @return {Vec3} The "target" vector object
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    const x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x;
    const y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y;
    const z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
  }
  /**
   * Compute the local AABB for the trimesh
   * @method computeLocalAABB
   * @param  {AABB} aabb
   */


  computeLocalAABB(aabb) {
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const n = this.vertices.length;
    const vertices = this.vertices;
    const v = computeLocalAABB_worldVert;
    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for (let i = 0; i !== n; i++) {
      this.getVertex(i, v);

      if (v.x < l.x) {
        l.x = v.x;
      } else if (v.x > u.x) {
        u.x = v.x;
      }

      if (v.y < l.y) {
        l.y = v.y;
      } else if (v.y > u.y) {
        u.y = v.y;
      }

      if (v.z < l.z) {
        l.z = v.z;
      } else if (v.z > u.z) {
        u.z = v.z;
      }
    }
  }
  /**
   * Update the .aabb property
   * @method updateAABB
   */


  updateAABB() {
    this.computeLocalAABB(this.aabb);
  }
  /**
   * Will update the .boundingSphereRadius property
   * @method updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const vertices = this.vertices;
    const v = new Vec3();

    for (let i = 0, N = vertices.length / 3; i !== N; i++) {
      this.getVertex(i, v);
      const norm2 = v.lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * @method calculateWorldAABB
   * @param {Vec3}        pos
   * @param {Quaternion}  quat
   * @param {Vec3}        min
   * @param {Vec3}        max
   */


  calculateWorldAABB(pos, quat, min, max) {
    /*
        const n = this.vertices.length / 3,
            verts = this.vertices;
        const minx,miny,minz,maxx,maxy,maxz;
         const v = tempWorldVertex;
        for(let i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
             if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
             if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
    // Faster approximation using local AABB
    const frame = calculateWorldAABB_frame;
    const result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
  }
  /**
   * Get approximate volume
   * @method volume
   * @return {Number}
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }

}
const computeNormals_n = new Vec3();
const unscaledAABB = new AABB();
const getEdgeVector_va = new Vec3();
const getEdgeVector_vb = new Vec3();
/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */

const cb = new Vec3();
const ab = new Vec3();

Trimesh.computeNormal = (va, vb, vc, target) => {
  vb.vsub(va, ab);
  vc.vsub(vb, cb);
  cb.cross(ab, target);

  if (!target.isZero()) {
    target.normalize();
  }
};

const va = new Vec3();
const vb = new Vec3();
const vc = new Vec3();
const cli_aabb = new AABB();
const computeLocalAABB_worldVert = new Vec3();
const calculateWorldAABB_frame = new Transform();
const calculateWorldAABB_aabb = new AABB();
/**
 * Create a Trimesh instance, shaped as a torus.
 * @static
 * @method createTorus
 * @param  {number} [radius=1]
 * @param  {number} [tube=0.5]
 * @param  {number} [radialSegments=8]
 * @param  {number} [tubularSegments=6]
 * @param  {number} [arc=6.283185307179586]
 * @return {Trimesh} A torus
 */

Trimesh.createTorus = (radius = 1, tube = 0.5, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) => {
  const vertices = [];
  const indices = [];

  for (let j = 0; j <= radialSegments; j++) {
    for (let i = 0; i <= tubularSegments; i++) {
      const u = i / tubularSegments * arc;
      const v = j / radialSegments * Math.PI * 2;
      const x = (radius + tube * Math.cos(v)) * Math.cos(u);
      const y = (radius + tube * Math.cos(v)) * Math.sin(u);
      const z = tube * Math.sin(v);
      vertices.push(x, y, z);
    }
  }

  for (let j = 1; j <= radialSegments; j++) {
    for (let i = 1; i <= tubularSegments; i++) {
      const a = (tubularSegments + 1) * j + i - 1;
      const b = (tubularSegments + 1) * (j - 1) + i - 1;
      const c = (tubularSegments + 1) * (j - 1) + i;
      const d = (tubularSegments + 1) * j + i;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }

  return new Trimesh(vertices, indices);
};

/**
 * Constraint equation solver base class.
 * @class Solver
 * @constructor
 * @author schteppe / https://github.com/schteppe
 */
class Solver {
  // All equations to be solved
  constructor() {
    this.equations = [];
  }
  /**
   * Should be implemented in subclasses!
   * @method solve
   * @param  {Number} dt
   * @param  {World} world
   * @return {Number} number of iterations performed
   */


  solve(dt, world) {
    return (// Should return the number of iterations done!
      0
    );
  }
  /**
   * Add an equation
   * @method addEquation
   * @param {Equation} eq
   */


  addEquation(eq) {
    if (eq.enabled) {
      this.equations.push(eq);
    }
  }
  /**
   * Remove an equation
   * @method removeEquation
   * @param {Equation} eq
   */


  removeEquation(eq) {
    const eqs = this.equations;
    const i = eqs.indexOf(eq);

    if (i !== -1) {
      eqs.splice(i, 1);
    }
  }
  /**
   * Add all equations
   * @method removeAllEquations
   */


  removeAllEquations() {
    this.equations.length = 0;
  }

}

/**
 * Constraint equation Gauss-Seidel solver.
 * @class GSSolver
 * @constructor
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @author schteppe / https://github.com/schteppe
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 * @extends Solver
 */
class GSSolver extends Solver {
  // The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
  // When tolerance is reached, the system is assumed to be converged.
  constructor() {
    super();
    this.iterations = 10;
    this.tolerance = 1e-7;
  }
  /**
   * Solve
   * @method solve
   * @param  {Number} dt
   * @param  {World} world
   * @return {Number} number of iterations performed
   */


  solve(dt, world) {
    let iter = 0;
    const maxIter = this.iterations;
    const tolSquared = this.tolerance * this.tolerance;
    const equations = this.equations;
    const Neq = equations.length;
    const bodies = world.bodies;
    const Nbodies = bodies.length;
    const h = dt;
    let B;
    let invC;
    let deltalambda;
    let deltalambdaTot;
    let GWlambda;
    let lambdaj; // Update solve mass

    if (Neq !== 0) {
      for (let i = 0; i !== Nbodies; i++) {
        bodies[i].updateSolveMassProperties();
      }
    } // Things that does not change during iteration can be computed once


    const invCs = GSSolver_solve_invCs;
    const Bs = GSSolver_solve_Bs;
    const lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;

    for (let i = 0; i !== Neq; i++) {
      const c = equations[i];
      lambda[i] = 0.0;
      Bs[i] = c.computeB(h);
      invCs[i] = 1.0 / c.computeC();
    }

    if (Neq !== 0) {
      // Reset vlambda
      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const vlambda = b.vlambda;
        const wlambda = b.wlambda;
        vlambda.set(0, 0, 0);
        wlambda.set(0, 0, 0);
      } // Iterate over equations


      for (iter = 0; iter !== maxIter; iter++) {
        // Accumulate the total error for each iteration.
        deltalambdaTot = 0.0;

        for (let j = 0; j !== Neq; j++) {
          const c = equations[j]; // Compute iteration

          B = Bs[j];
          invC = invCs[j];
          lambdaj = lambda[j];
          GWlambda = c.computeGWlambda();
          deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

          if (lambdaj + deltalambda < c.minForce) {
            deltalambda = c.minForce - lambdaj;
          } else if (lambdaj + deltalambda > c.maxForce) {
            deltalambda = c.maxForce - lambdaj;
          }

          lambda[j] += deltalambda;
          deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

          c.addToWlambda(deltalambda);
        } // If the total error is small enough - stop iterate


        if (deltalambdaTot * deltalambdaTot < tolSquared) {
          break;
        }
      } // Add result to velocity


      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const v = b.velocity;
        const w = b.angularVelocity;
        b.vlambda.vmul(b.linearFactor, b.vlambda);
        v.vadd(b.vlambda, v);
        b.wlambda.vmul(b.angularFactor, b.wlambda);
        w.vadd(b.wlambda, w);
      } // Set the .multiplier property of each equation


      let l = equations.length;
      const invDt = 1 / h;

      while (l--) {
        equations[l].multiplier = lambda[l] * invDt;
      }
    }

    return iter;
  }

}
const GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.

const GSSolver_solve_invCs = [];
const GSSolver_solve_Bs = [];

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 * @class SplitSolver
 * @constructor
 * @extends Solver
 * @param {Solver} subsolver
 */
class SplitSolver extends Solver {
  // The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
  // When tolerance is reached, the system is assumed to be converged.
  constructor(subsolver) {
    super();
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = []; // Create needed nodes, reuse if possible

    while (this.nodePool.length < 128) {
      this.nodePool.push(this.createNode());
    }
  }

  createNode() {
    return {
      body: null,
      children: [],
      eqs: [],
      visited: false
    };
  }
  /**
   * Solve the subsystems
   * @method solve
   * @param  {Number} dt
   * @param  {World} world
   * @return {Number} number of iterations performed
   */


  solve(dt, world) {
    const nodes = SplitSolver_solve_nodes;
    const nodePool = this.nodePool;
    const bodies = world.bodies;
    const equations = this.equations;
    const Neq = equations.length;
    const Nbodies = bodies.length;
    const subsolver = this.subsolver; // Create needed nodes, reuse if possible

    while (nodePool.length < Nbodies) {
      nodePool.push(this.createNode());
    }

    nodes.length = Nbodies;

    for (let i = 0; i < Nbodies; i++) {
      nodes[i] = nodePool[i];
    } // Reset node values


    for (let i = 0; i !== Nbodies; i++) {
      const node = nodes[i];
      node.body = bodies[i];
      node.children.length = 0;
      node.eqs.length = 0;
      node.visited = false;
    }

    for (let k = 0; k !== Neq; k++) {
      const eq = equations[k];
      const i = bodies.indexOf(eq.bi);
      const j = bodies.indexOf(eq.bj);
      const ni = nodes[i];
      const nj = nodes[j];
      ni.children.push(nj);
      ni.eqs.push(eq);
      nj.children.push(ni);
      nj.eqs.push(eq);
    }

    let child;
    let n = 0;
    let eqs = SplitSolver_solve_eqs;
    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;
    const dummyWorld = SplitSolver_solve_dummyWorld;

    while (child = getUnvisitedNode(nodes)) {
      eqs.length = 0;
      dummyWorld.bodies.length = 0;
      bfs(child, visitFunc, dummyWorld.bodies, eqs);
      const Neqs = eqs.length;
      eqs = eqs.sort(sortById);

      for (let i = 0; i !== Neqs; i++) {
        subsolver.addEquation(eqs[i]);
      }

      const iter = subsolver.solve(dt, dummyWorld);
      subsolver.removeAllEquations();
      n++;
    }

    return n;
  }

} // Returns the number of subsystems

const SplitSolver_solve_nodes = []; // All allocated node objects

const SplitSolver_solve_eqs = []; // Temp array

const SplitSolver_solve_dummyWorld = {
  bodies: []
}; // Temp object

const STATIC = Body.STATIC;

function getUnvisitedNode(nodes) {
  const Nnodes = nodes.length;

  for (let i = 0; i !== Nnodes; i++) {
    const node = nodes[i];

    if (!node.visited && !(node.body.type & STATIC)) {
      return node;
    }
  }

  return false;
}

const queue = [];

function bfs(root, visitFunc, bds, eqs) {
  queue.push(root);
  root.visited = true;
  visitFunc(root, bds, eqs);

  while (queue.length) {
    const node = queue.pop(); // Loop over unvisited child nodes

    let child;

    while (child = getUnvisitedNode(node.children)) {
      child.visited = true;
      visitFunc(child, bds, eqs);
      queue.push(child);
    }
  }
}

function visitFunc(node, bds, eqs) {
  bds.push(node.body);
  const Neqs = node.eqs.length;

  for (let i = 0; i !== Neqs; i++) {
    const eq = node.eqs[i];

    if (!eqs.includes(eq)) {
      eqs.push(eq);
    }
  }
}

function sortById(a, b) {
  return b.id - a.id;
}

/**
 * For pooling objects that can be reused.
 * @class Pool
 * @constructor
 */
class Pool {
  constructor() {
    this.objects = [];
    this.type = Object;
  }
  /**
   * Release an object after use
   * @method release
   * @param {Object} obj
   */


  release(...args) {
    const Nargs = args.length;

    for (let i = 0; i !== Nargs; i++) {
      this.objects.push(args[i]);
    }

    return this;
  }
  /**
   * Get an object
   * @method get
   * @return {mixed}
   */


  get() {
    if (this.objects.length === 0) {
      return this.constructObject();
    } else {
      return this.objects.pop();
    }
  }
  /**
   * Construct an object. Should be implemented in each subclass.
   * @method constructObject
   * @return {mixed}
   */


  constructObject() {
    throw new Error('constructObject() not implemented in this Pool subclass yet!');
  }
  /**
   * @method resize
   * @param {number} size
   * @return {Pool} Self, for chaining
   */


  resize(size) {
    const objects = this.objects;

    while (objects.length > size) {
      objects.pop();
    }

    while (objects.length < size) {
      objects.push(this.constructObject());
    }

    return this;
  }

}

/**
 * @class Vec3Pool
 * @constructor
 * @extends Pool
 */

class Vec3Pool extends Pool {
  constructor() {
    super();
    this.type = Vec3;
  }
  /**
   * Construct a vector
   * @method constructObject
   * @return {Vec3}
   */


  constructObject() {
    return new Vec3();
  }

}

const COLLISION_TYPES = {
  sphereSphere: Shape.types.SPHERE,
  spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
  boxBox: Shape.types.BOX | Shape.types.BOX,
  sphereBox: Shape.types.SPHERE | Shape.types.BOX,
  planeBox: Shape.types.PLANE | Shape.types.BOX,
  convexConvex: Shape.types.CONVEXPOLYHEDRON,
  sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
  planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
  boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
  sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
  boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
  convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
  sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
  planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
  boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
  convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
  sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
  planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
};

/**
 * Helper class for the World. Generates ContactEquations.
 * @class Narrowphase
 * @constructor
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo should move methods to prototype
 */
class Narrowphase {
  // Internal storage of pooled contact points.
  // Pooled vectors.
  constructor(world) {
    this.contactPointPool = [];
    this.frictionEquationPool = [];
    this.result = [];
    this.frictionResult = [];
    this.v3pool = new Vec3Pool();
    this.world = world;
    this.currentContactMaterial = world.defaultContactMaterial;
    this.enableFrictionReduction = false;
  }
  /**
   * Make a contact object, by using the internal pool or creating a new one.
   * @method createContactEquation
   * @param {Body} bi
   * @param {Body} bj
   * @param {Shape} si
   * @param {Shape} sj
   * @param {Shape} overrideShapeA
   * @param {Shape} overrideShapeB
   * @return {ContactEquation}
   */


  createContactEquation(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
    let c;

    if (this.contactPointPool.length) {
      c = this.contactPointPool.pop();
      c.bi = bi;
      c.bj = bj;
    } else {
      c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    const cm = this.currentContactMaterial;
    c.restitution = cm.restitution;
    c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
    const matA = si.material || bi.material;
    const matB = sj.material || bj.material;

    if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
      c.restitution = matA.restitution * matB.restitution;
    }

    c.si = overrideShapeA || si;
    c.sj = overrideShapeB || sj;
    return c;
  }

  createFrictionEquationsFromContact(contactEquation, outArray) {
    const bodyA = contactEquation.bi;
    const bodyB = contactEquation.bj;
    const shapeA = contactEquation.si;
    const shapeB = contactEquation.sj;
    const world = this.world;
    const cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

    let friction = cm.friction;
    const matA = shapeA.material || bodyA.material;
    const matB = shapeB.material || bodyB.material;

    if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
      friction = matA.friction * matB.friction;
    }

    if (friction > 0) {
      // Create 2 tangent equations
      const mug = friction * world.gravity.length();
      let reducedMass = bodyA.invMass + bodyB.invMass;

      if (reducedMass > 0) {
        reducedMass = 1 / reducedMass;
      }

      const pool = this.frictionEquationPool;
      const c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      const c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      c1.bi = c2.bi = bodyA;
      c1.bj = c2.bj = bodyB;
      c1.minForce = c2.minForce = -mug * reducedMass;
      c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

      c1.ri.copy(contactEquation.ri);
      c1.rj.copy(contactEquation.rj);
      c2.ri.copy(contactEquation.ri);
      c2.rj.copy(contactEquation.rj); // Construct tangents

      contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

      c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c1.enabled = c2.enabled = contactEquation.enabled;
      outArray.push(c1, c2);
      return true;
    }

    return false;
  } // Take the average N latest contact point on the plane.


  createFrictionFromAverage(numContacts) {
    // The last contactEquation
    let c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
      return;
    }

    const f1 = this.frictionResult[this.frictionResult.length - 2];
    const f2 = this.frictionResult[this.frictionResult.length - 1];
    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();
    const bodyA = c.bi;
    const bodyB = c.bj;

    for (let i = 0; i !== numContacts; i++) {
      c = this.result[this.result.length - 1 - i];

      if (c.bi !== bodyA) {
        averageNormal.vadd(c.ni, averageNormal);
        averageContactPointA.vadd(c.ri, averageContactPointA);
        averageContactPointB.vadd(c.rj, averageContactPointB);
      } else {
        averageNormal.vsub(c.ni, averageNormal);
        averageContactPointA.vadd(c.rj, averageContactPointA);
        averageContactPointB.vadd(c.ri, averageContactPointB);
      }
    }

    const invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri);
    averageContactPointB.scale(invNumContacts, f1.rj);
    f2.ri.copy(f1.ri); // Should be the same

    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t); // return eq;
  }
  /**
   * Generate all contacts between a list of body pairs
   * @method getContacts
   * @param {array} p1 Array of body indices
   * @param {array} p2 Array of body indices
   * @param {World} world
   * @param {array} result Array to store generated contacts
   * @param {array} oldcontacts Optional. Array of reusable contact objects
   */


  getContacts(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;
    const qi = tmpQuat1;
    const qj = tmpQuat2;
    const xi = tmpVec1$2;
    const xj = tmpVec2$2;

    for (let k = 0, N = p1.length; k !== N; k++) {
      // Get current collision bodies
      const bi = p1[k];
      const bj = p2[k]; // Get contact material

      let bodyContactMaterial = null;

      if (bi.material && bj.material) {
        bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
      }

      const justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

      for (let i = 0; i < bi.shapes.length; i++) {
        bi.quaternion.mult(bi.shapeOrientations[i], qi);
        bi.quaternion.vmult(bi.shapeOffsets[i], xi);
        xi.vadd(bi.position, xi);
        const si = bi.shapes[i];

        for (let j = 0; j < bj.shapes.length; j++) {
          // Compute world transform of shapes
          bj.quaternion.mult(bj.shapeOrientations[j], qj);
          bj.quaternion.vmult(bj.shapeOffsets[j], xj);
          xj.vadd(bj.position, xj);
          const sj = bj.shapes[j];

          if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
            continue;
          }

          if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
            continue;
          } // Get collision material


          let shapeContactMaterial = null;

          if (si.material && sj.material) {
            shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
          }

          this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

          const resolverIndex = si.type | sj.type;
          const resolver = this[resolverIndex];

          if (resolver) {
            let retval = false; // TO DO: investigate why sphereParticle and convexParticle
            // resolvers expect si and sj shapes to be in reverse order
            // (i.e. larger integer value type first instead of smaller first)

            if (si.type < sj.type) {
              retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
            } else {
              retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
            }

            if (retval && justTest) {
              // Register overlap
              world.shapeOverlapKeeper.set(si.id, sj.id);
              world.bodyOverlapKeeper.set(bi.id, bj.id);
            }
          }
        }
      }
    }
  }

  sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    if (justTest) {
      return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
    } // We will have only one contact in this case


    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    xj.vsub(xi, r.ni);
    r.ni.normalize(); // Contact point locations

    r.ri.copy(r.ni);
    r.rj.copy(r.ni);
    r.ri.scale(si.radius, r.ri);
    r.rj.scale(-sj.radius, r.rj);
    r.ri.vadd(xi, r.ri);
    r.ri.vsub(bi.position, r.ri);
    r.rj.vadd(xj, r.rj);
    r.rj.vsub(bj.position, r.rj);
    this.result.push(r);
    this.createFrictionEquationsFromContact(r, this.frictionResult);
  }

  spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    // We will have one contact in this case
    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    r.ni.set(0, 0, 1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal

    r.ni.normalize(); // Needed?
    // Vector from sphere center to contact point

    r.ni.scale(si.radius, r.ri); // Project down sphere on plane

    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.scale(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
      if (justTest) {
        return true;
      } // Make it relative to the body


      const ri = r.ri;
      const rj = r.rj;
      ri.vadd(xi, ri);
      ri.vsub(bi.position, ri);
      rj.vadd(xj, rj);
      rj.vsub(bj.position, rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool; // we refer to the box as body j

    const sides = sphereBox_sides;
    xi.vsub(xj, box_to_sphere);
    sj.getSideNormals(sides, qj);
    const R = si.radius;

    let found = false; // Store the resulting side penetration info

    const side_ns = sphereBox_side_ns;
    const side_ns1 = sphereBox_side_ns1;
    const side_ns2 = sphereBox_side_ns2;
    let side_h = null;
    let side_penetrations = 0;
    let side_dot1 = 0;
    let side_dot2 = 0;
    let side_distance = null;

    for (let idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
      // Get the plane side normal (ns)
      const ns = sphereBox_ns;
      ns.copy(sides[idx]);
      const h = ns.length();
      ns.normalize(); // The normal/distance dot product tells which side of the plane we are

      const dot = box_to_sphere.dot(ns);

      if (dot < h + R && dot > 0) {
        // Intersects plane. Now check the other two dimensions
        const ns1 = sphereBox_ns1;
        const ns2 = sphereBox_ns2;
        ns1.copy(sides[(idx + 1) % 3]);
        ns2.copy(sides[(idx + 2) % 3]);
        const h1 = ns1.length();
        const h2 = ns2.length();
        ns1.normalize();
        ns2.normalize();
        const dot1 = box_to_sphere.dot(ns1);
        const dot2 = box_to_sphere.dot(ns2);

        if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
          const dist = Math.abs(dot - h - R);

          if (side_distance === null || dist < side_distance) {
            side_distance = dist;
            side_dot1 = dot1;
            side_dot2 = dot2;
            side_h = h;
            side_ns.copy(ns);
            side_ns1.copy(ns1);
            side_ns2.copy(ns2);
            side_penetrations++;

            if (justTest) {
              return true;
            }
          }
        }
      }
    }

    if (side_penetrations) {
      found = true;
      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      side_ns.scale(-R, r.ri); // Sphere r

      r.ni.copy(side_ns);
      r.ni.negate(r.ni); // Normal should be out of sphere

      side_ns.scale(side_h, side_ns);
      side_ns1.scale(side_dot1, side_ns1);
      side_ns.vadd(side_ns1, side_ns);
      side_ns2.scale(side_dot2, side_ns2);
      side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

      r.ri.vadd(xi, r.ri);
      r.ri.vsub(bi.position, r.ri);
      r.rj.vadd(xj, r.rj);
      r.rj.vsub(bj.position, r.rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    } // Check corners


    let rj = v3pool.get();
    const sphere_to_corner = sphereBox_sphere_to_corner;

    for (let j = 0; j !== 2 && !found; j++) {
      for (let k = 0; k !== 2 && !found; k++) {
        for (let l = 0; l !== 2 && !found; l++) {
          rj.set(0, 0, 0);

          if (j) {
            rj.vadd(sides[0], rj);
          } else {
            rj.vsub(sides[0], rj);
          }

          if (k) {
            rj.vadd(sides[1], rj);
          } else {
            rj.vsub(sides[1], rj);
          }

          if (l) {
            rj.vadd(sides[2], rj);
          } else {
            rj.vsub(sides[2], rj);
          } // World position of corner


          xj.vadd(rj, sphere_to_corner);
          sphere_to_corner.vsub(xi, sphere_to_corner);

          if (sphere_to_corner.lengthSquared() < R * R) {
            if (justTest) {
              return true;
            }

            found = true;
            const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.scale(R, r.ri);
            r.rj.copy(rj); // Make relative to bodies

            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(rj);
    rj = null; // Check edges

    const edgeTangent = v3pool.get();
    const edgeCenter = v3pool.get();
    const r = v3pool.get(); // r = edge center to sphere center

    const orthogonal = v3pool.get();
    const dist = v3pool.get();
    const Nsides = sides.length;

    for (let j = 0; j !== Nsides && !found; j++) {
      for (let k = 0; k !== Nsides && !found; k++) {
        if (j % 3 !== k % 3) {
          // Get edge tangent
          sides[k].cross(sides[j], edgeTangent);
          edgeTangent.normalize();
          sides[j].vadd(sides[k], edgeCenter);
          r.copy(xi);
          r.vsub(edgeCenter, r);
          r.vsub(xj, r);
          const orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

          edgeTangent.scale(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
          // Find the third side orthogonal to this one

          let l = 0;

          while (l === j % 3 || l === k % 3) {
            l++;
          } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


          dist.copy(xi);
          dist.vsub(orthogonal, dist);
          dist.vsub(edgeCenter, dist);
          dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

          const tdist = Math.abs(orthonorm);
          const ndist = dist.length();

          if (tdist < sides[l].length() && ndist < R) {
            if (justTest) {
              return true;
            }

            found = true;
            const res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            edgeCenter.vadd(orthogonal, res.rj); // box rj

            res.rj.copy(res.rj);
            dist.negate(res.ni);
            res.ni.normalize();
            res.ri.copy(res.rj);
            res.ri.vadd(xj, res.ri);
            res.ri.vsub(xi, res.ri);
            res.ri.normalize();
            res.ri.scale(R, res.ri); // Make relative to bodies

            res.ri.vadd(xi, res.ri);
            res.ri.vsub(bi.position, res.ri);
            res.rj.vadd(xj, res.rj);
            res.rj.vsub(bj.position, res.rj);
            this.result.push(res);
            this.createFrictionEquationsFromContact(res, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
  }

  planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
    const sepAxis = convexConvex_sepAxis;

    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
      return;
    }

    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
      const res = [];
      const q = convexConvex_q;
      si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
      let numContacts = 0;

      for (let j = 0; j !== res.length; j++) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        const ri = r.ri;
        const rj = r.rj;
        sepAxis.negate(r.ni);
        res[j].normal.negate(q);
        q.scale(res[j].depth, q);
        res[j].point.vadd(q, ri);
        rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

        ri.vsub(xi, ri);
        rj.vsub(xj, rj); // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }

      if (this.enableFrictionReduction && numContacts) {
        this.createFrictionFromAverage(numContacts);
      }
    }
  }

  sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool;
    xi.vsub(xj, convex_to_sphere);
    const normals = sj.faceNormals;
    const faces = sj.faces;
    const verts = sj.vertices;
    const R = si.radius;
    //     return;
    // }

    let found = false; // Check corners

    for (let i = 0; i !== verts.length; i++) {
      const v = verts[i]; // World position of corner

      const worldCorner = sphereConvex_worldCorner;
      qj.vmult(v, worldCorner);
      xj.vadd(worldCorner, worldCorner);
      const sphere_to_corner = sphereConvex_sphereToCorner;
      worldCorner.vsub(xi, sphere_to_corner);

      if (sphere_to_corner.lengthSquared() < R * R) {
        if (justTest) {
          return true;
        }

        found = true;
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        r.ri.copy(sphere_to_corner);
        r.ri.normalize();
        r.ni.copy(r.ri);
        r.ri.scale(R, r.ri);
        worldCorner.vsub(xj, r.rj); // Should be relative to the body.

        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
        return;
      }
    } // Check side (plane) intersections


    for (let i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
      const normal = normals[i];
      const face = faces[i]; // Get world-transformed normal of the face

      const worldNormal = sphereConvex_worldNormal;
      qj.vmult(normal, worldNormal); // Get a world vertex from the face

      const worldPoint = sphereConvex_worldPoint;
      qj.vmult(verts[face[0]], worldPoint);
      worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

      const worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
      worldNormal.scale(-R, worldSpherePointClosestToPlane);
      xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

      const penetrationVec = sphereConvex_penetrationVec;
      worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

      const penetration = penetrationVec.dot(worldNormal);
      const worldPointToSphere = sphereConvex_sphereToWorldPoint;
      xi.vsub(worldPoint, worldPointToSphere);

      if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
        // Intersects plane. Now check if the sphere is inside the face polygon
        const faceVerts = []; // Face vertices, in world coords

        for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
          const worldVertex = v3pool.get();
          qj.vmult(verts[face[j]], worldVertex);
          xj.vadd(worldVertex, worldVertex);
          faceVerts.push(worldVertex);
        }

        if (pointInPolygon(faceVerts, worldNormal, xi)) {
          // Is the sphere center in the face polygon?
          if (justTest) {
            return true;
          }

          found = true;
          const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          worldNormal.scale(-R, r.ri); // Contact offset, from sphere center to contact

          worldNormal.negate(r.ni); // Normal pointing out of sphere

          const penetrationVec2 = v3pool.get();
          worldNormal.scale(-penetration, penetrationVec2);
          const penetrationSpherePoint = v3pool.get();
          worldNormal.scale(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

          xi.vsub(xj, r.rj);
          r.rj.vadd(penetrationSpherePoint, r.rj);
          r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          v3pool.release(penetrationVec2);
          v3pool.release(penetrationSpherePoint);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

          for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
            v3pool.release(faceVerts[j]);
          }

          return; // We only expect *one* face contact
        } else {
          // Edge?
          for (let j = 0; j !== face.length; j++) {
            // Get two world transformed vertices
            const v1 = v3pool.get();
            const v2 = v3pool.get();
            qj.vmult(verts[face[(j + 1) % face.length]], v1);
            qj.vmult(verts[face[(j + 2) % face.length]], v2);
            xj.vadd(v1, v1);
            xj.vadd(v2, v2); // Construct edge vector

            const edge = sphereConvex_edge;
            v2.vsub(v1, edge); // Construct the same vector, but normalized

            const edgeUnit = sphereConvex_edgeUnit;
            edge.unit(edgeUnit); // p is xi projected onto the edge

            const p = v3pool.get();
            const v1_to_xi = v3pool.get();
            xi.vsub(v1, v1_to_xi);
            const dot = v1_to_xi.dot(edgeUnit);
            edgeUnit.scale(dot, p);
            p.vadd(v1, p); // Compute a vector from p to the center of the sphere

            const xi_to_p = v3pool.get();
            p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
            // AND if p is in between v1 and v2

            if (dot > 0 && dot * dot < edge.lengthSquared() && xi_to_p.lengthSquared() < R * R) {
              // Collision if the edge-sphere distance is less than the radius
              // Edge contact!
              if (justTest) {
                return true;
              }

              const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              p.vsub(xj, r.rj);
              p.vsub(xi, r.ni);
              r.ni.normalize();
              r.ni.scale(R, r.ri); // Should be relative to the body.

              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

              for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                v3pool.release(faceVerts[j]);
              }

              v3pool.release(v1);
              v3pool.release(v2);
              v3pool.release(p);
              v3pool.release(xi_to_p);
              v3pool.release(v1_to_xi);
              return;
            }

            v3pool.release(v1);
            v3pool.release(v2);
            v3pool.release(p);
            v3pool.release(xi_to_p);
            v3pool.release(v1_to_xi);
          }
        } // Release world vertices


        for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
          v3pool.release(faceVerts[j]);
        }
      }
    }
  }

  planeConvex(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
    // Simply return the points behind the plane.
    const worldVertex = planeConvex_v;
    const worldNormal = planeConvex_normal;
    worldNormal.set(0, 0, 1);
    planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

    let numContacts = 0;
    const relpos = planeConvex_relpos;

    for (let i = 0; i !== convexShape.vertices.length; i++) {
      // Get world convex vertex
      worldVertex.copy(convexShape.vertices[i]);
      convexQuat.vmult(worldVertex, worldVertex);
      convexPosition.vadd(worldVertex, worldVertex);
      worldVertex.vsub(planePosition, relpos);
      const dot = worldNormal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

        const projected = planeConvex_projected;
        worldNormal.scale(worldNormal.dot(relpos), projected);
        worldVertex.vsub(projected, projected);
        projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

        r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
        // rj is now just the vector from the convex center to the vertex

        worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

        r.ri.vadd(planePosition, r.ri);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.vadd(convexPosition, r.rj);
        r.rj.vsub(convexBody.position, r.rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    }

    if (this.enableFrictionReduction && numContacts) {
      this.createFrictionFromAverage(numContacts);
    }
  }

  boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereHeightfield(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const radius = sphereShape.radius;
    const w = hfShape.elementSize;
    const worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

    const localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

    let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
    let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we can't touch the bounding height box

    if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
      return;
    }

    const result = this.result;

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        const numContactsBefore = result.length;
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        }

        const numContacts = result.length - numContactsBefore;

        if (numContacts > 2) {
          return;
        }
        /*
          // Skip all but 1
          for (let k = 0; k < numContacts - 1; k++) {
              result.pop();
          }
        */

      }
    }
  }

  boxHeightfield(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const w = hfShape.elementSize;
    const radius = convexShape.boundingSphereRadius;
    const worldPillarOffset = convexHeightfield_tmp2;
    const faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

    const localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

    let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
    let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we're cant touch the bounding height box

    if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
      return;
    }

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        }
      }
    }
  }

  sphereParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    // The normal is the unit vector from sphere center to particle center
    const normal = particleSphere_normal;
    normal.set(0, 0, 1);
    xi.vsub(xj, normal);
    const lengthSquared = normal.lengthSquared();

    if (lengthSquared <= sj.radius * sj.radius) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      normal.normalize();
      r.rj.copy(normal);
      r.rj.scale(sj.radius, r.rj);
      r.ni.copy(normal); // Contact normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle

      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  planeParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    const normal = particlePlane_normal;
    normal.set(0, 0, 1);
    bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

    const relpos = particlePlane_relpos;
    xi.vsub(bj.position, relpos);
    const dot = normal.dot(relpos);

    if (dot <= 0.0) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      r.ni.copy(normal); // Contact normal is the plane normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle
      // Get particle position projected on plane

      const projected = particlePlane_projected;
      normal.scale(normal.dot(xi), projected);
      xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
      // rj is now the projected world position minus plane position

      r.rj.copy(projected);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    let penetratedFaceIndex = -1;
    const penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    const worldPenetrationVec = convexParticle_worldPenetrationVec;
    let minPenetration = null;

    const local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj, local); // Convert position to relative the convex origin

    qj.conjugate(cqj);
    cqj.vmult(local, local);

    if (sj.pointIsInside(local)) {
      if (sj.worldVerticesNeedsUpdate) {
        sj.computeWorldVertices(xj, qj);
      }

      if (sj.worldFaceNormalsNeedsUpdate) {
        sj.computeWorldFaceNormals(qj);
      } // For each world polygon in the polyhedra


      for (let i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
        // Construct world face vertices
        const verts = [sj.worldVertices[sj.faces[i][0]]];
        const normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

        xi.vsub(verts[0], convexParticle_vertexToParticle);
        const penetration = -normal.dot(convexParticle_vertexToParticle);

        if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
          if (justTest) {
            return true;
          }

          minPenetration = penetration;
          penetratedFaceIndex = i;
          penetratedFaceNormal.copy(normal);
        }
      }

      if (penetratedFaceIndex !== -1) {
        // Setup contact
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        penetratedFaceNormal.scale(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

        worldPenetrationVec.vadd(xi, worldPenetrationVec);
        worldPenetrationVec.vsub(xj, worldPenetrationVec);
        r.rj.copy(worldPenetrationVec); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
        //projectedToFace.copy(r.rj);
        //qj.vmult(r.rj,r.rj);

        penetratedFaceNormal.negate(r.ni); // Contact normal

        r.ri.set(0, 0, 0); // Center of particle

        const ri = r.ri;
        const rj = r.rj; // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      } else {
        console.warn('Point found inside convex, but did not find penetrating face!');
      }
    }
  }

  sphereTrimesh(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
    const edgeVertexA = sphereTrimesh_edgeVertexA;
    const edgeVertexB = sphereTrimesh_edgeVertexB;
    const edgeVector = sphereTrimesh_edgeVector;
    const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    const localSpherePos = sphereTrimesh_localSpherePos;
    const tmp = sphereTrimesh_tmp;
    const localSphereAABB = sphereTrimesh_localSphereAABB;
    const v2 = sphereTrimesh_v2;
    const relpos = sphereTrimesh_relpos;
    const triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

    const sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
    // Vertices

    const v = sphereTrimesh_v;
    const radiusSquared = sphereShape.radius * sphereShape.radius;

    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

        v.vsub(localSpherePos, relpos);

        if (relpos.lengthSquared() <= radiusSquared) {
          // Safe up
          v2.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
          v.vsub(spherePos, relpos);

          if (justTest) {
            return true;
          }

          let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
          r.ni.copy(relpos);
          r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

          r.ri.copy(r.ni);
          r.ri.scale(sphereShape.radius, r.ri);
          r.ri.vadd(spherePos, r.ri);
          r.ri.vsub(sphereBody.position, r.ri);
          r.rj.copy(v);
          r.rj.vsub(trimeshBody.position, r.rj); // Store result

          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    } // Check all edges


    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
        edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

        localSpherePos.vsub(edgeVertexB, tmp);
        const positionAlongEdgeB = tmp.dot(edgeVector);
        localSpherePos.vsub(edgeVertexA, tmp);
        let positionAlongEdgeA = tmp.dot(edgeVector);

        if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
          // Now check the orthogonal distance from edge to sphere center
          localSpherePos.vsub(edgeVertexA, tmp);
          edgeVectorUnit.copy(edgeVector);
          edgeVectorUnit.normalize();
          positionAlongEdgeA = tmp.dot(edgeVectorUnit);
          edgeVectorUnit.scale(positionAlongEdgeA, tmp);
          tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

          const dist = tmp.distanceTo(localSpherePos);

          if (dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }

            const r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            r.ri.vadd(spherePos, r.ri);
            r.ri.vsub(sphereBody.position, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    } // Triangle faces


    const va = sphereTrimesh_va;
    const vb = sphereTrimesh_vb;
    const vc = sphereTrimesh_vc;
    const normal = sphereTrimesh_normal;

    for (let i = 0, N = triangles.length; i !== N; i++) {
      trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
      trimeshShape.getNormal(triangles[i], normal);
      localSpherePos.vsub(va, tmp);
      let dist = tmp.dot(normal);
      normal.scale(dist, tmp);
      localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

      dist = tmp.distanceTo(localSpherePos);

      if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
        if (justTest) {
          return true;
        }

        let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
        tmp.vsub(localSpherePos, r.ni);
        r.ni.normalize();
        r.ni.scale(sphereShape.radius, r.ri);
        r.ri.vadd(spherePos, r.ri);
        r.ri.vsub(sphereBody.position, r.ri);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
        tmp.vsub(trimeshBody.position, r.rj);
        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }

    triangles.length = 0;
  }

  planeTrimesh(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
    // Make contacts!
    const v = new Vec3();
    const normal = planeTrimesh_normal;
    normal.set(0, 0, 1);
    planeQuat.vmult(normal, normal); // Turn normal according to plane

    for (let i = 0; i < trimeshShape.vertices.length / 3; i++) {
      // Get world vertex from trimesh
      trimeshShape.getVertex(i, v); // Safe up

      const v2 = new Vec3();
      v2.copy(v);
      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

      const relpos = planeTrimesh_relpos;
      v.vsub(planePos, relpos);
      const dot = normal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
        r.ni.copy(normal); // Contact normal is the plane normal
        // Get vertex position projected on plane

        const projected = planeTrimesh_projected;
        normal.scale(relpos.dot(normal), projected);
        v.vsub(projected, projected); // ri is the projected world position minus plane position

        r.ri.copy(projected);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.copy(v);
        r.rj.vsub(trimeshBody.position, r.rj); // Store result

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }
  } // convexTrimesh(
  //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
  //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
  //   faceListA?: number[] | null, faceListB?: number[] | null,
  // ) {
  //   const sepAxis = convexConvex_sepAxis;
  //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
  //       return;
  //   }
  //   // Construct a temp hull for each triangle
  //   const hullB = new ConvexPolyhedron();
  //   hullB.faces = [[0,1,2]];
  //   const va = new Vec3();
  //   const vb = new Vec3();
  //   const vc = new Vec3();
  //   hullB.vertices = [
  //       va,
  //       vb,
  //       vc
  //   ];
  //   for (let i = 0; i < sj.indices.length / 3; i++) {
  //       const triangleNormal = new Vec3();
  //       sj.getNormal(i, triangleNormal);
  //       hullB.faceNormals = [triangleNormal];
  //       sj.getTriangleVertices(i, va, vb, vc);
  //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //       if(!d){
  //           triangleNormal.scale(-1, triangleNormal);
  //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //           if(!d){
  //               continue;
  //           }
  //       }
  //       const res: ConvexPolyhedronContactPoint[] = [];
  //       const q = convexConvex_q;
  //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
  //       for(let j = 0; j !== res.length; j++){
  //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
  //               ri = r.ri,
  //               rj = r.rj;
  //           r.ni.copy(triangleNormal);
  //           r.ni.negate(r.ni);
  //           res[j].normal.negate(q);
  //           q.mult(res[j].depth, q);
  //           res[j].point.vadd(q, ri);
  //           rj.copy(res[j].point);
  //           // Contact points are in world coordinates. Transform back to relative
  //           ri.vsub(xi,ri);
  //           rj.vsub(xj,rj);
  //           // Make relative to bodies
  //           ri.vadd(xi, ri);
  //           ri.vsub(bi.position, ri);
  //           rj.vadd(xj, rj);
  //           rj.vsub(bj.position, rj);
  //           result.push(r);
  //       }
  //   }
  // }


}
const averageNormal = new Vec3();
const averageContactPointA = new Vec3();
const averageContactPointB = new Vec3();
const tmpVec1$2 = new Vec3();
const tmpVec2$2 = new Vec3();
const tmpQuat1 = new Quaternion();
const tmpQuat2 = new Quaternion();

Narrowphase.prototype[COLLISION_TYPES.boxBox] = Narrowphase.prototype.boxBox;
Narrowphase.prototype[COLLISION_TYPES.boxConvex] = Narrowphase.prototype.boxConvex;
Narrowphase.prototype[COLLISION_TYPES.boxParticle] = Narrowphase.prototype.boxParticle;
Narrowphase.prototype[COLLISION_TYPES.sphereSphere] = Narrowphase.prototype.sphereSphere;
const planeTrimesh_normal = new Vec3();
const planeTrimesh_relpos = new Vec3();
const planeTrimesh_projected = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.planeTrimesh] = Narrowphase.prototype.planeTrimesh;
const sphereTrimesh_normal = new Vec3();
const sphereTrimesh_relpos = new Vec3();
const sphereTrimesh_v = new Vec3();
const sphereTrimesh_v2 = new Vec3();
const sphereTrimesh_edgeVertexA = new Vec3();
const sphereTrimesh_edgeVertexB = new Vec3();
const sphereTrimesh_edgeVector = new Vec3();
const sphereTrimesh_edgeVectorUnit = new Vec3();
const sphereTrimesh_localSpherePos = new Vec3();
const sphereTrimesh_tmp = new Vec3();
const sphereTrimesh_va = new Vec3();
const sphereTrimesh_vb = new Vec3();
const sphereTrimesh_vc = new Vec3();
const sphereTrimesh_localSphereAABB = new AABB();
const sphereTrimesh_triangles = [];
Narrowphase.prototype[COLLISION_TYPES.sphereTrimesh] = Narrowphase.prototype.sphereTrimesh;
const point_on_plane_to_sphere = new Vec3();
const plane_to_sphere_ortho = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.spherePlane] = Narrowphase.prototype.spherePlane; // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html

const pointInPolygon_edge = new Vec3();
const pointInPolygon_edge_x_normal = new Vec3();
const pointInPolygon_vtp = new Vec3();

function pointInPolygon(verts, normal, p) {
  let positiveResult = null;
  const N = verts.length;

  for (let i = 0; i !== N; i++) {
    const v = verts[i]; // Get edge to the next vertex

    const edge = pointInPolygon_edge;
    verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

    const edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();

    edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

    const vertex_to_p = pointInPolygon_vtp;
    p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

    const r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
      if (positiveResult === null) {
        positiveResult = r > 0;
      }

      continue;
    } else {
      return false; // Encountered some other sign. Exit.
    }
  } // If we got here, all dot products were of the same sign.


  return true;
}

const box_to_sphere = new Vec3();
const sphereBox_ns = new Vec3();
const sphereBox_ns1 = new Vec3();
const sphereBox_ns2 = new Vec3();
const sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
const sphereBox_sphere_to_corner = new Vec3();
const sphereBox_side_ns = new Vec3();
const sphereBox_side_ns1 = new Vec3();
const sphereBox_side_ns2 = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.sphereBox] = Narrowphase.prototype.sphereBox;
const convex_to_sphere = new Vec3();
const sphereConvex_edge = new Vec3();
const sphereConvex_edgeUnit = new Vec3();
const sphereConvex_sphereToCorner = new Vec3();
const sphereConvex_worldCorner = new Vec3();
const sphereConvex_worldNormal = new Vec3();
const sphereConvex_worldPoint = new Vec3();
const sphereConvex_worldSpherePointClosestToPlane = new Vec3();
const sphereConvex_penetrationVec = new Vec3();
const sphereConvex_sphereToWorldPoint = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.sphereConvex] = Narrowphase.prototype.sphereConvex;
Narrowphase.prototype[COLLISION_TYPES.planeBox] = Narrowphase.prototype.planeBox;
const planeConvex_v = new Vec3();
const planeConvex_normal = new Vec3();
const planeConvex_relpos = new Vec3();
const planeConvex_projected = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.planeConvex] = Narrowphase.prototype.planeConvex;
const convexConvex_sepAxis = new Vec3();
const convexConvex_q = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.convexConvex] = Narrowphase.prototype.convexConvex; // Narrowphase.prototype[COLLISION_TYPES.convexTrimesh] = Narrowphase.prototype.convexTrimesh

const particlePlane_normal = new Vec3();
const particlePlane_relpos = new Vec3();
const particlePlane_projected = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.planeParticle] = Narrowphase.prototype.planeParticle;
const particleSphere_normal = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.sphereParticle] = Narrowphase.prototype.sphereParticle; // WIP

const cqj = new Quaternion();
const convexParticle_local = new Vec3();
const convexParticle_penetratedFaceNormal = new Vec3();
const convexParticle_vertexToParticle = new Vec3();
const convexParticle_worldPenetrationVec = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.convexParticle] = Narrowphase.prototype.convexParticle;
Narrowphase.prototype[COLLISION_TYPES.boxHeightfield] = Narrowphase.prototype.boxHeightfield;
const convexHeightfield_tmp1 = new Vec3();
const convexHeightfield_tmp2 = new Vec3();
const convexHeightfield_faceList = [0];
Narrowphase.prototype[COLLISION_TYPES.convexHeightfield] = Narrowphase.prototype.convexHeightfield;
const sphereHeightfield_tmp1 = new Vec3();
const sphereHeightfield_tmp2 = new Vec3();
Narrowphase.prototype[COLLISION_TYPES.sphereHeightfield] = Narrowphase.prototype.sphereHeightfield;

/**
 * @class OverlapKeeper
 * @constructor
 */
class OverlapKeeper {
  constructor() {
    this.current = [];
    this.previous = [];
  }

  getKey(i, j) {
    if (j < i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return i << 16 | j;
  }
  /**
   * @method set
   * @param {Number} i
   * @param {Number} j
   */


  set(i, j) {
    // Insertion sort. This way the diff will have linear complexity.
    const key = this.getKey(i, j);
    const current = this.current;
    let index = 0;

    while (key > current[index]) {
      index++;
    }

    if (key === current[index]) {
      return; // Pair was already added
    }

    for (let j = current.length - 1; j >= index; j--) {
      current[j + 1] = current[j];
    }

    current[index] = key;
  }
  /**
   * @method tick
   */


  tick() {
    const tmp = this.current;
    this.current = this.previous;
    this.previous = tmp;
    this.current.length = 0;
  }
  /**
   * @method getDiff
   * @param  {array} additions
   * @param  {array} removals
   */


  getDiff(additions, removals) {
    const a = this.current;
    const b = this.previous;
    const al = a.length;
    const bl = b.length;
    let j = 0;

    for (let i = 0; i < al; i++) {
      let found = false;
      const keyA = a[i];

      while (keyA > b[j]) {
        j++;
      }

      found = keyA === b[j];

      if (!found) {
        unpackAndPush(additions, keyA);
      }
    }

    j = 0;

    for (let i = 0; i < bl; i++) {
      let found = false;
      const keyB = b[i];

      while (keyB > a[j]) {
        j++;
      }

      found = a[j] === keyB;

      if (!found) {
        unpackAndPush(removals, keyB);
      }
    }
  }

}

function unpackAndPush(array, key) {
  array.push((key & 0xffff0000) >> 16, key & 0x0000ffff);
}

/**
 * @class TupleDictionary
 * @constructor
 */
class TupleDictionary {
  constructor() {
    this.data = {
      keys: []
    };
  }
  /**
   * @method get
   * @param  {Number} i
   * @param  {Number} j
   * @return {Object}
   */


  get(i, j) {
    if (i > j) {
      // swap
      const temp = j;
      j = i;
      i = temp;
    }

    return this.data[i + "-" + j];
  }
  /**
   * @method set
   * @param  {Number} i
   * @param  {Number} j
   * @param {Object} value
   */


  set(i, j, value) {
    if (i > j) {
      const temp = j;
      j = i;
      i = temp;
    }

    const key = i + "-" + j; // Check if key already exists

    if (!this.get(i, j)) {
      this.data.keys.push(key);
    }

    this.data[key] = value;
  }
  /**
   * @method reset
   */


  reset() {
    const data = this.data;
    const keys = data.keys;

    while (keys.length > 0) {
      const key = keys.pop();
      delete data[key];
    }
  }

}

/**
 * The physics world
 * @class World
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.gravity]
 * @param {boolean} [options.allowSleep]
 * @param {Broadphase} [options.broadphase]
 * @param {Solver} [options.solver]
 * @param {boolean} [options.quatNormalizeFast]
 * @param {number} [options.quatNormalizeSkip]
 */
class World extends EventTarget {
  // Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
  // Makes bodies go to sleep when they've been inactive.
  // All the current contacts (instances of ContactEquation) in the world.
  // How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
  // Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
  // The wall-clock time since simulation start.
  // Number of timesteps taken since start.
  // Default and last timestep sizes.
  // The broadphase algorithm to use. Default is NaiveBroadphase.
  // All bodies in this world
  // True if any bodies are not sleeping, false if every body is sleeping.
  // The solver algorithm to use. Default is GSSolver.
  // CollisionMatrix from the previous step.
  // All added materials.
  // Used to look up a ContactMaterial given two instances of Material.
  // This contact material is used if no suitable contactmaterial is found for a contact.
  // Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/
  // Dispatched after a body has been added to the world.
  // Dispatched after a body has been removed from the world.
  constructor(options = {}) {
    super();
    this.dt = -1;
    this.allowSleep = !!options.allowSleep;
    this.contacts = [];
    this.frictionEquations = [];
    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
    this.time = 0.0;
    this.stepnumber = 0;
    this.default_dt = 1 / 60;
    this.nextId = 0;
    this.gravity = new Vec3();

    if (options.gravity) {
      this.gravity.copy(options.gravity);
    }

    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
    this.bodies = [];
    this.hasActiveBodies = false;
    this.solver = options.solver !== undefined ? options.solver : new GSSolver();
    this.constraints = [];
    this.narrowphase = new Narrowphase(this);
    this.collisionMatrix = new ArrayCollisionMatrix();
    this.collisionMatrixPrevious = new ArrayCollisionMatrix();
    this.bodyOverlapKeeper = new OverlapKeeper();
    this.shapeOverlapKeeper = new OverlapKeeper();
    this.materials = [];
    this.contactmaterials = [];
    this.contactMaterialTable = new TupleDictionary();
    this.defaultMaterial = new Material('default');
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0.0
    });
    this.doProfiling = false;
    this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    };
    this.accumulator = 0;
    this.subsystems = [];
    this.addBodyEvent = {
      type: 'addBody',
      body: null
    };
    this.removeBodyEvent = {
      type: 'removeBody',
      body: null
    };
    this.idToBodyMap = {};
    this.broadphase.setWorld(this);
  }
  /**
   * Get the contact material between materials m1 and m2
   * @method getContactMaterial
   * @param {Material} m1
   * @param {Material} m2
   * @return {ContactMaterial} The contact material if it was found.
   */


  getContactMaterial(m1, m2) {
    return this.contactMaterialTable.get(m1.id, m2.id);
  }
  /**
   * Get number of objects in the world.
   * @method numObjects
   * @return {Number}
   * @deprecated
   */


  numObjects() {
    return this.bodies.length;
  }
  /**
   * Store old collision state info
   * @method collisionMatrixTick
   */


  collisionMatrixTick() {
    const temp = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix;
    this.collisionMatrix = temp;
    this.collisionMatrix.reset();
    this.bodyOverlapKeeper.tick();
    this.shapeOverlapKeeper.tick();
  }
  /**
   * Add a constraint to the simulation.
   * @method addConstraint
   * @param {Constraint} c
   */


  addConstraint(c) {
    this.constraints.push(c);
  }
  /**
   * Removes a constraint
   * @method removeConstraint
   * @param {Constraint} c
   */


  removeConstraint(c) {
    const idx = this.constraints.indexOf(c);

    if (idx !== -1) {
      this.constraints.splice(idx, 1);
    }
  }
  /**
   * Raycast test
   * @method rayTest
   * @param {Vec3} from
   * @param {Vec3} to
   * @param {RaycastResult} result
   * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
   */


  rayTest(from, to, result) {
    if (result instanceof RaycastResult) {
      // Do raycastClosest
      this.raycastClosest(from, to, {
        skipBackfaces: true
      }, result);
    } else {
      // Do raycastAll
      this.raycastAll(from, to, {
        skipBackfaces: true
      }, result);
    }
  }
  /**
   * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
   * @method raycastAll
   * @param  {Vec3} from
   * @param  {Vec3} to
   * @param  {Object} options
   * @param  {number} [options.collisionFilterMask=-1]
   * @param  {number} [options.collisionFilterGroup=-1]
   * @param  {boolean} [options.skipBackfaces=false]
   * @param  {boolean} [options.checkCollisionResponse=true]
   * @param  {Function} callback
   * @return {boolean} True if any body was hit.
   */


  raycastAll(from, to, options = {}, callback) {
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay$1.intersectWorld(this, options);
  }
  /**
   * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
   * @method raycastAny
   * @param  {Vec3} from
   * @param  {Vec3} to
   * @param  {Object} options
   * @param  {number} [options.collisionFilterMask=-1]
   * @param  {number} [options.collisionFilterGroup=-1]
   * @param  {boolean} [options.skipBackfaces=false]
   * @param  {boolean} [options.checkCollisionResponse=true]
   * @param  {RaycastResult} result
   * @return {boolean} True if any body was hit.
   */


  raycastAny(from, to, options = {}, result) {
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay$1.intersectWorld(this, options);
  }
  /**
   * Ray cast, and return information of the closest hit.
   * @method raycastClosest
   * @param  {Vec3} from
   * @param  {Vec3} to
   * @param  {Object} options
   * @param  {number} [options.collisionFilterMask=-1]
   * @param  {number} [options.collisionFilterGroup=-1]
   * @param  {boolean} [options.skipBackfaces=false]
   * @param  {boolean} [options.checkCollisionResponse=true]
   * @param  {RaycastResult} result
   * @return {boolean} True if any body was hit.
   */


  raycastClosest(from, to, options = {}, result) {
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay$1.intersectWorld(this, options);
  }
  /**
   * Add a rigid body to the simulation.
   * @method add
   * @param {Body} body
   * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
   * @todo Adding an array of bodies should be possible. This would save some loops too
   */


  addBody(body) {
    if (this.bodies.includes(body)) {
      return;
    }

    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;

    if (body instanceof Body) {
      body.initAngularVelocity.copy(body.angularVelocity);
      body.initQuaternion.copy(body.quaternion);
    }

    this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.idToBodyMap[body.id] = body;
    this.dispatchEvent(this.addBodyEvent);
  }
  /**
   * Remove a rigid body from the simulation.
   * @method remove
   * @param {Body} body
   */


  removeBody(body) {
    body.world = null;
    const n = this.bodies.length - 1;
    const bodies = this.bodies;
    const idx = bodies.indexOf(body);

    if (idx !== -1) {
      bodies.splice(idx, 1); // Todo: should use a garbage free method
      // Recompute index

      for (let i = 0; i !== bodies.length; i++) {
        bodies[i].index = i;
      }

      this.collisionMatrix.setNumObjects(n);
      this.removeBodyEvent.body = body;
      delete this.idToBodyMap[body.id];
      this.dispatchEvent(this.removeBodyEvent);
    }
  }

  getBodyById(id) {
    return this.idToBodyMap[id];
  } // TODO Make a faster map


  getShapeById(id) {
    const bodies = this.bodies;

    for (let i = 0, bl = bodies.length; i < bl; i++) {
      const shapes = bodies[i].shapes;

      for (let j = 0, sl = shapes.length; j < sl; j++) {
        const shape = shapes[j];

        if (shape.id === id) {
          return shape;
        }
      }
    }
  }
  /**
   * Adds a material to the World.
   * @method addMaterial
   * @param {Material} m
   * @todo Necessary?
   */


  addMaterial(m) {
    this.materials.push(m);
  }
  /**
   * Adds a contact material to the World
   * @method addContactMaterial
   * @param {ContactMaterial} cmat
   */


  addContactMaterial(cmat) {
    // Add contact material
    this.contactmaterials.push(cmat); // Add current contact material to the material table

    this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
  }
  /**
   * Step the physics world forward in time.
   *
   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
   *
   * @method step
   * @param {Number} dt                       The fixed time step size to use.
   * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
   * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
   *
   * @example
   *     // fixed timestepping without interpolation
   *     world.step(1/60);
   *
   * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
   */


  step(dt, timeSinceLastCalled = 0, maxSubSteps = 10) {
    if (timeSinceLastCalled === 0) {
      // Fixed, simple stepping
      this.internalStep(dt); // Increment time

      this.time += dt;
    } else {
      this.accumulator += timeSinceLastCalled;
      let substeps = 0;

      while (this.accumulator >= dt && substeps < maxSubSteps) {
        // Do fixed steps to catch up
        this.internalStep(dt);
        this.accumulator -= dt;
        substeps++;
      }

      const t = this.accumulator % dt / dt;

      for (let j = 0; j !== this.bodies.length; j++) {
        const b = this.bodies[j];
        b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
        b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
        b.previousQuaternion.normalize();
      }

      this.time += timeSinceLastCalled;
    }
  }

  internalStep(dt) {
    this.dt = dt;
    const contacts = this.contacts;
    const p1 = World_step_p1;
    const p2 = World_step_p2;
    const N = this.numObjects();
    const bodies = this.bodies;
    const solver = this.solver;
    const gravity = this.gravity;
    const doProfiling = this.doProfiling;
    const profile = this.profile;
    const DYNAMIC = Body.DYNAMIC;
    let profilingStart = -Infinity;
    const constraints = this.constraints;
    const frictionEquationPool = World_step_frictionEquationPool;
    const gnorm = gravity.length();
    const gx = gravity.x;
    const gy = gravity.y;
    const gz = gravity.z;
    let i = 0;

    if (doProfiling) {
      profilingStart = performance.now();
    } // Add gravity to all objects


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type === DYNAMIC) {
        // Only for dynamic bodies
        const f = bi.force;
        const m = bi.mass;
        f.x += m * gx;
        f.y += m * gy;
        f.z += m * gz;
      }
    } // Update subsystems


    for (let i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
      this.subsystems[i].update();
    } // Collision detection


    if (doProfiling) {
      profilingStart = performance.now();
    }

    p1.length = 0; // Clean up pair arrays from last step

    p2.length = 0;
    this.broadphase.collisionPairs(this, p1, p2);

    if (doProfiling) {
      profile.broadphase = performance.now() - profilingStart;
    } // Remove constrained pairs with collideConnected == false


    let Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];

      if (!c.collideConnected) {
        for (let j = p1.length - 1; j >= 0; j -= 1) {
          if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
            p1.splice(j, 1);
            p2.splice(j, 1);
          }
        }
      }
    }

    this.collisionMatrixTick(); // Generate contacts

    if (doProfiling) {
      profilingStart = performance.now();
    }

    const oldcontacts = World_step_oldContacts;
    const NoldContacts = contacts.length;

    for (i = 0; i !== NoldContacts; i++) {
      oldcontacts.push(contacts[i]);
    }

    contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

    const NoldFrictionEquations = this.frictionEquations.length;

    for (i = 0; i !== NoldFrictionEquations; i++) {
      frictionEquationPool.push(this.frictionEquations[i]);
    }

    this.frictionEquations.length = 0;
    this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
    this.frictionEquations, frictionEquationPool);

    if (doProfiling) {
      profile.narrowphase = performance.now() - profilingStart;
    } // Loop over all collisions


    if (doProfiling) {
      profilingStart = performance.now();
    } // Add all friction eqs


    for (i = 0; i < this.frictionEquations.length; i++) {
      solver.addEquation(this.frictionEquations[i]);
    }

    const ncontacts = contacts.length;

    for (let k = 0; k !== ncontacts; k++) {
      // Current contact
      const c = contacts[k]; // Get current collision indeces

      const bi = c.bi;
      const bj = c.bj;
      const si = c.si;
      const sj = c.sj; // Get collision properties

      let cm;

      if (bi.material && bj.material) {
        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
      } else {
        cm = this.defaultContactMaterial;
      } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;


      let mu = cm.friction; // c.restitution = cm.restitution;
      // If friction or restitution were specified in the material, use them

      if (bi.material && bj.material) {
        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
          mu = bi.material.friction * bj.material.friction;
        }

        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
          c.restitution = bi.material.restitution * bj.material.restitution;
        }
      } // c.setSpookParams(
      //           cm.contactEquationStiffness,
      //           cm.contactEquationRelaxation,
      //           dt
      //       );


      solver.addEquation(c); // // Add friction constraint equation
      // if(mu > 0){
      // 	// Create 2 tangent equations
      // 	const mug = mu * gnorm;
      // 	const reducedMass = (bi.invMass + bj.invMass);
      // 	if(reducedMass > 0){
      // 		reducedMass = 1/reducedMass;
      // 	}
      // 	const pool = frictionEquationPool;
      // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	this.frictionEquations.push(c1, c2);
      // 	c1.bi = c2.bi = bi;
      // 	c1.bj = c2.bj = bj;
      // 	c1.minForce = c2.minForce = -mug*reducedMass;
      // 	c1.maxForce = c2.maxForce = mug*reducedMass;
      // 	// Copy over the relative vectors
      // 	c1.ri.copy(c.ri);
      // 	c1.rj.copy(c.rj);
      // 	c2.ri.copy(c.ri);
      // 	c2.rj.copy(c.rj);
      // 	// Construct tangents
      // 	c.ni.tangents(c1.t, c2.t);
      //           // Set spook params
      //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c1.enabled = c2.enabled = c.enabled;
      // 	// Add equations to solver
      // 	solver.addEquation(c1);
      // 	solver.addEquation(c2);
      // }

      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
        const speedSquaredB = bj.velocity.lengthSquared() + bj.angularVelocity.lengthSquared();
        const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;

        if (speedSquaredB >= speedLimitSquaredB * 2) {
          bi.wakeUpAfterNarrowphase = true;
        }
      }

      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
        const speedSquaredA = bi.velocity.lengthSquared() + bi.angularVelocity.lengthSquared();
        const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;

        if (speedSquaredA >= speedLimitSquaredA * 2) {
          bj.wakeUpAfterNarrowphase = true;
        }
      } // Now we know that i and j are in contact. Set collision matrix state


      this.collisionMatrix.set(bi, bj, true);

      if (!this.collisionMatrixPrevious.get(bi, bj)) {
        // First contact!
        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
        World_step_collideEvent.body = bj;
        World_step_collideEvent.contact = c;
        bi.dispatchEvent(World_step_collideEvent);
        World_step_collideEvent.body = bi;
        bj.dispatchEvent(World_step_collideEvent);
      }

      this.bodyOverlapKeeper.set(bi.id, bj.id);
      this.shapeOverlapKeeper.set(si.id, sj.id);
    }

    this.emitContactEvents();

    if (doProfiling) {
      profile.makeContactConstraints = performance.now() - profilingStart;
      profilingStart = performance.now();
    } // Wake up bodies


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.wakeUpAfterNarrowphase) {
        bi.wakeUp();
        bi.wakeUpAfterNarrowphase = false;
      }
    } // Add user-added constraints


    Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];
      c.update();

      for (let j = 0, Neq = c.equations.length; j !== Neq; j++) {
        const eq = c.equations[j];
        solver.addEquation(eq);
      }
    } // Solve the constrained system


    solver.solve(dt, this);

    if (doProfiling) {
      profile.solve = performance.now() - profilingStart;
    } // Remove all contacts from solver


    solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

    const pow = Math.pow;

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type & DYNAMIC) {
        // Only for dynamic bodies
        const ld = pow(1.0 - bi.linearDamping, dt);
        const v = bi.velocity;
        v.scale(ld, v);
        const av = bi.angularVelocity;

        if (av) {
          const ad = pow(1.0 - bi.angularDamping, dt);
          av.scale(ad, av);
        }
      }
    }

    this.dispatchEvent(World_step_preStepEvent); // Invoke pre-step callbacks

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.preStep) {
        bi.preStep.call(bi);
      }
    } // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew


    if (doProfiling) {
      profilingStart = performance.now();
    }

    const stepnumber = this.stepnumber;
    const quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    const quatNormalizeFast = this.quatNormalizeFast;

    for (i = 0; i !== N; i++) {
      bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
    }

    this.clearForces();
    this.broadphase.dirty = true;

    if (doProfiling) {
      profile.integrate = performance.now() - profilingStart;
    } // Update world time


    this.time += dt;
    this.stepnumber += 1;
    this.dispatchEvent(World_step_postStepEvent); // Invoke post-step callbacks

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];
      const postStep = bi.postStep;

      if (postStep) {
        postStep.call(bi);
      }
    } // Sleeping update


    let hasActiveBodies = true;

    if (this.allowSleep) {
      hasActiveBodies = false;

      for (i = 0; i !== N; i++) {
        const bi = bodies[i];
        bi.sleepTick(this.time);

        if (bi.sleepState !== Body.SLEEPING) {
          hasActiveBodies = true;
        }
      }
    }

    this.hasActiveBodies = hasActiveBodies;
  }
  /**
   * Sets all body forces in the world to zero.
   * @method clearForces
   */


  clearForces() {
    const bodies = this.bodies;
    const N = bodies.length;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      const force = b.force;
      const tau = b.torque;
      b.force.set(0, 0, 0);
      b.torque.set(0, 0, 0);
    }
  }

} // Temp stuff

const tmpAABB1 = new AABB();
const tmpRay$1 = new Ray(); // performance.now()

if (typeof performance === 'undefined') {
  performance = {};
}

if (!performance.now) {
  let nowOffset = Date.now();

  if (performance.timing && performance.timing.navigationStart) {
    nowOffset = performance.timing.navigationStart;
  }

  performance.now = () => Date.now() - nowOffset;
}
// Reusable event objects to save memory.

const World_step_postStepEvent = {
  type: 'postStep'
}; // Dispatched before the world steps forward in time.

const World_step_preStepEvent = {
  type: 'preStep'
};
const World_step_collideEvent = {
  type: Body.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
}; // Pools for unused objects

const World_step_oldContacts = [];
const World_step_frictionEquationPool = []; // Reusable arrays for collision pairs

const World_step_p1 = [];
const World_step_p2 = [];

World.prototype.emitContactEvents = (() => {
  const additions = [];
  const removals = [];
  const beginContactEvent = {
    type: 'beginContact',
    bodyA: null,
    bodyB: null
  };
  const endContactEvent = {
    type: 'endContact',
    bodyA: null,
    bodyB: null
  };
  const beginShapeContactEvent = {
    type: 'beginShapeContact',
    bodyA: null,
    bodyB: null,
    shapeA: null,
    shapeB: null
  };
  const endShapeContactEvent = {
    type: 'endShapeContact',
    bodyA: null,
    bodyB: null,
    shapeA: null,
    shapeB: null
  };
  return function () {
    const hasBeginContact = this.hasAnyEventListener('beginContact');
    const hasEndContact = this.hasAnyEventListener('endContact');

    if (hasBeginContact || hasEndContact) {
      this.bodyOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        beginContactEvent.bodyA = this.getBodyById(additions[i]);
        beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
        this.dispatchEvent(beginContactEvent);
      }

      beginContactEvent.bodyA = beginContactEvent.bodyB = null;
    }

    if (hasEndContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        endContactEvent.bodyA = this.getBodyById(removals[i]);
        endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
        this.dispatchEvent(endContactEvent);
      }

      endContactEvent.bodyA = endContactEvent.bodyB = null;
    }

    additions.length = removals.length = 0;
    const hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
    const hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

    if (hasBeginShapeContact || hasEndShapeContact) {
      this.shapeOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginShapeContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        const shapeA = this.getShapeById(additions[i]);
        const shapeB = this.getShapeById(additions[i + 1]);
        beginShapeContactEvent.shapeA = shapeA;
        beginShapeContactEvent.shapeB = shapeB;
        beginShapeContactEvent.bodyA = shapeA.body;
        beginShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(beginShapeContactEvent);
      }

      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
    }

    if (hasEndShapeContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        const shapeA = this.getShapeById(removals[i]);
        const shapeB = this.getShapeById(removals[i + 1]);
        endShapeContactEvent.shapeA = shapeA;
        endShapeContactEvent.shapeB = shapeB;
        endShapeContactEvent.bodyA = shapeA.body;
        endShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(endShapeContactEvent);
      }

      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
    }
  };
})();




/***/ }),

/***/ "./node_modules/three-to-ammo/index.js":
/*!*********************************************!*\
  !*** ./node_modules/three-to-ammo/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FIT: () => (/* binding */ FIT),
/* harmony export */   HEIGHTFIELD_DATA_TYPE: () => (/* binding */ HEIGHTFIELD_DATA_TYPE),
/* harmony export */   TYPE: () => (/* binding */ TYPE),
/* harmony export */   createBoxShape: () => (/* binding */ createBoxShape),
/* harmony export */   createCapsuleShape: () => (/* binding */ createCapsuleShape),
/* harmony export */   createCollisionShapes: () => (/* binding */ createCollisionShapes),
/* harmony export */   createConeShape: () => (/* binding */ createConeShape),
/* harmony export */   createCylinderShape: () => (/* binding */ createCylinderShape),
/* harmony export */   createHACDShapes: () => (/* binding */ createHACDShapes),
/* harmony export */   createHeightfieldTerrainShape: () => (/* binding */ createHeightfieldTerrainShape),
/* harmony export */   createHullShape: () => (/* binding */ createHullShape),
/* harmony export */   createSphereShape: () => (/* binding */ createSphereShape),
/* harmony export */   createTriMeshShape: () => (/* binding */ createTriMeshShape),
/* harmony export */   createVHACDShapes: () => (/* binding */ createVHACDShapes),
/* harmony export */   iterateGeometries: () => (/* binding */ iterateGeometries)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);

/* global Ammo */


const TYPE = {
  BOX: "box",
  CYLINDER: "cylinder",
  SPHERE: "sphere",
  CAPSULE: "capsule",
  CONE: "cone",
  HULL: "hull",
  HACD: "hacd", //Hierarchical Approximate Convex Decomposition
  VHACD: "vhacd", //Volumetric Hierarchical Approximate Convex Decomposition
  MESH: "mesh",
  HEIGHTFIELD: "heightfield"
};

const FIT = {
  ALL: "all", //A single shape is automatically sized to bound all meshes within the entity.
  MANUAL: "manual" //A single shape is sized manually. Requires halfExtents or sphereRadius.
};

const HEIGHTFIELD_DATA_TYPE = {
  short: "short",
  float: "float"
};

const createCollisionShapes = function(vertices, matrices, indexes, matrixWorld, options = {}) {
  switch (options.type) {
    case TYPE.BOX:
      return [createBoxShape(vertices, matrices, matrixWorld, options)];
    case TYPE.CYLINDER:
      return [createCylinderShape(vertices, matrices, matrixWorld, options)];
    case TYPE.CAPSULE:
      return [createCapsuleShape(vertices, matrices, matrixWorld, options)];
    case TYPE.CONE:
      return [createConeShape(vertices, matrices, matrixWorld, options)];
    case TYPE.SPHERE:
      return [createSphereShape(vertices, matrices, matrixWorld, options)];
    case TYPE.HULL:
      return [createHullShape(vertices, matrices, matrixWorld, options)];
    case TYPE.HACD:
      return createHACDShapes(vertices, matrices, indexes, matrixWorld, options);
    case TYPE.VHACD:
      return createVHACDShapes(vertices, matrices, indexes, matrixWorld, options);
    case TYPE.MESH:
      return [createTriMeshShape(vertices, matrices, indexes, matrixWorld, options)];
    case TYPE.HEIGHTFIELD:
      return [createHeightfieldTerrainShape(options)];
    default:
      console.warn(options.type + " is not currently supported");
      return [];
  }
};

//TODO: support gimpact (dynamic trimesh) and heightmap

const createBoxShape = function(vertices, matrices, matrixWorld, options = {}) {
  options.type = TYPE.BOX;
  _setOptions(options);

  if (options.fit === FIT.ALL) {
    options.halfExtents = _computeHalfExtents(
      _computeBounds(vertices, matrices),
      options.minHalfExtent,
      options.maxHalfExtent
    );
  }

  const btHalfExtents = new Ammo.btVector3(options.halfExtents.x, options.halfExtents.y, options.halfExtents.z);
  const collisionShape = new Ammo.btBoxShape(btHalfExtents);
  Ammo.destroy(btHalfExtents);

  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
  return collisionShape;
};

const createCylinderShape = function(vertices, matrices, matrixWorld, options = {}) {
  options.type = TYPE.CYLINDER;
  _setOptions(options);

  if (options.fit === FIT.ALL) {
    options.halfExtents = _computeHalfExtents(
      _computeBounds(vertices, matrices),
      options.minHalfExtent,
      options.maxHalfExtent
    );
  }

  const btHalfExtents = new Ammo.btVector3(options.halfExtents.x, options.halfExtents.y, options.halfExtents.z);
  const collisionShape = (() => {
    switch (options.cylinderAxis) {
      case "y":
        return new Ammo.btCylinderShape(btHalfExtents);
      case "x":
        return new Ammo.btCylinderShapeX(btHalfExtents);
      case "z":
        return new Ammo.btCylinderShapeZ(btHalfExtents);
    }
    return null;
  })();
  Ammo.destroy(btHalfExtents);

  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
  return collisionShape;
};

const createCapsuleShape = function(vertices, matrices, matrixWorld, options = {}) {
  options.type = TYPE.CAPSULE;
  _setOptions(options);

  if (options.fit === FIT.ALL) {
    options.halfExtents = _computeHalfExtents(
      _computeBounds(vertices, matrices),
      options.minHalfExtent,
      options.maxHalfExtent
    );
  }

  const { x, y, z } = options.halfExtents;
  const collisionShape = (() => {
    switch (options.cylinderAxis) {
      case "y":
        return new Ammo.btCapsuleShape(Math.max(x, z), y * 2);
      case "x":
        return new Ammo.btCapsuleShapeX(Math.max(y, z), x * 2);
      case "z":
        return new Ammo.btCapsuleShapeZ(Math.max(x, y), z * 2);
    }
    return null;
  })();

  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
  return collisionShape;
};

const createConeShape = function(vertices, matrices, matrixWorld, options = {}) {
  options.type = TYPE.CONE;
  _setOptions(options);

  if (options.fit === FIT.ALL) {
    options.halfExtents = _computeHalfExtents(
      _computeBounds(vertices, matrices),
      options.minHalfExtent,
      options.maxHalfExtent
    );
  }

  const { x, y, z } = options.halfExtents;
  const collisionShape = (() => {
    switch (options.cylinderAxis) {
      case "y":
        return new Ammo.btConeShape(Math.max(x, z), y * 2);
      case "x":
        return new Ammo.btConeShapeX(Math.max(y, z), x * 2);
      case "z":
        return new Ammo.btConeShapeZ(Math.max(x, y), z * 2);
    }
    return null;
  })();

  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
  return collisionShape;
};

const createSphereShape = function(vertices, matrices, matrixWorld, options = {}) {
  options.type = TYPE.SPHERE;
  _setOptions(options);

  let radius;
  if (options.fit === FIT.MANUAL && !isNaN(options.sphereRadius)) {
    radius = options.sphereRadius;
  } else {
    radius = _computeRadius(vertices, matrices, _computeBounds(vertices, matrices));
  }

  const collisionShape = new Ammo.btSphereShape(radius);
  _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));

  return collisionShape;
};

const createHullShape = (function() {
  const vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(vertices, matrices, matrixWorld, options = {}) {
    options.type = TYPE.HULL;
    _setOptions(options);

    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: hull");
      return null;
    }

    const bounds = _computeBounds(vertices, matrices);

    const btVertex = new Ammo.btVector3();
    const originalHull = new Ammo.btConvexHullShape();
    originalHull.setMargin(options.margin);
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);

    let vertexCount = 0;
    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
    }

    const maxVertices = options.hullMaxVertices || 100000;
    // todo: might want to implement this in a deterministic way that doesn't do O(verts) calls to Math.random
    if (vertexCount > maxVertices) {
      console.warn(`too many vertices for hull shape; sampling ~${maxVertices} from ~${vertexCount} vertices`);
    }
    const p = Math.min(1, maxVertices / vertexCount);

    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        const isLastVertex = i === vertices.length - 1 && j === components.length - 3;
        if (Math.random() <= p || isLastVertex) {
          // always include the last vertex
          vertex
            .set(components[j], components[j + 1], components[j + 2])
            .applyMatrix4(matrix)
            .sub(center);
          btVertex.setValue(vertex.x, vertex.y, vertex.z);
          originalHull.addPoint(btVertex, isLastVertex); // recalc AABB only on last geometry
        }
      }
    }

    let collisionShape = originalHull;
    if (originalHull.getNumVertices() >= 100) {
      //Bullet documentation says don't use convexHulls with 100 verts or more
      const shapeHull = new Ammo.btShapeHull(originalHull);
      shapeHull.buildHull(options.margin);
      Ammo.destroy(originalHull);
      collisionShape = new Ammo.btConvexHullShape(
        Ammo.getPointer(shapeHull.getVertexPointer()),
        shapeHull.numVertices()
      );
      Ammo.destroy(shapeHull); // btConvexHullShape makes a copy
    }

    Ammo.destroy(btVertex);

    _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
    return collisionShape;
  };
})();

const createHACDShapes = (function() {
  const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.HACD;
    _setOptions(options);

    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: hacd");
      return [];
    }

    if (!Ammo.hasOwnProperty("HACD")) {
      console.warn(
        "HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."
      );
      return [];
    }

    const bounds = _computeBounds(vertices, matrices);
    const scale = _computeScale(matrixWorld, options);

    let vertexCount = 0;
    let triCount = 0;
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);

    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
      if (indexes && indexes[i]) {
        triCount += indexes[i].length / 3;
      } else {
        triCount += vertices[i].length / 9;
      }
    }

    const hacd = new Ammo.HACD();
    if (options.hasOwnProperty("compacityWeight")) hacd.SetCompacityWeight(options.compacityWeight);
    if (options.hasOwnProperty("volumeWeight")) hacd.SetVolumeWeight(options.volumeWeight);
    if (options.hasOwnProperty("nClusters")) hacd.SetNClusters(options.nClusters);
    if (options.hasOwnProperty("nVerticesPerCH")) hacd.SetNVerticesPerCH(options.nVerticesPerCH);
    if (options.hasOwnProperty("concavity")) hacd.SetConcavity(options.concavity);

    const points = Ammo._malloc(vertexCount * 3 * 8);
    const triangles = Ammo._malloc(triCount * 3 * 4);
    hacd.SetPoints(points);
    hacd.SetTriangles(triangles);
    hacd.SetNPoints(vertexCount);
    hacd.SetNTriangles(triCount);

    let pptr = points / 8,
      tptr = triangles / 4;

    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        vector
          .set(components[j + 0], components[j + 1], components[j + 2])
          .applyMatrix4(matrix)
          .sub(center);
        Ammo.HEAPF64[pptr + 0] = vector.x;
        Ammo.HEAPF64[pptr + 1] = vector.y;
        Ammo.HEAPF64[pptr + 2] = vector.z;
        pptr += 3;
      }
      if (indexes[i]) {
        const indices = indexes[i];
        for (let j = 0; j < indices.length; j++) {
          Ammo.HEAP32[tptr] = indices[j];
          tptr++;
        }
      } else {
        for (let j = 0; j < components.length / 3; j++) {
          Ammo.HEAP32[tptr] = j;
          tptr++;
        }
      }
    }

    hacd.Compute();
    Ammo._free(points);
    Ammo._free(triangles);
    const nClusters = hacd.GetNClusters();

    const shapes = [];
    for (let i = 0; i < nClusters; i++) {
      const hull = new Ammo.btConvexHullShape();
      hull.setMargin(options.margin);
      const nPoints = hacd.GetNPointsCH(i);
      const nTriangles = hacd.GetNTrianglesCH(i);
      const hullPoints = Ammo._malloc(nPoints * 3 * 8);
      const hullTriangles = Ammo._malloc(nTriangles * 3 * 4);
      hacd.GetCH(i, hullPoints, hullTriangles);

      const pptr = hullPoints / 8;
      for (let pi = 0; pi < nPoints; pi++) {
        const btVertex = new Ammo.btVector3();
        const px = Ammo.HEAPF64[pptr + pi * 3 + 0];
        const py = Ammo.HEAPF64[pptr + pi * 3 + 1];
        const pz = Ammo.HEAPF64[pptr + pi * 3 + 2];
        btVertex.setValue(px, py, pz);
        hull.addPoint(btVertex, pi === nPoints - 1);
        Ammo.destroy(btVertex);
      }

      _finishCollisionShape(hull, options, scale);
      shapes.push(hull);
    }

    return shapes;
  };
})();

const createVHACDShapes = (function() {
  const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.VHACD;
    _setOptions(options);

    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: vhacd");
      return [];
    }

    if (!Ammo.hasOwnProperty("VHACD")) {
      console.warn(
        "VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."
      );
      return [];
    }

    const bounds = _computeBounds(vertices, matrices);
    const scale = _computeScale(matrixWorld, options);

    let vertexCount = 0;
    let triCount = 0;
    center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);

    for (let i = 0; i < vertices.length; i++) {
      vertexCount += vertices[i].length / 3;
      if (indexes && indexes[i]) {
        triCount += indexes[i].length / 3;
      } else {
        triCount += vertices[i].length / 9;
      }
    }

    const vhacd = new Ammo.VHACD();
    const params = new Ammo.Parameters();
    //https://kmamou.blogspot.com/2014/12/v-hacd-20-parameters-description.html
    if (options.hasOwnProperty("resolution")) params.set_m_resolution(options.resolution);
    if (options.hasOwnProperty("depth")) params.set_m_depth(options.depth);
    if (options.hasOwnProperty("concavity")) params.set_m_concavity(options.concavity);
    if (options.hasOwnProperty("planeDownsampling")) params.set_m_planeDownsampling(options.planeDownsampling);
    if (options.hasOwnProperty("convexhullDownsampling"))
      params.set_m_convexhullDownsampling(options.convexhullDownsampling);
    if (options.hasOwnProperty("alpha")) params.set_m_alpha(options.alpha);
    if (options.hasOwnProperty("beta")) params.set_m_beta(options.beta);
    if (options.hasOwnProperty("gamma")) params.set_m_gamma(options.gamma);
    if (options.hasOwnProperty("pca")) params.set_m_pca(options.pca);
    if (options.hasOwnProperty("mode")) params.set_m_mode(options.mode);
    if (options.hasOwnProperty("maxNumVerticesPerCH")) params.set_m_maxNumVerticesPerCH(options.maxNumVerticesPerCH);
    if (options.hasOwnProperty("minVolumePerCH")) params.set_m_minVolumePerCH(options.minVolumePerCH);
    if (options.hasOwnProperty("convexhullApproximation"))
      params.set_m_convexhullApproximation(options.convexhullApproximation);
    if (options.hasOwnProperty("oclAcceleration")) params.set_m_oclAcceleration(options.oclAcceleration);

    const points = Ammo._malloc(vertexCount * 3 * 8 + 3);
    const triangles = Ammo._malloc(triCount * 3 * 4);

    let pptr = points / 8,
      tptr = triangles / 4;

    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < components.length; j += 3) {
        vector
          .set(components[j + 0], components[j + 1], components[j + 2])
          .applyMatrix4(matrix)
          .sub(center);
        Ammo.HEAPF64[pptr + 0] = vector.x;
        Ammo.HEAPF64[pptr + 1] = vector.y;
        Ammo.HEAPF64[pptr + 2] = vector.z;
        pptr += 3;
      }
      if (indexes[i]) {
        const indices = indexes[i];
        for (let j = 0; j < indices.length; j++) {
          Ammo.HEAP32[tptr] = indices[j];
          tptr++;
        }
      } else {
        for (let j = 0; j < components.length / 3; j++) {
          Ammo.HEAP32[tptr] = j;
          tptr++;
        }
      }
    }
    vhacd.Compute(points, 3, vertexCount, triangles, 3, triCount, params);
    Ammo._free(points);
    Ammo._free(triangles);
    const nHulls = vhacd.GetNConvexHulls();

    const shapes = [];
    const ch = new Ammo.ConvexHull();
    for (let i = 0; i < nHulls; i++) {
      vhacd.GetConvexHull(i, ch);
      const nPoints = ch.get_m_nPoints();
      const hullPoints = ch.get_m_points();

      const hull = new Ammo.btConvexHullShape();
      hull.setMargin(options.margin);

      for (let pi = 0; pi < nPoints; pi++) {
        const btVertex = new Ammo.btVector3();
        const px = ch.get_m_points(pi * 3 + 0);
        const py = ch.get_m_points(pi * 3 + 1);
        const pz = ch.get_m_points(pi * 3 + 2);
        btVertex.setValue(px, py, pz);
        hull.addPoint(btVertex, pi === nPoints - 1);
        Ammo.destroy(btVertex);
      }

      _finishCollisionShape(hull, options, scale);
      shapes.push(hull);
    }
    Ammo.destroy(ch);
    Ammo.destroy(vhacd);

    return shapes;
  };
})();

const createTriMeshShape = (function() {
  const va = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const vb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const vc = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(vertices, matrices, indexes, matrixWorld, options = {}) {
    options.type = TYPE.MESH;
    _setOptions(options);

    if (options.fit === FIT.MANUAL) {
      console.warn("cannot use fit: manual with type: mesh");
      return null;
    }

    const scale = _computeScale(matrixWorld, options);

    const bta = new Ammo.btVector3();
    const btb = new Ammo.btVector3();
    const btc = new Ammo.btVector3();
    const triMesh = new Ammo.btTriangleMesh(true, false);

    for (let i = 0; i < vertices.length; i++) {
      const components = vertices[i];
      const index = indexes[i] ? indexes[i] : null;
      matrix.fromArray(matrices[i]);
      if (index) {
        for (let j = 0; j < index.length; j += 3) {
          const ai = index[j] * 3;
          const bi = index[j + 1] * 3;
          const ci = index[j + 2] * 3;
          va.set(components[ai], components[ai + 1], components[ai + 2]).applyMatrix4(matrix);
          vb.set(components[bi], components[bi + 1], components[bi + 2]).applyMatrix4(matrix);
          vc.set(components[ci], components[ci + 1], components[ci + 2]).applyMatrix4(matrix);
          bta.setValue(va.x, va.y, va.z);
          btb.setValue(vb.x, vb.y, vb.z);
          btc.setValue(vc.x, vc.y, vc.z);
          triMesh.addTriangle(bta, btb, btc, false);
        }
      } else {
        for (let j = 0; j < components.length; j += 9) {
          va.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix);
          vb.set(components[j + 3], components[j + 4], components[j + 5]).applyMatrix4(matrix);
          vc.set(components[j + 6], components[j + 7], components[j + 8]).applyMatrix4(matrix);
          bta.setValue(va.x, va.y, va.z);
          btb.setValue(vb.x, vb.y, vb.z);
          btc.setValue(vc.x, vc.y, vc.z);
          triMesh.addTriangle(bta, btb, btc, false);
        }
      }
    }

    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
    triMesh.setScaling(localScale);
    Ammo.destroy(localScale);

    const collisionShape = new Ammo.btBvhTriangleMeshShape(triMesh, true, true);
    collisionShape.resources = [triMesh];

    Ammo.destroy(bta);
    Ammo.destroy(btb);
    Ammo.destroy(btc);

    _finishCollisionShape(collisionShape, options);
    return collisionShape;
  };
})();

const createHeightfieldTerrainShape = function(options = {}) {
  _setOptions(options);

  if (options.fit === FIT.ALL) {
    console.warn("cannot use fit: all with type: heightfield");
    return null;
  }
  const heightfieldDistance = options.heightfieldDistance || 1;
  const heightfieldData = options.heightfieldData || [];
  const heightScale = options.heightScale || 0;
  const upAxis = options.hasOwnProperty("upAxis") ? options.upAxis : 1; // x = 0; y = 1; z = 2
  const hdt = (() => {
    switch (options.heightDataType) {
      case "short":
        return Ammo.PHY_SHORT;
      case "float":
        return Ammo.PHY_FLOAT;
      default:
        return Ammo.PHY_FLOAT;
    }
  })();
  const flipQuadEdges = options.hasOwnProperty("flipQuadEdges") ? options.flipQuadEdges : true;

  const heightStickLength = heightfieldData.length;
  const heightStickWidth = heightStickLength > 0 ? heightfieldData[0].length : 0;

  const data = Ammo._malloc(heightStickLength * heightStickWidth * 4);
  const ptr = data / 4;

  let minHeight = Number.POSITIVE_INFINITY;
  let maxHeight = Number.NEGATIVE_INFINITY;
  let index = 0;
  for (let l = 0; l < heightStickLength; l++) {
    for (let w = 0; w < heightStickWidth; w++) {
      const height = heightfieldData[l][w];
      Ammo.HEAPF32[ptr + index] = height;
      index++;
      minHeight = Math.min(minHeight, height);
      maxHeight = Math.max(maxHeight, height);
    }
  }

  const collisionShape = new Ammo.btHeightfieldTerrainShape(
    heightStickWidth,
    heightStickLength,
    data,
    heightScale,
    minHeight,
    maxHeight,
    upAxis,
    hdt,
    flipQuadEdges
  );

  const scale = new Ammo.btVector3(heightfieldDistance, 1, heightfieldDistance);
  collisionShape.setLocalScaling(scale);
  Ammo.destroy(scale);

  collisionShape.heightfieldData = data;

  _finishCollisionShape(collisionShape, options);
  return collisionShape;
};

function _setOptions(options) {
  options.fit = options.hasOwnProperty("fit") ? options.fit : FIT.ALL;
  options.type = options.type || TYPE.HULL;
  options.minHalfExtent = options.hasOwnProperty("minHalfExtent") ? options.minHalfExtent : 0;
  options.maxHalfExtent = options.hasOwnProperty("maxHalfExtent") ? options.maxHalfExtent : Number.POSITIVE_INFINITY;
  options.cylinderAxis = options.cylinderAxis || "y";
  options.margin = options.hasOwnProperty("margin") ? options.margin : 0.01;
  options.includeInvisible = options.hasOwnProperty("includeInvisible") ? options.includeInvisible : false;

  if (!options.offset) {
    options.offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  }

  if (!options.orientation) {
    options.orientation = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
  }
}

const _finishCollisionShape = function(collisionShape, options, scale) {
  collisionShape.type = options.type;
  collisionShape.setMargin(options.margin);
  collisionShape.destroy = () => {
    for (let res of collisionShape.resources || []) {
      Ammo.destroy(res);
    }
    if (collisionShape.heightfieldData) {
      Ammo._free(collisionShape.heightfieldData);
    }
    Ammo.destroy(collisionShape);
  };

  const localTransform = new Ammo.btTransform();
  const rotation = new Ammo.btQuaternion();
  localTransform.setIdentity();

  localTransform.getOrigin().setValue(options.offset.x, options.offset.y, options.offset.z);
  rotation.setValue(options.orientation.x, options.orientation.y, options.orientation.z, options.orientation.w);

  localTransform.setRotation(rotation);
  Ammo.destroy(rotation);

  if (scale) {
    const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
    collisionShape.setLocalScaling(localScale);
    Ammo.destroy(localScale);
  }

  collisionShape.localTransform = localTransform;
};

const iterateGeometries = (function() {
  const inverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(root, options, cb) {
    inverse.copy(root.matrixWorld).invert();
    const scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    scale.setFromMatrixScale(root.matrixWorld);
    root.traverse(mesh => {
      const transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
      if (
        mesh.isMesh &&
        mesh.name !== "Sky" &&
        (options.includeInvisible || (mesh.el && mesh.el.object3D.visible) || mesh.visible)
      ) {
        if (mesh === root) {
          transform.identity();
        } else {
          mesh.updateWorldMatrix(true);
          transform.multiplyMatrices(inverse, mesh.matrixWorld);
        }
        // todo: might want to return null xform if this is the root so that callers can avoid multiplying
        // things by the identity matrix
        cb(
          mesh.geometry.isBufferGeometry ? mesh.geometry.attributes.position.array : mesh.geometry.vertices,
          transform.elements,
          mesh.geometry.index ? mesh.geometry.index.array : null
        );
      }
    });
  };
})();

const _computeScale = (function() {
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(matrixWorld, options = {}) {
    const scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);
    if (options.fit === FIT.ALL) {
      matrix.fromArray(matrixWorld);
      scale.setFromMatrixScale(matrix);
    }
    return scale;
  };
})();

const _computeRadius = (function() {
  const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  return function(vertices, matrices, bounds) {
    let maxRadiusSq = 0;
    let { x: cx, y: cy, z: cz } = bounds.getCenter(center);

    _iterateVertices(vertices, matrices, v => {
      const dx = cx - v.x;
      const dy = cy - v.y;
      const dz = cz - v.z;
      maxRadiusSq = Math.max(maxRadiusSq, dx * dx + dy * dy + dz * dz);
    });
    return Math.sqrt(maxRadiusSq);
  };
})();

const _computeHalfExtents = function(bounds, minHalfExtent, maxHalfExtent) {
  const halfExtents = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  return halfExtents
    .subVectors(bounds.max, bounds.min)
    .multiplyScalar(0.5)
    .clampScalar(minHalfExtent, maxHalfExtent);
};

const _computeLocalOffset = function(matrix, bounds, target) {
  target
    .addVectors(bounds.max, bounds.min)
    .multiplyScalar(0.5)
    .applyMatrix4(matrix);
  return target;
};

// returns the bounding box for the geometries underneath `root`.
const _computeBounds = function(vertices, matrices) {
  const bounds = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
  let minX = +Infinity;
  let minY = +Infinity;
  let minZ = +Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  bounds.min.set(0, 0, 0);
  bounds.max.set(0, 0, 0);

  _iterateVertices(vertices, matrices, v => {
    if (v.x < minX) minX = v.x;
    if (v.y < minY) minY = v.y;
    if (v.z < minZ) minZ = v.z;
    if (v.x > maxX) maxX = v.x;
    if (v.y > maxY) maxY = v.y;
    if (v.z > maxZ) maxZ = v.z;
  });

  bounds.min.set(minX, minY, minZ);
  bounds.max.set(maxX, maxY, maxZ);
  return bounds;
};

const _iterateVertices = (function() {
  const vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
  return function(vertices, matrices, cb) {
    for (let i = 0; i < vertices.length; i++) {
      matrix.fromArray(matrices[i]);
      for (let j = 0; j < vertices[i].length; j += 3) {
        vertex.set(vertices[i][j], vertices[i][j + 1], vertices[i][j + 2]).applyMatrix4(matrix);
        cb(vertex);
      }
    }
  };
})();


/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __nested_webpack_require_154__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_154__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __nested_webpack_require_154__.m = modules;

/******/  // expose the module cache
/******/  __nested_webpack_require_154__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __nested_webpack_require_154__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __nested_webpack_require_154__.d = function(exports, name, getter) {
/******/    if(!__nested_webpack_require_154__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __nested_webpack_require_154__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __nested_webpack_require_154__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __nested_webpack_require_154__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __nested_webpack_require_154__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __nested_webpack_require_154__.p = "/";

/******/  // on error function for async loading
/******/  __nested_webpack_require_154__.oe = function(err) { console.error(err); throw err; };

  var f = __nested_webpack_require_154__(__nested_webpack_require_154__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/components/ammo-constraint.js":
/*!*******************************************!*\
  !*** ./src/components/ammo-constraint.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global Ammo */
const CONSTRAINT = (__webpack_require__(/*! ../constants */ "./src/constants.js").CONSTRAINT);

module.exports = AFRAME.registerComponent("ammo-constraint", {
  multiple: true,

  schema: {
    // Type of constraint.
    type: {
      default: CONSTRAINT.LOCK,
      oneOf: [
        CONSTRAINT.LOCK,
        CONSTRAINT.FIXED,
        CONSTRAINT.SPRING,
        CONSTRAINT.SLIDER,
        CONSTRAINT.HINGE,
        CONSTRAINT.CONE_TWIST,
        CONSTRAINT.POINT_TO_POINT
      ]
    },

    // Target (other) body for the constraint.
    target: { type: "selector" },

    // Offset of the hinge or point-to-point constraint, defined locally in the body. Used for hinge, coneTwist pointToPoint constraints.
    pivot: { type: "vec3" },
    targetPivot: { type: "vec3" },

    // An axis that each body can rotate around, defined locally to that body. Used for hinge constraints.
    axis: { type: "vec3", default: { x: 0, y: 0, z: 1 } },
    targetAxis: { type: "vec3", default: { x: 0, y: 0, z: 1 } },

    // damping & stuffness - used for spring contraints only
    damping: { type: "number", default: 1 },
    stiffness: { type: "number", default: 100 },
  },

  init: function() {
    this.system = this.el.sceneEl.systems.physics;
    this.constraint = null;
  },

  remove: function() {
    if (!this.constraint) return;

    this.system.removeConstraint(this.constraint);
    this.constraint = null;
  },

  update: function() {
    const el = this.el,
      data = this.data;

    this.remove();

    if (!el.body || !data.target.body) {
      (el.body ? data.target : el).addEventListener("body-loaded", this.update.bind(this, {}), { once: true });
      return;
    }

    this.constraint = this.createConstraint();
    this.system.addConstraint(this.constraint);
  },

  /**
   * @return {Ammo.btTypedConstraint}
   */
  createConstraint: function() {
    let constraint;
    const data = this.data,
      body = this.el.body,
      targetBody = data.target.body;

    const bodyTransform = body
      .getCenterOfMassTransform()
      .inverse()
      .op_mul(targetBody.getWorldTransform());
    const targetTransform = new Ammo.btTransform();
    targetTransform.setIdentity();

    switch (data.type) {
      case CONSTRAINT.LOCK: {
        constraint = new Ammo.btGeneric6DofConstraint(body, targetBody, bodyTransform, targetTransform, true);
        const zero = new Ammo.btVector3(0, 0, 0);
        //TODO: allow these to be configurable
        constraint.setLinearLowerLimit(zero);
        constraint.setLinearUpperLimit(zero);
        constraint.setAngularLowerLimit(zero);
        constraint.setAngularUpperLimit(zero);
        Ammo.destroy(zero);
        break;
      }
      //TODO: test and verify all other constraint types
      case CONSTRAINT.FIXED: {
        //btFixedConstraint does not seem to debug render
        bodyTransform.setRotation(body.getWorldTransform().getRotation());
        targetTransform.setRotation(targetBody.getWorldTransform().getRotation());
        constraint = new Ammo.btFixedConstraint(body, targetBody, bodyTransform, targetTransform);
        break;
      }
      case CONSTRAINT.SPRING: {
        constraint = new Ammo.btGeneric6DofSpringConstraint(body, targetBody, bodyTransform, targetTransform, true);

        // Very limited initial implementation of spring constraint.
        // See: https://github.com/n5ro/aframe-physics-system/issues/171
        for (var i in [0,1,2,3,4,5]) {
          constraint.enableSpring(1, true)
          constraint.setStiffness(1, this.data.stiffness)
          constraint.setDamping(1, this.data.damping)
        }
        const upper = new Ammo.btVector3(-1, -1, -1);
        const lower = new Ammo.btVector3(1, 1, 1);
        constraint.setLinearUpperLimit(upper);
        constraint.setLinearLowerLimit(lower)
        Ammo.destroy(upper);
        Ammo.destroy(lower);
        break;
      }
      case CONSTRAINT.SLIDER: {
        //TODO: support setting linear and angular limits
        constraint = new Ammo.btSliderConstraint(body, targetBody, bodyTransform, targetTransform, true);
        constraint.setLowerLinLimit(-1);
        constraint.setUpperLinLimit(1);
        // constraint.setLowerAngLimit();
        // constraint.setUpperAngLimit();
        break;
      }
      case CONSTRAINT.HINGE: {
        const pivot = new Ammo.btVector3(data.pivot.x, data.pivot.y, data.pivot.z);
        const targetPivot = new Ammo.btVector3(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);

        const axis = new Ammo.btVector3(data.axis.x, data.axis.y, data.axis.z);
        const targetAxis = new Ammo.btVector3(data.targetAxis.x, data.targetAxis.y, data.targetAxis.z);

        constraint = new Ammo.btHingeConstraint(body, targetBody, pivot, targetPivot, axis, targetAxis, true);

        Ammo.destroy(pivot);
        Ammo.destroy(targetPivot);
        Ammo.destroy(axis);
        Ammo.destroy(targetAxis);
        break;
      }
      case CONSTRAINT.CONE_TWIST: {
        const pivotTransform = new Ammo.btTransform();
        pivotTransform.setIdentity();
        pivotTransform.getOrigin().setValue(data.pivot.x, data.pivot.y, data.pivot.z);
        const targetPivotTransform = new Ammo.btTransform();
        targetPivotTransform.setIdentity();
        targetPivotTransform.getOrigin().setValue(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);
        constraint = new Ammo.btConeTwistConstraint(body, targetBody, pivotTransform, targetPivotTransform);
        Ammo.destroy(pivotTransform);
        Ammo.destroy(targetPivotTransform);
        break;
      }
      case CONSTRAINT.POINT_TO_POINT: {
        const pivot = new Ammo.btVector3(data.pivot.x, data.pivot.y, data.pivot.z);
        const targetPivot = new Ammo.btVector3(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z);

        constraint = new Ammo.btPoint2PointConstraint(body, targetBody, pivot, targetPivot);

        Ammo.destroy(pivot);
        Ammo.destroy(targetPivot);
        break;
      }
      default:
        throw new Error("[constraint] Unexpected type: " + data.type);
    }

    Ammo.destroy(bodyTransform);
    Ammo.destroy(targetTransform);

    return constraint;
  }
});


/***/ }),

/***/ "./src/components/body/ammo-body.js":
/*!******************************************!*\
  !*** ./src/components/body/ammo-body.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global Ammo,THREE */
const AmmoDebugDrawer = __webpack_require__(/*! ammo-debug-drawer */ "./node_modules/ammo-debug-drawer/AmmoDebugDrawer.js");
const threeToAmmo = __webpack_require__(/*! three-to-ammo */ "./node_modules/three-to-ammo/index.js");
const CONSTANTS = __webpack_require__(/*! ../../constants */ "./src/constants.js"),
  ACTIVATION_STATE = CONSTANTS.ACTIVATION_STATE,
  COLLISION_FLAG = CONSTANTS.COLLISION_FLAG,
  SHAPE = CONSTANTS.SHAPE,
  TYPE = CONSTANTS.TYPE,
  FIT = CONSTANTS.FIT;

const ACTIVATION_STATES = [
  ACTIVATION_STATE.ACTIVE_TAG,
  ACTIVATION_STATE.ISLAND_SLEEPING,
  ACTIVATION_STATE.WANTS_DEACTIVATION,
  ACTIVATION_STATE.DISABLE_DEACTIVATION,
  ACTIVATION_STATE.DISABLE_SIMULATION
];

const RIGID_BODY_FLAGS = {
  NONE: 0,
  DISABLE_WORLD_GRAVITY: 1
};

function almostEqualsVector3(epsilon, u, v) {
  return Math.abs(u.x - v.x) < epsilon && Math.abs(u.y - v.y) < epsilon && Math.abs(u.z - v.z) < epsilon;
}

function almostEqualsBtVector3(epsilon, u, v) {
  return Math.abs(u.x() - v.x()) < epsilon && Math.abs(u.y() - v.y()) < epsilon && Math.abs(u.z() - v.z()) < epsilon;
}

function almostEqualsQuaternion(epsilon, u, v) {
  return (
    (Math.abs(u.x - v.x) < epsilon &&
      Math.abs(u.y - v.y) < epsilon &&
      Math.abs(u.z - v.z) < epsilon &&
      Math.abs(u.w - v.w) < epsilon) ||
    (Math.abs(u.x + v.x) < epsilon &&
      Math.abs(u.y + v.y) < epsilon &&
      Math.abs(u.z + v.z) < epsilon &&
      Math.abs(u.w + v.w) < epsilon)
  );
}

let AmmoBody = {
  schema: {
    loadedEvent: { default: "" },
    mass: { default: 1 },
    gravity: { type: "vec3", default: { x: undefined, y: undefined, z: undefined } },
    linearDamping: { default: 0.01 },
    angularDamping: { default: 0.01 },
    linearSleepingThreshold: { default: 1.6 },
    angularSleepingThreshold: { default: 2.5 },
    angularFactor: { type: "vec3", default: { x: 1, y: 1, z: 1 } },
    activationState: {
      default: ACTIVATION_STATE.ACTIVE_TAG,
      oneOf: ACTIVATION_STATES
    },
    type: { default: "dynamic", oneOf: [TYPE.STATIC, TYPE.DYNAMIC, TYPE.KINEMATIC] },
    emitCollisionEvents: { default: false },
    disableCollision: { default: false },
    collisionFilterGroup: { default: 1 }, //32-bit mask,
    collisionFilterMask: { default: 1 }, //32-bit mask
    scaleAutoUpdate: { default: true },
    restitution: {default: 0} // does not support updates
  },

  /**
   * Initializes a body component, assigning it to the physics system and binding listeners for
   * parsing the elements geometry.
   */
  init: function() {
    this.system = this.el.sceneEl.systems.physics;
    this.shapeComponents = [];

    if (this.data.loadedEvent === "") {
      this.loadedEventFired = true;
    } else {
      this.el.addEventListener(
        this.data.loadedEvent,
        () => {
          this.loadedEventFired = true;
        },
        { once: true }
      );
    }

    if (this.system.initialized && this.loadedEventFired) {
      this.initBody();
    }
  },

  /**
   * Parses an element's geometry and component metadata to create an Ammo body instance for the
   * component.
   */
  initBody: (function() {
    const pos = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    const boundingBox = new THREE.Box3();

    return function() {
      const el = this.el,
        data = this.data;
      const clamp = (num, min, max) => Math.min(Math.max(num, min), max)

      this.localScaling = new Ammo.btVector3();

      const obj = this.el.object3D;
      obj.getWorldPosition(pos);
      obj.getWorldQuaternion(quat);

      this.prevScale = new THREE.Vector3(1, 1, 1);
      this.prevNumChildShapes = 0;

      this.msTransform = new Ammo.btTransform();
      this.msTransform.setIdentity();
      this.rotation = new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w);

      this.msTransform.getOrigin().setValue(pos.x, pos.y, pos.z);
      this.msTransform.setRotation(this.rotation);

      this.motionState = new Ammo.btDefaultMotionState(this.msTransform);

      this.localInertia = new Ammo.btVector3(0, 0, 0);

      this.compoundShape = new Ammo.btCompoundShape(true);

      this.rbInfo = new Ammo.btRigidBodyConstructionInfo(
        data.mass,
        this.motionState,
        this.compoundShape,
        this.localInertia
      );
      this.rbInfo.m_restitution = clamp(this.data.restitution, 0, 1);
      this.body = new Ammo.btRigidBody(this.rbInfo);
      this.body.setActivationState(ACTIVATION_STATES.indexOf(data.activationState) + 1);
      this.body.setSleepingThresholds(data.linearSleepingThreshold, data.angularSleepingThreshold);

      this.body.setDamping(data.linearDamping, data.angularDamping);

      const angularFactor = new Ammo.btVector3(data.angularFactor.x, data.angularFactor.y, data.angularFactor.z);
      this.body.setAngularFactor(angularFactor);
      Ammo.destroy(angularFactor);

      this._updateBodyGravity(data.gravity)

      this.updateCollisionFlags();

      this.el.body = this.body;
      this.body.el = el;

      this.isLoaded = true;

      this.el.emit("body-loaded", { body: this.el.body });

      this._addToSystem();
    };
  })(),

  tick: function() {
    if (this.system.initialized && !this.isLoaded && this.loadedEventFired) {
      this.initBody();
    }
  },

  _updateBodyGravity(gravity) {

    if (gravity.x !== undefined &&
        gravity.y !== undefined &&
        gravity.z !== undefined) {
      const gravityBtVec = new Ammo.btVector3(gravity.x, gravity.y, gravity.z);
      if (!almostEqualsBtVector3(0.001, gravityBtVec, this.system.driver.physicsWorld.getGravity())) {
        this.body.setFlags(RIGID_BODY_FLAGS.DISABLE_WORLD_GRAVITY);
      } else {
        this.body.setFlags(RIGID_BODY_FLAGS.NONE);
      }
      this.body.setGravity(gravityBtVec);
      Ammo.destroy(gravityBtVec);
    }
    else {
      // no per-body gravity specified - just use world gravity
      this.body.setFlags(RIGID_BODY_FLAGS.NONE);
    }
  },

  _updateShapes: (function() {
    const needsPolyhedralInitialization = [SHAPE.HULL, SHAPE.HACD, SHAPE.VHACD];
    return function() {
      let updated = false;

      const obj = this.el.object3D;
      if (this.data.scaleAutoUpdate && this.prevScale && !almostEqualsVector3(0.001, obj.scale, this.prevScale)) {
        this.prevScale.copy(obj.scale);
        updated = true;

        this.localScaling.setValue(this.prevScale.x, this.prevScale.y, this.prevScale.z);
        this.compoundShape.setLocalScaling(this.localScaling);
      }

      if (this.shapeComponentsChanged) {
        this.shapeComponentsChanged = false;
        updated = true;
        for (let i = 0; i < this.shapeComponents.length; i++) {
          const shapeComponent = this.shapeComponents[i];
          if (shapeComponent.getShapes().length === 0) {
            this._createCollisionShape(shapeComponent);
          }
          const collisionShapes = shapeComponent.getShapes();
          for (let j = 0; j < collisionShapes.length; j++) {
            const collisionShape = collisionShapes[j];
            if (!collisionShape.added) {
              this.compoundShape.addChildShape(collisionShape.localTransform, collisionShape);
              collisionShape.added = true;
            }
          }
        }

        if (this.data.type === TYPE.DYNAMIC) {
          this.updateMass();
        }

        this.system.driver.updateBody(this.body);
      }

      //call initializePolyhedralFeatures for hull shapes if debug is turned on and/or scale changes
      if (this.system.debug && (updated || !this.polyHedralFeaturesInitialized)) {
        for (let i = 0; i < this.shapeComponents.length; i++) {
          const collisionShapes = this.shapeComponents[i].getShapes();
          for (let j = 0; j < collisionShapes.length; j++) {
            const collisionShape = collisionShapes[j];
            if (needsPolyhedralInitialization.indexOf(collisionShape.type) !== -1) {
              collisionShape.initializePolyhedralFeatures(0);
            }
          }
        }
        this.polyHedralFeaturesInitialized = true;
      }
    };
  })(),

  _createCollisionShape: function(shapeComponent) {
    const data = shapeComponent.data;
    const vertices = [];
    const matrices = [];
    const indexes = [];

    const root = shapeComponent.el.object3D;
    const matrixWorld = root.matrixWorld;

    threeToAmmo.iterateGeometries(root, data, (vertexArray, matrixArray, indexArray) => {
      vertices.push(vertexArray);
      matrices.push(matrixArray);
      indexes.push(indexArray);
    });

    const collisionShapes = threeToAmmo.createCollisionShapes(vertices, matrices, indexes, matrixWorld.elements, data);
    shapeComponent.addShapes(collisionShapes);
    return;
  },

  /**
   * Registers the component with the physics system.
   */
  play: function() {
    if (this.isLoaded) {
      this._addToSystem();
    }
  },

  _addToSystem: function() {
    if (!this.addedToSystem) {
      this.system.addBody(this.body, this.data.collisionFilterGroup, this.data.collisionFilterMask);

      if (this.data.emitCollisionEvents) {
        this.system.driver.addEventListener(this.body);
      }

      this.system.addComponent(this);
      this.addedToSystem = true;
    }
  },

  /**
   * Unregisters the component with the physics system.
   */
  pause: function() {
    if (this.addedToSystem) {
      this.system.removeComponent(this);
      this.system.removeBody(this.body);
      this.addedToSystem = false;
    }
  },

  /**
   * Updates the rigid body instance, where possible.
   */
  update: function(prevData) {
    if (this.isLoaded) {
      if (!this.hasUpdated) {
        //skip the first update
        this.hasUpdated = true;
        return;
      }

      const data = this.data;

      if (prevData.type !== data.type || prevData.disableCollision !== data.disableCollision) {
        this.updateCollisionFlags();
      }

      if (prevData.activationState !== data.activationState) {
        this.body.forceActivationState(ACTIVATION_STATES.indexOf(data.activationState) + 1);
        if (data.activationState === ACTIVATION_STATE.ACTIVE_TAG) {
          this.body.activate(true);
        }
      }

      if (
        prevData.collisionFilterGroup !== data.collisionFilterGroup ||
        prevData.collisionFilterMask !== data.collisionFilterMask
      ) {
        const broadphaseProxy = this.body.getBroadphaseProxy();
        broadphaseProxy.set_m_collisionFilterGroup(data.collisionFilterGroup);
        broadphaseProxy.set_m_collisionFilterMask(data.collisionFilterMask);
        this.system.driver.broadphase
          .getOverlappingPairCache()
          .removeOverlappingPairsContainingProxy(broadphaseProxy, this.system.driver.dispatcher);
      }

      if (prevData.linearDamping != data.linearDamping || prevData.angularDamping != data.angularDamping) {
        this.body.setDamping(data.linearDamping, data.angularDamping);
      }

      if (!almostEqualsVector3(0.001, prevData.gravity, data.gravity)) {
        this._updateBodyGravity(data.gravity)
      }

      if (
        prevData.linearSleepingThreshold != data.linearSleepingThreshold ||
        prevData.angularSleepingThreshold != data.angularSleepingThreshold
      ) {
        this.body.setSleepingThresholds(data.linearSleepingThreshold, data.angularSleepingThreshold);
      }

      if (!almostEqualsVector3(0.001, prevData.angularFactor, data.angularFactor)) {
        const angularFactor = new Ammo.btVector3(data.angularFactor.x, data.angularFactor.y, data.angularFactor.z);
        this.body.setAngularFactor(angularFactor);
        Ammo.destroy(angularFactor);
      }

      if (prevData.restitution != data.restitution ) {
        console.warn("ammo-body restitution cannot be updated from its initial value.")
      }

      //TODO: support dynamic update for other properties
    }
  },

  /**
   * Removes the component and all physics and scene side effects.
   */
  remove: function() {
    if (this.triMesh) Ammo.destroy(this.triMesh);
    if (this.localScaling) Ammo.destroy(this.localScaling);
    if (this.compoundShape) Ammo.destroy(this.compoundShape);
    if (this.body) {
      Ammo.destroy(this.body);
      delete this.body;
    }
    Ammo.destroy(this.rbInfo);
    Ammo.destroy(this.msTransform);
    Ammo.destroy(this.motionState);
    Ammo.destroy(this.localInertia);
    Ammo.destroy(this.rotation);
  },

  beforeStep: function() {
    this._updateShapes();
    // Note that since static objects don't move,
    // we don't sync them to physics on a routine basis.
    if (this.data.type === TYPE.KINEMATIC) {
      this.syncToPhysics();
    }
  },

  step: function() {
    if (this.data.type === TYPE.DYNAMIC) {
      this.syncFromPhysics();
    }
  },

  /**
   * Updates the rigid body's position, velocity, and rotation, based on the scene.
   */
  syncToPhysics: (function() {
    const q = new THREE.Quaternion();
    const v = new THREE.Vector3();
    const q2 = new THREE.Vector3();
    const v2 = new THREE.Vector3();
    return function() {
      const el = this.el,
        parentEl = el.parentEl,
        body = this.body;

      if (!body) return;

      this.motionState.getWorldTransform(this.msTransform);

      if (parentEl.isScene) {
        v.copy(el.object3D.position);
        q.copy(el.object3D.quaternion);
      } else {
        el.object3D.getWorldPosition(v);
        el.object3D.getWorldQuaternion(q);
      }

      const position = this.msTransform.getOrigin();
      v2.set(position.x(), position.y(), position.z());

      const quaternion = this.msTransform.getRotation();
      q2.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());

      if (!almostEqualsVector3(0.001, v, v2) || !almostEqualsQuaternion(0.001, q, q2)) {
        if (!this.body.isActive()) {
          this.body.activate(true);
        }
        this.msTransform.getOrigin().setValue(v.x, v.y, v.z);
        this.rotation.setValue(q.x, q.y, q.z, q.w);
        this.msTransform.setRotation(this.rotation);
        this.motionState.setWorldTransform(this.msTransform);

        if (this.data.type === TYPE.STATIC) {
          this.body.setCenterOfMassTransform(this.msTransform);
        }
      }
    };
  })(),

  /**
   * Updates the scene object's position and rotation, based on the physics simulation.
   */
  syncFromPhysics: (function() {
    const v = new THREE.Vector3(),
      q1 = new THREE.Quaternion(),
      q2 = new THREE.Quaternion();
    return function() {
      this.motionState.getWorldTransform(this.msTransform);
      const position = this.msTransform.getOrigin();
      const quaternion = this.msTransform.getRotation();

      const el = this.el,
        body = this.body;

      // For the parent, prefer to use the THHREE.js scene graph parent (if it can be determined)
      // and only use the HTML scene graph parent as a fallback.
      // Usually these are the same, but there are various cases where it's useful to modify the THREE.js
      // scene graph so that it deviates from the HTML.
      // In these cases the THREE.js scene graph should be considered the definitive reference in terms
      // of object positioning etc.
      // For specific examples, and more discussion, see:
      // https://github.com/c-frame/aframe-physics-system/pull/1#issuecomment-1264686433
      const parentEl = el.object3D.parent.el ? el.object3D.parent.el : el.parentEl;

      if (!body) return;
      if (!parentEl) return;

      if (parentEl.isScene) {
        el.object3D.position.set(position.x(), position.y(), position.z());
        el.object3D.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());
      } else {
        q1.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());
        parentEl.object3D.getWorldQuaternion(q2);
        q1.multiply(q2.invert());
        el.object3D.quaternion.copy(q1);

        v.set(position.x(), position.y(), position.z());
        parentEl.object3D.worldToLocal(v);
        el.object3D.position.copy(v);
      }
    };
  })(),

  addShapeComponent: function(shapeComponent) {
    if (shapeComponent.data.type === SHAPE.MESH && this.data.type !== TYPE.STATIC) {
      console.warn("non-static mesh colliders not supported");
      return;
    }

    this.shapeComponents.push(shapeComponent);
    this.shapeComponentsChanged = true;
  },

  removeShapeComponent: function(shapeComponent) {
    const index = this.shapeComponents.indexOf(shapeComponent);
    if (this.compoundShape && index !== -1 && this.body) {
      const shapes = shapeComponent.getShapes();
      for (var i = 0; i < shapes.length; i++) {
        this.compoundShape.removeChildShape(shapes[i]);
      }
      this.shapeComponentsChanged = true;
      this.shapeComponents.splice(index, 1);
    }
  },

  updateMass: function() {
    const shape = this.body.getCollisionShape();
    const mass = this.data.type === TYPE.DYNAMIC ? this.data.mass : 0;
    shape.calculateLocalInertia(mass, this.localInertia);
    this.body.setMassProps(mass, this.localInertia);
    this.body.updateInertiaTensor();
  },

  updateCollisionFlags: function() {
    let flags = this.data.disableCollision ? 4 : 0;
    switch (this.data.type) {
      case TYPE.STATIC:
        flags |= COLLISION_FLAG.STATIC_OBJECT;
        break;
      case TYPE.KINEMATIC:
        flags |= COLLISION_FLAG.KINEMATIC_OBJECT;
        break;
      default:
        this.body.applyGravity();
        break;
    }
    this.body.setCollisionFlags(flags);

    this.updateMass();

    // TODO: enable CCD if dynamic?
    // this.body.setCcdMotionThreshold(0.001);
    // this.body.setCcdSweptSphereRadius(0.001);

    this.system.driver.updateBody(this.body);
  },

  getVelocity: function() {
    return this.body.getLinearVelocity();
  }
};

module.exports.definition = AmmoBody;
module.exports.Component = AFRAME.registerComponent("ammo-body", AmmoBody);


/***/ }),

/***/ "./src/components/body/body.js":
/*!*************************************!*\
  !*** ./src/components/body/body.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
const { threeToCannon, ShapeType } = __webpack_require__(/*! three-to-cannon */ "./node_modules/three-to-cannon/dist/three-to-cannon.cjs");
const identityQuaternion = new THREE.Quaternion()

function mesh2shape (object, options) {

  const result = threeToCannon(object, options);
  return result;
}

__webpack_require__(/*! ../../../lib/CANNON-shape2mesh */ "./lib/CANNON-shape2mesh.js");

var Body = {
  dependencies: ['velocity'],

  schema: {
    mass: {default: 5, if: {type: 'dynamic'}},
    linearDamping:  { default: 0.01, if: {type: 'dynamic'}},
    angularDamping: { default: 0.01,  if: {type: 'dynamic'}},
    shape: {default: 'auto', oneOf: ['auto', 'box', 'cylinder', 'sphere', 'hull', 'mesh', 'none']},
    cylinderAxis: {default: 'y', oneOf: ['x', 'y', 'z']},
    sphereRadius: {default: NaN},
    type: {default: 'dynamic', oneOf: ['static', 'dynamic']}
  },

  /**
   * Initializes a body component, assigning it to the physics system and binding listeners for
   * parsing the elements geometry.
   */
  init: function () {
    this.system = this.el.sceneEl.systems.physics;

    if (this.el.sceneEl.hasLoaded) {
      this.initBody();
    } else {
      this.el.sceneEl.addEventListener('loaded', this.initBody.bind(this));
    }
  },

  /**
   * Parses an element's geometry and component metadata to create a CANNON.Body instance for the
   * component.
   */
  initBody: function () {
    var el = this.el,
        data = this.data;

    var obj = this.el.object3D;
    var pos = obj.position;
    var quat = obj.quaternion;

    this.body = new CANNON.Body({
      mass: data.type === 'static' ? 0 : data.mass || 0,
      material: this.system.getMaterial('defaultMaterial'),
      position: new CANNON.Vec3(pos.x, pos.y, pos.z),
      quaternion: new CANNON.Quaternion(quat.x, quat.y, quat.z, quat.w),
      linearDamping: data.linearDamping,
      angularDamping: data.angularDamping,
      type: data.type === 'dynamic' ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC,
    });

    // Matrix World must be updated at root level, if scale is to be applied  updateMatrixWorld()
    // only checks an object's parent, not the rest of the ancestors. Hence, a wrapping entity with
    // scale="0.5 0.5 0.5" will be ignored.
    // Reference: https://github.com/mrdoob/three.js/blob/master/src/core/Object3D.js#L511-L541
    // Potential fix: https://github.com/mrdoob/three.js/pull/7019
    this.el.object3D.updateMatrixWorld(true);

    if(data.shape !== 'none') {
      var options = data.shape === 'auto' ? undefined : AFRAME.utils.extend({}, this.data, {
        type: ShapeType[data.shape.toUpperCase()]
      });

      const shapeInfo = mesh2shape(this.el.object3D, options);
      let shape, offset, orientation;
      if (shapeInfo) {
        ({ shape, offset, orientation } = shapeInfo);
      }

      if (!shape) {
        el.addEventListener('object3dset', this.initBody.bind(this));
        return;
      }

      this.body.addShape(shape, offset, orientation);

      // Show wireframe
      if (this.system.debug) {
        this.shouldUpdateWireframe = true;
      }

      this.hasShape = true;
    }

    this.el.body = this.body;
    this.body.el = el;

    // If component wasn't initialized when play() was called, finish up.
    if (this.isPlaying) {
      this._play();
    }

    if (this.hasShape) {
      this.el.emit('body-loaded', {body: this.el.body});
    }
  },

  addShape: function(shape, offset, orientation) {
    if (this.data.shape !== 'none') {
      console.warn('shape can only be added if shape property is none');
      return;
    }

    if (!shape) {
      console.warn('shape cannot be null');
      return;
    }

    if (!this.body) {
      console.warn('shape cannot be added before body is loaded');
      return;
    }
    this.body.addShape(shape, offset, orientation);

    if (this.system.debug) {
      this.shouldUpdateWireframe = true;
    }

    this.shouldUpdateBody = true;
  },

  tick: function () {
    if (this.shouldUpdateBody) {
      
      // Calling play will result in the object being re-added to the
      // physics system with the updated body / shape data.
      // But we mustn't add it twice, so any previously loaded body should be paused first.
      this._pause();
      this.hasShape = true;
      this._play()

      this.el.emit('body-loaded', {body: this.el.body});
      this.shouldUpdateBody = false;
    }

    if (this.shouldUpdateWireframe) {
      this.createWireframe(this.body);
      this.shouldUpdateWireframe = false;
    }
  },

  /**
   * Registers the component with the physics system, if ready.
   */
  play: function () {
    this._play();
  },

  /**
   * Internal helper to register component with physics system.
   */
  _play: function () {

    if (!this.hasShape) return;

    this.syncToPhysics();
    this.system.addComponent(this);
    this.system.addBody(this.body);
    if (this.wireframe) this.el.sceneEl.object3D.add(this.wireframe);
  },

  /**
   * Unregisters the component with the physics system.
   */
  pause: function () {
    this._pause();
  },

  _pause: function () {

    if (!this.hasShape) return;

    this.system.removeComponent(this);
    if (this.body) this.system.removeBody(this.body);
    if (this.wireframe) this.el.sceneEl.object3D.remove(this.wireframe);
  },

  /**
   * Updates the CANNON.Body instance, where possible.
   */
  update: function (prevData) {
    if (!this.body) return;

    var data = this.data;

    if (prevData.type != undefined && data.type != prevData.type) {
      this.body.type = data.type === 'dynamic' ? CANNON.Body.DYNAMIC : CANNON.Body.STATIC;
    }

    this.body.mass = data.mass || 0;
    if (data.type === 'dynamic') {
      this.body.linearDamping = data.linearDamping;
      this.body.angularDamping = data.angularDamping;
    }
    if (data.mass !== prevData.mass) {
      this.body.updateMassProperties();
    }
    if (this.body.updateProperties) this.body.updateProperties();
  },

  /**
   * Removes the component and all physics and scene side effects.
   */
  remove: function () {
    if (this.body) {
      delete this.body.el;
      delete this.body;
    }
    delete this.el.body;
    delete this.wireframe;
  },

  beforeStep: function () {
    if (this.body.mass === 0) {
      this.syncToPhysics();
    }
  },

  step: function () {
    if (this.body.mass !== 0) {
      this.syncFromPhysics();
    }
  },

  /**
   * Creates a wireframe for the body, for debugging.
   * TODO(donmccurdy)  Refactor this into a standalone utility or component.
   * @param  {CANNON.Body} body
   * @param  {CANNON.Shape} shape
   */
  createWireframe: function (body) {
    if (this.wireframe) {
      this.el.sceneEl.object3D.remove(this.wireframe);
      delete this.wireframe;
    }
    this.wireframe = new THREE.Object3D();
    this.el.sceneEl.object3D.add(this.wireframe);

    var offset, mesh;
    var orientation = new THREE.Quaternion();
    for (var i = 0; i < this.body.shapes.length; i++)
    {
      offset = this.body.shapeOffsets[i],
      orientation.copy(this.body.shapeOrientations[i]),
      mesh = CANNON.shape2mesh(this.body).children[i];

      var wireframe = new THREE.LineSegments(
        new THREE.EdgesGeometry(mesh.geometry),
        new THREE.LineBasicMaterial({color: 0xff0000})
      );

      if (offset) {
        wireframe.position.copy(offset);
      }

      if (orientation) {
        wireframe.quaternion.copy(orientation);
      }

      this.wireframe.add(wireframe);
    }

    this.syncWireframe();
  },

  /**
   * Updates the debugging wireframe's position and rotation.
   */
  syncWireframe: function () {
    var offset,
        wireframe = this.wireframe;

    if (!this.wireframe) return;

    // Apply rotation. If the shape required custom orientation, also apply
    // that on the wireframe.
    wireframe.quaternion.copy(this.body.quaternion);
    if (wireframe.orientation) {
      wireframe.quaternion.multiply(wireframe.orientation);
    }

    // Apply position. If the shape required custom offset, also apply that on
    // the wireframe.
    wireframe.position.copy(this.body.position);
    if (wireframe.offset) {
      offset = wireframe.offset.clone().applyQuaternion(wireframe.quaternion);
      wireframe.position.add(offset);
    }

    wireframe.updateMatrix();
  },

  /**
   * Updates the CANNON.Body instance's position, velocity, and rotation, based on the scene.
   */
  syncToPhysics: (function () {
    var q =  new THREE.Quaternion(),
        v = new THREE.Vector3();
    return function () {
      var el = this.el,
          parentEl = el.parentEl,
          body = this.body;

      if (!body) return;

      if (el.components.velocity) body.velocity.copy(el.getAttribute('velocity'));

      if (parentEl.isScene) {
        body.quaternion.copy(el.object3D.quaternion);
        body.position.copy(el.object3D.position);
      } else {
        el.object3D.getWorldQuaternion(q);
        body.quaternion.copy(q);
        el.object3D.getWorldPosition(v);
        body.position.copy(v);
      }

      if (this.body.updateProperties) this.body.updateProperties();
      if (this.wireframe) this.syncWireframe();
    };
  }()),

  /**
   * Updates the scene object's position and rotation, based on the physics simulation.
   */
  syncFromPhysics: (function () {
    var v = new THREE.Vector3(),
        q1 = new THREE.Quaternion(),
        q2 = new THREE.Quaternion();
    return function () {
      var el = this.el,
          parentEl = el.parentEl,
          body = this.body;

      if (!body) return;
      if (!parentEl) return;

      if (parentEl.isScene) {
        el.object3D.quaternion.copy(body.quaternion);
        el.object3D.position.copy(body.position);
      } else {
        q1.copy(body.quaternion);
        parentEl.object3D.getWorldQuaternion(q2);
        q1.premultiply(q2.invert());
        el.object3D.quaternion.copy(q1);

        v.copy(body.position);
        parentEl.object3D.worldToLocal(v);
        el.object3D.position.copy(v);
      }

      if (this.wireframe) this.syncWireframe();
    };
  }())
};

module.exports.definition = Body;
module.exports.Component = AFRAME.registerComponent('body', Body);


/***/ }),

/***/ "./src/components/body/dynamic-body.js":
/*!*********************************************!*\
  !*** ./src/components/body/dynamic-body.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Body = __webpack_require__(/*! ./body */ "./src/components/body/body.js");

/**
 * Dynamic body.
 *
 * Moves according to physics simulation, and may collide with other objects.
 */
var DynamicBody = AFRAME.utils.extend({}, Body.definition);

module.exports = AFRAME.registerComponent('dynamic-body', DynamicBody);


/***/ }),

/***/ "./src/components/body/static-body.js":
/*!********************************************!*\
  !*** ./src/components/body/static-body.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Body = __webpack_require__(/*! ./body */ "./src/components/body/body.js");

/**
 * Static body.
 *
 * Solid body with a fixed position. Unaffected by gravity and collisions, but
 * other objects may collide with it.
 */
var StaticBody = AFRAME.utils.extend({}, Body.definition);

StaticBody.schema = AFRAME.utils.extend({}, Body.definition.schema, {
  type: {default: 'static', oneOf: ['static', 'dynamic']},
  mass: {default: 0}
});

module.exports = AFRAME.registerComponent('static-body', StaticBody);


/***/ }),

/***/ "./src/components/constraint.js":
/*!**************************************!*\
  !*** ./src/components/constraint.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");

module.exports = AFRAME.registerComponent("constraint", {
  multiple: true,

  schema: {
    // Type of constraint.
    type: { default: "lock", oneOf: ["coneTwist", "distance", "hinge", "lock", "pointToPoint"] },

    // Target (other) body for the constraint.
    target: { type: "selector" },

    // Maximum force that should be applied to constraint the bodies.
    maxForce: { default: 1e6, min: 0 },

    // If true, bodies can collide when they are connected.
    collideConnected: { default: true },

    // Wake up bodies when connected.
    wakeUpBodies: { default: true },

    // The distance to be kept between the bodies. If 0, will be set to current distance.
    distance: { default: 0, min: 0 },

    // Offset of the hinge or point-to-point constraint, defined locally in the body.
    pivot: { type: "vec3" },
    targetPivot: { type: "vec3" },

    // An axis that each body can rotate around, defined locally to that body.
    axis: { type: "vec3", default: { x: 0, y: 0, z: 1 } },
    targetAxis: { type: "vec3", default: { x: 0, y: 0, z: 1 } }
  },

  init: function() {
    this.system = this.el.sceneEl.systems.physics;
    this.constraint = /* {CANNON.Constraint} */ null;
  },

  remove: function() {
    if (!this.constraint) return;

    this.system.removeConstraint(this.constraint);
    this.constraint = null;
  },

  update: function() {
    var el = this.el,
      data = this.data;

    this.remove();

    if (!el.body || !data.target.body) {
      (el.body ? data.target : el).addEventListener("body-loaded", this.update.bind(this, {}));
      return;
    }

    this.constraint = this.createConstraint();
    this.system.addConstraint(this.constraint);
  },

  /**
   * Creates a new constraint, given current component data. The CANNON.js constructors are a bit
   * different for each constraint type. A `.type` property is added to each constraint, because
   * `instanceof` checks are not reliable for some types. These types are needed for serialization.
   * @return {CANNON.Constraint}
   */
  createConstraint: function() {
    var constraint,
      data = this.data,
      pivot = new CANNON.Vec3(data.pivot.x, data.pivot.y, data.pivot.z),
      targetPivot = new CANNON.Vec3(data.targetPivot.x, data.targetPivot.y, data.targetPivot.z),
      axis = new CANNON.Vec3(data.axis.x, data.axis.y, data.axis.z),
      targetAxis = new CANNON.Vec3(data.targetAxis.x, data.targetAxis.y, data.targetAxis.z);

    var constraint;

    switch (data.type) {
      case "lock":
        constraint = new CANNON.LockConstraint(this.el.body, data.target.body, { maxForce: data.maxForce });
        constraint.type = "LockConstraint";
        break;

      case "distance":
        constraint = new CANNON.DistanceConstraint(this.el.body, data.target.body, data.distance, data.maxForce);
        constraint.type = "DistanceConstraint";
        break;

      case "hinge":
        constraint = new CANNON.HingeConstraint(this.el.body, data.target.body, {
          pivotA: pivot,
          pivotB: targetPivot,
          axisA: axis,
          axisB: targetAxis,
          maxForce: data.maxForce
        });
        constraint.type = "HingeConstraint";
        break;

      case "coneTwist":
        constraint = new CANNON.ConeTwistConstraint(this.el.body, data.target.body, {
          pivotA: pivot,
          pivotB: targetPivot,
          axisA: axis,
          axisB: targetAxis,
          maxForce: data.maxForce
        });
        constraint.type = "ConeTwistConstraint";
        break;

      case "pointToPoint":
        constraint = new CANNON.PointToPointConstraint(
          this.el.body,
          pivot,
          data.target.body,
          targetPivot,
          data.maxForce
        );
        constraint.type = "PointToPointConstraint";
        break;

      default:
        throw new Error("[constraint] Unexpected type: " + data.type);
    }

    constraint.collideConnected = data.collideConnected;
    return constraint;
  }
});


/***/ }),

/***/ "./src/components/math/index.js":
/*!**************************************!*\
  !*** ./src/components/math/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  'velocity':   __webpack_require__(/*! ./velocity */ "./src/components/math/velocity.js"),

  registerAll: function (AFRAME) {
    if (this._registered) return;

    AFRAME = AFRAME || window.AFRAME;

    if (!AFRAME.components['velocity'])    AFRAME.registerComponent('velocity',   this.velocity);

    this._registered = true;
  }
};


/***/ }),

/***/ "./src/components/math/velocity.js":
/*!*****************************************!*\
  !*** ./src/components/math/velocity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Velocity, in m/s.
 */
module.exports = AFRAME.registerComponent('velocity', {
  schema: {type: 'vec3'},

  init: function () {
    this.system = this.el.sceneEl.systems.physics;

    if (this.system) {
      this.system.addComponent(this);
    }
  },

  remove: function () {
    if (this.system) {
      this.system.removeComponent(this);
    }
  },

  tick: function (t, dt) {
    if (!dt) return;
    if (this.system) return;
    this.afterStep(t, dt);
  },

  afterStep: function (t, dt) {
    if (!dt) return;

    var physics = this.el.sceneEl.systems.physics || {data: {maxInterval: 1 / 60}},

    // TODO - There's definitely a bug with getComputedAttribute and el.data.
    velocity = this.el.getAttribute('velocity') || {x: 0, y: 0, z: 0},
    position = this.el.object3D.position || {x: 0, y: 0, z: 0};

    dt = Math.min(dt, physics.data.maxInterval * 1000);

    this.el.object3D.position.set(
      position.x + velocity.x * dt / 1000,
      position.y + velocity.y * dt / 1000,
      position.z + velocity.z * dt / 1000
    );
  }
});


/***/ }),

/***/ "./src/components/shape/ammo-shape.js":
/*!********************************************!*\
  !*** ./src/components/shape/ammo-shape.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global Ammo,THREE */
const threeToAmmo = __webpack_require__(/*! three-to-ammo */ "./node_modules/three-to-ammo/index.js");
const CONSTANTS = __webpack_require__(/*! ../../constants */ "./src/constants.js"),
  SHAPE = CONSTANTS.SHAPE,
  FIT = CONSTANTS.FIT;

var AmmoShape = {
  schema: {
    type: {
      default: SHAPE.HULL,
      oneOf: [
        SHAPE.BOX,
        SHAPE.CYLINDER,
        SHAPE.SPHERE,
        SHAPE.CAPSULE,
        SHAPE.CONE,
        SHAPE.HULL,
        SHAPE.HACD,
        SHAPE.VHACD,
        SHAPE.MESH,
        SHAPE.HEIGHTFIELD
      ]
    },
    fit: { default: FIT.ALL, oneOf: [FIT.ALL, FIT.MANUAL] },
    halfExtents: { type: "vec3", default: { x: 1, y: 1, z: 1 } },
    minHalfExtent: { default: 0 },
    maxHalfExtent: { default: Number.POSITIVE_INFINITY },
    sphereRadius: { default: NaN },
    cylinderAxis: { default: "y", oneOf: ["x", "y", "z"] },
    margin: { default: 0.01 },
    offset: { type: "vec3", default: { x: 0, y: 0, z: 0 } },
    orientation: { type: "vec4", default: { x: 0, y: 0, z: 0, w: 1 } },
    heightfieldData: { default: [] },
    heightfieldDistance: { default: 1 },
    includeInvisible: { default: false }
  },

  multiple: true,

  init: function() {
    if (this.data.fit !== FIT.MANUAL) {
      if (this.el.object3DMap.mesh) {
	this.mesh = this.el.object3DMap.mesh;
      } else {
	const self = this;
	this.el.addEventListener("object3dset", function (e) {
	  if (e.detail.type === "mesh") {
	    self.init();
	  }
	});
	console.log("Cannot use FIT.ALL without object3DMap.mesh. Waiting for it to be set.");
        return;
      }
    }

    this.system = this.el.sceneEl.systems.physics;
    this.collisionShapes = [];

    let bodyEl = this.el;
    this.body = bodyEl.components["ammo-body"] || null;
    while (!this.body && bodyEl.parentNode != this.el.sceneEl) {
      bodyEl = bodyEl.parentNode;
      if (bodyEl.components["ammo-body"]) {
        this.body = bodyEl.components["ammo-body"];
      }
    }
    if (!this.body) {
      console.warn("body not found");
      return;
    }
    this.body.addShapeComponent(this);
  },

  getMesh: function() {
    return this.mesh || null;
  },

  addShapes: function(collisionShapes) {
    this.collisionShapes = collisionShapes;
  },

  getShapes: function() {
    return this.collisionShapes;
  },

  remove: function() {
    if (!this.body) {
      return;
    }

    this.body.removeShapeComponent(this);

    while (this.collisionShapes.length > 0) {
      const collisionShape = this.collisionShapes.pop();
      collisionShape.destroy();
      Ammo.destroy(collisionShape.localTransform);
    }
  }
};

module.exports.definition = AmmoShape;
module.exports.Component = AFRAME.registerComponent("ammo-shape", AmmoShape);


/***/ }),

/***/ "./src/components/shape/shape.js":
/*!***************************************!*\
  !*** ./src/components/shape/shape.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");

var Shape = {
  schema: {
    shape: {default: 'box', oneOf: ['box', 'sphere', 'cylinder']},
    offset: {type: 'vec3', default: {x: 0, y: 0, z: 0}},
    orientation: {type: 'vec4', default: {x: 0, y: 0, z: 0, w: 1}},

    // sphere
    radius: {type: 'number', default: 1, if: {shape: ['sphere']}},

    // box
    halfExtents: {type: 'vec3', default: {x: 0.5, y: 0.5, z: 0.5}, if: {shape: ['box']}},
    
    // cylinder
    radiusTop: {type: 'number', default: 1, if: {shape: ['cylinder']}},
    radiusBottom: {type: 'number', default: 1, if: {shape: ['cylinder']}},
    height: {type: 'number', default: 1, if: {shape: ['cylinder']}},
    numSegments: {type: 'int', default: 8, if: {shape: ['cylinder']}}
  },

  multiple: true,

  init: function() {
    if (this.el.sceneEl.hasLoaded) {
      this.initShape();
    } else {
      this.el.sceneEl.addEventListener('loaded', this.initShape.bind(this));
    }
  },

  initShape: function() {
    this.bodyEl = this.el;
    var bodyType = this._findType(this.bodyEl);
    var data = this.data;

    while (!bodyType && this.bodyEl.parentNode != this.el.sceneEl) {
      this.bodyEl = this.bodyEl.parentNode;
      bodyType = this._findType(this.bodyEl);
    }

    if (!bodyType) {
      console.warn('body not found');
      return;
    }

    var scale = new THREE.Vector3();
    this.bodyEl.object3D.getWorldScale(scale);
    var shape, offset, orientation;

    if (data.hasOwnProperty('offset')) {
      offset = new CANNON.Vec3(
        data.offset.x * scale.x, 
        data.offset.y * scale.y, 
        data.offset.z * scale.z
      );
    }

    if (data.hasOwnProperty('orientation')) {
      orientation = new CANNON.Quaternion();
      orientation.copy(data.orientation);
    }

    switch(data.shape) {
      case 'sphere':
        shape = new CANNON.Sphere(data.radius * scale.x);
        break;
      case 'box':
        var halfExtents = new CANNON.Vec3(
          data.halfExtents.x * scale.x, 
          data.halfExtents.y * scale.y, 
          data.halfExtents.z * scale.z
        );
        shape = new CANNON.Box(halfExtents);
        break;
      case 'cylinder':
        shape = new CANNON.Cylinder(
          data.radiusTop * scale.x, 
          data.radiusBottom * scale.x, 
          data.height * scale.y, 
          data.numSegments
        );

        //rotate by 90 degrees similar to mesh2shape:createCylinderShape
        var quat = new CANNON.Quaternion();
        quat.setFromEuler(90 * THREE.MathUtils.DEG2RAD, 0, 0, 'XYZ').normalize();
        orientation.mult(quat, orientation);
        break;
      default:
          console.warn(data.shape + ' shape not supported');
        return;
    }

    if (this.bodyEl.body) {
      this.bodyEl.components[bodyType].addShape(shape, offset, orientation);
    } else {
      this.bodyEl.addEventListener('body-loaded', function() {
        this.bodyEl.components[bodyType].addShape(shape, offset, orientation);
      }, {once: true});
    }
  },

  _findType: function(el) {
    if (el.hasAttribute('body')) {
      return 'body';
    } else if (el.hasAttribute('dynamic-body')) {
      return 'dynamic-body';
    } else if (el.hasAttribute('static-body')) {
      return'static-body';
    }
    return null;
  },

  remove: function() {
    if (this.bodyEl.parentNode) {
      console.warn('removing shape component not currently supported');
    }
  }
};

module.exports.definition = Shape;
module.exports.Component = AFRAME.registerComponent('shape', Shape);


/***/ }),

/***/ "./src/components/spring.js":
/*!**********************************!*\
  !*** ./src/components/spring.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");

module.exports = AFRAME.registerComponent('spring', {

  multiple: true,

  schema: {
    // Target (other) body for the constraint.
    target: {type: 'selector'},

    // Length of the spring, when no force acts upon it.
    restLength: {default: 1, min: 0},

    // How much will the spring suppress the force.
    stiffness: {default: 100, min: 0},

    // Stretch factor of the spring.
    damping: {default: 1, min: 0},

    // Offsets.
    localAnchorA: {type: 'vec3', default: {x: 0, y: 0, z: 0}},
    localAnchorB: {type: 'vec3', default: {x: 0, y: 0, z: 0}},
  },

  init: function() {
    this.system = this.el.sceneEl.systems.physics;
    this.system.addComponent(this);
    this.isActive = true;
    this.spring = /* {CANNON.Spring} */ null;
  },

  update: function(oldData) {
    var el = this.el;
    var data = this.data;

    if (!data.target) {
      console.warn('Spring: invalid target specified.');
      return; 
    }
    
    // wait until the CANNON bodies is created and attached
    if (!el.body || !data.target.body) {
      (el.body ? data.target : el).addEventListener('body-loaded', this.update.bind(this, {}));
      return;
    }

    // create the spring if necessary
    this.createSpring();
    // apply new data to the spring
    this.updateSpring(oldData);
  },

  updateSpring: function(oldData) {
    if (!this.spring) {
      console.warn('Spring: Component attempted to change spring before its created. No changes made.');
      return;
    } 
    var data = this.data;
    var spring = this.spring;

    // Cycle through the schema and check if an attribute has changed.
    // if so, apply it to the spring
    Object.keys(data).forEach(function(attr) {
      if (data[attr] !== oldData[attr]) {
        if (attr === 'target') {
          // special case for the target selector
          spring.bodyB = data.target.body;
          return;
        }
        spring[attr] = data[attr];
      }
    })
  },

  createSpring: function() {
    if (this.spring) return; // no need to create a new spring
    this.spring = new CANNON.Spring(this.el.body);
  },

  // If the spring is valid, update the force each tick the physics are calculated
  step: function(t, dt) {
    return this.spring && this.isActive ? this.spring.applyForce() : void 0;
  },

  // resume updating the force when component upon calling play()
  play: function() {
    this.isActive = true;
  },

  // stop updating the force when component upon calling stop()
  pause: function() {
    this.isActive = false;
  },

  //remove the event listener + delete the spring
  remove: function() {
    if (this.spring)
      delete this.spring;
      this.spring = null;
  }
})


/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((module) => {

module.exports = {
  GRAVITY: -9.8,
  MAX_INTERVAL: 4 / 60,
  ITERATIONS: 10,
  CONTACT_MATERIAL: {
    friction: 0.01,
    restitution: 0.3,
    contactEquationStiffness: 1e8,
    contactEquationRelaxation: 3,
    frictionEquationStiffness: 1e8,
    frictionEquationRegularization: 3
  },
  ACTIVATION_STATE: {
    ACTIVE_TAG: "active",
    ISLAND_SLEEPING: "islandSleeping",
    WANTS_DEACTIVATION: "wantsDeactivation",
    DISABLE_DEACTIVATION: "disableDeactivation",
    DISABLE_SIMULATION: "disableSimulation"
  },
  COLLISION_FLAG: {
    STATIC_OBJECT: 1,
    KINEMATIC_OBJECT: 2,
    NO_CONTACT_RESPONSE: 4,
    CUSTOM_MATERIAL_CALLBACK: 8, //this allows per-triangle material (friction/restitution)
    CHARACTER_OBJECT: 16,
    DISABLE_VISUALIZE_OBJECT: 32, //disable debug drawing
    DISABLE_SPU_COLLISION_PROCESSING: 64 //disable parallel/SPU processing
  },
  TYPE: {
    STATIC: "static",
    DYNAMIC: "dynamic",
    KINEMATIC: "kinematic"
  },
  SHAPE: {
    BOX: "box",
    CYLINDER: "cylinder",
    SPHERE: "sphere",
    CAPSULE: "capsule",
    CONE: "cone",
    HULL: "hull",
    HACD: "hacd",
    VHACD: "vhacd",
    MESH: "mesh",
    HEIGHTFIELD: "heightfield"
  },
  FIT: {
    ALL: "all",
    MANUAL: "manual"
  },
  CONSTRAINT: {
    LOCK: "lock",
    FIXED: "fixed",
    SPRING: "spring",
    SLIDER: "slider",
    HINGE: "hinge",
    CONE_TWIST: "coneTwist",
    POINT_TO_POINT: "pointToPoint"
  }
};


/***/ }),

/***/ "./src/drivers/ammo-driver.js":
/*!************************************!*\
  !*** ./src/drivers/ammo-driver.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global THREE */
const Driver = __webpack_require__(/*! ./driver */ "./src/drivers/driver.js");

if (typeof window !== 'undefined') {
  window.AmmoModule = window.Ammo;
  window.Ammo = null;
}

const EPS = 10e-6;

function AmmoDriver() {
  this.collisionConfiguration = null;
  this.dispatcher = null;
  this.broadphase = null;
  this.solver = null;
  this.physicsWorld = null;
  this.debugDrawer = null;

  this.els = new Map();
  this.eventListeners = [];
  this.collisions = new Map();
  this.collisionKeys = [];
  this.currentCollisions = new Map();
}

AmmoDriver.prototype = new Driver();
AmmoDriver.prototype.constructor = AmmoDriver;

module.exports = AmmoDriver;

/* @param {object} worldConfig */
AmmoDriver.prototype.init = function(worldConfig) {
  //Emscripten doesn't use real promises, just a .then() callback, so it necessary to wrap in a real promise.
  return new Promise(resolve => {
    AmmoModule().then(result => {
      Ammo = result;
      this.epsilon = worldConfig.epsilon || EPS;
      this.debugDrawMode = worldConfig.debugDrawMode || THREE.AmmoDebugConstants.NoDebug;
      this.maxSubSteps = worldConfig.maxSubSteps || 4;
      this.fixedTimeStep = worldConfig.fixedTimeStep || 1 / 60;
      this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
      this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
      this.broadphase = new Ammo.btDbvtBroadphase();
      this.solver = new Ammo.btSequentialImpulseConstraintSolver();
      this.physicsWorld = new Ammo.btDiscreteDynamicsWorld(
        this.dispatcher,
        this.broadphase,
        this.solver,
        this.collisionConfiguration
      );
      this.physicsWorld.setForceUpdateAllAabbs(false);
      this.physicsWorld.setGravity(
        new Ammo.btVector3(0, worldConfig.hasOwnProperty("gravity") ? worldConfig.gravity : -9.8, 0)
      );
      this.physicsWorld.getSolverInfo().set_m_numIterations(worldConfig.solverIterations);
      resolve();
    });
  });
};

/* @param {Ammo.btCollisionObject} body */
AmmoDriver.prototype.addBody = function(body, group, mask) {
  this.physicsWorld.addRigidBody(body, group, mask);
  this.els.set(Ammo.getPointer(body), body.el);
};

/* @param {Ammo.btCollisionObject} body */
AmmoDriver.prototype.removeBody = function(body) {
  this.physicsWorld.removeRigidBody(body);
  this.removeEventListener(body);
  const bodyptr = Ammo.getPointer(body);
  this.els.delete(bodyptr);
  this.collisions.delete(bodyptr);
  this.collisionKeys.splice(this.collisionKeys.indexOf(bodyptr), 1);
  this.currentCollisions.delete(bodyptr);
};

AmmoDriver.prototype.updateBody = function(body) {
  if (this.els.has(Ammo.getPointer(body))) {
    this.physicsWorld.updateSingleAabb(body);
  }
};

/* @param {number} deltaTime */
AmmoDriver.prototype.step = function(deltaTime) {
  this.physicsWorld.stepSimulation(deltaTime, this.maxSubSteps, this.fixedTimeStep);

  const numManifolds = this.dispatcher.getNumManifolds();
  for (let i = 0; i < numManifolds; i++) {
    const persistentManifold = this.dispatcher.getManifoldByIndexInternal(i);
    const numContacts = persistentManifold.getNumContacts();
    const body0ptr = Ammo.getPointer(persistentManifold.getBody0());
    const body1ptr = Ammo.getPointer(persistentManifold.getBody1());
    let collided = false;

    for (let j = 0; j < numContacts; j++) {
      const manifoldPoint = persistentManifold.getContactPoint(j);
      const distance = manifoldPoint.getDistance();
      if (distance <= this.epsilon) {
        collided = true;
        break;
      }
    }

    if (collided) {
      if (!this.collisions.has(body0ptr)) {
        this.collisions.set(body0ptr, []);
        this.collisionKeys.push(body0ptr);
      }
      if (this.collisions.get(body0ptr).indexOf(body1ptr) === -1) {
        this.collisions.get(body0ptr).push(body1ptr);
        if (this.eventListeners.indexOf(body0ptr) !== -1) {
          this.els.get(body0ptr).emit("collidestart", { targetEl: this.els.get(body1ptr) });
        }
        if (this.eventListeners.indexOf(body1ptr) !== -1) {
          this.els.get(body1ptr).emit("collidestart", { targetEl: this.els.get(body0ptr) });
        }
      }
      if (!this.currentCollisions.has(body0ptr)) {
        this.currentCollisions.set(body0ptr, new Set());
      }
      this.currentCollisions.get(body0ptr).add(body1ptr);
    }
  }

  for (let i = 0; i < this.collisionKeys.length; i++) {
    const body0ptr = this.collisionKeys[i];
    const body1ptrs = this.collisions.get(body0ptr);
    for (let j = body1ptrs.length - 1; j >= 0; j--) {
      const body1ptr = body1ptrs[j];
      if (this.currentCollisions.get(body0ptr).has(body1ptr)) {
        continue;
      }
      if (this.eventListeners.indexOf(body0ptr) !== -1) {
        this.els.get(body0ptr).emit("collideend", { targetEl: this.els.get(body1ptr) });
      }
      if (this.eventListeners.indexOf(body1ptr) !== -1) {
        this.els.get(body1ptr).emit("collideend", { targetEl: this.els.get(body0ptr) });
      }
      body1ptrs.splice(j, 1);
    }
    this.currentCollisions.get(body0ptr).clear();
  }

  if (this.debugDrawer) {
    this.debugDrawer.update();
  }
};

/* @param {?} constraint */
AmmoDriver.prototype.addConstraint = function(constraint) {
  this.physicsWorld.addConstraint(constraint, false);
};

/* @param {?} constraint */
AmmoDriver.prototype.removeConstraint = function(constraint) {
  this.physicsWorld.removeConstraint(constraint);
};

/* @param {Ammo.btCollisionObject} body */
AmmoDriver.prototype.addEventListener = function(body) {
  this.eventListeners.push(Ammo.getPointer(body));
};

/* @param {Ammo.btCollisionObject} body */
AmmoDriver.prototype.removeEventListener = function(body) {
  const ptr = Ammo.getPointer(body);
  if (this.eventListeners.indexOf(ptr) !== -1) {
    this.eventListeners.splice(this.eventListeners.indexOf(ptr), 1);
  }
};

AmmoDriver.prototype.destroy = function() {
  Ammo.destroy(this.collisionConfiguration);
  Ammo.destroy(this.dispatcher);
  Ammo.destroy(this.broadphase);
  Ammo.destroy(this.solver);
  Ammo.destroy(this.physicsWorld);
  Ammo.destroy(this.debugDrawer);
};

/**
 * @param {THREE.Scene} scene
 * @param {object} options
 */
AmmoDriver.prototype.getDebugDrawer = function(scene, options) {
  if (!this.debugDrawer) {
    options = options || {};
    options.debugDrawMode = options.debugDrawMode || this.debugDrawMode;
    this.debugDrawer = new THREE.AmmoDebugDrawer(scene, this.physicsWorld, options);
  }
  return this.debugDrawer;
};


/***/ }),

/***/ "./src/drivers/driver.js":
/*!*******************************!*\
  !*** ./src/drivers/driver.js ***!
  \*******************************/
/***/ ((module) => {

/**
 * Driver - defines limited API to local and remote physics controllers.
 */

function Driver () {}

module.exports = Driver;

/******************************************************************************
 * Lifecycle
 */

/* @param {object} worldConfig */
Driver.prototype.init = abstractMethod;

/* @param {number} deltaMS */
Driver.prototype.step = abstractMethod;

Driver.prototype.destroy = abstractMethod;

/******************************************************************************
 * Bodies
 */

/* @param {CANNON.Body} body */
Driver.prototype.addBody = abstractMethod;

/* @param {CANNON.Body} body */
Driver.prototype.removeBody = abstractMethod;

/**
 * @param {CANNON.Body} body
 * @param {string} methodName
 * @param {Array} args
 */
Driver.prototype.applyBodyMethod = abstractMethod;

/** @param {CANNON.Body} body */
Driver.prototype.updateBodyProperties = abstractMethod;

/******************************************************************************
 * Materials
 */

/** @param {object} materialConfig */
Driver.prototype.addMaterial = abstractMethod;

/**
 * @param {string} materialName1
 * @param {string} materialName2
 * @param {object} contactMaterialConfig
 */
Driver.prototype.addContactMaterial = abstractMethod;

/******************************************************************************
 * Constraints
 */

/* @param {CANNON.Constraint} constraint */
Driver.prototype.addConstraint = abstractMethod;

/* @param {CANNON.Constraint} constraint */
Driver.prototype.removeConstraint = abstractMethod;

/******************************************************************************
 * Contacts
 */

/** @return {Array<object>} */
Driver.prototype.getContacts = abstractMethod;

/*****************************************************************************/

function abstractMethod () {
  throw new Error('Method not implemented.');
}


/***/ }),

/***/ "./src/drivers/event.js":
/*!******************************!*\
  !*** ./src/drivers/event.js ***!
  \******************************/
/***/ ((module) => {

module.exports = {
  INIT: 'init',
  STEP: 'step',

  // Bodies.
  ADD_BODY: 'add-body',
  REMOVE_BODY: 'remove-body',
  APPLY_BODY_METHOD: 'apply-body-method',
  UPDATE_BODY_PROPERTIES: 'update-body-properties',

  // Materials.
  ADD_MATERIAL: 'add-material',
  ADD_CONTACT_MATERIAL: 'add-contact-material',

  // Constraints.
  ADD_CONSTRAINT: 'add-constraint',
  REMOVE_CONSTRAINT: 'remove-constraint',

  // Events.
  COLLIDE: 'collide'
};


/***/ }),

/***/ "./src/drivers/local-driver.js":
/*!*************************************!*\
  !*** ./src/drivers/local-driver.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"),
    Driver = __webpack_require__(/*! ./driver */ "./src/drivers/driver.js");

function LocalDriver () {
  this.world = null;
  this.materials = {};
  this.contactMaterial = null;
}

LocalDriver.prototype = new Driver();
LocalDriver.prototype.constructor = LocalDriver;

module.exports = LocalDriver;

/******************************************************************************
 * Lifecycle
 */

/* @param {object} worldConfig */
LocalDriver.prototype.init = function (worldConfig) {
  var world = new CANNON.World();
  world.quatNormalizeSkip = worldConfig.quatNormalizeSkip;
  world.quatNormalizeFast = worldConfig.quatNormalizeFast;
  world.solver.iterations = worldConfig.solverIterations;
  world.gravity.set(0, worldConfig.gravity, 0);
  world.broadphase = new CANNON.NaiveBroadphase();

  this.world = world;
};

/* @param {number} deltaMS */
LocalDriver.prototype.step = function (deltaMS) {
  this.world.step(deltaMS);
};

LocalDriver.prototype.destroy = function () {
  delete this.world;
  delete this.contactMaterial;
  this.materials = {};
};

/******************************************************************************
 * Bodies
 */

/* @param {CANNON.Body} body */
LocalDriver.prototype.addBody = function (body) {
  this.world.addBody(body);
};

/* @param {CANNON.Body} body */
LocalDriver.prototype.removeBody = function (body) {
  this.world.removeBody(body);
};

/**
 * @param {CANNON.Body} body
 * @param {string} methodName
 * @param {Array} args
 */
LocalDriver.prototype.applyBodyMethod = function (body, methodName, args) {
  body['__' + methodName].apply(body, args);
};

/** @param {CANNON.Body} body */
LocalDriver.prototype.updateBodyProperties = function () {};

/******************************************************************************
 * Materials
 */

/**
 * @param {string} name
 * @return {CANNON.Material}
 */
LocalDriver.prototype.getMaterial = function (name) {
  return this.materials[name];
};

/** @param {object} materialConfig */
LocalDriver.prototype.addMaterial = function (materialConfig) {
  this.materials[materialConfig.name] = new CANNON.Material(materialConfig);
  this.materials[materialConfig.name].name = materialConfig.name;
};

/**
 * @param {string} matName1
 * @param {string} matName2
 * @param {object} contactMaterialConfig
 */
LocalDriver.prototype.addContactMaterial = function (matName1, matName2, contactMaterialConfig) {
  var mat1 = this.materials[matName1],
      mat2 = this.materials[matName2];
  this.contactMaterial = new CANNON.ContactMaterial(mat1, mat2, contactMaterialConfig);
  this.world.addContactMaterial(this.contactMaterial);
};

/******************************************************************************
 * Constraints
 */

/* @param {CANNON.Constraint} constraint */
LocalDriver.prototype.addConstraint = function (constraint) {
  if (!constraint.type) {
    if (constraint instanceof CANNON.LockConstraint) {
      constraint.type = 'LockConstraint';
    } else if (constraint instanceof CANNON.DistanceConstraint) {
      constraint.type = 'DistanceConstraint';
    } else if (constraint instanceof CANNON.HingeConstraint) {
      constraint.type = 'HingeConstraint';
    } else if (constraint instanceof CANNON.ConeTwistConstraint) {
      constraint.type = 'ConeTwistConstraint';
    } else if (constraint instanceof CANNON.PointToPointConstraint) {
      constraint.type = 'PointToPointConstraint';
    }
  }
  this.world.addConstraint(constraint);
};

/* @param {CANNON.Constraint} constraint */
LocalDriver.prototype.removeConstraint = function (constraint) {
  this.world.removeConstraint(constraint);
};

/******************************************************************************
 * Contacts
 */

/** @return {Array<object>} */
LocalDriver.prototype.getContacts = function () {
  return this.world.contacts;
};


/***/ }),

/***/ "./src/drivers/network-driver.js":
/*!***************************************!*\
  !*** ./src/drivers/network-driver.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Driver = __webpack_require__(/*! ./driver */ "./src/drivers/driver.js");

function NetworkDriver () {
  throw new Error('[NetworkDriver] Driver not implemented.');
}

NetworkDriver.prototype = new Driver();
NetworkDriver.prototype.constructor = NetworkDriver;

module.exports = NetworkDriver;


/***/ }),

/***/ "./src/drivers/webworkify-debug.js":
/*!*****************************************!*\
  !*** ./src/drivers/webworkify-debug.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Stub version of webworkify, for debugging code outside of a webworker.
 */
function webworkifyDebug (worker) {
  var targetA = new EventTarget(),
      targetB = new EventTarget();

  targetA.setTarget(targetB);
  targetB.setTarget(targetA);

  worker(targetA);
  return targetB;
}

module.exports = webworkifyDebug;

/******************************************************************************
 * EventTarget
 */

function EventTarget () {
  this.listeners = [];
}

EventTarget.prototype.setTarget = function (target) {
  this.target = target;
};

EventTarget.prototype.addEventListener = function (type, fn) {
  this.listeners.push(fn);
};

EventTarget.prototype.dispatchEvent = function (type, event) {
  for (var i = 0; i < this.listeners.length; i++) {
    this.listeners[i](event);
  }
};

EventTarget.prototype.postMessage = function (msg) {
  this.target.dispatchEvent('message', {data: msg});
};


/***/ }),

/***/ "./src/drivers/worker-driver.js":
/*!**************************************!*\
  !*** ./src/drivers/worker-driver.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global performance */

var webworkify = __webpack_require__(/*! webworkify-webpack */ "./node_modules/webworkify-webpack/index.js"),
    webworkifyDebug = __webpack_require__(/*! ./webworkify-debug */ "./src/drivers/webworkify-debug.js"),
    Driver = __webpack_require__(/*! ./driver */ "./src/drivers/driver.js"),
    Event = __webpack_require__(/*! ./event */ "./src/drivers/event.js"),
    worker = __webpack_require__(/*! ./worker */ "./src/drivers/worker.js"),
    protocol = __webpack_require__(/*! ../utils/protocol */ "./src/utils/protocol.js");

var ID = protocol.ID;

/******************************************************************************
 * Constructor
 */

function WorkerDriver (options) {
  this.fps = options.fps;
  this.engine = options.engine;
  this.interpolate = options.interpolate;
  // Approximate number of physics steps to 'pad' rendering.
  this.interpBufferSize = options.interpolationBufferSize;
  this.debug = options.debug;

  this.bodies = {};
  this.contacts = [];

  // https://gafferongames.com/post/snapshot_interpolation/
  this.frameDelay = this.interpBufferSize * 1000 / this.fps;
  this.frameBuffer = [];

  this.worker = this.debug
    ? webworkifyDebug(worker)
    : webworkify(worker);
  this.worker.addEventListener('message', this._onMessage.bind(this));
}

WorkerDriver.prototype = new Driver();
WorkerDriver.prototype.constructor = WorkerDriver;

module.exports = WorkerDriver;

/******************************************************************************
 * Lifecycle
 */

/* @param {object} worldConfig */
WorkerDriver.prototype.init = function (worldConfig) {
  this.worker.postMessage({
    type: Event.INIT,
    worldConfig: worldConfig,
    fps: this.fps,
    engine: this.engine
  });
};

/**
 * Increments the physics world forward one step, if interpolation is enabled.
 * If disabled, increments are performed as messages arrive.
 * @param {number} deltaMS
 */
WorkerDriver.prototype.step = function () {
  if (!this.interpolate) return;

  // Get the two oldest frames that haven't expired. Ideally we would use all
  // available frames to keep things smooth, but lerping is easier and faster.
  var prevFrame = this.frameBuffer[0];
  var nextFrame = this.frameBuffer[1];
  var timestamp = performance.now();
  while (prevFrame && nextFrame && timestamp - prevFrame.timestamp > this.frameDelay) {
    this.frameBuffer.shift();
    prevFrame = this.frameBuffer[0];
    nextFrame = this.frameBuffer[1];
  }

  if (!prevFrame || !nextFrame) return;

  var mix = (timestamp - prevFrame.timestamp) / this.frameDelay;
  mix = (mix - (1 - 1 / this.interpBufferSize)) * this.interpBufferSize;

  for (var id in prevFrame.bodies) {
    if (prevFrame.bodies.hasOwnProperty(id) && nextFrame.bodies.hasOwnProperty(id)) {
      protocol.deserializeInterpBodyUpdate(
        prevFrame.bodies[id],
        nextFrame.bodies[id],
        this.bodies[id],
        mix
      );
    }
  }
};

WorkerDriver.prototype.destroy = function () {
  this.worker.terminate();
  delete this.worker;
};

/** {Event} event */
WorkerDriver.prototype._onMessage = function (event) {
  if (event.data.type === Event.STEP) {
    var data = event.data,
        bodies = data.bodies;

    this.contacts = event.data.contacts;

    // If interpolation is enabled, store the frame. If not, update all bodies
    // immediately.
    if (this.interpolate) {
      this.frameBuffer.push({timestamp: performance.now(), bodies: bodies});
    } else {
      for (var id in bodies) {
        if (bodies.hasOwnProperty(id)) {
          protocol.deserializeBodyUpdate(bodies[id], this.bodies[id]);
        }
      }
    }

  } else if (event.data.type === Event.COLLIDE) {
    var body = this.bodies[event.data.bodyID];
    var target = this.bodies[event.data.targetID];
    var contact = protocol.deserializeContact(event.data.contact, this.bodies);
    if (!body._listeners || !body._listeners.collide) return;
    for (var i = 0; i < body._listeners.collide.length; i++) {
      body._listeners.collide[i]({target: target, body: body, contact: contact});
    }

  } else {
    throw new Error('[WorkerDriver] Unexpected message type.');
  }
};

/******************************************************************************
 * Bodies
 */

/* @param {CANNON.Body} body */
WorkerDriver.prototype.addBody = function (body) {
  protocol.assignID('body', body);
  this.bodies[body[ID]] = body;
  this.worker.postMessage({type: Event.ADD_BODY, body: protocol.serializeBody(body)});
};

/* @param {CANNON.Body} body */
WorkerDriver.prototype.removeBody = function (body) {
  this.worker.postMessage({type: Event.REMOVE_BODY, bodyID: body[ID]});
  delete this.bodies[body[ID]];
};

/**
 * @param {CANNON.Body} body
 * @param {string} methodName
 * @param {Array} args
 */
WorkerDriver.prototype.applyBodyMethod = function (body, methodName, args) {
  switch (methodName) {
    case 'applyForce':
    case 'applyImpulse':
      this.worker.postMessage({
        type: Event.APPLY_BODY_METHOD,
        bodyID: body[ID],
        methodName: methodName,
        args: [args[0].toArray(), args[1].toArray()]
      });
      break;
    default:
      throw new Error('Unexpected methodName: %s', methodName);
  }
};

/** @param {CANNON.Body} body */
WorkerDriver.prototype.updateBodyProperties = function (body) {
  this.worker.postMessage({
    type: Event.UPDATE_BODY_PROPERTIES,
    body: protocol.serializeBody(body)
  });
};

/******************************************************************************
 * Materials
 */

/**
 * @param  {string} name
 * @return {CANNON.Material}
 */
WorkerDriver.prototype.getMaterial = function (name) {
  // No access to materials here. Eventually we might return the name or ID, if
  // multiple materials were selected, but for now there's only one and it's safe
  // to assume the worker is already using it.
  return undefined;
};

/** @param {object} materialConfig */
WorkerDriver.prototype.addMaterial = function (materialConfig) {
  this.worker.postMessage({type: Event.ADD_MATERIAL, materialConfig: materialConfig});
};

/**
 * @param {string} matName1
 * @param {string} matName2
 * @param {object} contactMaterialConfig
 */
WorkerDriver.prototype.addContactMaterial = function (matName1, matName2, contactMaterialConfig) {
  this.worker.postMessage({
    type: Event.ADD_CONTACT_MATERIAL,
    materialName1: matName1,
    materialName2: matName2,
    contactMaterialConfig: contactMaterialConfig
  });
};

/******************************************************************************
 * Constraints
 */

/* @param {CANNON.Constraint} constraint */
WorkerDriver.prototype.addConstraint = function (constraint) {
  if (!constraint.type) {
    if (constraint instanceof CANNON.LockConstraint) {
      constraint.type = 'LockConstraint';
    } else if (constraint instanceof CANNON.DistanceConstraint) {
      constraint.type = 'DistanceConstraint';
    } else if (constraint instanceof CANNON.HingeConstraint) {
      constraint.type = 'HingeConstraint';
    } else if (constraint instanceof CANNON.ConeTwistConstraint) {
      constraint.type = 'ConeTwistConstraint';
    } else if (constraint instanceof CANNON.PointToPointConstraint) {
      constraint.type = 'PointToPointConstraint';
    }
  }
  protocol.assignID('constraint', constraint);
  this.worker.postMessage({
    type: Event.ADD_CONSTRAINT,
    constraint: protocol.serializeConstraint(constraint)
  });
};

/* @param {CANNON.Constraint} constraint */
WorkerDriver.prototype.removeConstraint = function (constraint) {
  this.worker.postMessage({
    type: Event.REMOVE_CONSTRAINT,
    constraintID: constraint[ID]
  });
};

/******************************************************************************
 * Contacts
 */

/** @return {Array<object>} */
WorkerDriver.prototype.getContacts = function () {
  // TODO(donmccurdy): There's some wasted memory allocation here.
  var bodies = this.bodies;
  return this.contacts.map(function (message) {
    return protocol.deserializeContact(message, bodies);
  });
};


/***/ }),

/***/ "./src/drivers/worker.js":
/*!*******************************!*\
  !*** ./src/drivers/worker.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Event = __webpack_require__(/*! ./event */ "./src/drivers/event.js"),
    LocalDriver = __webpack_require__(/*! ./local-driver */ "./src/drivers/local-driver.js"),
    AmmoDriver = __webpack_require__(/*! ./ammo-driver */ "./src/drivers/ammo-driver.js"),
    protocol = __webpack_require__(/*! ../utils/protocol */ "./src/utils/protocol.js");

var ID = protocol.ID;

module.exports = function (self) {
  var driver = null;
  var bodies = {};
  var constraints = {};
  var stepSize;

  self.addEventListener('message', function (event) {
    var data = event.data;

    switch (data.type) {
      // Lifecycle.
      case Event.INIT:
        driver = data.engine === 'cannon'
          ? new LocalDriver()
          : new AmmoDriver();
        driver.init(data.worldConfig);
        stepSize = 1 / data.fps;
        setInterval(step, 1000 / data.fps);
        break;

      // Bodies.
      case Event.ADD_BODY:
        var body = protocol.deserializeBody(data.body);
        body.material = driver.getMaterial( 'defaultMaterial' );
        bodies[body[ID]] = body;

        body.addEventListener('collide', function (evt) {
          var message = {
            type: Event.COLLIDE,
            bodyID: evt.target[ID], // set the target as the body to be identical to the local driver
            targetID: evt.body[ID], // set the body as the target to be identical to the local driver
            contact: protocol.serializeContact(evt.contact)
          }
          self.postMessage(message);
        });
        driver.addBody(body);
        break;
      case Event.REMOVE_BODY:
        driver.removeBody(bodies[data.bodyID]);
        delete bodies[data.bodyID];
        break;
      case Event.APPLY_BODY_METHOD:
        bodies[data.bodyID][data.methodName](
          protocol.deserializeVec3(data.args[0]),
          protocol.deserializeVec3(data.args[1])
        );
        break;
      case Event.UPDATE_BODY_PROPERTIES:
        protocol.deserializeBodyUpdate(data.body, bodies[data.body.id]);
        break;

      // Materials.
      case Event.ADD_MATERIAL:
        driver.addMaterial(data.materialConfig);
        break;
      case Event.ADD_CONTACT_MATERIAL:
        driver.addContactMaterial(
          data.materialName1,
          data.materialName2,
          data.contactMaterialConfig
        );
        break;

      // Constraints.
      case Event.ADD_CONSTRAINT:
        var constraint = protocol.deserializeConstraint(data.constraint, bodies);
        constraints[constraint[ID]] = constraint;
        driver.addConstraint(constraint);
        break;
      case Event.REMOVE_CONSTRAINT:
        driver.removeConstraint(constraints[data.constraintID]);
        delete constraints[data.constraintID];
        break;

      default:
        throw new Error('[Worker] Unexpected event type: %s', data.type);

    }
  });

  function step () {
    driver.step(stepSize);

    var bodyMessages = {};
    Object.keys(bodies).forEach(function (id) {
      bodyMessages[id] = protocol.serializeBody(bodies[id]);
    });

    self.postMessage({
      type: Event.STEP,
      bodies: bodyMessages,
      contacts: driver.getContacts().map(protocol.serializeContact)
    });
  }
};


/***/ }),

/***/ "./src/system.js":
/*!***********************!*\
  !*** ./src/system.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global THREE */
var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"),
    CONSTANTS = __webpack_require__(/*! ./constants */ "./src/constants.js"),
    C_GRAV = CONSTANTS.GRAVITY,
    C_MAT = CONSTANTS.CONTACT_MATERIAL;

const { TYPE } = __webpack_require__(/*! ./constants */ "./src/constants.js");
var LocalDriver = __webpack_require__(/*! ./drivers/local-driver */ "./src/drivers/local-driver.js"),
    WorkerDriver = __webpack_require__(/*! ./drivers/worker-driver */ "./src/drivers/worker-driver.js"),
    NetworkDriver = __webpack_require__(/*! ./drivers/network-driver */ "./src/drivers/network-driver.js"),
    AmmoDriver = __webpack_require__(/*! ./drivers/ammo-driver */ "./src/drivers/ammo-driver.js");
__webpack_require__(/*! aframe-stats-panel */ "./node_modules/aframe-stats-panel/index.js")

/**
 * Physics system.
 */
module.exports = AFRAME.registerSystem('physics', {
  schema: {
    // CANNON.js driver type
    driver:                         { default: 'local', oneOf: ['local', 'worker', 'network', 'ammo'] },
    networkUrl:                     { default: '', if: {driver: 'network'} },
    workerFps:                      { default: 60, if: {driver: 'worker'} },
    workerInterpolate:              { default: true, if: {driver: 'worker'} },
    workerInterpBufferSize:         { default: 2, if: {driver: 'worker'} },
    workerEngine:                   { default: 'cannon', if: {driver: 'worker'}, oneOf: ['cannon'] },
    workerDebug:                    { default: false, if: {driver: 'worker'} },

    gravity:                        { default: C_GRAV },
    iterations:                     { default: CONSTANTS.ITERATIONS },
    friction:                       { default: C_MAT.friction },
    restitution:                    { default: C_MAT.restitution },
    contactEquationStiffness:       { default: C_MAT.contactEquationStiffness },
    contactEquationRelaxation:      { default: C_MAT.contactEquationRelaxation },
    frictionEquationStiffness:      { default: C_MAT.frictionEquationStiffness },
    frictionEquationRegularization: { default: C_MAT.frictionEquationRegularization },

    // Never step more than four frames at once. Effectively pauses the scene
    // when out of focus, and prevents weird "jumps" when focus returns.
    maxInterval:                    { default: 4 / 60 },

    // If true, show wireframes around physics bodies.
    debug:                          { default: false },

    // If using ammo, set the default rendering mode for debug
    debugDrawMode: { default: THREE.AmmoDebugConstants.NoDebug },
    // If using ammo, set the max number of steps per frame 
    maxSubSteps: { default: 4 },
    // If using ammo, set the framerate of the simulation
    fixedTimeStep: { default: 1 / 60 },
    // Whether to output stats, and how to output them.  One or more of "console", "events", "panel"
    stats: {type: 'array', default: []}
  },

  /**
   * Initializes the physics system.
   */
  async init() {
    var data = this.data;

    // If true, show wireframes around physics bodies.
    this.debug = data.debug;
    this.initStats();

    this.callbacks = {beforeStep: [], step: [], afterStep: []};

    this.listeners = {};
    

    this.driver = null;
    switch (data.driver) {
      case 'local':
        this.driver = new LocalDriver();
        break;

      case 'ammo':
        this.driver = new AmmoDriver();
        break;

      case 'network':
        this.driver = new NetworkDriver(data.networkUrl);
        break;

      case 'worker':
        this.driver = new WorkerDriver({
          fps: data.workerFps,
          engine: data.workerEngine,
          interpolate: data.workerInterpolate,
          interpolationBufferSize: data.workerInterpBufferSize,
          debug: data.workerDebug
        });
        break;

      default:
        throw new Error('[physics] Driver not recognized: "%s".', data.driver);
    }

    if (data.driver !== 'ammo') {
      await this.driver.init({
        quatNormalizeSkip: 0,
        quatNormalizeFast: false,
        solverIterations: data.iterations,
        gravity: data.gravity,
      });
      this.driver.addMaterial({name: 'defaultMaterial'});
      this.driver.addMaterial({name: 'staticMaterial'});
      this.driver.addContactMaterial('defaultMaterial', 'defaultMaterial', {
        friction: data.friction,
        restitution: data.restitution,
        contactEquationStiffness: data.contactEquationStiffness,
        contactEquationRelaxation: data.contactEquationRelaxation,
        frictionEquationStiffness: data.frictionEquationStiffness,
        frictionEquationRegularization: data.frictionEquationRegularization
      });
      this.driver.addContactMaterial('staticMaterial', 'defaultMaterial', {
        friction: 1.0,
        restitution: 0.0,
        contactEquationStiffness: data.contactEquationStiffness,
        contactEquationRelaxation: data.contactEquationRelaxation,
        frictionEquationStiffness: data.frictionEquationStiffness,
        frictionEquationRegularization: data.frictionEquationRegularization
      });
    } else {
      await this.driver.init({
      gravity: data.gravity,
      debugDrawMode: data.debugDrawMode,
      solverIterations: data.iterations,
      maxSubSteps: data.maxSubSteps,
      fixedTimeStep: data.fixedTimeStep
    });
    }

    this.initialized = true;

    if (this.debug) {
      this.setDebug(true);
    }
  },

  initStats() {
    // Data used for performance monitoring.
    this.statsToConsole = this.data.stats.includes("console")
    this.statsToEvents = this.data.stats.includes("events")
    this.statsToPanel = this.data.stats.includes("panel")

    if (this.statsToConsole || this.statsToEvents || this.statsToPanel) {
      this.trackPerf = true;
      this.tickCounter = 0;
      
      this.statsTickData = {};
      this.statsBodyData = {};

      this.countBodies = {
        "ammo": () => this.countBodiesAmmo(),
        "local": () => this.countBodiesCannon(false),
        "worker": () => this.countBodiesCannon(true)
      }

      this.bodyTypeToStatsPropertyMap = {
        "ammo": {
          [TYPE.STATIC] : "staticBodies",
          [TYPE.KINEMATIC] : "kinematicBodies",
          [TYPE.DYNAMIC] : "dynamicBodies",
        }, 
        "cannon": {
          [CANNON.Body.STATIC] : "staticBodies",
          [CANNON.Body.DYNAMIC] : "dynamicBodies"
        }
      }
      
      const scene = this.el.sceneEl;
      scene.setAttribute("stats-collector", `inEvent: physics-tick-data;
                                             properties: before, after, engine, total;
                                             outputFrequency: 100;
                                             outEvent: physics-tick-summary;
                                             outputs: percentile__50, percentile__90, max`);
    }

    if (this.statsToPanel) {
      const scene = this.el.sceneEl;
      const space = "&nbsp&nbsp&nbsp"
    
      scene.setAttribute("stats-panel", "")
      scene.setAttribute("stats-group__bodies", `label: Physics Bodies`)
      scene.setAttribute("stats-row__b1", `group: bodies;
                                           event:physics-body-data;
                                           properties: staticBodies;
                                           label: Static`)
      scene.setAttribute("stats-row__b2", `group: bodies;
                                           event:physics-body-data;
                                           properties: dynamicBodies;
                                           label: Dynamic`)
      if (this.data.driver === 'local' || this.data.driver === 'worker') {
        scene.setAttribute("stats-row__b3", `group: bodies;
                                             event:physics-body-data;
                                             properties: contacts;
                                             label: Contacts`)
      }
      else if (this.data.driver === 'ammo') {
        scene.setAttribute("stats-row__b3", `group: bodies;
                                             event:physics-body-data;
                                             properties: kinematicBodies;
                                             label: Kinematic`)
        scene.setAttribute("stats-row__b4", `group: bodies;
                                             event: physics-body-data;
                                             properties: manifolds;
                                             label: Manifolds`)
        scene.setAttribute("stats-row__b5", `group: bodies;
                                             event: physics-body-data;
                                             properties: manifoldContacts;
                                             label: Contacts`)
        scene.setAttribute("stats-row__b6", `group: bodies;
                                             event: physics-body-data;
                                             properties: collisions;
                                             label: Collisions`)
        scene.setAttribute("stats-row__b7", `group: bodies;
                                             event: physics-body-data;
                                             properties: collisionKeys;
                                             label: Coll Keys`)
      }

      scene.setAttribute("stats-group__tick", `label: Physics Ticks: Median${space}90th%${space}99th%`)
      scene.setAttribute("stats-row__1", `group: tick;
                                          event:physics-tick-summary;
                                          properties: before.percentile__50, 
                                                      before.percentile__90, 
                                                      before.max;
                                          label: Before`)
      scene.setAttribute("stats-row__2", `group: tick;
                                          event:physics-tick-summary;
                                          properties: after.percentile__50, 
                                                      after.percentile__90, 
                                                      after.max; 
                                          label: After`)
      scene.setAttribute("stats-row__3", `group: tick; 
                                          event:physics-tick-summary; 
                                          properties: engine.percentile__50, 
                                                      engine.percentile__90, 
                                                      engine.max;
                                          label: Engine`)
      scene.setAttribute("stats-row__4", `group: tick;
                                          event:physics-tick-summary;
                                          properties: total.percentile__50, 
                                                      total.percentile__90, 
                                                      total.max;
                                          label: Total`)
    }
  },

  /**
   * Updates the physics world on each tick of the A-Frame scene. It would be
   * entirely possible to separate the two  updating physics more or less
   * frequently than the scene  if greater precision or performance were
   * necessary.
   * @param  {number} t
   * @param  {number} dt
   */
  tick: function (t, dt) {
    if (!this.initialized || !dt) return;

    const beforeStartTime = performance.now();

    var i;
    var callbacks = this.callbacks;

    for (i = 0; i < this.callbacks.beforeStep.length; i++) {
      this.callbacks.beforeStep[i].beforeStep(t, dt);
    }

    const engineStartTime = performance.now();

    this.driver.step(Math.min(dt / 1000, this.data.maxInterval));

    const engineEndTime = performance.now();

    for (i = 0; i < callbacks.step.length; i++) {
      callbacks.step[i].step(t, dt);
    }

    for (i = 0; i < callbacks.afterStep.length; i++) {
      callbacks.afterStep[i].afterStep(t, dt);
    }

    if (this.trackPerf) {
      const afterEndTime = performance.now();

      this.statsTickData.before = engineStartTime - beforeStartTime
      this.statsTickData.engine = engineEndTime - engineStartTime
      this.statsTickData.after = afterEndTime - engineEndTime
      this.statsTickData.total = afterEndTime - beforeStartTime

      this.el.emit("physics-tick-data", this.statsTickData)

      this.tickCounter++;

      if (this.tickCounter === 100) {

        this.countBodies[this.data.driver]()

        if (this.statsToConsole) {
          console.log("Physics body stats:", this.statsBodyData)
        }

        if (this.statsToEvents  || this.statsToPanel) {
          this.el.emit("physics-body-data", this.statsBodyData)
        }
        this.tickCounter = 0;
      }
    }
  },

  countBodiesAmmo() {

    const statsData = this.statsBodyData
    statsData.manifolds = this.driver.dispatcher.getNumManifolds();
    statsData.manifoldContacts = 0;
    for (let i = 0; i < statsData.manifolds; i++) {
      const manifold = this.driver.dispatcher.getManifoldByIndexInternal(i);
      statsData.manifoldContacts += manifold.getNumContacts();
    }
    statsData.collisions = this.driver.collisions.size;
    statsData.collisionKeys = this.driver.collisionKeys.length;
    statsData.staticBodies = 0
    statsData.kinematicBodies = 0
    statsData.dynamicBodies = 0
    
    function type(el) {
      return el.components['ammo-body'].data.type
    }

    this.driver.els.forEach((el) => {
      const property = this.bodyTypeToStatsPropertyMap["ammo"][type(el)]
      statsData[property]++
    })
  },

  countBodiesCannon(worker) {

    const statsData = this.statsBodyData
    statsData.contacts = worker ? this.driver.contacts.length : this.driver.world.contacts.length;
    statsData.staticBodies = 0
    statsData.dynamicBodies = 0

    const bodies = worker ? Object.values(this.driver.bodies)  : this.driver.world.bodies

    bodies.forEach((body) => {
      const property = this.bodyTypeToStatsPropertyMap["cannon"][body.type]
      statsData[property]++
    })
  },

  setDebug: function(debug) {
    this.debug = debug;
    if (this.data.driver === 'ammo' && this.initialized) {
      if (debug && !this.debugDrawer) {
        this.debugDrawer = this.driver.getDebugDrawer(this.el.object3D);
        this.debugDrawer.enable();
      } else if (this.debugDrawer) {
        this.debugDrawer.disable();
        this.debugDrawer = null;
      }
    }
  },

  /**
   * Adds a body to the scene, and binds proxied methods to the driver.
   * @param {CANNON.Body} body
   */
  addBody: function (body, group, mask) {
    var driver = this.driver;

    if (this.data.driver === 'local') {
      body.__applyImpulse = body.applyImpulse;
      body.applyImpulse = function () {
        driver.applyBodyMethod(body, 'applyImpulse', arguments);
      };

      body.__applyForce = body.applyForce;
      body.applyForce = function () {
        driver.applyBodyMethod(body, 'applyForce', arguments);
      };

      body.updateProperties = function () {
        driver.updateBodyProperties(body);
      };

      this.listeners[body.id] = function (e) { body.el.emit('collide', e); };
      body.addEventListener('collide', this.listeners[body.id]);
    }

    this.driver.addBody(body, group, mask);
  },

  /**
   * Removes a body and its proxied methods.
   * @param {CANNON.Body} body
   */
  removeBody: function (body) {
    this.driver.removeBody(body);

    if (this.data.driver === 'local' || this.data.driver === 'worker') {
      body.removeEventListener('collide', this.listeners[body.id]);
      delete this.listeners[body.id];

      body.applyImpulse = body.__applyImpulse;
      delete body.__applyImpulse;

      body.applyForce = body.__applyForce;
      delete body.__applyForce;

      delete body.updateProperties;
    }
  },

  /** @param {CANNON.Constraint or Ammo.btTypedConstraint} constraint */
  addConstraint: function (constraint) {
    this.driver.addConstraint(constraint);
  },

  /** @param {CANNON.Constraint or Ammo.btTypedConstraint} constraint */
  removeConstraint: function (constraint) {
    this.driver.removeConstraint(constraint);
  },

  /**
   * Adds a component instance to the system and schedules its update methods to be called
   * the given phase.
   * @param {Component} component
   * @param {string} phase
   */
  addComponent: function (component) {
    var callbacks = this.callbacks;
    if (component.beforeStep) callbacks.beforeStep.push(component);
    if (component.step)       callbacks.step.push(component);
    if (component.afterStep)  callbacks.afterStep.push(component);
  },

  /**
   * Removes a component instance from the system.
   * @param {Component} component
   * @param {string} phase
   */
  removeComponent: function (component) {
    var callbacks = this.callbacks;
    if (component.beforeStep) {
      callbacks.beforeStep.splice(callbacks.beforeStep.indexOf(component), 1);
    }
    if (component.step) {
      callbacks.step.splice(callbacks.step.indexOf(component), 1);
    }
    if (component.afterStep) {
      callbacks.afterStep.splice(callbacks.afterStep.indexOf(component), 1);
    }
  },

  /** @return {Array<object>} */
  getContacts: function () {
    return this.driver.getContacts();
  },

  getMaterial: function (name) {
    return this.driver.getMaterial(name);
  }
});


/***/ }),

/***/ "./src/utils/math.js":
/*!***************************!*\
  !*** ./src/utils/math.js ***!
  \***************************/
/***/ ((module) => {

module.exports.slerp = function ( a, b, t ) {
  if ( t <= 0 ) return a;
  if ( t >= 1 ) return b;

  var x = a[0], y = a[1], z = a[2], w = a[3];

  // https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  var cosHalfTheta = w * b[3] + x * b[0] + y * b[1] + z * b[2];

  if ( cosHalfTheta < 0 ) {

    a = a.slice();

    a[3] = - b[3];
    a[0] = - b[0];
    a[1] = - b[1];
    a[2] = - b[2];

    cosHalfTheta = - cosHalfTheta;

  } else {

    return b;

  }

  if ( cosHalfTheta >= 1.0 ) {

    a[3] = w;
    a[0] = x;
    a[1] = y;
    a[2] = z;

    return this;

  }

  var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

  if ( Math.abs( sinHalfTheta ) < 0.001 ) {

    a[3] = 0.5 * ( w + a[3] );
    a[0] = 0.5 * ( x + a[0] );
    a[1] = 0.5 * ( y + a[1] );
    a[2] = 0.5 * ( z + a[2] );

    return this;

  }

  var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta;
  var ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  a[3] = ( w * ratioA + a[3] * ratioB );
  a[0] = ( x * ratioA + a[0] * ratioB );
  a[1] = ( y * ratioA + a[1] * ratioB );
  a[2] = ( z * ratioA + a[2] * ratioB );

  return a;

};


/***/ }),

/***/ "./src/utils/protocol.js":
/*!*******************************!*\
  !*** ./src/utils/protocol.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CANNON = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
var mathUtils = __webpack_require__(/*! ./math */ "./src/utils/math.js");

/******************************************************************************
 * IDs
 */

var ID = '__id';
module.exports.ID = ID;

var nextID = {};
module.exports.assignID = function (prefix, object) {
  if (object[ID]) return;
  nextID[prefix] = nextID[prefix] || 1;
  object[ID] = prefix + '_' + nextID[prefix]++;
};

/******************************************************************************
 * Bodies
 */

module.exports.serializeBody = function (body) {
  var message = {
    // Shapes.
    shapes: body.shapes.map(serializeShape),
    shapeOffsets: body.shapeOffsets.map(serializeVec3),
    shapeOrientations: body.shapeOrientations.map(serializeQuaternion),

    // Vectors.
    position: serializeVec3(body.position),
    quaternion: body.quaternion.toArray(),
    velocity: serializeVec3(body.velocity),
    angularVelocity: serializeVec3(body.angularVelocity),

    // Properties.
    id: body[ID],
    mass: body.mass,
    linearDamping: body.linearDamping,
    angularDamping: body.angularDamping,
    fixedRotation: body.fixedRotation,
    allowSleep: body.allowSleep,
    sleepSpeedLimit: body.sleepSpeedLimit,
    sleepTimeLimit: body.sleepTimeLimit
  };

  return message;
};

module.exports.deserializeBodyUpdate = function (message, body) {
  body.position.set(message.position[0], message.position[1], message.position[2]);
  body.quaternion.set(message.quaternion[0], message.quaternion[1], message.quaternion[2], message.quaternion[3]);
  body.velocity.set(message.velocity[0], message.velocity[1], message.velocity[2]);
  body.angularVelocity.set(message.angularVelocity[0], message.angularVelocity[1], message.angularVelocity[2]);

  body.linearDamping = message.linearDamping;
  body.angularDamping = message.angularDamping;
  body.fixedRotation = message.fixedRotation;
  body.allowSleep = message.allowSleep;
  body.sleepSpeedLimit = message.sleepSpeedLimit;
  body.sleepTimeLimit = message.sleepTimeLimit;

  if (body.mass !== message.mass) {
    body.mass = message.mass;
    body.updateMassProperties();
  }

  return body;
};

module.exports.deserializeInterpBodyUpdate = function (message1, message2, body, mix) {
  var weight1 = 1 - mix;
  var weight2 = mix;

  body.position.set(
    message1.position[0] * weight1 + message2.position[0] * weight2,
    message1.position[1] * weight1 + message2.position[1] * weight2,
    message1.position[2] * weight1 + message2.position[2] * weight2
  );
  var quaternion = mathUtils.slerp(message1.quaternion, message2.quaternion, mix);
  body.quaternion.set(quaternion[0], quaternion[1], quaternion[2], quaternion[3]);
  body.velocity.set(
    message1.velocity[0] * weight1 + message2.velocity[0] * weight2,
    message1.velocity[1] * weight1 + message2.velocity[1] * weight2,
    message1.velocity[2] * weight1 + message2.velocity[2] * weight2
  );
  body.angularVelocity.set(
    message1.angularVelocity[0] * weight1 + message2.angularVelocity[0] * weight2,
    message1.angularVelocity[1] * weight1 + message2.angularVelocity[1] * weight2,
    message1.angularVelocity[2] * weight1 + message2.angularVelocity[2] * weight2
  );

  body.linearDamping = message2.linearDamping;
  body.angularDamping = message2.angularDamping;
  body.fixedRotation = message2.fixedRotation;
  body.allowSleep = message2.allowSleep;
  body.sleepSpeedLimit = message2.sleepSpeedLimit;
  body.sleepTimeLimit = message2.sleepTimeLimit;

  if (body.mass !== message2.mass) {
    body.mass = message2.mass;
    body.updateMassProperties();
  }

  return body;
};

module.exports.deserializeBody = function (message) {
  var body = new CANNON.Body({
    mass: message.mass,

    position: deserializeVec3(message.position),
    quaternion: deserializeQuaternion(message.quaternion),
    velocity: deserializeVec3(message.velocity),
    angularVelocity: deserializeVec3(message.angularVelocity),

    linearDamping: message.linearDamping,
    angularDamping: message.angularDamping,
    fixedRotation: message.fixedRotation,
    allowSleep: message.allowSleep,
    sleepSpeedLimit: message.sleepSpeedLimit,
    sleepTimeLimit: message.sleepTimeLimit
  });

  for (var shapeMsg, i = 0; (shapeMsg = message.shapes[i]); i++) {
    body.addShape(
      deserializeShape(shapeMsg),
      deserializeVec3(message.shapeOffsets[i]),
      deserializeQuaternion(message.shapeOrientations[i])
    );
  }

  body[ID] = message.id;

  return body;
};

/******************************************************************************
 * Shapes
 */

module.exports.serializeShape = serializeShape;
function serializeShape (shape) {
  var shapeMsg = {type: shape.type};
  if (shape.type === CANNON.Shape.types.BOX) {
    shapeMsg.halfExtents = serializeVec3(shape.halfExtents);

  } else if (shape.type === CANNON.Shape.types.SPHERE) {
    shapeMsg.radius = shape.radius;

  // Patch schteppe/cannon.js#329.
  } else if (shape._type === CANNON.Shape.types.CYLINDER) {
    shapeMsg.type = CANNON.Shape.types.CYLINDER;
    shapeMsg.radiusTop = shape.radiusTop;
    shapeMsg.radiusBottom = shape.radiusBottom;
    shapeMsg.height = shape.height;
    shapeMsg.numSegments = shape.numSegments;

  } else {
    // TODO(donmccurdy): Support for other shape types.
    throw new Error('Unimplemented shape type: %s', shape.type);
  }
  return shapeMsg;
}

module.exports.deserializeShape = deserializeShape;
function deserializeShape (message) {
  var shape;

  if (message.type === CANNON.Shape.types.BOX) {
    shape = new CANNON.Box(deserializeVec3(message.halfExtents));

  } else if (message.type === CANNON.Shape.types.SPHERE) {
    shape = new CANNON.Sphere(message.radius);

  // Patch schteppe/cannon.js#329.
  } else if (message.type === CANNON.Shape.types.CYLINDER) {
    shape = new CANNON.Cylinder(message.radiusTop, message.radiusBottom, message.height, message.numSegments);
    shape._type = CANNON.Shape.types.CYLINDER;

  } else {
    // TODO(donmccurdy): Support for other shape types.
    throw new Error('Unimplemented shape type: %s', message.type);
  }

  return shape;
}

/******************************************************************************
 * Constraints
 */

module.exports.serializeConstraint = function (constraint) {

  var message = {
    id: constraint[ID],
    type: constraint.type,
    maxForce: constraint.maxForce,
    bodyA: constraint.bodyA[ID],
    bodyB: constraint.bodyB[ID]
  };

  switch (constraint.type) {
    case 'LockConstraint':
      break;
    case 'DistanceConstraint':
      message.distance = constraint.distance;
      break;
    case 'HingeConstraint':
    case 'ConeTwistConstraint':
      message.axisA = serializeVec3(constraint.axisA);
      message.axisB = serializeVec3(constraint.axisB);
      message.pivotA = serializeVec3(constraint.pivotA);
      message.pivotB = serializeVec3(constraint.pivotB);
      break;
    case 'PointToPointConstraint':
      message.pivotA = serializeVec3(constraint.pivotA);
      message.pivotB = serializeVec3(constraint.pivotB);
      break;
    default:
      throw new Error(''
        + 'Unexpected constraint type: ' + constraint.type + '. '
        + 'You may need to manually set `constraint.type = "FooConstraint";`.'
      );
  }

  return message;
};

module.exports.deserializeConstraint = function (message, bodies) {
  var TypedConstraint = CANNON[message.type];
  var bodyA = bodies[message.bodyA];
  var bodyB = bodies[message.bodyB];

  var constraint;

  switch (message.type) {
    case 'LockConstraint':
      constraint = new CANNON.LockConstraint(bodyA, bodyB, message);
      break;

    case 'DistanceConstraint':
      constraint = new CANNON.DistanceConstraint(
        bodyA,
        bodyB,
        message.distance,
        message.maxForce
      );
      break;

    case 'HingeConstraint':
    case 'ConeTwistConstraint':
      constraint = new TypedConstraint(bodyA, bodyB, {
        pivotA: deserializeVec3(message.pivotA),
        pivotB: deserializeVec3(message.pivotB),
        axisA: deserializeVec3(message.axisA),
        axisB: deserializeVec3(message.axisB),
        maxForce: message.maxForce
      });
      break;

    case 'PointToPointConstraint':
      constraint = new CANNON.PointToPointConstraint(
        bodyA,
        deserializeVec3(message.pivotA),
        bodyB,
        deserializeVec3(message.pivotB),
        message.maxForce
      );
      break;

    default:
      throw new Error('Unexpected constraint type: ' + message.type);
  }

  constraint[ID] = message.id;
  return constraint;
};

/******************************************************************************
 * Contacts
 */

module.exports.serializeContact = function (contact) {
  return {
    bi: contact.bi[ID],
    bj: contact.bj[ID],
    ni: serializeVec3(contact.ni),
    ri: serializeVec3(contact.ri),
    rj: serializeVec3(contact.rj)
  };
};

module.exports.deserializeContact = function (message, bodies) {
  return {
    bi: bodies[message.bi],
    bj: bodies[message.bj],
    ni: deserializeVec3(message.ni),
    ri: deserializeVec3(message.ri),
    rj: deserializeVec3(message.rj)
  };
};

/******************************************************************************
 * Math
 */

module.exports.serializeVec3 = serializeVec3;
function serializeVec3 (vec3) {
  return vec3.toArray();
}

module.exports.deserializeVec3 = deserializeVec3;
function deserializeVec3 (message) {
  return new CANNON.Vec3(message[0], message[1], message[2]);
}

module.exports.serializeQuaternion = serializeQuaternion;
function serializeQuaternion (quat) {
  return quat.toArray();
}

module.exports.deserializeQuaternion = deserializeQuaternion;
function deserializeQuaternion (message) {
  return new CANNON.Quaternion(message[0], message[1], message[2], message[3]);
}


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = THREE;

/***/ }),

/***/ "./node_modules/three-to-cannon/dist/three-to-cannon.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/three-to-cannon/dist/three-to-cannon.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var cannonEs = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
var three = __webpack_require__(/*! three */ "three");

/**
 * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)
 */

var ConvexHull = function () {
  var Visible = 0;
  var Deleted = 1;
  var v1 = new three.Vector3();

  function ConvexHull() {
    this.tolerance = -1;
    this.faces = []; // the generated faces of the convex hull

    this.newFaces = []; // this array holds the faces that are generated within a single iteration
    // the vertex lists work as follows:
    //
    // let 'a' and 'b' be 'Face' instances
    // let 'v' be points wrapped as instance of 'Vertex'
    //
    //     [v, v, ..., v, v, v, ...]
    //      ^             ^
    //      |             |
    //  a.outside     b.outside
    //

    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = []; // vertices of the hull (internal representation of given geometry data)
  }

  Object.assign(ConvexHull.prototype, {
    setFromPoints: function (points) {
      if (Array.isArray(points) !== true) {
        console.error('THREE.ConvexHull: Points parameter is not an array.');
      }

      if (points.length < 4) {
        console.error('THREE.ConvexHull: The algorithm needs at least four points.');
      }

      this.makeEmpty();

      for (var i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }

      this.compute();
      return this;
    },
    setFromObject: function (object) {
      var points = [];
      object.updateMatrixWorld(true);
      object.traverse(function (node) {
        var i, l, point;
        var geometry = node.geometry;
        if (geometry === undefined) return;

        if (geometry.isGeometry) {
          geometry = geometry.toBufferGeometry ? geometry.toBufferGeometry() : new three.BufferGeometry().fromGeometry(geometry);
        }

        if (geometry.isBufferGeometry) {
          var attribute = geometry.attributes.position;

          if (attribute !== undefined) {
            for (i = 0, l = attribute.count; i < l; i++) {
              point = new three.Vector3();
              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
              points.push(point);
            }
          }
        }
      });
      return this.setFromPoints(points);
    },
    containsPoint: function (point) {
      var faces = this.faces;

      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i]; // compute signed distance and check on what half space the point lies

        if (face.distanceToPoint(point) > this.tolerance) return false;
      }

      return true;
    },
    intersectRay: function (ray, target) {
      // based on "Fast Ray-Convex Polyhedron Intersection"  by Eric Haines, GRAPHICS GEMS II
      var faces = this.faces;
      var tNear = -Infinity;
      var tFar = Infinity;

      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i]; // interpret faces as planes for the further computation

        var vN = face.distanceToPoint(ray.origin);
        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can "see" the origin) and
        // the ray is turned away or parallel to the plane, there is no intersection

        if (vN > 0 && vD >= 0) return null; // compute the distance from the rays origin to the intersection with the plane

        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point
        // lies "behind" the origin

        if (t <= 0) continue; // now categorized plane as front-facing or back-facing

        if (vD > 0) {
          //  plane faces away from the ray, so this plane is a back-face
          tFar = Math.min(t, tFar);
        } else {
          // front-face
          tNear = Math.max(t, tNear);
        }

        if (tNear > tFar) {
          // if tNear ever is greater than tFar, the ray must miss the convex hull
          return null;
        }
      } // evaluate intersection point
      // always try tNear first since its the closer intersection point


      if (tNear !== -Infinity) {
        ray.at(tNear, target);
      } else {
        ray.at(tFar, target);
      }

      return target;
    },
    intersectsRay: function (ray) {
      return this.intersectRay(ray, v1) !== null;
    },
    makeEmpty: function () {
      this.faces = [];
      this.vertices = [];
      return this;
    },
    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
    addVertexToFace: function (vertex, face) {
      vertex.face = face;

      if (face.outside === null) {
        this.assigned.append(vertex);
      } else {
        this.assigned.insertBefore(face.outside, vertex);
      }

      face.outside = vertex;
      return this;
    },
    // Removes a vertex from the 'assigned' list of vertices and from the given face
    removeVertexFromFace: function (vertex, face) {
      if (vertex === face.outside) {
        // fix face.outside link
        if (vertex.next !== null && vertex.next.face === face) {
          // face has at least 2 outside vertices, move the 'outside' reference
          face.outside = vertex.next;
        } else {
          // vertex was the only outside vertex that face had
          face.outside = null;
        }
      }

      this.assigned.remove(vertex);
      return this;
    },
    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list
    removeAllVerticesFromFace: function (face) {
      if (face.outside !== null) {
        // reference to the first and last vertex of this face
        var start = face.outside;
        var end = face.outside;

        while (end.next !== null && end.next.face === face) {
          end = end.next;
        }

        this.assigned.removeSubList(start, end); // fix references

        start.prev = end.next = null;
        face.outside = null;
        return start;
      }
    },
    // Removes all the visible vertices that 'face' is able to see
    deleteFaceVertices: function (face, absorbingFace) {
      var faceVertices = this.removeAllVerticesFromFace(face);

      if (faceVertices !== undefined) {
        if (absorbingFace === undefined) {
          // mark the vertices to be reassigned to some other face
          this.unassigned.appendChain(faceVertices);
        } else {
          // if there's an absorbing face try to assign as many vertices as possible to it
          var vertex = faceVertices;

          do {
            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
            // will be changed by upcoming method calls
            var nextVertex = vertex.next;
            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'

            if (distance > this.tolerance) {
              this.addVertexToFace(vertex, absorbingFace);
            } else {
              this.unassigned.append(vertex);
            } // now assign next vertex


            vertex = nextVertex;
          } while (vertex !== null);
        }
      }

      return this;
    },
    // Reassigns as many vertices as possible from the unassigned list to the new faces
    resolveUnassignedPoints: function (newFaces) {
      if (this.unassigned.isEmpty() === false) {
        var vertex = this.unassigned.first();

        do {
          // buffer 'next' reference, see .deleteFaceVertices()
          var nextVertex = vertex.next;
          var maxDistance = this.tolerance;
          var maxFace = null;

          for (var i = 0; i < newFaces.length; i++) {
            var face = newFaces[i];

            if (face.mark === Visible) {
              var distance = face.distanceToPoint(vertex.point);

              if (distance > maxDistance) {
                maxDistance = distance;
                maxFace = face;
              }

              if (maxDistance > 1000 * this.tolerance) break;
            }
          } // 'maxFace' can be null e.g. if there are identical vertices


          if (maxFace !== null) {
            this.addVertexToFace(vertex, maxFace);
          }

          vertex = nextVertex;
        } while (vertex !== null);
      }

      return this;
    },
    // Computes the extremes of a simplex which will be the initial hull
    computeExtremes: function () {
      var min = new three.Vector3();
      var max = new three.Vector3();
      var minVertices = [];
      var maxVertices = [];
      var i, l, j; // initially assume that the first vertex is the min/max

      for (i = 0; i < 3; i++) {
        minVertices[i] = maxVertices[i] = this.vertices[0];
      }

      min.copy(this.vertices[0].point);
      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions

      for (i = 0, l = this.vertices.length; i < l; i++) {
        var vertex = this.vertices[i];
        var point = vertex.point; // update the min coordinates

        for (j = 0; j < 3; j++) {
          if (point.getComponent(j) < min.getComponent(j)) {
            min.setComponent(j, point.getComponent(j));
            minVertices[j] = vertex;
          }
        } // update the max coordinates


        for (j = 0; j < 3; j++) {
          if (point.getComponent(j) > max.getComponent(j)) {
            max.setComponent(j, point.getComponent(j));
            maxVertices[j] = vertex;
          }
        }
      } // use min/max vectors to compute an optimal epsilon


      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
      return {
        min: minVertices,
        max: maxVertices
      };
    },
    // Computes the initial simplex assigning to its faces all the points
    // that are candidates to form part of the hull
    computeInitialHull: function () {
      var line3, plane, closestPoint;
      return function computeInitialHull() {
        if (line3 === undefined) {
          line3 = new three.Line3();
          plane = new three.Plane();
          closestPoint = new three.Vector3();
        }

        var vertex,
            vertices = this.vertices;
        var extremes = this.computeExtremes();
        var min = extremes.min;
        var max = extremes.max;
        var v0, v1, v2, v3;
        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
        // (max.x - min.x)
        // (max.y - min.y)
        // (max.z - min.z)

        var distance,
            maxDistance = 0;
        var index = 0;

        for (i = 0; i < 3; i++) {
          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);

          if (distance > maxDistance) {
            maxDistance = distance;
            index = i;
          }
        }

        v0 = min[index];
        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

        maxDistance = 0;
        line3.set(v0.point, v1.point);

        for (i = 0, l = this.vertices.length; i < l; i++) {
          vertex = vertices[i];

          if (vertex !== v0 && vertex !== v1) {
            line3.closestPointToPoint(vertex.point, true, closestPoint);
            distance = closestPoint.distanceToSquared(vertex.point);

            if (distance > maxDistance) {
              maxDistance = distance;
              v2 = vertex;
            }
          }
        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'


        maxDistance = -1;
        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);

        for (i = 0, l = this.vertices.length; i < l; i++) {
          vertex = vertices[i];

          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
            distance = Math.abs(plane.distanceToPoint(vertex.point));

            if (distance > maxDistance) {
              maxDistance = distance;
              v3 = vertex;
            }
          }
        }

        var faces = [];

        if (plane.distanceToPoint(v3.point) < 0) {
          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron
          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge

          for (i = 0; i < 3; i++) {
            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face

            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3

            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
          }
        } else {
          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron
          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge

          for (i = 0; i < 3; i++) {
            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face

            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]

            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
          }
        } // the initial hull is the tetrahedron


        for (i = 0; i < 4; i++) {
          this.faces.push(faces[i]);
        } // initial assignment of vertices to the faces of the tetrahedron


        for (i = 0, l = vertices.length; i < l; i++) {
          vertex = vertices[i];

          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
            maxDistance = this.tolerance;
            var maxFace = null;

            for (j = 0; j < 4; j++) {
              distance = this.faces[j].distanceToPoint(vertex.point);

              if (distance > maxDistance) {
                maxDistance = distance;
                maxFace = this.faces[j];
              }
            }

            if (maxFace !== null) {
              this.addVertexToFace(vertex, maxFace);
            }
          }
        }

        return this;
      };
    }(),
    // Removes inactive faces
    reindexFaces: function () {
      var activeFaces = [];

      for (var i = 0; i < this.faces.length; i++) {
        var face = this.faces[i];

        if (face.mark === Visible) {
          activeFaces.push(face);
        }
      }

      this.faces = activeFaces;
      return this;
    },
    // Finds the next vertex to create faces with the current hull
    nextVertexToAdd: function () {
      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'
      if (this.assigned.isEmpty() === false) {
        var eyeVertex,
            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face

        var eyeFace = this.assigned.first().face;
        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see

        do {
          var distance = eyeFace.distanceToPoint(vertex.point);

          if (distance > maxDistance) {
            maxDistance = distance;
            eyeVertex = vertex;
          }

          vertex = vertex.next;
        } while (vertex !== null && vertex.face === eyeFace);

        return eyeVertex;
      }
    },
    // Computes a chain of half edges in CCW order called the 'horizon'.
    // For an edge to be part of the horizon it must join a face that can see
    // 'eyePoint' and a face that cannot see 'eyePoint'.
    computeHorizon: function (eyePoint, crossEdge, face, horizon) {
      // moves face's vertices to the 'unassigned' vertex list
      this.deleteFaceVertices(face);
      face.mark = Deleted;
      var edge;

      if (crossEdge === null) {
        edge = crossEdge = face.getEdge(0);
      } else {
        // start from the next edge since 'crossEdge' was already analyzed
        // (actually 'crossEdge.twin' was the edge who called this method recursively)
        edge = crossEdge.next;
      }

      do {
        var twinEdge = edge.twin;
        var oppositeFace = twinEdge.face;

        if (oppositeFace.mark === Visible) {
          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
            // the opposite face can see the vertex, so proceed with next edge
            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
          } else {
            // the opposite face can't see the vertex, so this edge is part of the horizon
            horizon.push(edge);
          }
        }

        edge = edge.next;
      } while (edge !== crossEdge);

      return this;
    },
    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
    addAdjoiningFace: function (eyeVertex, horizonEdge) {
      // all the half edges are created in ccw order thus the face is always pointing outside the hull
      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

      face.getEdge(-1).setTwin(horizonEdge.twin);
      return face.getEdge(0); // the half edge whose vertex is the eyeVertex
    },
    //  Adds 'horizon.length' faces to the hull, each face will be linked with the
    //  horizon opposite face and the face on the left/right
    addNewFaces: function (eyeVertex, horizon) {
      this.newFaces = [];
      var firstSideEdge = null;
      var previousSideEdge = null;

      for (var i = 0; i < horizon.length; i++) {
        var horizonEdge = horizon[i]; // returns the right side edge

        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);

        if (firstSideEdge === null) {
          firstSideEdge = sideEdge;
        } else {
          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )
          sideEdge.next.setTwin(previousSideEdge);
        }

        this.newFaces.push(sideEdge.face);
        previousSideEdge = sideEdge;
      } // perform final join of new faces


      firstSideEdge.next.setTwin(previousSideEdge);
      return this;
    },
    // Adds a vertex to the hull
    addVertexToHull: function (eyeVertex) {
      var horizon = [];
      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

      this.removeVertexFromFace(eyeVertex, eyeVertex.face);
      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces

      this.resolveUnassignedPoints(this.newFaces);
      return this;
    },
    cleanup: function () {
      this.assigned.clear();
      this.unassigned.clear();
      this.newFaces = [];
      return this;
    },
    compute: function () {
      var vertex;
      this.computeInitialHull(); // add all available vertices gradually to the hull

      while ((vertex = this.nextVertexToAdd()) !== undefined) {
        this.addVertexToHull(vertex);
      }

      this.reindexFaces();
      this.cleanup();
      return this;
    }
  }); //

  function Face() {
    this.normal = new three.Vector3();
    this.midpoint = new three.Vector3();
    this.area = 0;
    this.constant = 0; // signed distance from face to the origin

    this.outside = null; // reference to a vertex in a vertex list this face can see

    this.mark = Visible;
    this.edge = null;
  }

  Object.assign(Face, {
    create: function (a, b, c) {
      var face = new Face();
      var e0 = new HalfEdge(a, face);
      var e1 = new HalfEdge(b, face);
      var e2 = new HalfEdge(c, face); // join edges

      e0.next = e2.prev = e1;
      e1.next = e0.prev = e2;
      e2.next = e1.prev = e0; // main half edge reference

      face.edge = e0;
      return face.compute();
    }
  });
  Object.assign(Face.prototype, {
    getEdge: function (i) {
      var edge = this.edge;

      while (i > 0) {
        edge = edge.next;
        i--;
      }

      while (i < 0) {
        edge = edge.prev;
        i++;
      }

      return edge;
    },
    compute: function () {
      var triangle;
      return function compute() {
        if (triangle === undefined) triangle = new three.Triangle();
        var a = this.edge.tail();
        var b = this.edge.head();
        var c = this.edge.next.head();
        triangle.set(a.point, b.point, c.point);
        triangle.getNormal(this.normal);
        triangle.getMidpoint(this.midpoint);
        this.area = triangle.getArea();
        this.constant = this.normal.dot(this.midpoint);
        return this;
      };
    }(),
    distanceToPoint: function (point) {
      return this.normal.dot(point) - this.constant;
    }
  }); // Entity for a Doubly-Connected Edge List (DCEL).

  function HalfEdge(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }

  Object.assign(HalfEdge.prototype, {
    head: function () {
      return this.vertex;
    },
    tail: function () {
      return this.prev ? this.prev.vertex : null;
    },
    length: function () {
      var head = this.head();
      var tail = this.tail();

      if (tail !== null) {
        return tail.point.distanceTo(head.point);
      }

      return -1;
    },
    lengthSquared: function () {
      var head = this.head();
      var tail = this.tail();

      if (tail !== null) {
        return tail.point.distanceToSquared(head.point);
      }

      return -1;
    },
    setTwin: function (edge) {
      this.twin = edge;
      edge.twin = this;
      return this;
    }
  }); // A vertex as a double linked list node.

  function VertexNode(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null; // the face that is able to see this vertex
  } // A double linked list that contains vertex nodes.


  function VertexList() {
    this.head = null;
    this.tail = null;
  }

  Object.assign(VertexList.prototype, {
    first: function () {
      return this.head;
    },
    last: function () {
      return this.tail;
    },
    clear: function () {
      this.head = this.tail = null;
      return this;
    },
    // Inserts a vertex before the target vertex
    insertBefore: function (target, vertex) {
      vertex.prev = target.prev;
      vertex.next = target;

      if (vertex.prev === null) {
        this.head = vertex;
      } else {
        vertex.prev.next = vertex;
      }

      target.prev = vertex;
      return this;
    },
    // Inserts a vertex after the target vertex
    insertAfter: function (target, vertex) {
      vertex.prev = target;
      vertex.next = target.next;

      if (vertex.next === null) {
        this.tail = vertex;
      } else {
        vertex.next.prev = vertex;
      }

      target.next = vertex;
      return this;
    },
    // Appends a vertex to the end of the linked list
    append: function (vertex) {
      if (this.head === null) {
        this.head = vertex;
      } else {
        this.tail.next = vertex;
      }

      vertex.prev = this.tail;
      vertex.next = null; // the tail has no subsequent vertex

      this.tail = vertex;
      return this;
    },
    // Appends a chain of vertices where 'vertex' is the head.
    appendChain: function (vertex) {
      if (this.head === null) {
        this.head = vertex;
      } else {
        this.tail.next = vertex;
      }

      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain

      while (vertex.next !== null) {
        vertex = vertex.next;
      }

      this.tail = vertex;
      return this;
    },
    // Removes a vertex from the linked list
    remove: function (vertex) {
      if (vertex.prev === null) {
        this.head = vertex.next;
      } else {
        vertex.prev.next = vertex.next;
      }

      if (vertex.next === null) {
        this.tail = vertex.prev;
      } else {
        vertex.next.prev = vertex.prev;
      }

      return this;
    },
    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
    removeSubList: function (a, b) {
      if (a.prev === null) {
        this.head = b.next;
      } else {
        a.prev.next = b.next;
      }

      if (b.next === null) {
        this.tail = a.prev;
      } else {
        b.next.prev = a.prev;
      }

      return this;
    },
    isEmpty: function () {
      return this.head === null;
    }
  });
  return ConvexHull;
}();

const _v1 = new three.Vector3();

const _v2 = new three.Vector3();

const _q1 = new three.Quaternion();
/**
* Returns a single geometry for the given object. If the object is compound,
* its geometries are automatically merged. Bake world scale into each
* geometry, because we can't easily apply that to the cannonjs shapes later.
*/


function getGeometry(object) {
  const meshes = getMeshes(object);
  if (meshes.length === 0) return null; // Single mesh. Return, preserving original type.

  if (meshes.length === 1) {
    return normalizeGeometry(meshes[0]);
  } // Multiple meshes. Merge and return.


  let mesh;
  const geometries = [];

  while (mesh = meshes.pop()) {
    geometries.push(simplifyGeometry(normalizeGeometry(mesh)));
  }

  return mergeBufferGeometries(geometries);
}

function normalizeGeometry(mesh) {
  let geometry = mesh.geometry;

  if (geometry.toBufferGeometry) {
    geometry = geometry.toBufferGeometry();
  } else {
    // Preserve original type, e.g. CylinderBufferGeometry.
    geometry = geometry.clone();
  }

  mesh.updateMatrixWorld();
  mesh.matrixWorld.decompose(_v1, _q1, _v2);
  geometry.scale(_v2.x, _v2.y, _v2.z);
  return geometry;
}
/**
 * Greatly simplified version of BufferGeometryUtils.mergeBufferGeometries.
 * Because we only care about the vertex positions, and not the indices or
 * other attributes, we throw everything else away.
 */


function mergeBufferGeometries(geometries) {
  let vertexCount = 0;

  for (let i = 0; i < geometries.length; i++) {
    const position = geometries[i].attributes.position;

    if (position && position.itemSize === 3) {
      vertexCount += position.count;
    }
  }

  const positionArray = new Float32Array(vertexCount * 3);
  let positionOffset = 0;

  for (let i = 0; i < geometries.length; i++) {
    const position = geometries[i].attributes.position;

    if (position && position.itemSize === 3) {
      for (let j = 0; j < position.count; j++) {
        positionArray[positionOffset++] = position.getX(j);
        positionArray[positionOffset++] = position.getY(j);
        positionArray[positionOffset++] = position.getZ(j);
      }
    }
  }

  return new three.BufferGeometry().setAttribute('position', new three.BufferAttribute(positionArray, 3));
}

function getVertices(geometry) {
  const position = geometry.attributes.position;
  const vertices = new Float32Array(position.count * 3);

  for (let i = 0; i < position.count; i++) {
    vertices[i * 3] = position.getX(i);
    vertices[i * 3 + 1] = position.getY(i);
    vertices[i * 3 + 2] = position.getZ(i);
  }

  return vertices;
}
/**
* Returns a flat array of THREE.Mesh instances from the given object. If
* nested transformations are found, they are applied to child meshes
* as mesh.userData.matrix, so that each mesh has its position/rotation/scale
* independently of all of its parents except the top-level object.
*/

function getMeshes(object) {
  const meshes = [];
  object.traverse(function (o) {
    if (o.isMesh) {
      meshes.push(o);
    }
  });
  return meshes;
}

function getComponent(v, component) {
  switch (component) {
    case 'x':
      return v.x;

    case 'y':
      return v.y;

    case 'z':
      return v.z;
  }

  throw new Error("Unexpected component " + component);
}
/**
* Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex
* attributes other than position.
*
* @param {THREE.BufferGeometry} geometry
* @param {number} tolerance
* @return {THREE.BufferGeometry>}
*/

function simplifyGeometry(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it
  // if it's already available.

  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute('position');
  const vertexCount = indices ? indices.count : positions.count; // Next value for triangle indices.

  let nextIndex = 0;
  const newIndices = [];
  const newPositions = []; // Convert the error tolerance to an amount of decimal places to truncate to.

  const decimalShift = Math.log10(1 / tolerance);
  const shiftMultiplier = Math.pow(10, decimalShift);

  for (let i = 0; i < vertexCount; i++) {
    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'.

    let hash = ''; // Double tilde truncates the decimal value.

    hash += ~~(positions.getX(index) * shiftMultiplier) + ",";
    hash += ~~(positions.getY(index) * shiftMultiplier) + ",";
    hash += ~~(positions.getZ(index) * shiftMultiplier) + ","; // Add another reference to the vertex if it's already
    // used by another index.

    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      newPositions.push(positions.getX(index));
      newPositions.push(positions.getY(index));
      newPositions.push(positions.getZ(index));
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  } // Construct merged BufferGeometry.


  const positionAttribute = new three.BufferAttribute(new Float32Array(newPositions), positions.itemSize, positions.normalized);
  const result = new three.BufferGeometry();
  result.setAttribute('position', positionAttribute);
  result.setIndex(newIndices);
  return result;
}

const PI_2 = Math.PI / 2;
exports.ShapeType = void 0;

(function (ShapeType) {
  ShapeType["BOX"] = "Box";
  ShapeType["CYLINDER"] = "Cylinder";
  ShapeType["SPHERE"] = "Sphere";
  ShapeType["HULL"] = "ConvexPolyhedron";
  ShapeType["MESH"] = "Trimesh";
})(exports.ShapeType || (exports.ShapeType = {}));
/**
 * Given a THREE.Object3D instance, creates parameters for a CANNON shape.
 */


const getShapeParameters = function (object, options = {}) {
  let geometry;

  if (options.type === exports.ShapeType.BOX) {
    return getBoundingBoxParameters(object);
  } else if (options.type === exports.ShapeType.CYLINDER) {
    return getBoundingCylinderParameters(object, options);
  } else if (options.type === exports.ShapeType.SPHERE) {
    return getBoundingSphereParameters(object, options);
  } else if (options.type === exports.ShapeType.HULL) {
    return getConvexPolyhedronParameters(object);
  } else if (options.type === exports.ShapeType.MESH) {
    geometry = getGeometry(object);
    return geometry ? getTrimeshParameters(geometry) : null;
  } else if (options.type) {
    throw new Error("[CANNON.getShapeParameters] Invalid type \"" + options.type + "\".");
  }

  geometry = getGeometry(object);
  if (!geometry) return null;

  switch (geometry.type) {
    case 'BoxGeometry':
    case 'BoxBufferGeometry':
      return getBoxParameters(geometry);

    case 'CylinderGeometry':
    case 'CylinderBufferGeometry':
      return getCylinderParameters(geometry);

    case 'PlaneGeometry':
    case 'PlaneBufferGeometry':
      return getPlaneParameters(geometry);

    case 'SphereGeometry':
    case 'SphereBufferGeometry':
      return getSphereParameters(geometry);

    case 'TubeGeometry':
    case 'BufferGeometry':
      return getBoundingBoxParameters(object);

    default:
      console.warn('Unrecognized geometry: "%s". Using bounding box as shape.', geometry.type);
      return getBoxParameters(geometry);
  }
};
/**
 * Given a THREE.Object3D instance, creates a corresponding CANNON shape.
 */

const threeToCannon = function (object, options = {}) {
  const shapeParameters = getShapeParameters(object, options);

  if (!shapeParameters) {
    return null;
  }

  const {
    type,
    params,
    offset,
    orientation
  } = shapeParameters;
  let shape;

  if (type === exports.ShapeType.BOX) {
    shape = createBox(params);
  } else if (type === exports.ShapeType.CYLINDER) {
    shape = createCylinder(params);
  } else if (type === exports.ShapeType.SPHERE) {
    shape = createSphere(params);
  } else if (type === exports.ShapeType.HULL) {
    shape = createConvexPolyhedron(params);
  } else {
    shape = createTrimesh(params);
  }

  return {
    shape,
    offset,
    orientation
  };
};
/******************************************************************************
 * Shape construction
 */

function createBox(params) {
  const {
    x,
    y,
    z
  } = params;
  const shape = new cannonEs.Box(new cannonEs.Vec3(x, y, z));
  return shape;
}

function createCylinder(params) {
  const {
    radiusTop,
    radiusBottom,
    height,
    segments
  } = params;
  const shape = new cannonEs.Cylinder(radiusTop, radiusBottom, height, segments); // Include metadata for serialization.
  // TODO(cleanup): Is this still necessary?

  shape.radiusTop = radiusBottom;
  shape.radiusBottom = radiusBottom;
  shape.height = height;
  shape.numSegments = segments;
  return shape;
}

function createSphere(params) {
  const shape = new cannonEs.Sphere(params.radius);
  return shape;
}

function createConvexPolyhedron(params) {
  const {
    faces,
    vertices: verticesArray
  } = params;
  const vertices = [];

  for (let i = 0; i < verticesArray.length; i += 3) {
    vertices.push(new cannonEs.Vec3(verticesArray[i], verticesArray[i + 1], verticesArray[i + 2]));
  }

  const shape = new cannonEs.ConvexPolyhedron({
    faces,
    vertices
  });
  return shape;
}

function createTrimesh(params) {
  const {
    vertices,
    indices
  } = params;
  const shape = new cannonEs.Trimesh(vertices, indices);
  return shape;
}
/******************************************************************************
 * Shape parameters
 */


function getBoxParameters(geometry) {
  const vertices = getVertices(geometry);
  if (!vertices.length) return null;
  geometry.computeBoundingBox();
  const box = geometry.boundingBox;
  return {
    type: exports.ShapeType.BOX,
    params: {
      x: (box.max.x - box.min.x) / 2,
      y: (box.max.y - box.min.y) / 2,
      z: (box.max.z - box.min.z) / 2
    }
  };
}
/** Bounding box needs to be computed with the entire subtree, not just geometry. */


function getBoundingBoxParameters(object) {
  const clone = object.clone();
  clone.quaternion.set(0, 0, 0, 1);
  clone.updateMatrixWorld();
  const box = new three.Box3().setFromObject(clone);
  if (!isFinite(box.min.lengthSq())) return null;
  const localPosition = box.translate(clone.position.negate()).getCenter(new three.Vector3());
  return {
    type: exports.ShapeType.BOX,
    params: {
      x: (box.max.x - box.min.x) / 2,
      y: (box.max.y - box.min.y) / 2,
      z: (box.max.z - box.min.z) / 2
    },
    offset: localPosition.lengthSq() ? new cannonEs.Vec3(localPosition.x, localPosition.y, localPosition.z) : undefined
  };
}
/** Computes 3D convex hull as a CANNON.ConvexPolyhedron. */


function getConvexPolyhedronParameters(object) {
  const geometry = getGeometry(object);
  if (!geometry) return null; // Perturb.

  const eps = 1e-4;

  for (let i = 0; i < geometry.attributes.position.count; i++) {
    geometry.attributes.position.setXYZ(i, geometry.attributes.position.getX(i) + (Math.random() - 0.5) * eps, geometry.attributes.position.getY(i) + (Math.random() - 0.5) * eps, geometry.attributes.position.getZ(i) + (Math.random() - 0.5) * eps);
  } // Compute the 3D convex hull.


  const hull = new ConvexHull().setFromObject(new three.Mesh(geometry));
  const hullFaces = hull.faces;
  const vertices = [];
  const faces = [];
  let currentFaceVertex = 0;

  for (let i = 0; i < hullFaces.length; i++) {
    const hullFace = hullFaces[i];
    const face = [];
    faces.push(face);
    let edge = hullFace.edge;

    do {
      const point = edge.head().point;
      vertices.push(point.x, point.y, point.z);
      face.push(currentFaceVertex);
      currentFaceVertex++;
      edge = edge.next;
    } while (edge !== hullFace.edge);
  }

  const verticesTypedArray = new Float32Array(vertices.length);
  verticesTypedArray.set(vertices);
  return {
    type: exports.ShapeType.HULL,
    params: {
      vertices: verticesTypedArray,
      faces
    }
  };
}

function getCylinderParameters(geometry) {
  const params = geometry.parameters;
  return {
    type: exports.ShapeType.CYLINDER,
    params: {
      radiusTop: params.radiusTop,
      radiusBottom: params.radiusBottom,
      height: params.height,
      segments: params.radialSegments
    },
    orientation: new cannonEs.Quaternion().setFromEuler(three.MathUtils.degToRad(-90), 0, 0, 'XYZ').normalize()
  };
}

function getBoundingCylinderParameters(object, options) {
  const axes = ['x', 'y', 'z'];
  const majorAxis = options.cylinderAxis || 'y';
  const minorAxes = axes.splice(axes.indexOf(majorAxis), 1) && axes;
  const box = new three.Box3().setFromObject(object);
  if (!isFinite(box.min.lengthSq())) return null; // Compute cylinder dimensions.

  const height = box.max[majorAxis] - box.min[majorAxis];
  const radius = 0.5 * Math.max(getComponent(box.max, minorAxes[0]) - getComponent(box.min, minorAxes[0]), getComponent(box.max, minorAxes[1]) - getComponent(box.min, minorAxes[1]));
  const eulerX = majorAxis === 'y' ? PI_2 : 0;
  const eulerY = majorAxis === 'z' ? PI_2 : 0;
  return {
    type: exports.ShapeType.CYLINDER,
    params: {
      radiusTop: radius,
      radiusBottom: radius,
      height,
      segments: 12
    },
    orientation: new cannonEs.Quaternion().setFromEuler(eulerX, eulerY, 0, 'XYZ').normalize()
  };
}

function getPlaneParameters(geometry) {
  geometry.computeBoundingBox();
  const box = geometry.boundingBox;
  return {
    type: exports.ShapeType.BOX,
    params: {
      x: (box.max.x - box.min.x) / 2 || 0.1,
      y: (box.max.y - box.min.y) / 2 || 0.1,
      z: (box.max.z - box.min.z) / 2 || 0.1
    }
  };
}

function getSphereParameters(geometry) {
  return {
    type: exports.ShapeType.SPHERE,
    params: {
      radius: geometry.parameters.radius
    }
  };
}

function getBoundingSphereParameters(object, options) {
  if (options.sphereRadius) {
    return {
      type: exports.ShapeType.SPHERE,
      params: {
        radius: options.sphereRadius
      }
    };
  }

  const geometry = getGeometry(object);
  if (!geometry) return null;
  geometry.computeBoundingSphere();
  return {
    type: exports.ShapeType.SPHERE,
    params: {
      radius: geometry.boundingSphere.radius
    }
  };
}

function getTrimeshParameters(geometry) {
  const vertices = getVertices(geometry);
  if (!vertices.length) return null;
  const indices = new Uint32Array(vertices.length);

  for (let i = 0; i < vertices.length; i++) {
    indices[i] = i;
  }

  return {
    type: exports.ShapeType.MESH,
    params: {
      vertices,
      indices
    }
  };
}

exports.getShapeParameters = getShapeParameters;
exports.threeToCannon = threeToCannon;
//# sourceMappingURL=three-to-cannon.cjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUN2UkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGFBQWEsU0FBUztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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TjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE1BQU07QUFDcEIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1IscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUixzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxNQUFNOzs7QUFHTixvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRixvQ0FBb0M7O0FBRXBDLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsY0FBYztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUhBQXFIOztBQUVySDtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLG9FQUFvRTs7QUFFcEU7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsc0JBQXNCO0FBQ3RCOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsbUNBQW1DO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QyxzQkFBc0IsbUJBQW1CO0FBQ3pDLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QyxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhELG9EQUFvRDtBQUNwRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkIsb0JBQW9CLG9CQUFvQjtBQUN4QywwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTs7QUFFM0UseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVix1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzR0FBc0c7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0MsZ0NBQWdDO0FBQ2hDOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFdBQVc7QUFDbkMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DLDBCQUEwQixXQUFXO0FBQ3JDLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUixnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQywyQkFBMkI7O0FBRTNCO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DLHFGQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQixxQ0FBcUMsd0JBQXdCO0FBQ2hKOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQyxzQkFBc0IsT0FBTztBQUM3QiwrRUFBK0U7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sb0JBQW9CLHNCQUFzQjtBQUMxQyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3Qjs7QUFFeEI7QUFDQSxzQ0FBc0M7O0FBRXRDLHdEQUF3RDs7QUFFeEQsdUNBQXVDOztBQUV2QztBQUNBLDRCQUE0Qjs7QUFFNUIsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixvQkFBb0I7QUFDcEI7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsaUJBQWlCO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFNBQVM7QUFDdkI7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsU0FBUztBQUN2Qjs7O0FBR0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxTQUFTO0FBQ3ZCOzs7QUFHQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTiwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQzs7QUFFQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUEsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUiw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTs7QUFFQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04saUNBQWlDOztBQUVqQzs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV5c0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbmlZN3JCO0FBQ2I7QUFDK0I7O0FBRXhCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyw2RkFBNkY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTyw2RUFBNkU7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPLGtGQUFrRjtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVPLGlGQUFpRjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVPLDhFQUE4RTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVPLGdGQUFnRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQLHFCQUFxQiwwQ0FBYTtBQUNsQyxxQkFBcUIsMENBQWE7QUFDbEMscUJBQXFCLDBDQUFhO0FBQ2xDLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZLGFBQWEsUUFBUSxhQUFhO0FBQ3BHO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1AscUJBQXFCLDBDQUFhO0FBQ2xDLHFCQUFxQiwwQ0FBYTtBQUNsQyxxQkFBcUIsMENBQWE7QUFDbEMsd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQLHFCQUFxQiwwQ0FBYTtBQUNsQyxxQkFBcUIsMENBQWE7QUFDbEMscUJBQXFCLDBDQUFhO0FBQ2xDLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUCxpQkFBaUIsMENBQWE7QUFDOUIsaUJBQWlCLDBDQUFhO0FBQzlCLGlCQUFpQiwwQ0FBYTtBQUM5QixxQkFBcUIsMENBQWE7QUFDbEMsd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDJEQUEyRDtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxVQUFVLE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsMENBQWE7QUFDdEM7O0FBRUE7QUFDQSw4QkFBOEIsNkNBQWdCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1Asc0JBQXNCLDBDQUFhO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsMENBQWE7QUFDbkM7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQiwwQ0FBYTtBQUNsQywyQ0FBMkM7QUFDM0Msc0JBQXNCLDBDQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsMENBQWE7QUFDbEM7QUFDQTtBQUNBLFVBQVUsc0JBQXNCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsMEJBQTBCLDBDQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwwQ0FBYTtBQUNsQyxxQkFBcUIsMENBQWE7QUFDbEM7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUM5d0JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBbUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsOEJBQW1COztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOEJBQW1COztBQUU3QjtBQUNBLFVBQVUsOEJBQW1COztBQUU3QjtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1Qjs7QUFFcEQ7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQkFBZ0IsOEJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QiwyREFBMkQsYUFBYTtBQUN4RTs7QUFFQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSw0Q0FBNEM7QUFDNUMsWUFBWSw4QkFBbUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQzs7QUFFL0Q7QUFDQSxVQUFVLDhCQUFtQjs7QUFFN0I7QUFDQSxVQUFVLDhCQUFtQixzQkFBc0Isb0JBQW9COztBQUV2RSxVQUFVLDhCQUFtQixDQUFDLDhCQUFtQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFtQjtBQUM3Qjs7QUFFQSx3Q0FBd0Msa0NBQWtDOztBQUUxRTs7QUFFQSxxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsdUNBQXVDO0FBQzdILHNJQUFzSSxnREFBZ0Qsd0VBQXdFLGdCQUFnQixFQUFFO0FBQ2hSLEdBQUc7O0FBRUgsaUhBQWlILDZDQUE2QyxxRUFBcUUsZ0JBQWdCLFNBQVM7O0FBRTVQLHNDQUFzQyx5QkFBeUI7QUFDL0Qsc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQSxtQkFBbUIsMEVBQWtDOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWMsa0JBQWtCOztBQUVoQztBQUNBLGFBQWEsY0FBYztBQUMzQixtQkFBbUIsY0FBYzs7QUFFakM7QUFDQSxZQUFZLHlCQUF5QixvQkFBb0I7QUFDekQsa0JBQWtCLHlCQUF5QixvQkFBb0I7O0FBRS9EO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsaUJBQWlCLDhCQUE4QjtBQUMvQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0RkFBNEYsS0FBSyxZQUFZO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUM3S0Q7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsNERBQWU7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMkNBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLFlBQVksWUFBWTtBQUN4QixlQUFlLHlCQUF5Qiw0Q0FBNEM7QUFDcEYscUJBQXFCLGVBQWU7QUFDcEMsc0JBQXNCLGVBQWU7QUFDckMsK0JBQStCLGNBQWM7QUFDN0MsZ0NBQWdDLGNBQWM7QUFDOUMscUJBQXFCLHlCQUF5QixvQkFBb0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksd0VBQXdFO0FBQ3BGLDJCQUEyQixnQkFBZ0I7QUFDM0Msd0JBQXdCLGdCQUFnQjtBQUN4Qyw0QkFBNEIsWUFBWTtBQUN4QywyQkFBMkIsWUFBWTtBQUN2Qyx1QkFBdUIsZUFBZTtBQUN0QyxrQkFBa0IsWUFBWTtBQUM5QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxvQkFBb0I7O0FBRXhEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DLGlEQUFpRDs7QUFFakQsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQixLQUFLO0FBQy9DO0FBQ0E7QUFDQTs7O0FBR0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtGQUFrRjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUEsa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjs7Ozs7OztVQzV5Q0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7VUVOQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL2luZGV4LmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL2xpYi9DQU5OT04tc2hhcGUybWVzaC5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvYWZyYW1lLXN0YXRzLXBhbmVsL2luZGV4LmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL25vZGVfbW9kdWxlcy9hbW1vLWRlYnVnLWRyYXdlci9BbW1vRGVidWdEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vbm9kZV9tb2R1bGVzL2Nhbm5vbi1lcy9kaXN0L2Nhbm5vbi1lcy5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvdGhyZWUtdG8tYW1tby9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9jb21wb25lbnRzL2FtbW8tY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvY29tcG9uZW50cy9ib2R5L2FtbW8tYm9keS5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvY29tcG9uZW50cy9ib2R5L2JvZHkuanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vc3JjL2NvbXBvbmVudHMvYm9keS9keW5hbWljLWJvZHkuanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vc3JjL2NvbXBvbmVudHMvYm9keS9zdGF0aWMtYm9keS5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvY29tcG9uZW50cy9jb25zdHJhaW50LmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9jb21wb25lbnRzL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vc3JjL2NvbXBvbmVudHMvbWF0aC92ZWxvY2l0eS5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvY29tcG9uZW50cy9zaGFwZS9hbW1vLXNoYXBlLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9jb21wb25lbnRzL3NoYXBlL3NoYXBlLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9jb21wb25lbnRzL3NwcmluZy5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9kcml2ZXJzL2FtbW8tZHJpdmVyLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9kcml2ZXJzL2RyaXZlci5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvZHJpdmVycy9ldmVudC5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvZHJpdmVycy9sb2NhbC1kcml2ZXIuanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vc3JjL2RyaXZlcnMvbmV0d29yay1kcml2ZXIuanMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtLy4vc3JjL2RyaXZlcnMvd2Vid29ya2lmeS1kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvZHJpdmVycy93b3JrZXItZHJpdmVyLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy9kcml2ZXJzL3dvcmtlci5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9zcmMvc3lzdGVtLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy91dGlscy9tYXRoLmpzIiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS8uL3NyYy91dGlscy9wcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vZXh0ZXJuYWwgdmFyIFwiVEhSRUVcIiIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvdGhyZWUtdG8tY2Fubm9uL2Rpc3QvdGhyZWUtdG8tY2Fubm9uLmNqcyIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL0BjLWZyYW1lL2FmcmFtZS1waHlzaWNzLXN5c3RlbS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vQGMtZnJhbWUvYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9AYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDQU5OT04gPSByZXF1aXJlKCdjYW5ub24tZXMnKTtcblxucmVxdWlyZSgnLi9zcmMvY29tcG9uZW50cy9tYXRoJyk7XG5yZXF1aXJlKCcuL3NyYy9jb21wb25lbnRzL2JvZHkvYW1tby1ib2R5Jyk7XG5yZXF1aXJlKCcuL3NyYy9jb21wb25lbnRzL2JvZHkvYm9keScpO1xucmVxdWlyZSgnLi9zcmMvY29tcG9uZW50cy9ib2R5L2R5bmFtaWMtYm9keScpO1xucmVxdWlyZSgnLi9zcmMvY29tcG9uZW50cy9ib2R5L3N0YXRpYy1ib2R5Jyk7XG5yZXF1aXJlKCcuL3NyYy9jb21wb25lbnRzL3NoYXBlL3NoYXBlJyk7XG5yZXF1aXJlKCcuL3NyYy9jb21wb25lbnRzL3NoYXBlL2FtbW8tc2hhcGUnKVxucmVxdWlyZSgnLi9zcmMvY29tcG9uZW50cy9hbW1vLWNvbnN0cmFpbnQnKTtcbnJlcXVpcmUoJy4vc3JjL2NvbXBvbmVudHMvY29uc3RyYWludCcpO1xucmVxdWlyZSgnLi9zcmMvY29tcG9uZW50cy9zcHJpbmcnKTtcbnJlcXVpcmUoJy4vc3JjL3N5c3RlbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVnaXN0ZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLndhcm4oJ3JlZ2lzdGVyQWxsKCkgaXMgZGVwcmVjYXRlZC4gQ29tcG9uZW50cyBhcmUgYXV0b21hdGljYWxseSByZWdpc3RlcmVkLicpO1xuICB9XG59O1xuXG4vLyBFeHBvcnQgQ0FOTk9OLmpzLlxud2luZG93LkNBTk5PTiA9IHdpbmRvdy5DQU5OT04gfHwgQ0FOTk9OO1xuIiwiLyoqXG4gKiBDQU5OT04uc2hhcGUybWVzaFxuICpcbiAqIFNvdXJjZTogaHR0cHM6Ly9zY2h0ZXBwZS5naXRodWIuaW8vY2Fubm9uLmpzL2J1aWxkL2Nhbm5vbi5kZW1vLmpzXG4gKiBBdXRob3I6IEBzY2h0ZXBwZVxuICovXG52YXIgQ0FOTk9OID0gcmVxdWlyZSgnY2Fubm9uLWVzJyk7XG5cbkNBTk5PTi5zaGFwZTJtZXNoID0gZnVuY3Rpb24oYm9keSl7XG4gICAgdmFyIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyR2VvbWV0cnkocG9zaXRpb25zLCBmYWNlcykge1xuXG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChmYWNlcyk7XG4gICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGJvZHkuc2hhcGVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2xdO1xuXG4gICAgICAgIHZhciBtZXNoO1xuXG4gICAgICAgIHN3aXRjaChzaGFwZS50eXBlKXtcblxuICAgICAgICBjYXNlIENBTk5PTi5TaGFwZS50eXBlcy5TUEhFUkU6XG4gICAgICAgICAgICB2YXIgc3BoZXJlX2dlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzaGFwZS5yYWRpdXMsIDgsIDgpO1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBzcGhlcmVfZ2VvbWV0cnksIHRoaXMuY3VycmVudE1hdGVyaWFsICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENBTk5PTi5TaGFwZS50eXBlcy5QQVJUSUNMRTpcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5wYXJ0aWNsZUdlbywgdGhpcy5wYXJ0aWNsZU1hdGVyaWFsICk7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgICAgICBtZXNoLnNjYWxlLnNldChzLnBhcnRpY2xlU2l6ZSxzLnBhcnRpY2xlU2l6ZSxzLnBhcnRpY2xlU2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENBTk5PTi5TaGFwZS50eXBlcy5QTEFORTpcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDEwLCAxMCwgNCwgNCk7XG4gICAgICAgICAgICBtZXNoID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gICAgICAgICAgICB2YXIgc3VibWVzaCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgICAgICAgICAgdmFyIGdyb3VuZCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgdGhpcy5jdXJyZW50TWF0ZXJpYWwgKTtcbiAgICAgICAgICAgIGdyb3VuZC5zY2FsZS5zZXQoMTAwLCAxMDAsIDEwMCk7XG4gICAgICAgICAgICBzdWJtZXNoLmFkZChncm91bmQpO1xuXG4gICAgICAgICAgICBncm91bmQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICBncm91bmQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lc2guYWRkKHN1Ym1lc2gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDQU5OT04uU2hhcGUudHlwZXMuQk9YOlxuICAgICAgICAgICAgdmFyIGJveF9nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggIHNoYXBlLmhhbGZFeHRlbnRzLngqMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuaGFsZkV4dGVudHMueSoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5oYWxmRXh0ZW50cy56KjIgKTtcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggYm94X2dlb21ldHJ5LCB0aGlzLmN1cnJlbnRNYXRlcmlhbCApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDQU5OT04uU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTjpcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRpY2VzXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW11cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHYueCwgdi55LCB2LnopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBbXVxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBzaGFwZS5mYWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBzaGFwZS5mYWNlc1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGZhY2VbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBmYWNlLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZhY2Vbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZmFjZVtqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goYSwgYiwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2VvID0gY3JlYXRlQnVmZmVyR2VvbWV0cnkocG9zaXRpb25zLCBmYWNlcyk7XG4gICAgICAgICAgICBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlbywgdGhpcy5jdXJyZW50TWF0ZXJpYWwgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ0FOTk9OLlNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEOlxuXG4gICAgICAgICAgICB2YXIgdjAgPSBuZXcgQ0FOTk9OLlZlYzMoKTtcbiAgICAgICAgICAgIHZhciB2MSA9IG5ldyBDQU5OT04uVmVjMygpO1xuICAgICAgICAgICAgdmFyIHYyID0gbmV3IENBTk5PTi5WZWMzKCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHhpID0gMDsgeGkgPCBzaGFwZS5kYXRhLmxlbmd0aCAtIDE7IHhpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5aSA9IDA7IHlpIDwgc2hhcGUuZGF0YVt4aV0ubGVuZ3RoIC0gMTsgeWkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBrPT09MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2MC5jb3B5KHNoYXBlLnBpbGxhckNvbnZleC52ZXJ0aWNlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2MS5jb3B5KHNoYXBlLnBpbGxhckNvbnZleC52ZXJ0aWNlc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Mi5jb3B5KHNoYXBlLnBpbGxhckNvbnZleC52ZXJ0aWNlc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2MC52YWRkKHNoYXBlLnBpbGxhck9mZnNldCwgdjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjEudmFkZChzaGFwZS5waWxsYXJPZmZzZXQsIHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyLnZhZGQoc2hhcGUucGlsbGFyT2Zmc2V0LCB2Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MC54LCB2MC55LCB2MC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxLngsIHYxLnksIHYxLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIueCwgdjIueSwgdjIuelxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaChpLCBpKzEsIGkrMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBjcmVhdGVCdWZmZXJHZW9tZXRyeShwb3NpdGlvbnMsIGZhY2VzKTtcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgdGhpcy5jdXJyZW50TWF0ZXJpYWwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDQU5OT04uU2hhcGUudHlwZXMuVFJJTUVTSDpcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgICAgICAgICB2YXIgdjAgPSBuZXcgQ0FOTk9OLlZlYzMoKTtcbiAgICAgICAgICAgIHZhciB2MSA9IG5ldyBDQU5OT04uVmVjMygpO1xuICAgICAgICAgICAgdmFyIHYyID0gbmV3IENBTk5PTi5WZWMzKCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgZmFjZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIHYwLCB2MSwgdjIpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB2MC54LCB2MC55LCB2MC56LFxuICAgICAgICAgICAgICAgICAgICB2MS54LCB2MS55LCB2MS56LFxuICAgICAgICAgICAgICAgICAgICB2Mi54LCB2Mi55LCB2Mi56XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMztcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKGosIGorMSwgaisyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IGNyZWF0ZUJ1ZmZlckdlb21ldHJ5KHBvc2l0aW9ucywgZmFjZXMpO1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCB0aGlzLmN1cnJlbnRNYXRlcmlhbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJWaXN1YWwgdHlwZSBub3QgcmVjb2duaXplZDogXCIrc2hhcGUudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lc2gucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIG1lc2guY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgIGlmKG1lc2guY2hpbGRyZW4pe1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bWVzaC5jaGlsZHJlbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbWVzaC5jaGlsZHJlbltpXS5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZXNoLmNoaWxkcmVuW2ldLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmKG1lc2guY2hpbGRyZW5baV0pe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajxtZXNoLmNoaWxkcmVuW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guY2hpbGRyZW5baV0uY2hpbGRyZW5bal0uY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmNoaWxkcmVuW2ldLmNoaWxkcmVuW2pdLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG8gPSBib2R5LnNoYXBlT2Zmc2V0c1tsXTtcbiAgICAgICAgdmFyIHEgPSBib2R5LnNoYXBlT3JpZW50YXRpb25zW2xdO1xuICAgICAgICBtZXNoLnBvc2l0aW9uLnNldChvLngsIG8ueSwgby56KTtcbiAgICAgICAgbWVzaC5xdWF0ZXJuaW9uLnNldChxLngsIHEueSwgcS56LCBxLncpO1xuXG4gICAgICAgIG9iai5hZGQobWVzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ0FOTk9OLnNoYXBlMm1lc2g7XG4iLCJBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3N0YXRzLXBhbmVsJywge1xyXG4gIHNjaGVtYToge1xyXG4gICAgbWVyZ2U6IHt0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9XHJcbiAgfSxcclxuXHJcbiAgaW5pdCgpIHtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucnMtY29udGFpbmVyJylcclxuXHJcbiAgICBpZiAoY29udGFpbmVyICYmIHRoaXMuZGF0YS5tZXJnZSkge1xyXG4gICAgICAvL3N0YXRzIHBhbmVsIGV4aXN0cywganVzdCBtZXJnZSBpbnRvIGl0LlxyXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgc3RhdHMgcGFuZWwgZG9lc24ndCBleGlzdCwgYWRkIG9uZSB0byBzdXBwb3J0IG91ciBjdXN0b20gc3RhdHMuXHJcbiAgICB0aGlzLmJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGhpcy5iYXNlLmNsYXNzTGlzdC5hZGQoJ3JzLWJhc2UnKVxyXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXVxyXG5cclxuICAgIGlmIChjb250YWluZXIgJiYgIXRoaXMuZGF0YS5tZXJnZSkge1xyXG4gICAgICB0aGlzLmJhc2Uuc3R5bGUudG9wID0gXCJhdXRvXCJcclxuICAgICAgdGhpcy5iYXNlLnN0eWxlLmJvdHRvbSA9IFwiMjBweFwiXHJcbiAgICB9XHJcblxyXG4gICAgYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhc2UpXHJcblxyXG4gICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncnMtY29udGFpbmVyJylcclxuICAgIHRoaXMuYmFzZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcilcclxuICB9XHJcbn0pO1xyXG5cclxuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzdGF0cy1ncm91cCcsIHtcclxuICBtdWx0aXBsZTogdHJ1ZSxcclxuICBzY2hlbWE6IHtcclxuICAgIGxhYmVsOiB7dHlwZTogJ3N0cmluZyd9XHJcbiAgfSxcclxuXHJcbiAgaW5pdCgpIHtcclxuXHJcbiAgICBsZXQgY29udGFpbmVyXHJcbiAgICBjb25zdCBiYXNlQ29tcG9uZW50ID0gdGhpcy5lbC5jb21wb25lbnRzWydzdGF0cy1wYW5lbCddXHJcbiAgICBpZiAoYmFzZUNvbXBvbmVudCkge1xyXG4gICAgICBjb250YWluZXIgPSBiYXNlQ29tcG9uZW50LmNvbnRhaW5lclxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ycy1jb250YWluZXInKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGRuJ3QgZmluZCBzdGF0cyBjb250YWluZXIgdG8gYWRkIHN0YXRzIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgIEFkZCBlaXRoZXIgc3RhdHMgb3Igc3RhdHMtcGFuZWwgY29tcG9uZW50IHRvIGEtc2NlbmVgKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZ3JvdXBIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpXHJcbiAgICB0aGlzLmdyb3VwSGVhZGVyLmlubmVySFRNTCA9IHRoaXMuZGF0YS5sYWJlbFxyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ3JvdXBIZWFkZXIpXHJcblxyXG4gICAgdGhpcy5ncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0aGlzLmdyb3VwLmNsYXNzTGlzdC5hZGQoJ3JzLWdyb3VwJylcclxuICAgIC8vIHJzLWdyb3VwIGhzIHN0eWxlIGZsZXgtZGlyZWN0aW9uIG9mICdjb2x1bW4tcmV2ZXJzZSdcclxuICAgIC8vIE5vIGlkZWEgd2h5IGl0J3MgbGlrZSB0aGF0LCBidXQgaXQncyBub3Qgd2hhdCB3ZSB3YW50IGZvciBvdXIgc3RhdHMuXHJcbiAgICAvLyBXZSBwcmVmZXIgdGhlbSByZW5kZXJlZCBpbiB0aGUgb3JkZXIgc3BlaWZpZWQuXHJcbiAgICAvLyBTbyBvdmVycmlkZSB0aGlzIHN0eWxlLlxyXG4gICAgdGhpcy5ncm91cC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gJ2NvbHVtbidcclxuICAgIHRoaXMuZ3JvdXAuc3R5bGUud2ViS2l0RmxleERpcmVjdGlvbiA9ICdjb2x1bW4nXHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ncm91cClcclxuICB9XHJcbn0pO1xyXG5cclxuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzdGF0cy1yb3cnLCB7XHJcbiAgbXVsdGlwbGU6IHRydWUsXHJcbiAgc2NoZW1hOiB7XHJcbiAgICAvLyBuYW1lIG9mIHRoZSBncm91cCB0byBhZGQgdGhlIHN0YXRzIHJvdyB0by5cclxuICAgIGdyb3VwOiB7dHlwZTogJ3N0cmluZyd9LFxyXG5cclxuICAgIC8vIG5hbWUgb2YgYW4gZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgZXZlbnQ6IHt0eXBlOiAnc3RyaW5nJ30sXHJcblxyXG4gICAgLy8gcHJvcGVydHkgZnJvbSBldmVudCB0byBvdXRwdXQgaW4gc3RhdHMgcGFuZWxcclxuICAgIHByb3BlcnRpZXM6IHt0eXBlOiAnYXJyYXknfSxcclxuXHJcbiAgICAvLyBsYWJlbCBmb3IgdGhlIHJvdyBpbiB0aGUgc3RhdHMgcGFuZWxcclxuICAgIGxhYmVsOiB7dHlwZTogJ3N0cmluZyd9XHJcbiAgfSxcclxuXHJcbiAgaW5pdCAoKSB7XHJcblxyXG4gICAgY29uc3QgZ3JvdXBDb21wb25lbnROYW1lID0gXCJzdGF0cy1ncm91cF9fXCIgKyB0aGlzLmRhdGEuZ3JvdXBcclxuICAgIGNvbnN0IGdyb3VwQ29tcG9uZW50ID0gdGhpcy5lbC5jb21wb25lbnRzW2dyb3VwQ29tcG9uZW50TmFtZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5zY2VuZUVsLmNvbXBvbmVudHNbZ3JvdXBDb21wb25lbnROYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmNvbXBvbmVudHNbXCJzdGF0cy1ncm91cFwiXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnNjZW5lRWwuY29tcG9uZW50c1tcInN0YXRzLWdyb3VwXCJdXHJcblxyXG4gICAgaWYgKCFncm91cENvbXBvbmVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkbid0IGZpbmQgc3RhdHMgZ3JvdXAgJHtncm91cENvbXBvbmVudE5hbWV9YClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgdGhpcy5jb3VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRoaXMuY291bnRlci5jbGFzc0xpc3QuYWRkKCdycy1jb3VudGVyLWJhc2UnKVxyXG4gICAgZ3JvdXBDb21wb25lbnQuZ3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5jb3VudGVyKVxyXG5cclxuICAgIHRoaXMuY291bnRlcklkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRoaXMuY291bnRlcklkLmNsYXNzTGlzdC5hZGQoJ3JzLWNvdW50ZXItaWQnKVxyXG4gICAgdGhpcy5jb3VudGVySWQuaW5uZXJIVE1MID0gdGhpcy5kYXRhLmxhYmVsXHJcbiAgICB0aGlzLmNvdW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5jb3VudGVySWQpXHJcblxyXG4gICAgdGhpcy5jb3VudGVyVmFsdWVzID0ge31cclxuICAgIHRoaXMuZGF0YS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgIGNvdW50ZXJWYWx1ZS5jbGFzc0xpc3QuYWRkKCdycy1jb3VudGVyLXZhbHVlJylcclxuICAgICAgY291bnRlclZhbHVlLmlubmVySFRNTCA9IFwiLi4uXCJcclxuICAgICAgdGhpcy5jb3VudGVyLmFwcGVuZENoaWxkKGNvdW50ZXJWYWx1ZSlcclxuICAgICAgdGhpcy5jb3VudGVyVmFsdWVzW3Byb3BlcnR5XSA9IGNvdW50ZXJWYWx1ZVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURhdGEgPSB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKVxyXG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZGF0YS5ldmVudCwgdGhpcy51cGRhdGVEYXRhKVxyXG5cclxuICAgIHRoaXMuc3BsaXRDYWNoZSA9IHt9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlRGF0YShlKSB7XHJcbiAgICBcclxuICAgIHRoaXMuZGF0YS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgIGNvbnN0IHNwbGl0ID0gdGhpcy5zcGxpdERvdChwcm9wZXJ0eSk7XHJcbiAgICAgIGxldCB2YWx1ZSA9IGUuZGV0YWlsO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlW3NwbGl0W2ldXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmNvdW50ZXJWYWx1ZXNbcHJvcGVydHldLmlubmVySFRNTCA9IHZhbHVlXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG4gIHNwbGl0RG90IChwYXRoKSB7XHJcbiAgICBpZiAocGF0aCBpbiB0aGlzLnNwbGl0Q2FjaGUpIHsgcmV0dXJuIHRoaXMuc3BsaXRDYWNoZVtwYXRoXTsgfVxyXG4gICAgdGhpcy5zcGxpdENhY2hlW3BhdGhdID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgcmV0dXJuIHRoaXMuc3BsaXRDYWNoZVtwYXRoXTtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc3RhdHMtY29sbGVjdG9yJywge1xyXG4gIG11bHRpcGxlOiB0cnVlLFxyXG5cclxuICBzY2hlbWE6IHtcclxuICAgIC8vIG5hbWUgb2YgYW4gZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgaW5FdmVudDoge3R5cGU6ICdzdHJpbmcnfSxcclxuXHJcbiAgICAvLyBwcm9wZXJ0eSBmcm9tIGV2ZW50IHRvIG91dHB1dCBpbiBzdGF0cyBwYW5lbFxyXG4gICAgcHJvcGVydGllczoge3R5cGU6ICdhcnJheSd9LFxyXG5cclxuICAgIC8vIGZyZXF1ZW5jeSBvZiBvdXRwdXQgaW4gdGVybXMgb2YgZXZlbnRzIHJlY2VpdmVkLlxyXG4gICAgb3V0cHV0RnJlcXVlbmN5OiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEwMH0sXHJcblxyXG4gICAgLy8gbmFtZSBvZiBldmVudCB0byBlbWl0XHJcbiAgICBvdXRFdmVudDoge3R5cGU6ICdzdHJpbmcnfSxcclxuICAgIFxyXG4gICAgLy8gb3V0cHV0cyAoZ2VuZXJhdGVkIGZvciBlYWNoIHByb3BlcnR5KVxyXG4gICAgLy8gQ29tYmluYXRpb24gb2Y6IG1lYW4sIG1heCwgcGVyY2VudGlsZV9fWFguWCAod2hlcmUgWFguWCBpcyBhIG51bWJlcilcclxuICAgIG91dHB1dHM6IHt0eXBlOiAnYXJyYXknfSxcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRvIG91dHB1dCB0byBjb25zb2xlIGFzIHdlbGwgYXMgZ2VuZXJhdGluZyBldmVudHNcclxuICAgIC8vIElmIGEgc3RyaW5nIGlzIHNwZWNpZmllZCwgdGhpcyBpcyBvdXRwdXQgdG8gY29uc29sZSwgdG9nZXRoZXIgd2l0aCB0aGUgZXZlbnQgZGF0YVxyXG4gICAgLy8gSWYgbm8gc3RyaW5nIGlzIHNwZWNpZmllZCwgbm90aGluZyBpcyBvdXRwdXQgdG8gY29uc29sZS5cclxuICAgIG91dHB1dFRvQ29uc29sZToge3R5cGU6ICdzdHJpbmcnfVxyXG4gIH0sXHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICBcclxuICAgIHRoaXMuc3RhdHNEYXRhID0ge31cclxuICAgIHRoaXMucmVzZXREYXRhKClcclxuICAgIHRoaXMub3V0cHV0RGV0YWlsID0ge31cclxuICAgIHRoaXMuZGF0YS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgIHRoaXMub3V0cHV0RGV0YWlsW3Byb3BlcnR5XSA9IHt9XHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMuc3RhdHNSZWNlaXZlZCA9IHRoaXMuc3RhdHNSZWNlaXZlZC5iaW5kKHRoaXMpXHJcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5kYXRhLmluRXZlbnQsIHRoaXMuc3RhdHNSZWNlaXZlZClcclxuICB9LFxyXG4gIFxyXG4gIHJlc2V0RGF0YSgpIHtcclxuXHJcbiAgICB0aGlzLmNvdW50ZXIgPSAwXHJcbiAgICB0aGlzLmRhdGEucHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICBcclxuICAgICAgLy8gRm9yIGNhbGN1bGF0aW5nIHBlcmNlbnRpbGVzIGxpa2UgMC4wMSBhbmQgOTkuOSUgd2UnbGwgd2FudCB0byBzdG9yZVxyXG4gICAgICAvLyBhZGRpdGlvbmFsIGRhdGEgLSBzb21ldGhpbmcgbGlrZSB0aGlzLi4uXHJcbiAgICAgIC8vIFN0b3JlIG9mZiBvdXRsaWVycywgYW5kIGRpc2NhcmQgZGF0YS5cclxuICAgICAgLy8gY29uc3QgbWluID0gTWF0aC5taW4oLi4udGhpcy5zdGF0c0RhdGFbcHJvcGVydHldKVxyXG4gICAgICAvLyB0aGlzLmxvd091dGxpZXJzW3Byb3BlcnR5XS5wdXNoKG1pbilcclxuICAgICAgLy8gY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4udGhpcy5zdGF0c0RhdGFbcHJvcGVydHldKVxyXG4gICAgICAvLyB0aGlzLmhpZ2hPdXRsaWVyc1twcm9wZXJ0eV0ucHVzaChtYXgpXHJcblxyXG4gICAgICB0aGlzLnN0YXRzRGF0YVtwcm9wZXJ0eV0gPSBbXVxyXG4gICAgfSlcclxuICB9LFxyXG5cclxuICBzdGF0c1JlY2VpdmVkKGUpIHtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURhdGEoZS5kZXRhaWwpXHJcblxyXG4gICAgdGhpcy5jb3VudGVyKysgXHJcbiAgICBpZiAodGhpcy5jb3VudGVyID09PSB0aGlzLmRhdGEub3V0cHV0RnJlcXVlbmN5KSB7XHJcbiAgICAgIHRoaXMub3V0cHV0RGF0YSgpXHJcbiAgICAgIHRoaXMucmVzZXREYXRhKClcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVEYXRhKGRldGFpbCkge1xyXG5cclxuICAgIHRoaXMuZGF0YS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgIGxldCB2YWx1ZSA9IGRldGFpbDtcclxuICAgICAgdmFsdWUgPSB2YWx1ZVtwcm9wZXJ0eV07XHJcbiAgICAgIHRoaXMuc3RhdHNEYXRhW3Byb3BlcnR5XS5wdXNoKHZhbHVlKVxyXG4gICAgfSlcclxuICB9LFxyXG5cclxuICBvdXRwdXREYXRhKCkge1xyXG4gICAgdGhpcy5kYXRhLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcclxuICAgICAgdGhpcy5kYXRhLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXREZXRhaWxbcHJvcGVydHldW291dHB1dF0gPSB0aGlzLmNvbXB1dGVPdXRwdXQob3V0cHV0LCB0aGlzLnN0YXRzRGF0YVtwcm9wZXJ0eV0pXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIGlmICh0aGlzLmRhdGEub3V0RXZlbnQpIHtcclxuICAgICAgdGhpcy5lbC5lbWl0KHRoaXMuZGF0YS5vdXRFdmVudCwgdGhpcy5vdXRwdXREZXRhaWwpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZGF0YS5vdXRwdXRUb0NvbnNvbGUpIHtcclxuICAgICAgY29uc29sZS5sb2codGhpcy5kYXRhLm91dHB1dFRvQ29uc29sZSwgdGhpcy5vdXRwdXREZXRhaWwpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY29tcHV0ZU91dHB1dChvdXRwdXRJbnN0cnVjdGlvbiwgZGF0YSkge1xyXG5cclxuICAgIGNvbnN0IG91dHB1dEluc3RydWN0aW9ucyA9IG91dHB1dEluc3RydWN0aW9uLnNwbGl0KFwiX19cIilcclxuICAgIGNvbnN0IG91dHB1dFR5cGUgPSBvdXRwdXRJbnN0cnVjdGlvbnNbMF1cclxuICAgIGxldCBvdXRwdXRcclxuXHJcbiAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcclxuICAgICAgY2FzZSBcIm1lYW5cIjpcclxuICAgICAgICBvdXRwdXQgPSBkYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIFxyXG4gICAgICBjYXNlIFwibWF4XCI6XHJcbiAgICAgICAgb3V0cHV0ID0gTWF0aC5tYXgoLi4uZGF0YSlcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgXCJtaW5cIjpcclxuICAgICAgICBvdXRwdXQgPSBNYXRoLm1pbiguLi5kYXRhKVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBcInBlcmNlbnRpbGVcIjpcclxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBkYXRhLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxyXG4gICAgICAgIC8vIGRlY2ltYWwgcGVyY2VudGlsZXMgZW5jb2RlZCBsaWtlIDk5KzkgcmF0aGVyIHRoYW4gOTkuOSBkdWUgdG8gXCIuXCIgYmVpbmcgdXNlZCBhcyBhIFxyXG4gICAgICAgIC8vIHNlcGFyYXRvciBmb3IgbmVzdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgY29uc3QgcGVyY2VudGlsZVN0cmluZyA9IG91dHB1dEluc3RydWN0aW9uc1sxXS5yZXBsYWNlKFwiX1wiLCBcIi5cIilcclxuICAgICAgICBjb25zdCBwcm9wb3J0aW9uID0gK3BlcmNlbnRpbGVTdHJpbmcgLyAxMDBcclxuXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgY2FsY3VsYXRpb24gb2YgdGhlIHBlcmNlbnRpbGUgaXMgaW5hY2N1cmF0ZSB3aGVuIHRoZXJlIGlzIGluc3VmZmljaWVudCBkYXRhXHJcbiAgICAgICAgLy8gZS5nLiBmb3IgMC4xdGggb3IgOTkuOXRoIHBlcmNlbnRpbGUgd2hlbiBvbmx5IDEwMCBkYXRhIHBvaW50cy5cclxuICAgICAgICAvLyBHcmVhdGVyIGFjY3VyYWN5IHdvdWxkIHJlcXVpcmUgc3RvcmluZyBvZmYgbW9yZSBkYXRhIChzcGVjaWZpY2FsbHkgb3V0bGllcnMpIGFuZCBmb2xkaW5nIHRoZXNlXHJcbiAgICAgICAgLy8gaW50byB0aGUgY29tcHV0YXRpb24uXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAoZGF0YS5sZW5ndGggLSAxKSAqIHByb3BvcnRpb25cclxuICAgICAgICBjb25zdCBiYXNlID0gTWF0aC5mbG9vcihwb3NpdGlvbilcclxuICAgICAgICBjb25zdCBkZWx0YSA9IHBvc2l0aW9uIC0gYmFzZTtcclxuICAgICAgICBpZiAoc29ydGVkW2Jhc2UgKyAxXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IHNvcnRlZFtiYXNlXSArIGRlbHRhICogKHNvcnRlZFtiYXNlICsgMV0gLSBzb3J0ZWRbYmFzZV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IHNvcnRlZFtiYXNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0LnRvRml4ZWQoMilcclxuICB9XHJcbn0pO1xyXG4iLCIvKiBnbG9iYWwgQW1tbyxUSFJFRSAqL1xuXG5USFJFRS5BbW1vRGVidWdDb25zdGFudHMgPSB7XG4gIE5vRGVidWc6IDAsXG4gIERyYXdXaXJlZnJhbWU6IDEsXG4gIERyYXdBYWJiOiAyLFxuICBEcmF3RmVhdHVyZXNUZXh0OiA0LFxuICBEcmF3Q29udGFjdFBvaW50czogOCxcbiAgTm9EZWFjdGl2YXRpb246IDE2LFxuICBOb0hlbHBUZXh0OiAzMixcbiAgRHJhd1RleHQ6IDY0LFxuICBQcm9maWxlVGltaW5nczogMTI4LFxuICBFbmFibGVTYXRDb21wYXJpc29uOiAyNTYsXG4gIERpc2FibGVCdWxsZXRMQ1A6IDUxMixcbiAgRW5hYmxlQ0NEOiAxMDI0LFxuICBEcmF3Q29uc3RyYWludHM6IDEgPDwgMTEsIC8vMjA0OFxuICBEcmF3Q29uc3RyYWludExpbWl0czogMSA8PCAxMiwgLy80MDk2XG4gIEZhc3RXaXJlZnJhbWU6IDEgPDwgMTMsIC8vODE5MlxuICBEcmF3Tm9ybWFsczogMSA8PCAxNCwgLy8xNjM4NFxuICBEcmF3T25Ub3A6IDEgPDwgMTUsIC8vMzI3NjhcbiAgTUFYX0RFQlVHX0RSQVdfTU9ERTogMHhmZmZmZmZmZlxufTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYnRJRGVidWdEcmF3IGludGVyZmFjZSBpbiBBbW1vLmpzLCBmb3IgZGVidWcgcmVuZGVyaW5nIG9mIEFtbW8gc2hhcGVzXG4gKiBAY2xhc3MgQW1tb0RlYnVnRHJhd2VyXG4gKiBAcGFyYW0ge1RIUkVFLlNjZW5lfSBzY2VuZVxuICogQHBhcmFtIHtBbW1vLmJ0Q29sbGlzaW9uV29ybGR9IHdvcmxkXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblRIUkVFLkFtbW9EZWJ1Z0RyYXdlciA9IGZ1bmN0aW9uKHNjZW5lLCB3b3JsZCwgb3B0aW9ucykge1xuICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5kZWJ1Z0RyYXdNb2RlID0gb3B0aW9ucy5kZWJ1Z0RyYXdNb2RlIHx8IFRIUkVFLkFtbW9EZWJ1Z0NvbnN0YW50cy5EcmF3V2lyZWZyYW1lO1xuICB2YXIgZHJhd09uVG9wID0gdGhpcy5kZWJ1Z0RyYXdNb2RlICYgVEhSRUUuQW1tb0RlYnVnQ29uc3RhbnRzLkRyYXdPblRvcCB8fCBmYWxzZTtcbiAgdmFyIG1heEJ1ZmZlclNpemUgPSBvcHRpb25zLm1heEJ1ZmZlclNpemUgfHwgMTAwMDAwMDtcblxuICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkobWF4QnVmZmVyU2l6ZSAqIDMpO1xuICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShtYXhCdWZmZXJTaXplICogMyk7XG5cbiAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKS5zZXRVc2FnZShUSFJFRS5EeW5hbWljRHJhd1VzYWdlKSk7XG4gIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwiY29sb3JcIiwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpLnNldFVzYWdlKFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2UpKTtcblxuICB0aGlzLmluZGV4ID0gMDtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICBkZXB0aFRlc3Q6ICFkcmF3T25Ub3BcbiAgfSk7XG5cbiAgdGhpcy5tZXNoID0gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyh0aGlzLmdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gIGlmIChkcmF3T25Ub3ApIHRoaXMubWVzaC5yZW5kZXJPcmRlciA9IDk5OTtcbiAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblxuICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICB0aGlzLmRlYnVnRHJhd2VyID0gbmV3IEFtbW8uRGVidWdEcmF3ZXIoKTtcbiAgdGhpcy5kZWJ1Z0RyYXdlci5kcmF3TGluZSA9IHRoaXMuZHJhd0xpbmUuYmluZCh0aGlzKTtcbiAgdGhpcy5kZWJ1Z0RyYXdlci5kcmF3Q29udGFjdFBvaW50ID0gdGhpcy5kcmF3Q29udGFjdFBvaW50LmJpbmQodGhpcyk7XG4gIHRoaXMuZGVidWdEcmF3ZXIucmVwb3J0RXJyb3JXYXJuaW5nID0gdGhpcy5yZXBvcnRFcnJvcldhcm5pbmcuYmluZCh0aGlzKTtcbiAgdGhpcy5kZWJ1Z0RyYXdlci5kcmF3M2RUZXh0ID0gdGhpcy5kcmF3M2RUZXh0LmJpbmQodGhpcyk7XG4gIHRoaXMuZGVidWdEcmF3ZXIuc2V0RGVidWdNb2RlID0gdGhpcy5zZXREZWJ1Z01vZGUuYmluZCh0aGlzKTtcbiAgdGhpcy5kZWJ1Z0RyYXdlci5nZXREZWJ1Z01vZGUgPSB0aGlzLmdldERlYnVnTW9kZS5iaW5kKHRoaXMpO1xuICB0aGlzLmRlYnVnRHJhd2VyLmVuYWJsZSA9IHRoaXMuZW5hYmxlLmJpbmQodGhpcyk7XG4gIHRoaXMuZGVidWdEcmF3ZXIuZGlzYWJsZSA9IHRoaXMuZGlzYWJsZS5iaW5kKHRoaXMpO1xuICB0aGlzLmRlYnVnRHJhd2VyLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgdGhpcy53b3JsZC5zZXREZWJ1Z0RyYXdlcih0aGlzLmRlYnVnRHJhd2VyKTtcbn07XG5cblRIUkVFLkFtbW9EZWJ1Z0RyYXdlci5wcm90b3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGVidWdEcmF3ZXI7XG59O1xuXG5USFJFRS5BbW1vRGVidWdEcmF3ZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xufTtcblxuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLm1lc2gpO1xufTtcblxuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5pbmRleCAhPSAwKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy53b3JsZC5kZWJ1Z0RyYXdXb3JsZCgpO1xuXG4gIHRoaXMuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKDAsIHRoaXMuaW5kZXgpO1xufTtcblxuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS5kcmF3TGluZSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBjb2xvcikge1xuICBjb25zdCBoZWFwID0gQW1tby5IRUFQRjMyO1xuICBjb25zdCByID0gaGVhcFsoY29sb3IgKyAwKSAvIDRdO1xuICBjb25zdCBnID0gaGVhcFsoY29sb3IgKyA0KSAvIDRdO1xuICBjb25zdCBiID0gaGVhcFsoY29sb3IgKyA4KSAvIDRdO1xuXG4gIGNvbnN0IGZyb21YID0gaGVhcFsoZnJvbSArIDApIC8gNF07XG4gIGNvbnN0IGZyb21ZID0gaGVhcFsoZnJvbSArIDQpIC8gNF07XG4gIGNvbnN0IGZyb21aID0gaGVhcFsoZnJvbSArIDgpIC8gNF07XG4gIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5zZXRYWVoodGhpcy5pbmRleCwgZnJvbVgsIGZyb21ZLCBmcm9tWik7XG4gIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5zZXRYWVoodGhpcy5pbmRleCsrLCByLCBnLCBiKTtcblxuICBjb25zdCB0b1ggPSBoZWFwWyh0byArIDApIC8gNF07XG4gIGNvbnN0IHRvWSA9IGhlYXBbKHRvICsgNCkgLyA0XTtcbiAgY29uc3QgdG9aID0gaGVhcFsodG8gKyA4KSAvIDRdO1xuICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uc2V0WFlaKHRoaXMuaW5kZXgsIHRvWCwgdG9ZLCB0b1opO1xuICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3Iuc2V0WFlaKHRoaXMuaW5kZXgrKywgciwgZywgYik7XG59O1xuXG4vL1RPRE86IGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgbGlmZVRpbWUgd29ya1xuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS5kcmF3Q29udGFjdFBvaW50ID0gZnVuY3Rpb24ocG9pbnRPbkIsIG5vcm1hbE9uQiwgZGlzdGFuY2UsIGxpZmVUaW1lLCBjb2xvcikge1xuICBjb25zdCBoZWFwID0gQW1tby5IRUFQRjMyO1xuICBjb25zdCByID0gaGVhcFsoY29sb3IgKyAwKSAvIDRdO1xuICBjb25zdCBnID0gaGVhcFsoY29sb3IgKyA0KSAvIDRdO1xuICBjb25zdCBiID0gaGVhcFsoY29sb3IgKyA4KSAvIDRdO1xuXG4gIGNvbnN0IHggPSBoZWFwWyhwb2ludE9uQiArIDApIC8gNF07XG4gIGNvbnN0IHkgPSBoZWFwWyhwb2ludE9uQiArIDQpIC8gNF07XG4gIGNvbnN0IHogPSBoZWFwWyhwb2ludE9uQiArIDgpIC8gNF07XG4gIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5zZXRYWVoodGhpcy5pbmRleCwgeCwgeSwgeik7XG4gIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5zZXRYWVoodGhpcy5pbmRleCsrLCByLCBnLCBiKTtcblxuICBjb25zdCBkeCA9IGhlYXBbKG5vcm1hbE9uQiArIDApIC8gNF0gKiBkaXN0YW5jZTtcbiAgY29uc3QgZHkgPSBoZWFwWyhub3JtYWxPbkIgKyA0KSAvIDRdICogZGlzdGFuY2U7XG4gIGNvbnN0IGR6ID0gaGVhcFsobm9ybWFsT25CICsgOCkgLyA0XSAqIGRpc3RhbmNlO1xuICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uc2V0WFlaKHRoaXMuaW5kZXgsIHggKyBkeCwgeSArIGR5LCB6ICsgZHopO1xuICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3Iuc2V0WFlaKHRoaXMuaW5kZXgrKywgciwgZywgYik7XG59O1xuXG5USFJFRS5BbW1vRGVidWdEcmF3ZXIucHJvdG90eXBlLnJlcG9ydEVycm9yV2FybmluZyA9IGZ1bmN0aW9uKHdhcm5pbmdTdHJpbmcpIHtcbiAgaWYgKEFtbW8uaGFzT3duUHJvcGVydHkoXCJQb2ludGVyX3N0cmluZ2lmeVwiKSkge1xuICAgIGNvbnNvbGUud2FybihBbW1vLlBvaW50ZXJfc3RyaW5naWZ5KHdhcm5pbmdTdHJpbmcpKTtcbiAgfSBlbHNlIGlmICghdGhpcy53YXJuZWRPbmNlKSB7XG4gICAgdGhpcy53YXJuZWRPbmNlID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oXCJDYW5ub3QgcHJpbnQgd2FybmluZ1N0cmluZywgcGxlYXNlIHJlYnVpbGQgQW1tby5qcyB1c2luZyAnZGVidWcnIGZsYWdcIik7XG4gIH1cbn07XG5cblRIUkVFLkFtbW9EZWJ1Z0RyYXdlci5wcm90b3R5cGUuZHJhdzNkVGV4dCA9IGZ1bmN0aW9uKGxvY2F0aW9uLCB0ZXh0U3RyaW5nKSB7XG4gIC8vVE9ET1xuICBjb25zb2xlLndhcm4oXCJUT0RPOiBkcmF3M2RUZXh0XCIpO1xufTtcblxuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS5zZXREZWJ1Z01vZGUgPSBmdW5jdGlvbihkZWJ1Z01vZGUpIHtcbiAgdGhpcy5kZWJ1Z0RyYXdNb2RlID0gZGVidWdNb2RlO1xufTtcblxuVEhSRUUuQW1tb0RlYnVnRHJhd2VyLnByb3RvdHlwZS5nZXREZWJ1Z01vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGVidWdEcmF3TW9kZTtcbn07XG4iLCIvKipcclxuICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXJcclxuICogQGNsYXNzIE9iamVjdENvbGxpc2lvbk1hdHJpeFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBPYmplY3RDb2xsaXNpb25NYXRyaXgge1xuICAvLyBUaGUgbWF0cml4IHN0b3JhZ2UuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWF0cml4ID0ge307XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBnZXRcclxuICAgKiBAcGFyYW0gIHtCb2R5fSBpXHJcbiAgICogQHBhcmFtICB7Qm9keX0galxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXG5cblxuICBnZXQoYmksIGJqKSB7XG4gICAgbGV0IHtcbiAgICAgIGlkOiBpXG4gICAgfSA9IGJpO1xuICAgIGxldCB7XG4gICAgICBpZDogalxuICAgIH0gPSBiajtcblxuICAgIGlmIChqID4gaSkge1xuICAgICAgY29uc3QgdGVtcCA9IGo7XG4gICAgICBqID0gaTtcbiAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiBpICsgXCItXCIgKyBqIGluIHRoaXMubWF0cml4O1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2V0XHJcbiAgICogQHBhcmFtICB7Qm9keX0gaVxyXG4gICAqIEBwYXJhbSAge0JvZHl9IGpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICovXG5cblxuICBzZXQoYmksIGJqLCB2YWx1ZSkge1xuICAgIGxldCB7XG4gICAgICBpZDogaVxuICAgIH0gPSBiaTtcbiAgICBsZXQge1xuICAgICAgaWQ6IGpcbiAgICB9ID0gYmo7XG5cbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBqO1xuICAgICAgaiA9IGk7XG4gICAgICBpID0gdGVtcDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMubWF0cml4W2kgKyBcIi1cIiArIGpdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMubWF0cml4W2kgKyBcIi1cIiArIGpdO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBFbXB0eSB0aGUgbWF0cml4XHJcbiAgICogQG1ldGhvZCByZXNldFxyXG4gICAqL1xuXG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tYXRyaXggPSB7fTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgbWF4IG51bWJlciBvZiBvYmplY3RzXHJcbiAgICogQG1ldGhvZCBzZXROdW1PYmplY3RzXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICAgKi9cblxuXG4gIHNldE51bU9iamVjdHMobikge31cblxufVxuXG4vKipcclxuICogQSAzeDMgbWF0cml4LlxyXG4gKiBAY2xhc3MgTWF0M1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgQSB2ZWN0b3Igb2YgbGVuZ3RoIDksIGNvbnRhaW5pbmcgYWxsIG1hdHJpeCBlbGVtZW50cy4gT3B0aW9uYWwuXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cbmNsYXNzIE1hdDMge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuICAvKipcclxuICAgKiBTZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHlcclxuICAgKiBAbWV0aG9kIGlkZW50aXR5XHJcbiAgICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBzZXRJZGVudGl0eSgpIHRvIGJlIG1vcmUgY2xlYXIuXHJcbiAgICogQHRvZG8gQ3JlYXRlIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBpbW1lZGlhdGVseSBjcmVhdGVzIGFuIGlkZW50aXR5IG1hdHJpeCBlZy4gZXllKClcclxuICAgKi9cblxuXG4gIGlkZW50aXR5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSAxO1xuICAgIGVbMV0gPSAwO1xuICAgIGVbMl0gPSAwO1xuICAgIGVbM10gPSAwO1xuICAgIGVbNF0gPSAxO1xuICAgIGVbNV0gPSAwO1xuICAgIGVbNl0gPSAwO1xuICAgIGVbN10gPSAwO1xuICAgIGVbOF0gPSAxO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBhbGwgZWxlbWVudHMgdG8gemVyb1xyXG4gICAqIEBtZXRob2Qgc2V0WmVyb1xyXG4gICAqL1xuXG5cbiAgc2V0WmVybygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gMDtcbiAgICBlWzFdID0gMDtcbiAgICBlWzJdID0gMDtcbiAgICBlWzNdID0gMDtcbiAgICBlWzRdID0gMDtcbiAgICBlWzVdID0gMDtcbiAgICBlWzZdID0gMDtcbiAgICBlWzddID0gMDtcbiAgICBlWzhdID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzNcclxuICAgKiBAbWV0aG9kIHNldFRyYWNlXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzXHJcbiAgICovXG5cblxuICBzZXRUcmFjZSh2ZWN0b3IpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gdmVjdG9yLng7XG4gICAgZVs0XSA9IHZlY3Rvci55O1xuICAgIGVbOF0gPSB2ZWN0b3IuejtcbiAgfVxuICAvKipcclxuICAgKiBHZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHNcclxuICAgKiBAbWV0aG9kIGdldFRyYWNlXHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIGdldFRyYWNlKHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICB0YXJnZXQueCA9IGVbMF07XG4gICAgdGFyZ2V0LnkgPSBlWzRdO1xuICAgIHRhcmdldC56ID0gZVs4XTtcbiAgfVxuICAvKipcclxuICAgKiBNYXRyaXgtVmVjdG9yIG11bHRpcGxpY2F0aW9uXHJcbiAgICogQG1ldGhvZCB2bXVsdFxyXG4gICAqIEBwYXJhbSB7VmVjM30gdiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGhcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCwgdGFyZ2V0IHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cclxuICAgKi9cblxuXG4gIHZtdWx0KHYsIHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCB4ID0gdi54O1xuICAgIGNvbnN0IHkgPSB2Lnk7XG4gICAgY29uc3QgeiA9IHYuejtcbiAgICB0YXJnZXQueCA9IGVbMF0gKiB4ICsgZVsxXSAqIHkgKyBlWzJdICogejtcbiAgICB0YXJnZXQueSA9IGVbM10gKiB4ICsgZVs0XSAqIHkgKyBlWzVdICogejtcbiAgICB0YXJnZXQueiA9IGVbNl0gKiB4ICsgZVs3XSAqIHkgKyBlWzhdICogejtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIE1hdHJpeC1zY2FsYXIgbXVsdGlwbGljYXRpb25cclxuICAgKiBAbWV0aG9kIHNtdWx0XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNcclxuICAgKi9cblxuXG4gIHNtdWx0KHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0gKj0gcztcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICogQG1ldGhvZCBtbXVsdFxyXG4gICAqIEBwYXJhbSB7TWF0M30gbWF0cml4IE1hdHJpeCB0byBtdWx0aXBseSB3aXRoIGZyb20gbGVmdCBzaWRlLlxyXG4gICAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXHJcbiAgICovXG5cblxuICBtbXVsdChtYXRyaXgsIHRhcmdldCA9IG5ldyBNYXQzKCkpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBtYXRyaXg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgbGV0IHN1bSA9IDAuMDtcblxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICAgIHN1bSArPSBlbGVtZW50c1tpICsgayAqIDNdICogdGhpcy5lbGVtZW50c1trICsgaiAqIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LmVsZW1lbnRzW2kgKyBqICogM10gPSBzdW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICAvKipcclxuICAgKiBTY2FsZSBlYWNoIGNvbHVtbiBvZiB0aGUgbWF0cml4XHJcbiAgICogQG1ldGhvZCBzY2FsZVxyXG4gICAqIEBwYXJhbSB7VmVjM30gdlxyXG4gICAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXHJcbiAgICovXG5cblxuICBzY2FsZSh2ZWN0b3IsIHRhcmdldCA9IG5ldyBNYXQzKCkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCB0ID0gdGFyZ2V0LmVsZW1lbnRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDM7IGkrKykge1xuICAgICAgdFszICogaSArIDBdID0gdmVjdG9yLnggKiBlWzMgKiBpICsgMF07XG4gICAgICB0WzMgKiBpICsgMV0gPSB2ZWN0b3IueSAqIGVbMyAqIGkgKyAxXTtcbiAgICAgIHRbMyAqIGkgKyAyXSA9IHZlY3Rvci56ICogZVszICogaSArIDJdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogU29sdmUgQXg9YlxyXG4gICAqIEBtZXRob2Qgc29sdmVcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGIgVGhlIHJpZ2h0IGhhbmQgc2lkZVxyXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uXHJcbiAgICogQHJldHVybiB7VmVjM30gVGhlIHNvbHV0aW9uIHhcclxuICAgKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzXHJcbiAgICovXG5cblxuICBzb2x2ZShiLCB0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgIGNvbnN0IG5yID0gMzsgLy8gbnVtIHJvd3NcblxuICAgIGNvbnN0IG5jID0gNDsgLy8gbnVtIGNvbHNcblxuICAgIGNvbnN0IGVxbnMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuciAqIG5jOyBpKyspIHtcbiAgICAgIGVxbnMucHVzaCgwKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIGVxbnNbaSArIG5jICogal0gPSB0aGlzLmVsZW1lbnRzW2kgKyAzICogal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXFuc1szICsgNCAqIDBdID0gYi54O1xuICAgIGVxbnNbMyArIDQgKiAxXSA9IGIueTtcbiAgICBlcW5zWzMgKyA0ICogMl0gPSBiLno7IC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuXG4gICAgbGV0IG4gPSAzO1xuICAgIGNvbnN0IGsgPSBuO1xuICAgIGxldCBucDtcbiAgICBjb25zdCBrcCA9IDQ7IC8vIG51bSByb3dzXG5cbiAgICBsZXQgcDtcblxuICAgIGRvIHtcbiAgICAgIGkgPSBrIC0gbjtcblxuICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gPT09IDApIHtcbiAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBqXSAhPT0gMCkge1xuICAgICAgICAgICAgbnAgPSBrcDtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAvLyBkbyBsaWduZSggaSApID0gbGlnbmUoIGkgKSArIGxpZ25lKCBrIClcbiAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgIGVxbnNbcCArIG5jICogaV0gKz0gZXFuc1twICsgbmMgKiBqXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVxbnNbaSArIG5jICogaV0gIT09IDApIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gZXFuc1tpICsgbmMgKiBqXSAvIGVxbnNbaSArIG5jICogaV07XG4gICAgICAgICAgbnAgPSBrcDtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIGRvIGxpZ25lKCBrICkgPSBsaWduZSggayApIC0gbXVsdGlwbGllciAqIGxpZ25lKCBpIClcbiAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgZXFuc1twICsgbmMgKiBqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlICgtLW4pOyAvLyBHZXQgdGhlIHNvbHV0aW9uXG5cblxuICAgIHRhcmdldC56ID0gZXFuc1syICogbmMgKyAzXSAvIGVxbnNbMiAqIG5jICsgMl07XG4gICAgdGFyZ2V0LnkgPSAoZXFuc1sxICogbmMgKyAzXSAtIGVxbnNbMSAqIG5jICsgMl0gKiB0YXJnZXQueikgLyBlcW5zWzEgKiBuYyArIDFdO1xuICAgIHRhcmdldC54ID0gKGVxbnNbMCAqIG5jICsgM10gLSBlcW5zWzAgKiBuYyArIDJdICogdGFyZ2V0LnogLSBlcW5zWzAgKiBuYyArIDFdICogdGFyZ2V0LnkpIC8gZXFuc1swICogbmMgKyAwXTtcblxuICAgIGlmIChpc05hTih0YXJnZXQueCkgfHwgaXNOYU4odGFyZ2V0LnkpIHx8IGlzTmFOKHRhcmdldC56KSB8fCB0YXJnZXQueCA9PT0gSW5maW5pdHkgfHwgdGFyZ2V0LnkgPT09IEluZmluaXR5IHx8IHRhcmdldC56ID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgXCJDb3VsZCBub3Qgc29sdmUgZXF1YXRpb24hIEdvdCB4PVtcIiArIHRhcmdldC50b1N0cmluZygpICsgXCJdLCBiPVtcIiArIGIudG9TdHJpbmcoKSArIFwiXSwgQT1bXCIgKyB0aGlzLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIVxyXG4gICAqIEBtZXRob2QgZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcclxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE9wdGlvbmFsLiBJZiBwcm92aWRlZCwgdGhlIG1hdHJpeCBlbGVtZW50IHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZShyb3csIGNvbHVtbiwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbY29sdW1uICsgMyAqIHJvd107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldCB2YWx1ZVxuICAgICAgdGhpcy5lbGVtZW50c1tjb2x1bW4gKyAzICogcm93XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb3B5IGFub3RoZXIgbWF0cml4IGludG8gdGhpcyBtYXRyaXggb2JqZWN0LlxyXG4gICAqIEBtZXRob2QgY29weVxyXG4gICAqIEBwYXJhbSB7TWF0M30gc291cmNlXHJcbiAgICogQHJldHVybiB7TWF0M30gdGhpc1xyXG4gICAqL1xuXG5cbiAgY29weShtYXRyaXgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG1hdHJpeC5lbGVtZW50c1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXguXHJcbiAgICogQG1ldGhvZCB0b1N0cmluZ1xyXG4gICAqIEByZXR1cm4gc3RyaW5nXHJcbiAgICovXG5cblxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgciA9ICcnO1xuICAgIGNvbnN0IHNlcCA9ICcsJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgLyoqXHJcbiAgICogcmV2ZXJzZSB0aGUgbWF0cml4XHJcbiAgICogQG1ldGhvZCByZXZlcnNlXHJcbiAgICogQHBhcmFtIHtNYXQzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCBtYXRyaXggdG8gc2F2ZSBpbi5cclxuICAgKiBAcmV0dXJuIHtNYXQzfSBUaGUgc29sdXRpb24geFxyXG4gICAqL1xuXG5cbiAgcmV2ZXJzZSh0YXJnZXQgPSBuZXcgTWF0MygpKSB7XG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgIGNvbnN0IG5yID0gMzsgLy8gbnVtIHJvd3NcblxuICAgIGNvbnN0IG5jID0gNjsgLy8gbnVtIGNvbHNcblxuICAgIGNvbnN0IGVxbnMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuciAqIG5jOyBpKyspIHtcbiAgICAgIGVxbnMucHVzaCgwKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIGVxbnNbaSArIG5jICogal0gPSB0aGlzLmVsZW1lbnRzW2kgKyAzICogal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXFuc1szICsgNiAqIDBdID0gMTtcbiAgICBlcW5zWzMgKyA2ICogMV0gPSAwO1xuICAgIGVxbnNbMyArIDYgKiAyXSA9IDA7XG4gICAgZXFuc1s0ICsgNiAqIDBdID0gMDtcbiAgICBlcW5zWzQgKyA2ICogMV0gPSAxO1xuICAgIGVxbnNbNCArIDYgKiAyXSA9IDA7XG4gICAgZXFuc1s1ICsgNiAqIDBdID0gMDtcbiAgICBlcW5zWzUgKyA2ICogMV0gPSAwO1xuICAgIGVxbnNbNSArIDYgKiAyXSA9IDE7IC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuXG4gICAgbGV0IG4gPSAzO1xuICAgIGNvbnN0IGsgPSBuO1xuICAgIGxldCBucDtcbiAgICBjb25zdCBrcCA9IG5jOyAvLyBudW0gcm93c1xuXG4gICAgbGV0IHA7XG5cbiAgICBkbyB7XG4gICAgICBpID0gayAtIG47XG5cbiAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHtcbiAgICAgICAgICAgIG5wID0ga3A7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgLy8gZG8gbGluZSggaSApID0gbGluZSggaSApICsgbGluZSggayApXG4gICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICBlcW5zW3AgKyBuYyAqIGldICs9IGVxbnNbcCArIG5jICogal07XG4gICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldICE9PSAwKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldO1xuICAgICAgICAgIG5wID0ga3A7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBkbyBsaW5lKCBrICkgPSBsaW5lKCBrICkgLSBtdWx0aXBsaWVyICogbGluZSggaSApXG4gICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgIGVxbnNbcCArIG5jICogal0gPSBwIDw9IGkgPyAwIDogZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoLS1uKTsgLy8gZWxpbWluYXRlIHRoZSB1cHBlciBsZWZ0IHRyaWFuZ2xlIG9mIHRoZSBtYXRyaXhcblxuXG4gICAgaSA9IDI7XG5cbiAgICBkbyB7XG4gICAgICBqID0gaSAtIDE7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldO1xuICAgICAgICBucCA9IG5jO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwID0gbmMgLSBucDtcbiAgICAgICAgICBlcW5zW3AgKyBuYyAqIGpdID0gZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgIH0gd2hpbGUgKGotLSk7XG4gICAgfSB3aGlsZSAoLS1pKTsgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWxcblxuXG4gICAgaSA9IDI7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaSArIG5jICogaV07XG4gICAgICBucCA9IG5jO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICBlcW5zW3AgKyBuYyAqIGldID0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7XG4gICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgaSA9IDI7XG5cbiAgICBkbyB7XG4gICAgICBqID0gMjtcblxuICAgICAgZG8ge1xuICAgICAgICBwID0gZXFuc1tuciArIGogKyBuYyAqIGldO1xuXG4gICAgICAgIGlmIChpc05hTihwKSB8fCBwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHJldmVyc2UhIEE9W1wiICsgdGhpcy50b1N0cmluZygpICsgXCJdXCI7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQuZShpLCBqLCBwKTtcbiAgICAgIH0gd2hpbGUgKGotLSk7XG4gICAgfSB3aGlsZSAoaS0tKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvblxyXG4gICAqIEBtZXRob2Qgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvblxyXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxyXG4gICAqL1xuXG5cbiAgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihxKSB7XG4gICAgY29uc3QgeCA9IHEueDtcbiAgICBjb25zdCB5ID0gcS55O1xuICAgIGNvbnN0IHogPSBxLno7XG4gICAgY29uc3QgdyA9IHEudztcbiAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgY29uc3QgejIgPSB6ICsgejtcbiAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICBjb25zdCB4eiA9IHggKiB6MjtcbiAgICBjb25zdCB5eSA9IHkgKiB5MjtcbiAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICBjb25zdCB6eiA9IHogKiB6MjtcbiAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICBjb25zdCB3eiA9IHcgKiB6MjtcbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzMgKiAwICsgMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIGVbMyAqIDAgKyAxXSA9IHh5IC0gd3o7XG4gICAgZVszICogMCArIDJdID0geHogKyB3eTtcbiAgICBlWzMgKiAxICsgMF0gPSB4eSArIHd6O1xuICAgIGVbMyAqIDEgKyAxXSA9IDEgLSAoeHggKyB6eik7XG4gICAgZVszICogMSArIDJdID0geXogLSB3eDtcbiAgICBlWzMgKiAyICsgMF0gPSB4eiAtIHd5O1xuICAgIGVbMyAqIDIgKyAxXSA9IHl6ICsgd3g7XG4gICAgZVszICogMiArIDJdID0gMSAtICh4eCArIHl5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBUcmFuc3Bvc2UgdGhlIG1hdHJpeFxyXG4gICAqIEBtZXRob2QgdHJhbnNwb3NlXHJcbiAgICogQHBhcmFtICB7TWF0M30gdGFyZ2V0IE9wdGlvbmFsLiBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gICAqIEByZXR1cm4ge01hdDN9IFRoZSB0YXJnZXQgTWF0Mywgb3IgYSBuZXcgTWF0MyBpZiB0YXJnZXQgd2FzIG9taXR0ZWQuXHJcbiAgICovXG5cblxuICB0cmFuc3Bvc2UodGFyZ2V0ID0gbmV3IE1hdDMoKSkge1xuICAgIGNvbnN0IE10ID0gdGFyZ2V0LmVsZW1lbnRzO1xuICAgIGNvbnN0IE0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IDM7IGorKykge1xuICAgICAgICBNdFszICogaSArIGpdID0gTVszICogaiArIGldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxufVxuXG4vKipcclxuICogMy1kaW1lbnNpb25hbCB2ZWN0b3JcclxuICogQGNsYXNzIFZlYzNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGV4YW1wbGVcclxuICogICAgIGNvbnN0IHYgPSBuZXcgVmVjMygxLCAyLCAzKTtcclxuICogICAgIGNvbnNvbGUubG9nKCd4PScgKyB2LngpOyAvLyB4PTFcclxuICovXG5cbmNsYXNzIFZlYzMge1xuICBjb25zdHJ1Y3Rvcih4ID0gMC4wLCB5ID0gMC4wLCB6ID0gMC4wKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gIH1cbiAgLyoqXHJcbiAgICogVmVjdG9yIGNyb3NzIHByb2R1Y3RcclxuICAgKiBAbWV0aG9kIGNyb3NzXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2XHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB0byBzYXZlIGluLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICBjcm9zcyh2ZWN0b3IsIHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICBjb25zdCB2eCA9IHZlY3Rvci54O1xuICAgIGNvbnN0IHZ5ID0gdmVjdG9yLnk7XG4gICAgY29uc3QgdnogPSB2ZWN0b3IuejtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgeiA9IHRoaXMuejtcbiAgICB0YXJnZXQueCA9IHkgKiB2eiAtIHogKiB2eTtcbiAgICB0YXJnZXQueSA9IHogKiB2eCAtIHggKiB2ejtcbiAgICB0YXJnZXQueiA9IHggKiB2eSAtIHkgKiB2eDtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdmVjdG9ycycgMyBlbGVtZW50c1xyXG4gICAqIEBtZXRob2Qgc2V0XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6XHJcbiAgICogQHJldHVybiBWZWMzXHJcbiAgICovXG5cblxuICBzZXQoeCwgeSwgeikge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBhbGwgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHRvIHplcm8uXHJcbiAgICogQG1ldGhvZCBzZXRaZXJvXHJcbiAgICovXG5cblxuICBzZXRaZXJvKCkge1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG4gIH1cbiAgLyoqXHJcbiAgICogVmVjdG9yIGFkZGl0aW9uXHJcbiAgICogQG1ldGhvZCB2YWRkXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2XHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuXHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIHZhZGQodmVjdG9yLCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQueCA9IHZlY3Rvci54ICsgdGhpcy54O1xuICAgICAgdGFyZ2V0LnkgPSB2ZWN0b3IueSArIHRoaXMueTtcbiAgICAgIHRhcmdldC56ID0gdmVjdG9yLnogKyB0aGlzLno7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyB2ZWN0b3IueCwgdGhpcy55ICsgdmVjdG9yLnksIHRoaXMueiArIHZlY3Rvci56KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogVmVjdG9yIHN1YnRyYWN0aW9uXHJcbiAgICogQG1ldGhvZCB2c3ViXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2XHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB0byBzYXZlIGluLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICB2c3ViKHZlY3RvciwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnggPSB0aGlzLnggLSB2ZWN0b3IueDtcbiAgICAgIHRhcmdldC55ID0gdGhpcy55IC0gdmVjdG9yLnk7XG4gICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHZlY3Rvci56O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54IC0gdmVjdG9yLngsIHRoaXMueSAtIHZlY3Rvci55LCB0aGlzLnogLSB2ZWN0b3Iueik7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBtYXRyaXggYV9jcm9zcyBmcm9tIGEgdmVjdG9yLCBzdWNoIHRoYXQgYSB4IGIgPSBhX2Nyb3NzICogYiA9IGNcclxuICAgKiBAbWV0aG9kIGNyb3NzbWF0XHJcbiAgICogQHNlZSBodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyL1REQkQyNC9WVDA2L2xlY3R1cmVzL0xlY3R1cmU2LnBkZlxyXG4gICAqIEByZXR1cm4ge01hdDN9XHJcbiAgICovXG5cblxuICBjcm9zc21hdCgpIHtcbiAgICByZXR1cm4gbmV3IE1hdDMoWzAsIC10aGlzLnosIHRoaXMueSwgdGhpcy56LCAwLCAtdGhpcy54LCAtdGhpcy55LCB0aGlzLngsIDBdKTtcbiAgfVxuICAvKipcclxuICAgKiBOb3JtYWxpemUgdGhlIHZlY3Rvci4gTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyB0aGUgdmFsdWVzIGluIHRoZSB2ZWN0b3IuXHJcbiAgICogQG1ldGhvZCBub3JtYWxpemVcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxyXG4gICAqL1xuXG5cbiAgbm9ybWFsaXplKCkge1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIGNvbnN0IG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcblxuICAgIGlmIChuID4gMC4wKSB7XG4gICAgICBjb25zdCBpbnZOID0gMSAvIG47XG4gICAgICB0aGlzLnggKj0gaW52TjtcbiAgICAgIHRoaXMueSAqPSBpbnZOO1xuICAgICAgdGhpcy56ICo9IGludk47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2Ugc29tZXRoaW5nIHVwXG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMueiA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuXHJcbiAgICogQG1ldGhvZCB1bml0XHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSBSZXR1cm5zIHRoZSB1bml0IHZlY3RvclxyXG4gICAqL1xuXG5cbiAgdW5pdCh0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgIGNvbnN0IHogPSB0aGlzLno7XG4gICAgbGV0IG5pbnYgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcblxuICAgIGlmIChuaW52ID4gMC4wKSB7XG4gICAgICBuaW52ID0gMS4wIC8gbmludjtcbiAgICAgIHRhcmdldC54ID0geCAqIG5pbnY7XG4gICAgICB0YXJnZXQueSA9IHkgKiBuaW52O1xuICAgICAgdGFyZ2V0LnogPSB6ICogbmludjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LnggPSAxO1xuICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgdGFyZ2V0LnogPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAqIEBtZXRob2QgbGVuZ3RoXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgbGVuZ3RoKCkge1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICogQG1ldGhvZCBsZW5ndGhTcXVhcmVkXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XHJcbiAgICogQG1ldGhvZCBkaXN0YW5jZVRvXHJcbiAgICogQHBhcmFtICB7VmVjM30gcFxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGRpc3RhbmNlVG8ocCkge1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIGNvbnN0IHB4ID0gcC54O1xuICAgIGNvbnN0IHB5ID0gcC55O1xuICAgIGNvbnN0IHB6ID0gcC56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHB4IC0geCkgKiAocHggLSB4KSArIChweSAtIHkpICogKHB5IC0geSkgKyAocHogLSB6KSAqIChweiAtIHopKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgdG8gYW5vdGhlciBwb2ludFxyXG4gICAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXHJcbiAgICogQHBhcmFtICB7VmVjM30gcFxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGRpc3RhbmNlU3F1YXJlZChwKSB7XG4gICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgIGNvbnN0IHogPSB0aGlzLno7XG4gICAgY29uc3QgcHggPSBwLng7XG4gICAgY29uc3QgcHkgPSBwLnk7XG4gICAgY29uc3QgcHogPSBwLno7XG4gICAgcmV0dXJuIChweCAtIHgpICogKHB4IC0geCkgKyAocHkgLSB5KSAqIChweSAtIHkpICsgKHB6IC0geikgKiAocHogLSB6KTtcbiAgfVxuICAvKipcclxuICAgKiBNdWx0aXBseSBhbGwgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAqIEBtZXRob2Qgc2NhbGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIHNjYWxlKHNjYWxhciwgdGFyZ2V0ID0gbmV3IFZlYzMoKSkge1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcbiAgICB0YXJnZXQueSA9IHNjYWxhciAqIHk7XG4gICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6O1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogTXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoIGFuIG90aGVyIHZlY3RvciwgY29tcG9uZW50LXdpc2UuXHJcbiAgICogQG1ldGhvZCB2bXVsdFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2ZWN0b3JcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cclxuICAgKiBAcmV0dXJuIHtWZWMzfVxyXG4gICAqL1xuXG5cbiAgdm11bCh2ZWN0b3IsIHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICB0YXJnZXQueCA9IHZlY3Rvci54ICogdGhpcy54O1xuICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKiB0aGlzLnk7XG4gICAgdGFyZ2V0LnogPSB2ZWN0b3IueiAqIHRoaXMuejtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIFNjYWxlIGEgdmVjdG9yIGFuZCBhZGQgaXQgdG8gdGhpcyB2ZWN0b3IuIFNhdmUgdGhlIHJlc3VsdCBpbiBcInRhcmdldFwiLiAodGFyZ2V0ID0gdGhpcyArIHZlY3RvciAqIHNjYWxhcilcclxuICAgKiBAbWV0aG9kIGFkZFNjYWxlZFZlY3RvclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHZlY3RvclxyXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB2ZWN0b3IgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICBhZGRTY2FsZWRWZWN0b3Ioc2NhbGFyLCB2ZWN0b3IsIHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54O1xuICAgIHRhcmdldC55ID0gdGhpcy55ICsgc2NhbGFyICogdmVjdG9yLnk7XG4gICAgdGFyZ2V0LnogPSB0aGlzLnogKyBzY2FsYXIgKiB2ZWN0b3IuejtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBkb3QgcHJvZHVjdFxyXG4gICAqIEBtZXRob2QgZG90XHJcbiAgICogQHBhcmFtIHtWZWMzfSB2XHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZG90KHZlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55ICsgdGhpcy56ICogdmVjdG9yLno7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBpc1plcm9cclxuICAgKiBAcmV0dXJuIGJvb2xcclxuICAgKi9cblxuXG4gIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCAmJiB0aGlzLnogPT09IDA7XG4gIH1cbiAgLyoqXHJcbiAgICogTWFrZSB0aGUgdmVjdG9yIHBvaW50IGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICogQG1ldGhvZCBuZWdhdGVcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpblxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICBuZWdhdGUodGFyZ2V0ID0gbmV3IFZlYzMoKSkge1xuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yXHJcbiAgICogQG1ldGhvZCB0YW5nZW50c1xyXG4gICAqIEBwYXJhbSB7VmVjM30gdDEgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBmaXJzdCB0YW5nZW50IGluXHJcbiAgICogQHBhcmFtIHtWZWMzfSB0MiBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIHNlY29uZCB0YW5nZW50IGluXHJcbiAgICovXG5cblxuICB0YW5nZW50cyh0MSwgdDIpIHtcbiAgICBjb25zdCBub3JtID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmIChub3JtID4gMC4wKSB7XG4gICAgICBjb25zdCBuID0gVmVjM190YW5nZW50c19uO1xuICAgICAgY29uc3QgaW5vcm0gPSAxIC8gbm9ybTtcbiAgICAgIG4uc2V0KHRoaXMueCAqIGlub3JtLCB0aGlzLnkgKiBpbm9ybSwgdGhpcy56ICogaW5vcm0pO1xuICAgICAgY29uc3QgcmFuZFZlYyA9IFZlYzNfdGFuZ2VudHNfcmFuZFZlYztcblxuICAgICAgaWYgKE1hdGguYWJzKG4ueCkgPCAwLjkpIHtcbiAgICAgICAgcmFuZFZlYy5zZXQoMSwgMCwgMCk7XG4gICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZFZlYy5zZXQoMCwgMSwgMCk7XG4gICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpO1xuICAgICAgfVxuXG4gICAgICBuLmNyb3NzKHQxLCB0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBub3JtYWwgbGVuZ3RoIGlzIHplcm8sIG1ha2Ugc29tZXRoaW5nIHVwXG4gICAgICB0MS5zZXQoMSwgMCwgMCk7XG4gICAgICB0Mi5zZXQoMCwgMSwgMCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRvIGEgbW9yZSByZWFkYWJsZSBmb3JtYXRcclxuICAgKiBAbWV0aG9kIHRvU3RyaW5nXHJcbiAgICogQHJldHVybiBzdHJpbmdcclxuICAgKi9cblxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiLFwiICsgdGhpcy56O1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRvIGFuIGFycmF5XHJcbiAgICogQG1ldGhvZCB0b0FycmF5XHJcbiAgICogQHJldHVybiBBcnJheVxyXG4gICAqL1xuXG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnpdO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICogQG1ldGhvZCBjb3B5XHJcbiAgICogQHBhcmFtIHtWZWMzfSBzb3VyY2VcclxuICAgKiBAcmV0dXJuIHtWZWMzfSB0aGlzXHJcbiAgICovXG5cblxuICBjb3B5KHZlY3Rvcikge1xuICAgIHRoaXMueCA9IHZlY3Rvci54O1xuICAgIHRoaXMueSA9IHZlY3Rvci55O1xuICAgIHRoaXMueiA9IHZlY3Rvci56O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG4gICAqIEBtZXRob2QgbGVycFxyXG4gICAqIEBwYXJhbSB7VmVjM30gdlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcclxuICAgKi9cblxuXG4gIGxlcnAodmVjdG9yLCB0LCB0YXJnZXQpIHtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgeiA9IHRoaXMuejtcbiAgICB0YXJnZXQueCA9IHggKyAodmVjdG9yLnggLSB4KSAqIHQ7XG4gICAgdGFyZ2V0LnkgPSB5ICsgKHZlY3Rvci55IC0geSkgKiB0O1xuICAgIHRhcmdldC56ID0geiArICh2ZWN0b3IueiAtIHopICogdDtcbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZlY3RvciBlcXVhbHMgaXMgYWxtb3N0IGVxdWFsIHRvIGFub3RoZXIgb25lLlxyXG4gICAqIEBtZXRob2QgYWxtb3N0RXF1YWxzXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gICAqIEByZXR1cm4gYm9vbFxyXG4gICAqL1xuXG5cbiAgYWxtb3N0RXF1YWxzKHZlY3RvciwgcHJlY2lzaW9uID0gMWUtNikge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSB2ZWN0b3IueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpID4gcHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoaXMueiAtIHZlY3Rvci56KSA+IHByZWNpc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXHJcbiAgICogQG1ldGhvZCBhbG1vc3RaZXJvXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gICAqL1xuXG5cbiAgYWxtb3N0WmVybyhwcmVjaXNpb24gPSAxZS02KSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMueCkgPiBwcmVjaXNpb24gfHwgTWF0aC5hYnModGhpcy55KSA+IHByZWNpc2lvbiB8fCBNYXRoLmFicyh0aGlzLnopID4gcHJlY2lzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLlxyXG4gICAqIEBtZXRob2QgaXNBbnRpcGFyYWxsZWxUb1xyXG4gICAqIEBwYXJhbSAge1ZlYzN9ICB2XHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgcHJlY2lzaW9uIFNldCB0byB6ZXJvIGZvciBleGFjdCBjb21wYXJpc29uc1xyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXG5cblxuICBpc0FudGlwYXJhbGxlbFRvKHZlY3RvciwgcHJlY2lzaW9uKSB7XG4gICAgdGhpcy5uZWdhdGUoYW50aXBfbmVnKTtcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2ZWN0b3IsIHByZWNpc2lvbik7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xvbmUgdGhlIHZlY3RvclxyXG4gICAqIEBtZXRob2QgY2xvbmVcclxuICAgKiBAcmV0dXJuIHtWZWMzfVxyXG4gICAqL1xuXG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICB9XG5cbn1cblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xuVmVjMy5VTklUX1ggPSBuZXcgVmVjMygxLCAwLCAwKTtcblZlYzMuVU5JVF9ZID0gbmV3IFZlYzMoMCwgMSwgMCk7XG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuLyoqXHJcbiAqIENvbXB1dGUgdHdvIGFydGlmaWNpYWwgdGFuZ2VudHMgdG8gdGhlIHZlY3RvclxyXG4gKiBAbWV0aG9kIHRhbmdlbnRzXHJcbiAqIEBwYXJhbSB7VmVjM30gdDEgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBmaXJzdCB0YW5nZW50IGluXHJcbiAqIEBwYXJhbSB7VmVjM30gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpblxyXG4gKi9cblxuY29uc3QgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcbmNvbnN0IFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7XG5jb25zdCBhbnRpcF9uZWcgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cclxuICogQGNsYXNzIEFBQkJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLnVwcGVyQm91bmRdIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gKiBAcGFyYW0ge1ZlYzN9ICAgW29wdGlvbnMubG93ZXJCb3VuZF0gVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3hcclxuICovXG5jbGFzcyBBQUJCIHtcbiAgLy8gVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3hcbiAgLy8gVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3hcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb3dlckJvdW5kID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYgKG9wdGlvbnMubG93ZXJCb3VuZCkge1xuICAgICAgdGhpcy5sb3dlckJvdW5kLmNvcHkob3B0aW9ucy5sb3dlckJvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51cHBlckJvdW5kKSB7XG4gICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxyXG4gICAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3MuXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvbiBPcHRpb25hbC5cclxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb24gT3B0aW9uYWwuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplIE9wdGlvbmFsLlxyXG4gICAqIEByZXR1cm4ge0FBQkJ9IFRoZSBzZWxmIG9iamVjdFxyXG4gICAqL1xuXG5cbiAgc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7XG4gICAgY29uc3QgdSA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICBjb25zdCBxID0gcXVhdGVybmlvbjsgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuXG4gICAgbC5jb3B5KHBvaW50c1swXSk7XG5cbiAgICBpZiAocSkge1xuICAgICAgcS52bXVsdChsLCBsKTtcbiAgICB9XG5cbiAgICB1LmNvcHkobCk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHAgPSBwb2ludHNbaV07XG5cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEudm11bHQocCwgdG1wKTtcbiAgICAgICAgcCA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHAueCA+IHUueCkge1xuICAgICAgICB1LnggPSBwLng7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLnggPCBsLngpIHtcbiAgICAgICAgbC54ID0gcC54O1xuICAgICAgfVxuXG4gICAgICBpZiAocC55ID4gdS55KSB7XG4gICAgICAgIHUueSA9IHAueTtcbiAgICAgIH1cblxuICAgICAgaWYgKHAueSA8IGwueSkge1xuICAgICAgICBsLnkgPSBwLnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLnogPiB1LnopIHtcbiAgICAgICAgdS56ID0gcC56O1xuICAgICAgfVxuXG4gICAgICBpZiAocC56IDwgbC56KSB7XG4gICAgICAgIGwueiA9IHAuejtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCBvZmZzZXRcblxuXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbi52YWRkKGwsIGwpO1xuICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTtcbiAgICB9XG5cbiAgICBpZiAoc2tpblNpemUpIHtcbiAgICAgIGwueCAtPSBza2luU2l6ZTtcbiAgICAgIGwueSAtPSBza2luU2l6ZTtcbiAgICAgIGwueiAtPSBza2luU2l6ZTtcbiAgICAgIHUueCArPSBza2luU2l6ZTtcbiAgICAgIHUueSArPSBza2luU2l6ZTtcbiAgICAgIHUueiArPSBza2luU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXHJcbiAgICogQG1ldGhvZCBjb3B5XHJcbiAgICogQHBhcmFtICB7QUFCQn0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tXHJcbiAgICogQHJldHVybiB7QUFCQn0gVGhlIHRoaXMgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5XHJcbiAgICovXG5cblxuICBjb3B5KGFhYmIpIHtcbiAgICB0aGlzLmxvd2VyQm91bmQuY29weShhYWJiLmxvd2VyQm91bmQpO1xuICAgIHRoaXMudXBwZXJCb3VuZC5jb3B5KGFhYmIudXBwZXJCb3VuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xvbmUgYW4gQUFCQlxyXG4gICAqIEBtZXRob2QgY2xvbmVcclxuICAgKi9cblxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQUFCQigpLmNvcHkodGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXHJcbiAgICogQG1ldGhvZCBleHRlbmRcclxuICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICovXG5cblxuICBleHRlbmQoYWFiYikge1xuICAgIHRoaXMubG93ZXJCb3VuZC54ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC54KTtcbiAgICB0aGlzLnVwcGVyQm91bmQueCA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC54LCBhYWJiLnVwcGVyQm91bmQueCk7XG4gICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueSwgYWFiYi5sb3dlckJvdW5kLnkpO1xuICAgIHRoaXMudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLnksIGFhYmIudXBwZXJCb3VuZC55KTtcbiAgICB0aGlzLmxvd2VyQm91bmQueiA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC56LCBhYWJiLmxvd2VyQm91bmQueik7XG4gICAgdGhpcy51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueiwgYWFiYi51cHBlckJvdW5kLnopO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXHJcbiAgICogQG1ldGhvZCBvdmVybGFwc1xyXG4gICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xuXG5cbiAgb3ZlcmxhcHMoYWFiYikge1xuICAgIGNvbnN0IGwxID0gdGhpcy5sb3dlckJvdW5kO1xuICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kO1xuICAgIGNvbnN0IGwyID0gYWFiYi5sb3dlckJvdW5kO1xuICAgIGNvbnN0IHUyID0gYWFiYi51cHBlckJvdW5kOyAvLyAgICAgIGwyICAgICAgICB1MlxuICAgIC8vICAgICAgfC0tLS0tLS0tLXxcbiAgICAvLyB8LS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgdTFcblxuICAgIGNvbnN0IG92ZXJsYXBzWCA9IGwyLnggPD0gdTEueCAmJiB1MS54IDw9IHUyLnggfHwgbDEueCA8PSB1Mi54ICYmIHUyLnggPD0gdTEueDtcbiAgICBjb25zdCBvdmVybGFwc1kgPSBsMi55IDw9IHUxLnkgJiYgdTEueSA8PSB1Mi55IHx8IGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnk7XG4gICAgY29uc3Qgb3ZlcmxhcHNaID0gbDIueiA8PSB1MS56ICYmIHUxLnogPD0gdTIueiB8fCBsMS56IDw9IHUyLnogJiYgdTIueiA8PSB1MS56O1xuICAgIHJldHVybiBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZICYmIG92ZXJsYXBzWjtcbiAgfSAvLyBNb3N0bHkgZm9yIGRlYnVnZ2luZ1xuXG5cbiAgdm9sdW1lKCkge1xuICAgIGNvbnN0IGwgPSB0aGlzLmxvd2VyQm91bmQ7XG4gICAgY29uc3QgdSA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICByZXR1cm4gKHUueCAtIGwueCkgKiAodS55IC0gbC55KSAqICh1LnogLSBsLnopO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLlxyXG4gICAqIEBtZXRob2QgY29udGFpbnNcclxuICAgKiBAcGFyYW0ge0FBQkJ9IGFhYmJcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xuXG5cbiAgY29udGFpbnMoYWFiYikge1xuICAgIGNvbnN0IGwxID0gdGhpcy5sb3dlckJvdW5kO1xuICAgIGNvbnN0IHUxID0gdGhpcy51cHBlckJvdW5kO1xuICAgIGNvbnN0IGwyID0gYWFiYi5sb3dlckJvdW5kO1xuICAgIGNvbnN0IHUyID0gYWFiYi51cHBlckJvdW5kOyAvLyAgICAgIGwyICAgICAgICB1MlxuICAgIC8vICAgICAgfC0tLS0tLS0tLXxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIGwxICAgICAgICAgICAgICB1MVxuXG4gICAgcmV0dXJuIGwxLnggPD0gbDIueCAmJiB1MS54ID49IHUyLnggJiYgbDEueSA8PSBsMi55ICYmIHUxLnkgPj0gdTIueSAmJiBsMS56IDw9IGwyLnogJiYgdTEueiA+PSB1Mi56O1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2QgZ2V0Q29ybmVyc1xyXG4gICAqIEBwYXJhbSB7VmVjM30gYVxyXG4gICAqIEBwYXJhbSB7VmVjM30gYlxyXG4gICAqIEBwYXJhbSB7VmVjM30gY1xyXG4gICAqIEBwYXJhbSB7VmVjM30gZFxyXG4gICAqIEBwYXJhbSB7VmVjM30gZVxyXG4gICAqIEBwYXJhbSB7VmVjM30gZlxyXG4gICAqIEBwYXJhbSB7VmVjM30gZ1xyXG4gICAqIEBwYXJhbSB7VmVjM30gaFxyXG4gICAqL1xuXG5cbiAgZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICBjb25zdCB1ID0gdGhpcy51cHBlckJvdW5kO1xuICAgIGEuY29weShsKTtcbiAgICBiLnNldCh1LngsIGwueSwgbC56KTtcbiAgICBjLnNldCh1LngsIHUueSwgbC56KTtcbiAgICBkLnNldChsLngsIHUueSwgdS56KTtcbiAgICBlLnNldCh1LngsIGwueSwgdS56KTtcbiAgICBmLnNldChsLngsIHUueSwgbC56KTtcbiAgICBnLnNldChsLngsIGwueSwgdS56KTtcbiAgICBoLmNvcHkodSk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIGFub3RoZXIgZnJhbWUuXHJcbiAgICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXHJcbiAgICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7QUFCQn0gVGhlIFwidGFyZ2V0XCIgQUFCQiBvYmplY3QuXHJcbiAgICovXG5cblxuICB0b0xvY2FsRnJhbWUoZnJhbWUsIHRhcmdldCkge1xuICAgIGNvbnN0IGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycztcbiAgICBjb25zdCBhID0gY29ybmVyc1swXTtcbiAgICBjb25zdCBiID0gY29ybmVyc1sxXTtcbiAgICBjb25zdCBjID0gY29ybmVyc1syXTtcbiAgICBjb25zdCBkID0gY29ybmVyc1szXTtcbiAgICBjb25zdCBlID0gY29ybmVyc1s0XTtcbiAgICBjb25zdCBmID0gY29ybmVyc1s1XTtcbiAgICBjb25zdCBnID0gY29ybmVyc1s2XTtcbiAgICBjb25zdCBoID0gY29ybmVyc1s3XTsgLy8gR2V0IGNvcm5lcnMgaW4gY3VycmVudCBmcmFtZVxuXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpOyAvLyBUcmFuc2Zvcm0gdGhlbSB0byBuZXcgbG9jYWwgZnJhbWVcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgIGNvbnN0IGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgICBmcmFtZS5wb2ludFRvTG9jYWwoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS5cclxuICAgKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxyXG4gICAqIEBwYXJhbSAge1RyYW5zZm9ybX0gZnJhbWVcclxuICAgKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cclxuICAgKi9cblxuXG4gIHRvV29ybGRGcmFtZShmcmFtZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIGNvbnN0IGEgPSBjb3JuZXJzWzBdO1xuICAgIGNvbnN0IGIgPSBjb3JuZXJzWzFdO1xuICAgIGNvbnN0IGMgPSBjb3JuZXJzWzJdO1xuICAgIGNvbnN0IGQgPSBjb3JuZXJzWzNdO1xuICAgIGNvbnN0IGUgPSBjb3JuZXJzWzRdO1xuICAgIGNvbnN0IGYgPSBjb3JuZXJzWzVdO1xuICAgIGNvbnN0IGcgPSBjb3JuZXJzWzZdO1xuICAgIGNvbnN0IGggPSBjb3JuZXJzWzddOyAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG5cbiAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7IC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykge1xuICAgICAgY29uc3QgY29ybmVyID0gY29ybmVyc1tpXTtcbiAgICAgIGZyYW1lLnBvaW50VG9Xb3JsZChjb3JuZXIsIGNvcm5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBBQUJCIGlzIGhpdCBieSBhIHJheS5cclxuICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXG5cblxuICBvdmVybGFwc1JheShyYXkpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBmcm9tXG4gICAgfSA9IHJheTtcblxuICAgIGNvbnN0IGRpckZyYWNYID0gMSAvIGRpcmVjdGlvbi54O1xuICAgIGNvbnN0IGRpckZyYWNZID0gMSAvIGRpcmVjdGlvbi55O1xuICAgIGNvbnN0IGRpckZyYWNaID0gMSAvIGRpcmVjdGlvbi56OyAvLyB0aGlzLmxvd2VyQm91bmQgaXMgdGhlIGNvcm5lciBvZiBBQUJCIHdpdGggbWluaW1hbCBjb29yZGluYXRlcyAtIGxlZnQgYm90dG9tLCBydCBpcyBtYXhpbWFsIGNvcm5lclxuXG4gICAgY29uc3QgdDEgPSAodGhpcy5sb3dlckJvdW5kLnggLSBmcm9tLngpICogZGlyRnJhY1g7XG4gICAgY29uc3QgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBmcm9tLngpICogZGlyRnJhY1g7XG4gICAgY29uc3QgdDMgPSAodGhpcy5sb3dlckJvdW5kLnkgLSBmcm9tLnkpICogZGlyRnJhY1k7XG4gICAgY29uc3QgdDQgPSAodGhpcy51cHBlckJvdW5kLnkgLSBmcm9tLnkpICogZGlyRnJhY1k7XG4gICAgY29uc3QgdDUgPSAodGhpcy5sb3dlckJvdW5kLnogLSBmcm9tLnopICogZGlyRnJhY1o7XG4gICAgY29uc3QgdDYgPSAodGhpcy51cHBlckJvdW5kLnogLSBmcm9tLnopICogZGlyRnJhY1o7IC8vIGNvbnN0IHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSk7XG4gICAgLy8gY29uc3QgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpKTtcblxuICAgIGNvbnN0IHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSwgTWF0aC5taW4odDUsIHQ2KSk7XG4gICAgY29uc3QgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTsgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1c1xuXG4gICAgaWYgKHRtYXggPCAwKSB7XG4gICAgICAvL3QgPSB0bWF4O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCXG5cblxuICAgIGlmICh0bWluID4gdG1heCkge1xuICAgICAgLy90ID0gdG1heDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5jb25zdCB0bXAgPSBuZXcgVmVjMygpO1xuY29uc3QgdHJhbnNmb3JtSW50b0ZyYW1lX2Nvcm5lcnMgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07XG5cbi8qKlxyXG4gKiBDb2xsaXNpb24gXCJtYXRyaXhcIi4gSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcFxyXG4gKiBAY2xhc3MgQXJyYXlDb2xsaXNpb25NYXRyaXhcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xuY2xhc3MgQXJyYXlDb2xsaXNpb25NYXRyaXgge1xuICAvLyBUaGUgbWF0cml4IHN0b3JhZ2UuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWF0cml4ID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVsZW1lbnRcclxuICAgKiBAbWV0aG9kIGdldFxyXG4gICAqIEBwYXJhbSAge0JvZHl9IGlcclxuICAgKiBAcGFyYW0gIHtCb2R5fSBqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZ2V0KGJpLCBiaikge1xuICAgIGxldCB7XG4gICAgICBpbmRleDogaVxuICAgIH0gPSBiaTtcbiAgICBsZXQge1xuICAgICAgaW5kZXg6IGpcbiAgICB9ID0gYmo7XG5cbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBqO1xuICAgICAgaiA9IGk7XG4gICAgICBpID0gdGVtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgaiAtIDFdO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBhbiBlbGVtZW50XHJcbiAgICogQG1ldGhvZCBzZXRcclxuICAgKiBAcGFyYW0ge0JvZHl9IGlcclxuICAgKiBAcGFyYW0ge0JvZHl9IGpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICovXG5cblxuICBzZXQoYmksIGJqLCB2YWx1ZSkge1xuICAgIGxldCB7XG4gICAgICBpbmRleDogaVxuICAgIH0gPSBiaTtcbiAgICBsZXQge1xuICAgICAgaW5kZXg6IGpcbiAgICB9ID0gYmo7XG5cbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBqO1xuICAgICAgaiA9IGk7XG4gICAgICBpID0gdGVtcDtcbiAgICB9XG5cbiAgICB0aGlzLm1hdHJpeFsoaSAqIChpICsgMSkgPj4gMSkgKyBqIC0gMV0gPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldHMgYWxsIGVsZW1lbnRzIHRvIHplcm9cclxuICAgKiBAbWV0aG9kIHJlc2V0XHJcbiAgICovXG5cblxuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubWF0cml4Lmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgICB0aGlzLm1hdHJpeFtpXSA9IDA7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG1heCBudW1iZXIgb2Ygb2JqZWN0c1xyXG4gICAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAgICovXG5cblxuICBzZXROdW1PYmplY3RzKG4pIHtcbiAgICB0aGlzLm1hdHJpeC5sZW5ndGggPSBuICogKG4gLSAxKSA+PiAxO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cclxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cbmNsYXNzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuICAvKipcclxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcclxuICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gICAqL1xuXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWxpc3RlbmVyc1t0eXBlXS5pbmNsdWRlcyhsaXN0ZW5lcikpIHtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxyXG4gICAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXG5cblxuICBoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgaWYgKGxpc3RlbmVyc1t0eXBlXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1t0eXBlXS5pbmNsdWRlcyhsaXN0ZW5lcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbnkgZXZlbnQgbGlzdGVuZXIgb2YgdGhlIGdpdmVuIHR5cGUgaXMgYWRkZWRcclxuICAgKiBAbWV0aG9kIGhhc0FueUV2ZW50TGlzdGVuZXJcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xuXG5cbiAgaGFzQW55RXZlbnRMaXN0ZW5lcih0eXBlKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHJldHVybiBsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcclxuICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gICAqL1xuXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG4gICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEVtaXQgYW4gZXZlbnQuXHJcbiAgICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQudHlwZVxyXG4gICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICovXG5cblxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTtcblxuICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJBcnJheVtpXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbi8qKlxuICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0geCBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGouXG4gKiBAcGFyYW0ge051bWJlcn0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuXG4gKiBAcGFyYW0ge051bWJlcn0gdyBNdWx0aXBsaWVyIG9mIHRoZSByZWFsIHBhcnQuXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvblxuICovXG5cbmNsYXNzIFF1YXRlcm5pb24ge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMudyA9IHc7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uXG4gICAqL1xuXG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLncgPSB3O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgcmVhZGFibGUgZm9ybWF0XG4gICAqIEByZXR1cm4ge1N0cmluZ30gXCJ4LHkseix3XCJcbiAgICovXG5cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIixcIiArIHRoaXMueiArIFwiLFwiICsgdGhpcy53O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGFuIEFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCwgeSwgeiwgd11cbiAgICovXG5cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBxdWF0ZXJuaW9uIGNvbXBvbmVudHMgZ2l2ZW4gYW4gYXhpcyBhbmQgYW4gYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG5cblxuICBzZXRGcm9tQXhpc0FuZ2xlKHZlY3RvciwgYW5nbGUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUgKiAwLjUpO1xuICAgIHRoaXMueCA9IHZlY3Rvci54ICogcztcbiAgICB0aGlzLnkgPSB2ZWN0b3IueSAqIHM7XG4gICAgdGhpcy56ID0gdmVjdG9yLnogKiBzO1xuICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlICogMC41KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHF1YXRlcm5pb24gdG8gWyBheGlzLCBhbmdsZSBdIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0ge1ZlYzN9IFt0YXJnZXRBeGlzXSBBIHZlY3RvciBvYmplY3QgdG8gcmV1c2UgZm9yIHN0b3JpbmcgdGhlIGF4aXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSwgZmlyc3QgZWxlbWVudCBpcyB0aGUgYXhpcyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG5cblxuICB0b0F4aXNBbmdsZSh0YXJnZXRBeGlzID0gbmV3IFZlYzMoKSkge1xuICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkXG5cbiAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLmFjb3ModGhpcy53KTtcbiAgICBjb25zdCBzID0gTWF0aC5zcXJ0KDEgLSB0aGlzLncgKiB0aGlzLncpOyAvLyBhc3N1bWluZyBxdWF0ZXJuaW9uIG5vcm1hbGlzZWQgdGhlbiB3IGlzIGxlc3MgdGhhbiAxLCBzbyB0ZXJtIGFsd2F5cyBwb3NpdGl2ZS5cblxuICAgIGlmIChzIDwgMC4wMDEpIHtcbiAgICAgIC8vIHRlc3QgdG8gYXZvaWQgZGl2aWRlIGJ5IHplcm8sIHMgaXMgYWx3YXlzIHBvc2l0aXZlIGR1ZSB0byBzcXJ0XG4gICAgICAvLyBpZiBzIGNsb3NlIHRvIHplcm8gdGhlbiBkaXJlY3Rpb24gb2YgYXhpcyBub3QgaW1wb3J0YW50XG4gICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLng7IC8vIGlmIGl0IGlzIGltcG9ydGFudCB0aGF0IGF4aXMgaXMgbm9ybWFsaXNlZCB0aGVuIHJlcGxhY2Ugd2l0aCB4PTE7IHk9ej0wO1xuXG4gICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnk7XG4gICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLno7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEF4aXMueCA9IHRoaXMueCAvIHM7IC8vIG5vcm1hbGlzZSBheGlzXG5cbiAgICAgIHRhcmdldEF4aXMueSA9IHRoaXMueSAvIHM7XG4gICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLnogLyBzO1xuICAgIH1cblxuICAgIHJldHVybiBbdGFyZ2V0QXhpcywgYW5nbGVdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuXG4gICAqL1xuXG5cbiAgc2V0RnJvbVZlY3RvcnModSwgdikge1xuICAgIGlmICh1LmlzQW50aXBhcmFsbGVsVG8odikpIHtcbiAgICAgIGNvbnN0IHQxID0gc2Z2X3QxO1xuICAgICAgY29uc3QgdDIgPSBzZnZfdDI7XG4gICAgICB1LnRhbmdlbnRzKHQxLCB0Mik7XG4gICAgICB0aGlzLnNldEZyb21BeGlzQW5nbGUodDEsIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhID0gdS5jcm9zcyh2KTtcbiAgICAgIHRoaXMueCA9IGEueDtcbiAgICAgIHRoaXMueSA9IGEueTtcbiAgICAgIHRoaXMueiA9IGEuejtcbiAgICAgIHRoaXMudyA9IE1hdGguc3FydCh1Lmxlbmd0aCgpICoqIDIgKiB2Lmxlbmd0aCgpICoqIDIpICsgdS5kb3Qodik7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiB3aXRoIGFuIG90aGVyIHF1YXRlcm5pb24uXG4gICAqL1xuXG5cbiAgbXVsdChxdWF0LCB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpKSB7XG4gICAgY29uc3QgYXggPSB0aGlzLng7XG4gICAgY29uc3QgYXkgPSB0aGlzLnk7XG4gICAgY29uc3QgYXogPSB0aGlzLno7XG4gICAgY29uc3QgYXcgPSB0aGlzLnc7XG4gICAgY29uc3QgYnggPSBxdWF0Lng7XG4gICAgY29uc3QgYnkgPSBxdWF0Lnk7XG4gICAgY29uc3QgYnogPSBxdWF0Lno7XG4gICAgY29uc3QgYncgPSBxdWF0Lnc7XG4gICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIHRhcmdldC55ID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICB0YXJnZXQueiA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW52ZXJzZSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICAgKi9cblxuXG4gIGludmVyc2UodGFyZ2V0ID0gbmV3IFF1YXRlcm5pb24oKSkge1xuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIGNvbnN0IHcgPSB0aGlzLnc7XG4gICAgdGhpcy5jb25qdWdhdGUodGFyZ2V0KTtcbiAgICBjb25zdCBpbm9ybTIgPSAxIC8gKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcbiAgICB0YXJnZXQueCAqPSBpbm9ybTI7XG4gICAgdGFyZ2V0LnkgKj0gaW5vcm0yO1xuICAgIHRhcmdldC56ICo9IGlub3JtMjtcbiAgICB0YXJnZXQudyAqPSBpbm9ybTI7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBxdWF0ZXJuaW9uIGNvbmp1Z2F0ZVxuICAgKi9cblxuXG4gIGNvbmp1Z2F0ZSh0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpKSB7XG4gICAgdGFyZ2V0LnggPSAtdGhpcy54O1xuICAgIHRhcmdldC55ID0gLXRoaXMueTtcbiAgICB0YXJnZXQueiA9IC10aGlzLno7XG4gICAgdGFyZ2V0LncgPSB0aGlzLnc7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uXG4gICAqIEBtZXRob2Qgbm9ybWFsaXplXG4gICAqL1xuXG5cbiAgbm9ybWFsaXplKCkge1xuICAgIGxldCBsID0gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyk7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IDEgLyBsO1xuICAgICAgdGhpcy54ICo9IGw7XG4gICAgICB0aGlzLnkgKj0gbDtcbiAgICAgIHRoaXMueiAqPSBsO1xuICAgICAgdGhpcy53ICo9IGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcHJveGltYXRpb24gb2YgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBXb3JrcyBiZXN0IHdoZW4gcXVhdCBpcyBhbHJlYWR5IGFsbW9zdC1ub3JtYWxpemVkLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2Zhc3QtcXVhdGVybmlvbi1ub3JtYWxpemF0aW9uXG4gICAqIEBhdXRob3IgdW5waGFzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS91bnBoYXNlZFxuICAgKi9cblxuXG4gIG5vcm1hbGl6ZUZhc3QoKSB7XG4gICAgY29uc3QgZiA9ICgzLjAgLSAodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KSkgLyAyLjA7XG5cbiAgICBpZiAoZiA9PT0gMCkge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ICo9IGY7XG4gICAgICB0aGlzLnkgKj0gZjtcbiAgICAgIHRoaXMueiAqPSBmO1xuICAgICAgdGhpcy53ICo9IGY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoZSBxdWF0ZXJuaW9uIGJ5IGEgdmVjdG9yXG4gICAqL1xuXG5cbiAgdm11bHQodiwgdGFyZ2V0ID0gbmV3IFZlYzMoKSkge1xuICAgIGNvbnN0IHggPSB2Lng7XG4gICAgY29uc3QgeSA9IHYueTtcbiAgICBjb25zdCB6ID0gdi56O1xuICAgIGNvbnN0IHF4ID0gdGhpcy54O1xuICAgIGNvbnN0IHF5ID0gdGhpcy55O1xuICAgIGNvbnN0IHF6ID0gdGhpcy56O1xuICAgIGNvbnN0IHF3ID0gdGhpcy53OyAvLyBxKnZcblxuICAgIGNvbnN0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgIGNvbnN0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIGNvbnN0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcbiAgICB0YXJnZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIHRhcmdldC56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdmFsdWUgb2Ygc291cmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gc291cmNlXG4gICAqIEByZXR1cm4ge1F1YXRlcm5pb259IHRoaXNcbiAgICovXG5cblxuICBjb3B5KHF1YXQpIHtcbiAgICB0aGlzLnggPSBxdWF0Lng7XG4gICAgdGhpcy55ID0gcXVhdC55O1xuICAgIHRoaXMueiA9IHF1YXQuejtcbiAgICB0aGlzLncgPSBxdWF0Lnc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHF1YXRlcm5pb24gdG8gZXVsZXIgYW5nbGUgcmVwcmVzZW50YXRpb24uIE9yZGVyOiBZWlgsIGFzIHRoaXMgcGFnZSBkZXNjcmliZXM6IGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL3N0YW5kYXJkcy9pbmRleC5odG1cbiAgICogQG1ldGhvZCB0b0V1bGVyXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nLCBkZWZhdWx0cyB0byBcIllaWFwiXG4gICAqL1xuXG5cbiAgdG9FdWxlcih0YXJnZXQsIG9yZGVyID0gJ1laWCcpIHtcbiAgICBsZXQgaGVhZGluZztcbiAgICBsZXQgYXR0aXR1ZGU7XG4gICAgbGV0IGJhbms7XG4gICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgIGNvbnN0IHogPSB0aGlzLno7XG4gICAgY29uc3QgdyA9IHRoaXMudztcblxuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgIGNhc2UgJ1laWCc6XG4gICAgICAgIGNvbnN0IHRlc3QgPSB4ICogeSArIHogKiB3O1xuXG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHtcbiAgICAgICAgICAvLyBzaW5ndWxhcml0eSBhdCBub3J0aCBwb2xlXG4gICAgICAgICAgaGVhZGluZyA9IDIgKiBNYXRoLmF0YW4yKHgsIHcpO1xuICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgYmFuayA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGVzdCA8IC0wLjQ5OSkge1xuICAgICAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGVcbiAgICAgICAgICBoZWFkaW5nID0gLTIgKiBNYXRoLmF0YW4yKHgsIHcpO1xuICAgICAgICAgIGF0dGl0dWRlID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHNxeCA9IHggKiB4O1xuICAgICAgICAgIGNvbnN0IHNxeSA9IHkgKiB5O1xuICAgICAgICAgIGNvbnN0IHNxeiA9IHogKiB6O1xuICAgICAgICAgIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIgKiB5ICogdyAtIDIgKiB4ICogeiwgMSAtIDIgKiBzcXkgLSAyICogc3F6KTsgLy8gSGVhZGluZ1xuXG4gICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMiAqIHRlc3QpOyAvLyBhdHRpdHVkZVxuXG4gICAgICAgICAgYmFuayA9IE1hdGguYXRhbjIoMiAqIHggKiB3IC0gMiAqIHkgKiB6LCAxIC0gMiAqIHNxeCAtIDIgKiBzcXopOyAvLyBiYW5rXG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXVsZXIgb3JkZXIgXCIgKyBvcmRlciArIFwiIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQueSA9IGhlYWRpbmc7XG4gICAgdGFyZ2V0LnogPSBhdHRpdHVkZTtcbiAgICB0YXJnZXQueCA9IGJhbms7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBUaGUgb3JkZXIgdG8gYXBwbHkgYW5nbGVzOiAnWFlaJyBvciAnWVhaJyBvciBhbnkgb3RoZXIgY29tYmluYXRpb25cbiAgICogQHNlZSBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvY29udGVudC9TcGluQ2FsYy5tXG4gICAqL1xuXG5cbiAgc2V0RnJvbUV1bGVyKHgsIHksIHosIG9yZGVyID0gJ1hZWicpIHtcbiAgICBjb25zdCBjMSA9IE1hdGguY29zKHggLyAyKTtcbiAgICBjb25zdCBjMiA9IE1hdGguY29zKHkgLyAyKTtcbiAgICBjb25zdCBjMyA9IE1hdGguY29zKHogLyAyKTtcbiAgICBjb25zdCBzMSA9IE1hdGguc2luKHggLyAyKTtcbiAgICBjb25zdCBzMiA9IE1hdGguc2luKHkgLyAyKTtcbiAgICBjb25zdCBzMyA9IE1hdGguc2luKHogLyAyKTtcblxuICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcbiAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG4gICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcbiAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG4gICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAgICovXG5cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24odGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICAgKlxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHRvUXVhdCBzZWNvbmQgb3BlcmFuZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSBzZWxmIHF1YXRlcm5pb24gYW5kIHRvUXVhdFxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IFt0YXJnZXRdIEEgcXVhdGVybmlvbiB0byBzdG9yZSB0aGUgcmVzdWx0IGluLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IG9uZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgXCJ0YXJnZXRcIiBvYmplY3RcbiAgICovXG5cblxuICBzbGVycCh0b1F1YXQsIHQsIHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCkpIHtcbiAgICBjb25zdCBheCA9IHRoaXMueDtcbiAgICBjb25zdCBheSA9IHRoaXMueTtcbiAgICBjb25zdCBheiA9IHRoaXMuejtcbiAgICBjb25zdCBhdyA9IHRoaXMudztcbiAgICBsZXQgYnggPSB0b1F1YXQueDtcbiAgICBsZXQgYnkgPSB0b1F1YXQueTtcbiAgICBsZXQgYnogPSB0b1F1YXQuejtcbiAgICBsZXQgYncgPSB0b1F1YXQudztcbiAgICBsZXQgb21lZ2E7XG4gICAgbGV0IGNvc29tO1xuICAgIGxldCBzaW5vbTtcbiAgICBsZXQgc2NhbGUwO1xuICAgIGxldCBzY2FsZTE7IC8vIGNhbGMgY29zaW5lXG5cbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gICAgaWYgKGNvc29tIDwgMC4wKSB7XG4gICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgIGJ4ID0gLWJ4O1xuICAgICAgYnkgPSAtYnk7XG4gICAgICBieiA9IC1iejtcbiAgICAgIGJ3ID0gLWJ3O1xuICAgIH0gLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuXG5cbiAgICBpZiAoMS4wIC0gY29zb20gPiAwLjAwMDAwMSkge1xuICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXG4gICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgc2NhbGUxID0gdDtcbiAgICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gICAgdGFyZ2V0LnggPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIHRhcmdldC55ID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICB0YXJnZXQueiA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgdGFyZ2V0LncgPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJvdGF0ZSBhbiBhYnNvbHV0ZSBvcmllbnRhdGlvbiBxdWF0ZXJuaW9uIGdpdmVuIGFuIGFuZ3VsYXIgdmVsb2NpdHkgYW5kIGEgdGltZSBzdGVwLlxuICAgKi9cblxuXG4gIGludGVncmF0ZShhbmd1bGFyVmVsb2NpdHksIGR0LCBhbmd1bGFyRmFjdG9yLCB0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpKSB7XG4gICAgY29uc3QgYXggPSBhbmd1bGFyVmVsb2NpdHkueCAqIGFuZ3VsYXJGYWN0b3IueCxcbiAgICAgICAgICBheSA9IGFuZ3VsYXJWZWxvY2l0eS55ICogYW5ndWxhckZhY3Rvci55LFxuICAgICAgICAgIGF6ID0gYW5ndWxhclZlbG9jaXR5LnogKiBhbmd1bGFyRmFjdG9yLnosXG4gICAgICAgICAgYnggPSB0aGlzLngsXG4gICAgICAgICAgYnkgPSB0aGlzLnksXG4gICAgICAgICAgYnogPSB0aGlzLnosXG4gICAgICAgICAgYncgPSB0aGlzLnc7XG4gICAgY29uc3QgaGFsZl9kdCA9IGR0ICogMC41O1xuICAgIHRhcmdldC54ICs9IGhhbGZfZHQgKiAoYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5KTtcbiAgICB0YXJnZXQueSArPSBoYWxmX2R0ICogKGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBieik7XG4gICAgdGFyZ2V0LnogKz0gaGFsZl9kdCAqIChheiAqIGJ3ICsgYXggKiBieSAtIGF5ICogYngpO1xuICAgIHRhcmdldC53ICs9IGhhbGZfZHQgKiAoLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieik7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG59XG5jb25zdCBzZnZfdDEgPSBuZXcgVmVjMygpO1xuY29uc3Qgc2Z2X3QyID0gbmV3IFZlYzMoKTtcblxuY29uc3QgU0hBUEVfVFlQRVMgPSB7XG4gIFNQSEVSRTogMSxcbiAgUExBTkU6IDIsXG4gIEJPWDogNCxcbiAgQ09NUE9VTkQ6IDgsXG4gIENPTlZFWFBPTFlIRURST046IDE2LFxuICBIRUlHSFRGSUVMRDogMzIsXG4gIFBBUlRJQ0xFOiA2NCxcbiAgQ1lMSU5ERVI6IDEyOCxcbiAgVFJJTUVTSDogMjU2XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlc1xuICogQGNsYXNzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXRlcmlhbD1udWxsXVxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5jbGFzcyBTaGFwZSB7XG4gIC8vIElkZW50aWZ5ZXIgb2YgdGhlIFNoYXBlLlxuICAvLyBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuXG4gIC8vIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXG4gIC8vIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAwO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwO1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAxO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgPyBvcHRpb25zLm1hdGVyaWFsIDogbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgc3BoZXJlIHJhZGl1cy4gVGhlIHJlc3VsdCBpcyBzdG9yZWQgaW4gdGhlIHByb3BlcnR5IC5ib3VuZGluZ1NwaGVyZVJhZGl1c1xuICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gICAqL1xuXG5cbiAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7XG4gICAgdGhyb3cgXCJjb21wdXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIgKyB0aGlzLnR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdm9sdW1lIG9mIHRoaXMgc2hhcGVcbiAgICogQG1ldGhvZCB2b2x1bWVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cblxuXG4gIHZvbHVtZSgpIHtcbiAgICB0aHJvdyBcInZvbHVtZSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIiArIHRoaXMudHlwZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaW5lcnRpYSBpbiB0aGUgbG9jYWwgZnJhbWUgZm9yIHRoaXMgc2hhcGUuXG4gICAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXNzXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gICAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxuICAgKi9cblxuXG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQpIHtcbiAgICB0aHJvdyBcImNhbGN1bGF0ZUxvY2FsSW5lcnRpYSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIiArIHRoaXMudHlwZTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVdvcmxkQUFCQihwb3MsIHF1YXQsIG1pbiwgbWF4KSB7XG4gICAgdGhyb3cgXCJjYWxjdWxhdGVXb3JsZEFBQkIoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIgKyB0aGlzLnR5cGU7XG4gIH1cblxufVxuU2hhcGUuaWRDb3VudGVyID0gMDtcbi8qKlxuICogVGhlIGF2YWlsYWJsZSBzaGFwZSB0eXBlcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB0eXBlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5TaGFwZS50eXBlcyA9IFNIQVBFX1RZUEVTO1xuXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5xdWF0ZXJuaW9uKSB7XG4gICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBHZXQgYSBnbG9iYWwgcG9pbnQgaW4gbG9jYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxyXG4gICAqL1xuXG5cbiAgcG9pbnRUb0xvY2FsKHdvcmxkUG9pbnQsIHJlc3VsdCkge1xuICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhIGxvY2FsIHBvaW50IGluIGdsb2JhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXHJcbiAgICovXG5cblxuICBwb2ludFRvV29ybGQobG9jYWxQb2ludCwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCk7XG4gIH1cblxuICB2ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxWZWN0b3IsIHJlc3VsdCA9IG5ldyBWZWMzKCkpIHtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBwb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0ID0gbmV3IFZlYzMoKSkge1xuICAgIHdvcmxkUG9pbnQudnN1Yihwb3NpdGlvbiwgcmVzdWx0KTtcbiAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0KTtcbiAgICB0bXBRdWF0LnZtdWx0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIHBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQgPSBuZXcgVmVjMygpKSB7XG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgdmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQgPSBuZXcgVmVjMygpKSB7XG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIHZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRWZWN0b3IsIHJlc3VsdCA9IG5ldyBWZWMzKCkpIHtcbiAgICBxdWF0ZXJuaW9uLncgKj0gLTE7XG4gICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTtcbiAgICBxdWF0ZXJuaW9uLncgKj0gLTE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59XG5jb25zdCB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXHJcbiAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXHJcbiAqIEBjbGFzcyBDb252ZXhQb2x5aGVkcm9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKiBAZGVzY3JpcHRpb24gVGhlIHNoYXBlIE1VU1QgYmUgY29udmV4IGZvciB0aGUgY29kZSB0byB3b3JrIHByb3Blcmx5LiBObyBwb2x5Z29ucyBtYXkgYmUgY29wbGFuYXIgKGNvbnRhaW5lZFxyXG4gKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgVmVjMydzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhbyAob3JpZ2luYWwgYXV0aG9yLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3FpYW8vdGhyZWUuanMvY29tbWl0Lzg1MDI2ZjBjNzY5ZTQwMDAxNDhhNjdkNDVhOWU5YjljNTEwODgzNmYpXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcclxuICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXHJcbiAqXHJcbiAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xyXG4gKiBAdG9kbyBBdXRvbWF0aWNhbGx5IG1lcmdlIGNvcGxhbmFyIHBvbHlnb25zIGluIGNvbnN0cnVjdG9yLlxyXG4gKi9cbmNsYXNzIENvbnZleFBvbHloZWRyb24gZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZlxuICAvLyBJZiBnaXZlbiwgdGhlc2UgbG9jYWxseSBkZWZpbmVkLCBub3JtYWxpemVkIGF4ZXMgYXJlIHRoZSBvbmx5IG9uZXMgYmVpbmcgY2hlY2tlZCB3aGVuIGRvaW5nIHNlcGFyYXRpbmcgYXhpcyBjaGVjay5cbiAgY29uc3RydWN0b3IocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcnRpY2VzID0gW10sXG4gICAgICBmYWNlcyA9IFtdLFxuICAgICAgbm9ybWFscyA9IFtdLFxuICAgICAgYXhlcyxcbiAgICAgIGJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gICAgfSA9IHByb3BzO1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05cbiAgICB9KTtcbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgdGhpcy5mYWNlcyA9IGZhY2VzO1xuICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBub3JtYWxzO1xuXG4gICAgaWYgKHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNvbXB1dGVOb3JtYWxzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gYm91bmRpbmdTcGhlcmVSYWRpdXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZFZlcnRpY2VzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLnZlcnRpY2VzXG5cbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLmZhY2VOb3JtYWxzXG5cbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy51bmlxdWVBeGVzID0gYXhlcyA/IGF4ZXMuc2xpY2UoKSA6IG51bGw7XG4gICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdO1xuICAgIHRoaXMuY29tcHV0ZUVkZ2VzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZXMgdW5pcXVlRWRnZXNcclxuICAgKiBAbWV0aG9kIGNvbXB1dGVFZGdlc1xyXG4gICAqL1xuXG5cbiAgY29tcHV0ZUVkZ2VzKCkge1xuICAgIGNvbnN0IGZhY2VzID0gdGhpcy5mYWNlcztcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLnVuaXF1ZUVkZ2VzO1xuICAgIGVkZ2VzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgZWRnZSA9IG5ldyBWZWMzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcbiAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gZmFjZS5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBudW1WZXJ0aWNlczsgaisrKSB7XG4gICAgICAgIGNvbnN0IGsgPSAoaiArIDEpICUgbnVtVmVydGljZXM7XG4gICAgICAgIHZlcnRpY2VzW2ZhY2Vbal1dLnZzdWIodmVydGljZXNbZmFjZVtrXV0sIGVkZ2UpO1xuICAgICAgICBlZGdlLm5vcm1hbGl6ZSgpO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICBpZiAoZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpIHx8IGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCByZXVzZSBleGlzdGluZyBWZWMzIG9iamVjdHMgaW4gdGhlIC5mYWNlTm9ybWFscyBhcnJheSBpZiB0aGV5IGV4aXN0LlxyXG4gICAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcclxuICAgKi9cblxuXG4gIGNvbXB1dGVOb3JtYWxzKCkge1xuICAgIHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID0gdGhpcy5mYWNlcy5sZW5ndGg7IC8vIEdlbmVyYXRlIG5vcm1hbHNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQ2hlY2sgc28gYWxsIHZlcnRpY2VzIGV4aXN0cyBmb3IgdGhpcyBmYWNlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVydGV4IFwiICsgdGhpcy5mYWNlc1tpXVtqXSArIFwiIG5vdCBmb3VuZCFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbiA9IHRoaXMuZmFjZU5vcm1hbHNbaV0gfHwgbmV3IFZlYzMoKTtcbiAgICAgIHRoaXMuZ2V0RmFjZU5vcm1hbChpLCBuKTtcbiAgICAgIG4ubmVnYXRlKG4pO1xuICAgICAgdGhpcy5mYWNlTm9ybWFsc1tpXSA9IG47XG4gICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bMF1dO1xuXG4gICAgICBpZiAobi5kb3QodmVydGV4KSA8IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIi5mYWNlTm9ybWFsc1tcIiArIGkgKyBcIl0gPSBWZWMzKFwiICsgbi50b1N0cmluZygpICsgXCIpIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuXCIpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIi52ZXJ0aWNlc1tcIiArIHRoaXMuZmFjZXNbaV1bal0gKyBcIl0gPSBWZWMzKFwiICsgdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2ldW2pdXS50b1N0cmluZygpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGUgdGhlIG5vcm1hbCBvZiBhIGZhY2UgZnJvbSBpdHMgdmVydGljZXNcclxuICAgKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcclxuICAgKi9cblxuXG4gIGdldEZhY2VOb3JtYWwoaSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZiA9IHRoaXMuZmFjZXNbaV07XG4gICAgY29uc3QgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xuICAgIGNvbnN0IHZiID0gdGhpcy52ZXJ0aWNlc1tmWzFdXTtcbiAgICBjb25zdCB2YyA9IHRoaXMudmVydGljZXNbZlsyXV07XG4gICAgQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLCB2YiwgdmMsIHRhcmdldCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBjbGlwQWdhaW5zdEh1bGxcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHBvc0FcclxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXHJcbiAgICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxyXG4gICAqIEBwYXJhbSB7VmVjM30gcG9zQlxyXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEaXN0XHJcbiAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IFRoZSBhbiBhcnJheSBvZiBjb250YWN0IHBvaW50IG9iamVjdHMsIHNlZSBjbGlwRmFjZUFnYWluc3RIdWxsXHJcbiAgICovXG5cblxuICBjbGlwQWdhaW5zdEh1bGwocG9zQSwgcXVhdEEsIGh1bGxCLCBwb3NCLCBxdWF0Qiwgc2VwYXJhdGluZ05vcm1hbCwgbWluRGlzdCwgbWF4RGlzdCwgcmVzdWx0KSB7XG4gICAgY29uc3QgV29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIGxldCBjbG9zZXN0RmFjZUIgPSAtMTtcbiAgICBsZXQgZG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBodWxsQi5mYWNlcy5sZW5ndGg7IGZhY2UrKykge1xuICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7XG4gICAgICBxdWF0Qi52bXVsdChXb3JsZE5vcm1hbCwgV29ybGROb3JtYWwpO1xuICAgICAgY29uc3QgZCA9IFdvcmxkTm9ybWFsLmRvdChzZXBhcmF0aW5nTm9ybWFsKTtcblxuICAgICAgaWYgKGQgPiBkbWF4KSB7XG4gICAgICAgIGRtYXggPSBkO1xuICAgICAgICBjbG9zZXN0RmFjZUIgPSBmYWNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdvcmxkVmVydHNCMSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsQi5mYWNlc1tjbG9zZXN0RmFjZUJdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiID0gaHVsbEIudmVydGljZXNbaHVsbEIuZmFjZXNbY2xvc2VzdEZhY2VCXVtpXV07XG4gICAgICBjb25zdCB3b3JsZGIgPSBuZXcgVmVjMygpO1xuICAgICAgd29ybGRiLmNvcHkoYik7XG4gICAgICBxdWF0Qi52bXVsdCh3b3JsZGIsIHdvcmxkYik7XG4gICAgICBwb3NCLnZhZGQod29ybGRiLCB3b3JsZGIpO1xuICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VzdEZhY2VCID49IDApIHtcbiAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0SHVsbChzZXBhcmF0aW5nTm9ybWFsLCBwb3NBLCBxdWF0QSwgd29ybGRWZXJ0c0IxLCBtaW5EaXN0LCBtYXhEaXN0LCByZXN1bHQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBGaW5kIHRoZSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGlzIGh1bGwgYW5kIGFub3RoZXJcclxuICAgKiBAbWV0aG9kIGZpbmRTZXBhcmF0aW5nQXhpc1xyXG4gICAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHBvc0FcclxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwb3NCXHJcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB0YXJnZXQgdmVjdG9yIHRvIHNhdmUgdGhlIGF4aXMgaW5cclxuICAgKiBAcmV0dXJuIHtib29sfSBSZXR1cm5zIGZhbHNlIGlmIGEgc2VwYXJhdGlvbiBpcyBmb3VuZCwgZWxzZSB0cnVlXHJcbiAgICovXG5cblxuICBmaW5kU2VwYXJhdGluZ0F4aXMoaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0QiwgdGFyZ2V0LCBmYWNlTGlzdEEsIGZhY2VMaXN0Qikge1xuICAgIGNvbnN0IGZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBXb3JsZG5vcm1hbDEgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IGRlbHRhQyA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3Qgd29ybGRFZGdlMCA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3Qgd29ybGRFZGdlMSA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgQ3Jvc3MgPSBuZXcgVmVjMygpO1xuICAgIGxldCBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBjb25zdCBodWxsQSA9IHRoaXM7XG5cbiAgICBpZiAoIWh1bGxBLnVuaXF1ZUF4ZXMpIHtcbiAgICAgIGNvbnN0IG51bUZhY2VzQSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QS5sZW5ndGggOiBodWxsQS5mYWNlcy5sZW5ndGg7IC8vIFRlc3QgZmFjZSBub3JtYWxzIGZyb20gaHVsbEFcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GYWNlc0E7IGkrKykge1xuICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QVtpXSA6IGk7IC8vIEdldCB3b3JsZCBmYWNlIG5vcm1hbFxuXG4gICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgcXVhdEEudm11bHQoZmFjZUFOb3JtYWxXUzMsIGZhY2VBTm9ybWFsV1MzKTtcbiAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcblxuICAgICAgICBpZiAoZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZCA8IGRtaW4pIHtcbiAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGh1bGxBLnVuaXF1ZUF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXNcbiAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlQXhlc1tpXSwgZmFjZUFOb3JtYWxXUzMpO1xuICAgICAgICBjb25zdCBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuXG4gICAgICAgIGlmIChkID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkIDwgZG1pbikge1xuICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaHVsbEIudW5pcXVlQXhlcykge1xuICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQlxuICAgICAgY29uc3QgbnVtRmFjZXNCID0gZmFjZUxpc3RCID8gZmFjZUxpc3RCLmxlbmd0aCA6IGh1bGxCLmZhY2VzLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GYWNlc0I7IGkrKykge1xuICAgICAgICBjb25zdCBmaSA9IGZhY2VMaXN0QiA/IGZhY2VMaXN0QltpXSA6IGk7XG4gICAgICAgIFdvcmxkbm9ybWFsMS5jb3B5KGh1bGxCLmZhY2VOb3JtYWxzW2ZpXSk7XG4gICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkbm9ybWFsMSwgV29ybGRub3JtYWwxKTtcbiAgICAgICAgY29uc3QgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG5cbiAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQgPCBkbWluKSB7XG4gICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgdGFyZ2V0LmNvcHkoV29ybGRub3JtYWwxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUZXN0IHVuaXF1ZSBheGVzIGluIEJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUF4ZXNbaV0sIFdvcmxkbm9ybWFsMSk7XG4gICAgICAgIGNvbnN0IGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuXG4gICAgICAgIGlmIChkID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkIDwgZG1pbikge1xuICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFRlc3QgZWRnZXNcblxuXG4gICAgZm9yIChsZXQgZTAgPSAwOyBlMCAhPT0gaHVsbEEudW5pcXVlRWRnZXMubGVuZ3RoOyBlMCsrKSB7XG4gICAgICAvLyBHZXQgd29ybGQgZWRnZVxuICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlRWRnZXNbZTBdLCB3b3JsZEVkZ2UwKTtcblxuICAgICAgZm9yIChsZXQgZTEgPSAwOyBlMSAhPT0gaHVsbEIudW5pcXVlRWRnZXMubGVuZ3RoOyBlMSsrKSB7XG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlIDJcbiAgICAgICAgcXVhdEIudm11bHQoaHVsbEIudW5pcXVlRWRnZXNbZTFdLCB3b3JsZEVkZ2UxKTtcbiAgICAgICAgd29ybGRFZGdlMC5jcm9zcyh3b3JsZEVkZ2UxLCBDcm9zcyk7XG5cbiAgICAgICAgaWYgKCFDcm9zcy5hbG1vc3RaZXJvKCkpIHtcbiAgICAgICAgICBDcm9zcy5ub3JtYWxpemUoKTtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gaHVsbEEudGVzdFNlcEF4aXMoQ3Jvc3MsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpc3QgPCBkbWluKSB7XG4gICAgICAgICAgICBkbWluID0gZGlzdDtcbiAgICAgICAgICAgIHRhcmdldC5jb3B5KENyb3NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3NCLnZzdWIocG9zQSwgZGVsdGFDKTtcblxuICAgIGlmIChkZWx0YUMuZG90KHRhcmdldCkgPiAwLjApIHtcbiAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBUZXN0IHNlcGFyYXRpbmcgYXhpcyBhZ2FpbnN0IHR3byBodWxscy4gQm90aCBodWxscyBhcmUgcHJvamVjdGVkIG9udG8gdGhlIGF4aXMgYW5kIHRoZSBvdmVybGFwIHNpemUgaXMgcmV0dXJuZWQgaWYgdGhlcmUgaXMgb25lLlxyXG4gICAqIEBtZXRob2QgdGVzdFNlcEF4aXNcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGF4aXNcclxuICAgKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxCXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxyXG4gICAqIEBwYXJhbSB7VmVjM30gcG9zQlxyXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi5cclxuICAgKi9cblxuXG4gIHRlc3RTZXBBeGlzKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpIHtcbiAgICBjb25zdCBodWxsQSA9IHRoaXM7XG4gICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxBLCBheGlzLCBwb3NBLCBxdWF0QSwgbWF4bWluQSk7XG4gICAgQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0KGh1bGxCLCBheGlzLCBwb3NCLCBxdWF0QiwgbWF4bWluQik7XG4gICAgY29uc3QgbWF4QSA9IG1heG1pbkFbMF07XG4gICAgY29uc3QgbWluQSA9IG1heG1pbkFbMV07XG4gICAgY29uc3QgbWF4QiA9IG1heG1pbkJbMF07XG4gICAgY29uc3QgbWluQiA9IG1heG1pbkJbMV07XG5cbiAgICBpZiAobWF4QSA8IG1pbkIgfHwgbWF4QiA8IG1pbkEpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gU2VwYXJhdGVkXG4gICAgfVxuXG4gICAgY29uc3QgZDAgPSBtYXhBIC0gbWluQjtcbiAgICBjb25zdCBkMSA9IG1heEIgLSBtaW5BO1xuICAgIGNvbnN0IGRlcHRoID0gZDAgPCBkMSA/IGQwIDogZDE7XG4gICAgcmV0dXJuIGRlcHRoO1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAgICovXG5cblxuICBjYWxjdWxhdGVMb2NhbEluZXJ0aWEobWFzcywgdGFyZ2V0KSB7XG4gICAgLy8gQXBwcm94aW1hdGUgd2l0aCBib3ggaW5lcnRpYVxuICAgIC8vIEV4YWN0IGluZXJ0aWEgY2FsY3VsYXRpb24gaXMgb3ZlcmtpbGwsIGJ1dCBzZWUgaHR0cDovL2dlb21ldHJpY3Rvb2xzLmNvbS9Eb2N1bWVudGF0aW9uL1BvbHloZWRyYWxNYXNzUHJvcGVydGllcy5wZGYgZm9yIHRoZSBjb3JyZWN0IHdheSB0byBkbyBpdFxuICAgIGNvbnN0IGFhYmJtYXggPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IGFhYmJtaW4gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQihhYWJibWluLCBhYWJibWF4KTtcbiAgICBjb25zdCB4ID0gYWFiYm1heC54IC0gYWFiYm1pbi54O1xuICAgIGNvbnN0IHkgPSBhYWJibWF4LnkgLSBhYWJibWluLnk7XG4gICAgY29uc3QgeiA9IGFhYmJtYXgueiAtIGFhYmJtaW4uejtcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeiAqIDIgKiB6KTtcbiAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB4ICogMiAqIHggKyAyICogeiAqIDIgKiB6KTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeCAqIDIgKiB4KTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIGdldFBsYW5lQ29uc3RhbnRPZkZhY2VcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZhY2VfaSBJbmRleCBvZiB0aGUgZmFjZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGdldFBsYW5lQ29uc3RhbnRPZkZhY2UoZmFjZV9pKSB7XG4gICAgY29uc3QgZiA9IHRoaXMuZmFjZXNbZmFjZV9pXTtcbiAgICBjb25zdCBuID0gdGhpcy5mYWNlTm9ybWFsc1tmYWNlX2ldO1xuICAgIGNvbnN0IHYgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xuICAgIGNvbnN0IGMgPSAtbi5kb3Qodik7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuXHJcbiAgICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RIdWxsXHJcbiAgICogQHBhcmFtIHtWZWMzfSBzZXBhcmF0aW5nTm9ybWFsXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwb3NBXHJcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkVmVydHNCMSBBbiBhcnJheSBvZiBWZWMzIHdpdGggdmVydGljZXMgaW4gdGhlIHdvcmxkIGZyYW1lLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IERpc3RhbmNlIGNsYW1waW5nXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcclxuICAgKiBAcGFyYW0gQXJyYXkgcmVzdWx0IEFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBjb250YWN0IHBvaW50cyBpbi4gV2lsbCBiZSBvYmplY3RzIHdpdGggcHJvcGVydGllczogcG9pbnQsIGRlcHRoLCBub3JtYWwuIFRoZXNlIGFyZSByZXByZXNlbnRlZCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgKi9cblxuXG4gIGNsaXBGYWNlQWdhaW5zdEh1bGwoc2VwYXJhdGluZ05vcm1hbCwgcG9zQSwgcXVhdEEsIHdvcmxkVmVydHNCMSwgbWluRGlzdCwgbWF4RGlzdCwgcmVzdWx0KSB7XG4gICAgY29uc3QgZmFjZUFOb3JtYWxXUyA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgZWRnZTAgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IFdvcmxkRWRnZTAgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IHdvcmxkUGxhbmVBbm9ybWFsMSA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgcGxhbmVOb3JtYWxXUzEgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IHdvcmxkQTEgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IGxvY2FsUGxhbmVOb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IHBsYW5lTm9ybWFsV1MgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IGh1bGxBID0gdGhpcztcbiAgICBjb25zdCB3b3JsZFZlcnRzQjIgPSBbXTtcbiAgICBjb25zdCBwVnR4SW4gPSB3b3JsZFZlcnRzQjE7XG4gICAgY29uc3QgcFZ0eE91dCA9IHdvcmxkVmVydHNCMjtcbiAgICBsZXQgY2xvc2VzdEZhY2VBID0gLTE7XG4gICAgbGV0IGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBGaW5kIHRoZSBmYWNlIHdpdGggbm9ybWFsIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuXG4gICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBodWxsQS5mYWNlcy5sZW5ndGg7IGZhY2UrKykge1xuICAgICAgZmFjZUFOb3JtYWxXUy5jb3B5KGh1bGxBLmZhY2VOb3JtYWxzW2ZhY2VdKTtcbiAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MsIGZhY2VBTm9ybWFsV1MpO1xuICAgICAgY29uc3QgZCA9IGZhY2VBTm9ybWFsV1MuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xuXG4gICAgICBpZiAoZCA8IGRtaW4pIHtcbiAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgIGNsb3Nlc3RGYWNlQSA9IGZhY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsb3Nlc3RGYWNlQSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCB0aGUgZmFjZSBhbmQgY29uc3RydWN0IGNvbm5lY3RlZCBmYWNlc1xuXG5cbiAgICBjb25zdCBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07XG4gICAgcG9seUEuY29ubmVjdGVkRmFjZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbEEuZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAvKiBTaGFyaW5nIGEgdmVydGV4Ki9cbiAgICAgICAgcG9seUEuaW5kZXhPZihodWxsQS5mYWNlc1tpXVtqXSkgIT09IC0xICYmXG4gICAgICAgIC8qIE5vdCB0aGUgb25lIHdlIGFyZSBsb29raW5nIGZvciBjb25uZWN0aW9ucyBmcm9tICovXG4gICAgICAgIGkgIT09IGNsb3Nlc3RGYWNlQSAmJlxuICAgICAgICAvKiBOb3QgYWxyZWFkeSBhZGRlZCAqL1xuICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENsaXAgdGhlIHBvbHlnb24gdG8gdGhlIGJhY2sgb2YgdGhlIHBsYW5lcyBvZiBhbGwgZmFjZXMgb2YgaHVsbCBBLFxuICAgIC8vIHRoYXQgYXJlIGFkamFjZW50IHRvIHRoZSB3aXRuZXNzIGZhY2VcblxuXG4gICAgY29uc3QgbnVtVmVydGljZXNBID0gcG9seUEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlc0E7IGkrKykge1xuICAgICAgY29uc3QgYSA9IGh1bGxBLnZlcnRpY2VzW3BvbHlBW2ldXTtcbiAgICAgIGNvbnN0IGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoaSArIDEpICUgbnVtVmVydGljZXNBXV07XG4gICAgICBhLnZzdWIoYiwgZWRnZTApO1xuICAgICAgV29ybGRFZGdlMC5jb3B5KGVkZ2UwKTtcbiAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApO1xuICAgICAgcG9zQS52YWRkKFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApO1xuICAgICAgd29ybGRQbGFuZUFub3JtYWwxLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tjbG9zZXN0RmFjZUFdKTtcbiAgICAgIHF1YXRBLnZtdWx0KHdvcmxkUGxhbmVBbm9ybWFsMSwgd29ybGRQbGFuZUFub3JtYWwxKTtcbiAgICAgIHBvc0EudmFkZCh3b3JsZFBsYW5lQW5vcm1hbDEsIHdvcmxkUGxhbmVBbm9ybWFsMSk7XG4gICAgICBXb3JsZEVkZ2UwLmNyb3NzKHdvcmxkUGxhbmVBbm9ybWFsMSwgcGxhbmVOb3JtYWxXUzEpO1xuICAgICAgcGxhbmVOb3JtYWxXUzEubmVnYXRlKHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgIHdvcmxkQTEuY29weShhKTtcbiAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsIHdvcmxkQTEpO1xuICAgICAgcG9zQS52YWRkKHdvcmxkQTEsIHdvcmxkQTEpO1xuICAgICAgY29uc3Qgb3RoZXJGYWNlID0gcG9seUEuY29ubmVjdGVkRmFjZXNbaV07XG4gICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tvdGhlckZhY2VdKTtcbiAgICAgIGNvbnN0IGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpO1xuICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7XG4gICAgICBjb25zdCBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTsgLy8gQ2xpcCBmYWNlIGFnYWluc3Qgb3VyIGNvbnN0cnVjdGVkIHBsYW5lXG5cbiAgICAgIHRoaXMuY2xpcEZhY2VBZ2FpbnN0UGxhbmUocFZ0eEluLCBwVnR4T3V0LCBwbGFuZU5vcm1hbFdTLCBwbGFuZUVxV1MpOyAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlbWFpbmluZyB1bnRpbCBuZXh0IGNsaXBcblxuICAgICAgd2hpbGUgKHBWdHhJbi5sZW5ndGgpIHtcbiAgICAgICAgcFZ0eEluLnNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwVnR4T3V0Lmxlbmd0aCkge1xuICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH0gLy8gb25seSBrZWVwIGNvbnRhY3QgcG9pbnRzIHRoYXQgYXJlIGJlaGluZCB0aGUgd2l0bmVzcyBmYWNlXG5cblxuICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pO1xuICAgIGNvbnN0IGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShjbG9zZXN0RmFjZUEpO1xuICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTtcbiAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLCBwbGFuZU5vcm1hbFdTKTtcbiAgICBjb25zdCBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcFZ0eEluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLyA/Pz9cblxuICAgICAgaWYgKGRlcHRoIDw9IG1pbkRpc3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjbGFtcGVkOiBkZXB0aD1cIiArIGRlcHRoICsgXCIgdG8gbWluRGlzdD1cIiArIG1pbkRpc3QpO1xuICAgICAgICBkZXB0aCA9IG1pbkRpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXB0aCA8PSBtYXhEaXN0KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcFZ0eEluW2ldO1xuXG4gICAgICAgIGlmIChkZXB0aCA8PSAxZS02KSB7XG4gICAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgbm9ybWFsOiBwbGFuZU5vcm1hbFdTLFxuICAgICAgICAgICAgZGVwdGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENsaXAgYSBmYWNlIGluIGEgaHVsbCBhZ2FpbnN0IHRoZSBiYWNrIG9mIGEgcGxhbmUuXHJcbiAgICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RQbGFuZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGluVmVydGljZXNcclxuICAgKiBAcGFyYW0ge0FycmF5fSBvdXRWZXJ0aWNlc1xyXG4gICAqIEBwYXJhbSB7VmVjM30gcGxhbmVOb3JtYWxcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcGxhbmVDb25zdGFudCBUaGUgY29uc3RhbnQgaW4gdGhlIG1hdGhlbWF0aWNhbCBwbGFuZSBlcXVhdGlvblxyXG4gICAqL1xuXG5cbiAgY2xpcEZhY2VBZ2FpbnN0UGxhbmUoaW5WZXJ0aWNlcywgb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KSB7XG4gICAgbGV0IG5fZG90X2ZpcnN0O1xuICAgIGxldCBuX2RvdF9sYXN0O1xuICAgIGNvbnN0IG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBpZiAobnVtVmVydHMgPCAyKSB7XG4gICAgICByZXR1cm4gb3V0VmVydGljZXM7XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0VmVydGV4ID0gaW5WZXJ0aWNlc1tpblZlcnRpY2VzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1swXTtcbiAgICBuX2RvdF9maXJzdCA9IHBsYW5lTm9ybWFsLmRvdChmaXJzdFZlcnRleCkgKyBwbGFuZUNvbnN0YW50O1xuXG4gICAgZm9yIChsZXQgdmkgPSAwOyB2aSA8IG51bVZlcnRzOyB2aSsrKSB7XG4gICAgICBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1t2aV07XG4gICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcblxuICAgICAgaWYgKG5fZG90X2ZpcnN0IDwgMCkge1xuICAgICAgICBpZiAobl9kb3RfbGFzdCA8IDApIHtcbiAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA8IDAsIHNvIG91dHB1dCBsYXN0VmVydGV4XG4gICAgICAgICAgY29uc3QgbmV3diA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgbmV3di5jb3B5KGxhc3RWZXJ0ZXgpO1xuICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPj0gMCwgc28gb3V0cHV0IGludGVyc2VjdGlvblxuICAgICAgICAgIGNvbnN0IG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCwgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSwgbmV3dik7XG4gICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5fZG90X2xhc3QgPCAwKSB7XG4gICAgICAgICAgLy8gU3RhcnQgPj0gMCwgZW5kIDwgMCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uIGFuZCBlbmRcbiAgICAgICAgICBjb25zdCBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksIG5ld3YpO1xuICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XG4gICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaXJzdFZlcnRleCA9IGxhc3RWZXJ0ZXg7XG4gICAgICBuX2RvdF9maXJzdCA9IG5fZG90X2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFZlcnRpY2VzO1xuICB9IC8vIFVwZGF0ZXMgLndvcmxkVmVydGljZXMgYW5kIHNldHMgLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSB0byBmYWxzZS5cblxuXG4gIGNvbXB1dGVXb3JsZFZlcnRpY2VzKHBvc2l0aW9uLCBxdWF0KSB7XG4gICAgd2hpbGUgKHRoaXMud29ybGRWZXJ0aWNlcy5sZW5ndGggPCB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2gobmV3IFZlYzMoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGNvbnN0IHdvcmxkVmVydHMgPSB0aGlzLndvcmxkVmVydGljZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcXVhdC52bXVsdCh2ZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7XG4gICAgICBwb3NpdGlvbi52YWRkKHdvcmxkVmVydHNbaV0sIHdvcmxkVmVydHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICBjb21wdXRlTG9jYWxBQUJCKGFhYmJtaW4sIGFhYmJtYXgpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgYWFiYm1pbi5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgaWYgKHYueCA8IGFhYmJtaW4ueCkge1xuICAgICAgICBhYWJibWluLnggPSB2Lng7XG4gICAgICB9IGVsc2UgaWYgKHYueCA+IGFhYmJtYXgueCkge1xuICAgICAgICBhYWJibWF4LnggPSB2Lng7XG4gICAgICB9XG5cbiAgICAgIGlmICh2LnkgPCBhYWJibWluLnkpIHtcbiAgICAgICAgYWFiYm1pbi55ID0gdi55O1xuICAgICAgfSBlbHNlIGlmICh2LnkgPiBhYWJibWF4LnkpIHtcbiAgICAgICAgYWFiYm1heC55ID0gdi55O1xuICAgICAgfVxuXG4gICAgICBpZiAodi56IDwgYWFiYm1pbi56KSB7XG4gICAgICAgIGFhYmJtaW4ueiA9IHYuejtcbiAgICAgIH0gZWxzZSBpZiAodi56ID4gYWFiYm1heC56KSB7XG4gICAgICAgIGFhYmJtYXgueiA9IHYuejtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxyXG4gICAqIEBtZXRob2QgY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHNcclxuICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAgICovXG5cblxuICBjb21wdXRlV29ybGRGYWNlTm9ybWFscyhxdWF0KSB7XG4gICAgY29uc3QgTiA9IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKHRoaXMud29ybGRGYWNlTm9ybWFscy5sZW5ndGggPCBOKSB7XG4gICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaChuZXcgVmVjMygpKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxzID0gdGhpcy5mYWNlTm9ybWFscztcbiAgICBjb25zdCB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICBxdWF0LnZtdWx0KG5vcm1hbHNbaV0sIHdvcmxkTm9ybWFsc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXHJcbiAgICovXG5cblxuICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHtcbiAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgbGV0IG1heDIgPSAwO1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2ZXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybTIgPSB2ZXJ0c1tpXS5sZW5ndGhTcXVhcmVkKCk7XG5cbiAgICAgIGlmIChub3JtMiA+IG1heDIpIHtcbiAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBjYWxjdWxhdGVXb3JsZEFBQkJcclxuICAgKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcclxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XHJcbiAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWluXHJcbiAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XHJcbiAgICovXG5cblxuICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBsZXQgbWlueDtcbiAgICBsZXQgbWlueTtcbiAgICBsZXQgbWluejtcbiAgICBsZXQgbWF4eDtcbiAgICBsZXQgbWF4eTtcbiAgICBsZXQgbWF4ejtcbiAgICBsZXQgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcbiAgICAgIHF1YXQudm11bHQodGVtcFdvcmxkVmVydGV4LCB0ZW1wV29ybGRWZXJ0ZXgpO1xuICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LCB0ZW1wV29ybGRWZXJ0ZXgpO1xuICAgICAgY29uc3QgdiA9IHRlbXBXb3JsZFZlcnRleDtcblxuICAgICAgaWYgKG1pbnggPT09IHVuZGVmaW5lZCB8fCB2LnggPCBtaW54KSB7XG4gICAgICAgIG1pbnggPSB2Lng7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXh4ID09PSB1bmRlZmluZWQgfHwgdi54ID4gbWF4eCkge1xuICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgfVxuXG4gICAgICBpZiAobWlueSA9PT0gdW5kZWZpbmVkIHx8IHYueSA8IG1pbnkpIHtcbiAgICAgICAgbWlueSA9IHYueTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heHkgPT09IHVuZGVmaW5lZCB8fCB2LnkgPiBtYXh5KSB7XG4gICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW56ID09PSB1bmRlZmluZWQgfHwgdi56IDwgbWlueikge1xuICAgICAgICBtaW56ID0gdi56O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4eiA9PT0gdW5kZWZpbmVkIHx8IHYueiA+IG1heHopIHtcbiAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4uc2V0KG1pbngsIG1pbnksIG1pbnopO1xuICAgIG1heC5zZXQobWF4eCwgbWF4eSwgbWF4eik7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFwcHJveGltYXRlIGNvbnZleCB2b2x1bWVcclxuICAgKiBAbWV0aG9kIHZvbHVtZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIHZvbHVtZSgpIHtcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFuIGF2ZXJhZ2Ugb2YgYWxsIHRoZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcclxuICAgKiBAbWV0aG9kIGdldEF2ZXJhZ2VQb2ludExvY2FsXHJcbiAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIGdldEF2ZXJhZ2VQb2ludExvY2FsKHRhcmdldCA9IG5ldyBWZWMzKCkpIHtcbiAgICBjb25zdCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0YXJnZXQuc2NhbGUoMSAvIHZlcnRzLmxlbmd0aCwgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzXHJcbiAgICogQG1ldGhvZCB0cmFuc2Zvcm1BbGxQb2ludHNcclxuICAgKiBAcGFyYW0gIHtWZWMzfSBvZmZzZXRcclxuICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAgICovXG5cblxuICB0cmFuc2Zvcm1BbGxQb2ludHMob2Zmc2V0LCBxdWF0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy52ZXJ0aWNlczsgLy8gQXBwbHkgcm90YXRpb25cblxuICAgIGlmIChxdWF0KSB7XG4gICAgICAvLyBSb3RhdGUgdmVydGljZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgIH0gLy8gUm90YXRlIGZhY2Ugbm9ybWFsc1xuXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5mYWNlTm9ybWFsc1tpXTtcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgIH1cbiAgICAgIC8qXHJcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBlZGdlc1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnVuaXF1ZUVkZ2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xyXG4gICAgICAgICAgICB9Ki9cblxuICAgIH0gLy8gQXBwbHkgb2Zmc2V0XG5cblxuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgdi52YWRkKG9mZnNldCwgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHAgaXMgaW5zaWRlIHRoZSBwb2x5aGVkcmEuIE11c3QgYmUgaW4gbG9jYWwgY29vcmRzLlxyXG4gICAqIFRoZSBwb2ludCBsaWVzIG91dHNpZGUgb2YgdGhlIGNvbnZleCBodWxsIG9mIHRoZSBvdGhlciBwb2ludHMgaWYgYW5kIG9ubHkgaWYgdGhlIGRpcmVjdGlvblxyXG4gICAqIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC5cclxuICAgKiBAbWV0aG9kIHBvaW50SXNJbnNpZGVcclxuICAgKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXG5cblxuICBwb2ludElzSW5zaWRlKHApIHtcbiAgICBjb25zdCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3QgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzO1xuICAgIGNvbnN0IHBvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKHBvaW50SW5zaWRlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBub3JtYWxzW2ldO1xuICAgICAgY29uc3QgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZVxuICAgICAgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXG5cbiAgICAgIGNvbnN0IHZUb1AgPSBuZXcgVmVjMygpO1xuICAgICAgcC52c3ViKHYsIHZUb1ApO1xuICAgICAgY29uc3QgcjEgPSBuLmRvdCh2VG9QKTtcbiAgICAgIGNvbnN0IHZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbiAgICAgIHBvaW50SW5zaWRlLnZzdWIodiwgdlRvUG9pbnRJbnNpZGUpO1xuICAgICAgY29uc3QgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7XG5cbiAgICAgIGlmIChyMSA8IDAgJiYgcjIgPiAwIHx8IHIxID4gMCAmJiByMiA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFbmNvdW50ZXJlZCBzb21lIG90aGVyIHNpZ24uIEV4aXQuXG4gICAgICB9XG4gICAgfSAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXG5cblxuICAgIHJldHVybiAgLTE7XG4gIH1cblxufVxuLyoqXHJcbiAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjb21wdXRlTm9ybWFsXHJcbiAqIEBwYXJhbSB7VmVjM30gdmFcclxuICogQHBhcmFtIHtWZWMzfSB2YlxyXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXHJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XHJcbiAqL1xuXG5Db252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwgPSAodmEsIHZiLCB2YywgdGFyZ2V0KSA9PiB7XG4gIGNvbnN0IGNiID0gbmV3IFZlYzMoKTtcbiAgY29uc3QgYWIgPSBuZXcgVmVjMygpO1xuICB2Yi52c3ViKHZhLCBhYik7XG4gIHZjLnZzdWIodmIsIGNiKTtcbiAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7XG5cbiAgaWYgKCF0YXJnZXQuaXNaZXJvKCkpIHtcbiAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gIH1cbn07XG5cbmNvbnN0IG1heG1pbkEgPSBbXTtcbmNvbnN0IG1heG1pbkIgPSBbXTtcbi8qKlxyXG4gKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuXHJcbiAqIFJlc3VsdHMgYXJlIHNhdmVkIGluIHRoZSBhcnJheSBtYXhtaW4uXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwcm9qZWN0XHJcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbFxyXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcclxuICogQHBhcmFtIHtWZWMzfSBwb3NcclxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XHJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuXHJcbiAqL1xuXG5Db252ZXhQb2x5aGVkcm9uLnByb2plY3QgPSAoc2hhcGUsIGF4aXMsIHBvcywgcXVhdCwgcmVzdWx0KSA9PiB7XG4gIGNvbnN0IG4gPSBzaGFwZS52ZXJ0aWNlcy5sZW5ndGg7XG4gIGNvbnN0IGxvY2FsQXhpcyA9IG5ldyBWZWMzKCk7XG4gIGxldCBtYXggPSAwO1xuICBsZXQgbWluID0gMDtcbiAgY29uc3QgbG9jYWxPcmlnaW4gPSBuZXcgVmVjMygpO1xuICBjb25zdCB2cyA9IHNoYXBlLnZlcnRpY2VzO1xuICBsb2NhbE9yaWdpbi5zZXRaZXJvKCk7IC8vIFRyYW5zZm9ybSB0aGUgYXhpcyB0byBsb2NhbFxuXG4gIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBheGlzLCBsb2NhbEF4aXMpO1xuICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pO1xuICBjb25zdCBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTtcbiAgbWluID0gbWF4ID0gdnNbMF0uZG90KGxvY2FsQXhpcyk7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBjb25zdCB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcblxuICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgIG1heCA9IHZhbDtcbiAgICB9XG5cbiAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICBtaW4gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgbWluIC09IGFkZDtcbiAgbWF4IC09IGFkZDtcblxuICBpZiAobWluID4gbWF4KSB7XG4gICAgLy8gSW5jb25zaXN0ZW50IC0gc3dhcFxuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH0gLy8gT3V0cHV0XG5cblxuICByZXN1bHRbMF0gPSBtYXg7XG4gIHJlc3VsdFsxXSA9IG1pbjtcbn07XG5cbi8qKlxuICogQSAzZCBib3ggc2hhcGUuXG4gKiBAY2xhc3MgQm94XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VmVjM30gaGFsZkV4dGVudHNcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmNsYXNzIEJveCBleHRlbmRzIFNoYXBlIHtcbiAgLy8gVXNlZCBieSB0aGUgY29udGFjdCBnZW5lcmF0b3IgdG8gbWFrZSBjb250YWN0cyB3aXRoIG90aGVyIGNvbnZleCBwb2x5aGVkcmEgZm9yIGV4YW1wbGUuXG4gIGNvbnN0cnVjdG9yKGhhbGZFeHRlbnRzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogU2hhcGUudHlwZXMuQk9YXG4gICAgfSk7XG4gICAgdGhpcy5oYWxmRXh0ZW50cyA9IGhhbGZFeHRlbnRzO1xuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbigpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgY29udmV4IHBvbHloZWRyb24gcmVwcmVzZW50YXRpb24gdXNlZCBmb3Igc29tZSBjb2xsaXNpb25zLlxuICAgKiBAbWV0aG9kIHVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvblxuICAgKi9cblxuXG4gIHVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbigpIHtcbiAgICBjb25zdCBzeCA9IHRoaXMuaGFsZkV4dGVudHMueDtcbiAgICBjb25zdCBzeSA9IHRoaXMuaGFsZkV4dGVudHMueTtcbiAgICBjb25zdCBzeiA9IHRoaXMuaGFsZkV4dGVudHMuejtcbiAgICBjb25zdCBWID0gVmVjMztcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtuZXcgVigtc3gsIC1zeSwgLXN6KSwgbmV3IFYoc3gsIC1zeSwgLXN6KSwgbmV3IFYoc3gsIHN5LCAtc3opLCBuZXcgVigtc3gsIHN5LCAtc3opLCBuZXcgVigtc3gsIC1zeSwgc3opLCBuZXcgVihzeCwgLXN5LCBzeiksIG5ldyBWKHN4LCBzeSwgc3opLCBuZXcgVigtc3gsIHN5LCBzeildO1xuICAgIGNvbnN0IGZhY2VzID0gW1szLCAyLCAxLCAwXSwgLy8gLXpcbiAgICBbNCwgNSwgNiwgN10sIC8vICt6XG4gICAgWzUsIDQsIDAsIDFdLCAvLyAteVxuICAgIFsyLCAzLCA3LCA2XSwgLy8gK3lcbiAgICBbMCwgNCwgNywgM10sIC8vIC14XG4gICAgWzEsIDIsIDYsIDVdIC8vICt4XG4gICAgXTtcbiAgICBjb25zdCBheGVzID0gW25ldyBWKDAsIDAsIDEpLCBuZXcgVigwLCAxLCAwKSwgbmV3IFYoMSwgMCwgMCldO1xuICAgIGNvbnN0IGggPSBuZXcgQ29udmV4UG9seWhlZHJvbih7XG4gICAgICB2ZXJ0aWNlcyxcbiAgICAgIGZhY2VzLFxuICAgICAgYXhlc1xuICAgIH0pO1xuICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gaDtcbiAgICBoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gICAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgKi9cblxuXG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJveCA2IHNpZGUgbm9ybWFsc1xuICAgKiBAbWV0aG9kIGdldFNpZGVOb3JtYWxzXG4gICAqIEBwYXJhbSB7YXJyYXl9ICAgICAgc2l4VGFyZ2V0VmVjdG9ycyBBbiBhcnJheSBvZiA2IHZlY3RvcnMsIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBub3JtYWxzIGluLlxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXQgICAgICAgICAgICAgT3JpZW50YXRpb24gdG8gYXBwbHkgdG8gdGhlIG5vcm1hbCB2ZWN0b3JzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB2ZWN0b3JzIHdpbGwgYmUgaW4gcmVzcGVjdCB0byB0aGUgbG9jYWwgZnJhbWUuXG4gICAqIEByZXR1cm4ge2FycmF5fVxuICAgKi9cblxuXG4gIGdldFNpZGVOb3JtYWxzKHNpeFRhcmdldFZlY3RvcnMsIHF1YXQpIHtcbiAgICBjb25zdCBzaWRlcyA9IHNpeFRhcmdldFZlY3RvcnM7XG4gICAgY29uc3QgZXggPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIHNpZGVzWzBdLnNldChleC54LCAwLCAwKTtcbiAgICBzaWRlc1sxXS5zZXQoMCwgZXgueSwgMCk7XG4gICAgc2lkZXNbMl0uc2V0KDAsIDAsIGV4LnopO1xuICAgIHNpZGVzWzNdLnNldCgtZXgueCwgMCwgMCk7XG4gICAgc2lkZXNbNF0uc2V0KDAsIC1leC55LCAwKTtcbiAgICBzaWRlc1s1XS5zZXQoMCwgMCwgLWV4LnopO1xuXG4gICAgaWYgKHF1YXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHNpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1YXQudm11bHQoc2lkZXNbaV0sIHNpZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lkZXM7XG4gIH1cblxuICB2b2x1bWUoKSB7XG4gICAgcmV0dXJuIDguMCAqIHRoaXMuaGFsZkV4dGVudHMueCAqIHRoaXMuaGFsZkV4dGVudHMueSAqIHRoaXMuaGFsZkV4dGVudHMuejtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkge1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLmxlbmd0aCgpO1xuICB9XG5cbiAgZm9yRWFjaFdvcmxkQ29ybmVyKHBvcywgcXVhdCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICBjb25zdCBjb3JuZXJzID0gW1tlLngsIGUueSwgZS56XSwgWy1lLngsIGUueSwgZS56XSwgWy1lLngsIC1lLnksIGUuel0sIFstZS54LCAtZS55LCAtZS56XSwgW2UueCwgLWUueSwgLWUuel0sIFtlLngsIGUueSwgLWUuel0sIFstZS54LCBlLnksIC1lLnpdLCBbZS54LCAtZS55LCBlLnpdXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ybmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnNldChjb3JuZXJzW2ldWzBdLCBjb3JuZXJzW2ldWzFdLCBjb3JuZXJzW2ldWzJdKTtcbiAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgcG9zLnZhZGQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgY2FsbGJhY2sod29ybGRDb3JuZXJUZW1wUG9zLngsIHdvcmxkQ29ybmVyVGVtcFBvcy55LCB3b3JsZENvcm5lclRlbXBQb3Mueik7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICB3b3JsZENvcm5lcnNUZW1wWzBdLnNldChlLngsIGUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzFdLnNldCgtZS54LCBlLnksIGUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzNdLnNldCgtZS54LCAtZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzRdLnNldChlLngsIC1lLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzZdLnNldCgtZS54LCBlLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbN10uc2V0KGUueCwgLWUueSwgZS56KTtcbiAgICBjb25zdCB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07XG4gICAgcXVhdC52bXVsdCh3Yywgd2MpO1xuICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgbWF4LmNvcHkod2MpO1xuICAgIG1pbi5jb3B5KHdjKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICBjb25zdCB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbaV07XG4gICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgICBwb3MudmFkZCh3Yywgd2MpO1xuICAgICAgY29uc3QgeCA9IHdjLng7XG4gICAgICBjb25zdCB5ID0gd2MueTtcbiAgICAgIGNvbnN0IHogPSB3Yy56O1xuXG4gICAgICBpZiAoeCA+IG1heC54KSB7XG4gICAgICAgIG1heC54ID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPiBtYXgueSkge1xuICAgICAgICBtYXgueSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh6ID4gbWF4LnopIHtcbiAgICAgICAgbWF4LnogPSB6O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IG1pbi54KSB7XG4gICAgICAgIG1pbi54ID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCBtaW4ueSkge1xuICAgICAgICBtaW4ueSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh6IDwgbWluLnopIHtcbiAgICAgICAgbWluLnogPSB6O1xuICAgICAgfVxuICAgIH0gLy8gR2V0IGVhY2ggYXhpcyBtYXhcbiAgICAvLyBtaW4uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTtcbiAgICAvLyBtYXguc2V0KC1JbmZpbml0eSwtSW5maW5pdHksLUluZmluaXR5KTtcbiAgICAvLyB0aGlzLmZvckVhY2hXb3JsZENvcm5lcihwb3MscXVhdCxmdW5jdGlvbih4LHkseil7XG4gICAgLy8gICAgIGlmKHggPiBtYXgueCl7XG4gICAgLy8gICAgICAgICBtYXgueCA9IHg7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeSA+IG1heC55KXtcbiAgICAvLyAgICAgICAgIG1heC55ID0geTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih6ID4gbWF4Lnope1xuICAgIC8vICAgICAgICAgbWF4LnogPSB6O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHggPCBtaW4ueCl7XG4gICAgLy8gICAgICAgICBtaW4ueCA9IHg7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeSA8IG1pbi55KXtcbiAgICAvLyAgICAgICAgIG1pbi55ID0geTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih6IDwgbWluLnope1xuICAgIC8vICAgICAgICAgbWluLnogPSB6O1xuICAgIC8vICAgICB9XG4gICAgLy8gfSk7XG5cbiAgfVxuXG59XG5cbkJveC5jYWxjdWxhdGVJbmVydGlhID0gKGhhbGZFeHRlbnRzLCBtYXNzLCB0YXJnZXQpID0+IHtcbiAgY29uc3QgZSA9IGhhbGZFeHRlbnRzO1xuICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiBlLnkgKiAyICogZS55ICsgMiAqIGUueiAqIDIgKiBlLnopO1xuICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiBlLnggKiAyICogZS54ICsgMiAqIGUueiAqIDIgKiBlLnopO1xuICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiBlLnkgKiAyICogZS55ICsgMiAqIGUueCAqIDIgKiBlLngpO1xufTtcblxuY29uc3Qgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTtcbmNvbnN0IHdvcmxkQ29ybmVyc1RlbXAgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07XG5cbmNvbnN0IEJPRFlfVFlQRVMgPSB7XG4gIERZTkFNSUM6IDEsXG4gIFNUQVRJQzogMixcbiAgS0lORU1BVElDOiA0XG59O1xuY29uc3QgQk9EWV9TTEVFUF9TVEFURVMgPSB7XG4gIEFXQUtFOiAwLFxuICBTTEVFUFk6IDEsXG4gIFNMRUVQSU5HOiAyXG59O1xuXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXHJcbiAqIEBjbGFzcyBCb2R5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucG9zaXRpb25dXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5XVxyXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IFtvcHRpb25zLnF1YXRlcm5pb25dXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxyXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR5cGVdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjAxXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXA9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdD0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5saW5lYXJGYWN0b3JdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhckZhY3Rvcl1cclxuICogQHBhcmFtIHtTaGFwZX0gW29wdGlvbnMuc2hhcGVdXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBjb25zdCBib2R5ID0gbmV3IEJvZHkoe1xyXG4gKiAgICAgICAgIG1hc3M6IDFcclxuICogICAgIH0pO1xyXG4gKiAgICAgY29uc3Qgc2hhcGUgPSBuZXcgU3BoZXJlKDEpO1xyXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gKi9cbmNsYXNzIEJvZHkgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8vIFBvc2l0aW9uIG9mIGJvZHkgaW4gV29ybGQuYm9kaWVzLiBVcGRhdGVkIGJ5IFdvcmxkIGFuZCB1c2VkIGluIEFycmF5Q29sbGlzaW9uTWF0cml4LlxuICAvLyBSZWZlcmVuY2UgdG8gdGhlIHdvcmxkIHRoZSBib2R5IGlzIGxpdmluZyBpbi5cbiAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEJFRk9SRSBzdGVwcGluZyB0aGUgc3lzdGVtLiBVc2UgaXQgdG8gYXBwbHkgZm9yY2VzLCBmb3IgZXhhbXBsZS4gSW5zaWRlIHRoZSBmdW5jdGlvbiwgXCJ0aGlzXCIgd2lsbCByZWZlciB0byB0aGlzIEJvZHkgb2JqZWN0LiBEZXByZWNhdGVkIC0gdXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkLlxuICAvLyBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgQUZURVIgc3RlcHBpbmcgdGhlIHN5c3RlbS4gSW5zaWRlIHRoZSBmdW5jdGlvbiwgXCJ0aGlzXCIgd2lsbCByZWZlciB0byB0aGlzIEJvZHkgb2JqZWN0LiBEZXByZWNhdGVkIC0gdXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkLlxuICAvLyBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQgLSBpLmUuIFwiY29sbGlkZVwiIGV2ZW50cyB3aWxsIGJlIHJhaXNlZCwgYnV0IGZvcmNlcyB3aWxsIG5vdCBiZSBhbHRlcmVkLlxuICAvLyBXb3JsZCBzcGFjZSBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgLy8gSW50ZXJwb2xhdGVkIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAvLyBJbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAvLyBXb3JsZCBzcGFjZSB2ZWxvY2l0eSBvZiB0aGUgYm9keS5cbiAgLy8gTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5IGluIHdvcmxkIHNwYWNlLlxuICAvLyBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxuICAvLyBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC5cbiAgLy8gQ3VycmVudCBzbGVlcCBzdGF0ZS5cbiAgLy8gSWYgdGhlIHNwZWVkICh0aGUgbm9ybSBvZiB0aGUgdmVsb2NpdHkpIGlzIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgYm9keSBpcyBjb25zaWRlcmVkIHNsZWVweS5cbiAgLy8gSWYgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXB5IGZvciB0aGlzIHNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuXG4gIC8vIFdvcmxkIHNwYWNlIHJvdGF0aW9uYWwgZm9yY2Ugb24gdGhlIGJvZHksIGFyb3VuZCBjZW50ZXIgb2YgbWFzcy5cbiAgLy8gV29ybGQgc3BhY2Ugb3JpZW50YXRpb24gb2YgdGhlIGJvZHkuXG4gIC8vIEludGVycG9sYXRlZCBvcmllbnRhdGlvbiBvZiB0aGUgYm9keS5cbiAgLy8gQW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSwgaW4gd29ybGQgc3BhY2UuIFRoaW5rIG9mIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGFzIGEgdmVjdG9yLCB3aGljaCB0aGUgYm9keSByb3RhdGVzIGFyb3VuZC4gVGhlIGxlbmd0aCBvZiB0aGlzIHZlY3RvciBkZXRlcm1pbmVzIGhvdyBmYXN0IChpbiByYWRpYW5zIHBlciBzZWNvbmQpIHRoZSBib2R5IHJvdGF0ZXMuXG4gIC8vIFBvc2l0aW9uIG9mIGVhY2ggU2hhcGUgaW4gdGhlIGJvZHksIGdpdmVuIGluIGxvY2FsIEJvZHkgc3BhY2UuXG4gIC8vIE9yaWVudGF0aW9uIG9mIGVhY2ggU2hhcGUsIGdpdmVuIGluIGxvY2FsIEJvZHkgc3BhY2UuXG4gIC8vIFNldCB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBib2R5IHRvIHJvdGF0ZS4gTWFrZSBzdXJlIHRvIHJ1biAudXBkYXRlTWFzc1Byb3BlcnRpZXMoKSBhZnRlciBjaGFuZ2luZyB0aGlzLlxuICAvLyBVc2UgdGhpcyBwcm9wZXJ0eSB0byBsaW1pdCB0aGUgbW90aW9uIGFsb25nIGFueSB3b3JsZCBheGlzLiAoMSwxLDEpIHdpbGwgYWxsb3cgbW90aW9uIGFsb25nIGFsbCBheGVzIHdoaWxlICgwLDAsMCkgYWxsb3dzIG5vbmUuXG4gIC8vIFVzZSB0aGlzIHByb3BlcnR5IHRvIGxpbWl0IHRoZSByb3RhdGlvbmFsIG1vdGlvbiBhbG9uZyBhbnkgd29ybGQgYXhpcy4gKDEsMSwxKSB3aWxsIGFsbG93IHJvdGF0aW9uIGFsb25nIGFsbCBheGVzIHdoaWxlICgwLDAsMCkgYWxsb3dzIG5vbmUuXG4gIC8vIFdvcmxkIHNwYWNlIGJvdW5kaW5nIGJveCBvZiB0aGUgYm9keSBhbmQgaXRzIHNoYXBlcy5cbiAgLy8gSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYmVmb3JlIHVzZS5cbiAgLy8gVG90YWwgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBCb2R5IGluY2x1ZGluZyBpdHMgc2hhcGVzLCByZWxhdGl2ZSB0byBib2R5LnBvc2l0aW9uLlxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBCb2R5LmlkQ291bnRlcisrO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcbiAgICB0aGlzLnByZVN0ZXAgPSBudWxsO1xuICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xuICAgIHRoaXMudmxhbWJkYSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAxO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2sgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogLTE7XG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHR5cGVvZiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaW5pdFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgIGlmIChvcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuaW5pdFBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZiAob3B0aW9ucy52ZWxvY2l0eSkge1xuICAgICAgdGhpcy52ZWxvY2l0eS5jb3B5KG9wdGlvbnMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBtYXNzID0gdHlwZW9mIG9wdGlvbnMubWFzcyA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1hc3MgOiAwO1xuICAgIHRoaXMubWFzcyA9IG1hc3M7XG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZiBvcHRpb25zLmxpbmVhckRhbXBpbmcgPT09ICdudW1iZXInID8gb3B0aW9ucy5saW5lYXJEYW1waW5nIDogMC4wMTtcbiAgICB0aGlzLnR5cGUgPSBtYXNzIDw9IDAuMCA/IEJvZHkuU1RBVElDIDogQm9keS5EWU5BTUlDO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IHR5cGVvZiBCb2R5LlNUQVRJQykge1xuICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIH1cblxuICAgIHRoaXMuYWxsb3dTbGVlcCA9IHR5cGVvZiBvcHRpb25zLmFsbG93U2xlZXAgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mIG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0IDogMC4xO1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwVGltZUxpbWl0IDogMTtcbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcbiAgICB0aGlzLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICB0aGlzLnRvcnF1ZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB0aGlzLmluaXRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmIChvcHRpb25zLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgICB0aGlzLmluaXRRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KSB7XG4gICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuc2hhcGVzID0gW107XG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcbiAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zID0gW107XG4gICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmludkluZXJ0aWEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcbiAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuICAgIHRoaXMuZml4ZWRSb3RhdGlvbiA9IHR5cGVvZiBvcHRpb25zLmZpeGVkUm90YXRpb24gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5maXhlZFJvdGF0aW9uIDogZmFsc2U7XG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZiBvcHRpb25zLmFuZ3VsYXJEYW1waW5nICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjAxO1xuICAgIHRoaXMubGluZWFyRmFjdG9yID0gbmV3IFZlYzMoMSwgMSwgMSk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5lYXJGYWN0b3IpIHtcbiAgICAgIHRoaXMubGluZWFyRmFjdG9yLmNvcHkob3B0aW9ucy5saW5lYXJGYWN0b3IpO1xuICAgIH1cblxuICAgIHRoaXMuYW5ndWxhckZhY3RvciA9IG5ldyBWZWMzKDEsIDEsIDEpO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5ndWxhckZhY3Rvcikge1xuICAgICAgdGhpcy5hbmd1bGFyRmFjdG9yLmNvcHkob3B0aW9ucy5hbmd1bGFyRmFjdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcbiAgICB0aGlzLndsYW1iZGEgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhcGUpIHtcbiAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICB9XG4gIC8qKlxyXG4gICAqIFdha2UgdGhlIGJvZHkgdXAuXHJcbiAgICogQG1ldGhvZCB3YWtlVXBcclxuICAgKi9cblxuXG4gIHdha2VVcCgpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gMDtcbiAgICB0aGlzLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuICAgIGlmIChwcmV2U3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5Lndha2V1cEV2ZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRm9yY2UgYm9keSBzbGVlcFxyXG4gICAqIEBtZXRob2Qgc2xlZXBcclxuICAgKi9cblxuXG4gIHNsZWVwKCkge1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXHJcbiAgICogQG1ldGhvZCBzbGVlcFRpY2tcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzXHJcbiAgICovXG5cblxuICBzbGVlcFRpY2sodGltZSkge1xuICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHtcbiAgICAgIGNvbnN0IHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgICBjb25zdCBzcGVlZFNxdWFyZWQgPSB0aGlzLnZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKSArIHRoaXMuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTtcbiAgICAgIGNvbnN0IHNwZWVkTGltaXRTcXVhcmVkID0gdGhpcy5zbGVlcFNwZWVkTGltaXQgKiogMjtcblxuICAgICAgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpIHtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweVxuXG4gICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZICYmIHNwZWVkU3F1YXJlZCA+IHNwZWVkTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXBcbiAgICAgIH0gZWxzZSBpZiAoc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUFkgJiYgdGltZSAtIHRoaXMudGltZUxhc3RTbGVlcHkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KSB7XG4gICAgICAgIHRoaXMuc2xlZXAoKTsgLy8gU2xlZXBpbmdcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cclxuICAgKiBAbWV0aG9kIHVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXNcclxuICAgKi9cblxuXG4gIHVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKSB7XG4gICAgaWYgKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSB7XG4gICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5zZXRaZXJvKCk7XG4gICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLnNldFplcm8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSB0aGlzLmludk1hc3M7XG4gICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYSk7XG4gICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICAgKiBAbWV0aG9kIHBvaW50VG9Mb2NhbEZyYW1lXHJcbiAgICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICBwb2ludFRvTG9jYWxGcmFtZSh3b3JsZFBvaW50LCByZXN1bHQgPSBuZXcgVmVjMygpKSB7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHJlc3VsdCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSB3b3JsZCB2ZWN0b3IgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICAgKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcclxuICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcclxuICAgKiBAcmV0dXJuIHtWZWMzfVxyXG4gICAqL1xuXG5cbiAgdmVjdG9yVG9Mb2NhbEZyYW1lKHdvcmxkVmVjdG9yLCByZXN1bHQgPSBuZXcgVmVjMygpKSB7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHdvcmxkVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuXHJcbiAgICogQG1ldGhvZCBwb2ludFRvV29ybGRGcmFtZVxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnRcclxuICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcclxuICAgKiBAcmV0dXJuIHtWZWMzfVxyXG4gICAqL1xuXG5cbiAgcG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVzdWx0ID0gbmV3IFZlYzMoKSkge1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHRoaXMucG9zaXRpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICAgKiBAbWV0aG9kIHZlY3RvclRvV29ybGRGcmFtZVxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsVmVjdG9yXHJcbiAgICogQHBhcmFtICB7VmVjM30gcmVzdWx0XHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIHZlY3RvclRvV29ybGRGcmFtZShsb2NhbFZlY3RvciwgcmVzdWx0ID0gbmV3IFZlYzMoKSkge1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5IHdpdGggYSBsb2NhbCBvZmZzZXQgYW5kIG9yaWVudGF0aW9uLlxyXG4gICAqIEBtZXRob2QgYWRkU2hhcGVcclxuICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxyXG4gICAqIEBwYXJhbSB7VmVjM30gW19vZmZzZXRdXHJcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbX29yaWVudGF0aW9uXVxyXG4gICAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5IG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgKi9cblxuXG4gIGFkZFNoYXBlKHNoYXBlLCBfb2Zmc2V0LCBfb3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmIChfb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQuY29weShfb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5jb3B5KF9vcmllbnRhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZSk7XG4gICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMucHVzaChvcmllbnRhdGlvbik7XG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgc2hhcGUuYm9keSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGVzIGFyZSBjaGFuZ2VkLlxyXG4gICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgKi9cblxuXG4gIHVwZGF0ZUJvdW5kaW5nUmFkaXVzKCkge1xuICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc2hhcGVzO1xuICAgIGNvbnN0IHNoYXBlT2Zmc2V0cyA9IHRoaXMuc2hhcGVPZmZzZXRzO1xuICAgIGNvbnN0IE4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIGxldCByYWRpdXMgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbaV07XG4gICAgICBzaGFwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc2hhcGVPZmZzZXRzW2ldLmxlbmd0aCgpO1xuICAgICAgY29uc3QgciA9IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzO1xuXG4gICAgICBpZiAob2Zmc2V0ICsgciA+IHJhZGl1cykge1xuICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgLmFhYmJcclxuICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICogQHRvZG8gcmVuYW1lIHRvIHVwZGF0ZUFBQkIoKVxyXG4gICAqL1xuXG5cbiAgY29tcHV0ZUFBQkIoKSB7XG4gICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zaGFwZXM7XG4gICAgY29uc3Qgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHM7XG4gICAgY29uc3Qgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zO1xuICAgIGNvbnN0IE4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIGNvbnN0IG9mZnNldCA9IHRtcFZlYztcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRtcFF1YXQkMTtcbiAgICBjb25zdCBib2R5UXVhdCA9IHRoaXMucXVhdGVybmlvbjtcbiAgICBjb25zdCBhYWJiID0gdGhpcy5hYWJiO1xuICAgIGNvbnN0IHNoYXBlQUFCQiA9IGNvbXB1dGVBQUJCX3NoYXBlQUFCQjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldOyAvLyBHZXQgc2hhcGUgd29ybGQgcG9zaXRpb25cblxuICAgICAgYm9keVF1YXQudm11bHQoc2hhcGVPZmZzZXRzW2ldLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0LnZhZGQodGhpcy5wb3NpdGlvbiwgb2Zmc2V0KTsgLy8gR2V0IHNoYXBlIHdvcmxkIHF1YXRlcm5pb25cblxuICAgICAgYm9keVF1YXQubXVsdChzaGFwZU9yaWVudGF0aW9uc1tpXSwgb3JpZW50YXRpb24pOyAvLyBHZXQgc2hhcGUgQUFCQlxuXG4gICAgICBzaGFwZS5jYWxjdWxhdGVXb3JsZEFBQkIob2Zmc2V0LCBvcmllbnRhdGlvbiwgc2hhcGVBQUJCLmxvd2VyQm91bmQsIHNoYXBlQUFCQi51cHBlckJvdW5kKTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIC5pbmVydGlhV29ybGQgYW5kIC5pbnZJbmVydGlhV29ybGRcclxuICAgKiBAbWV0aG9kIHVwZGF0ZUluZXJ0aWFXb3JsZFxyXG4gICAqL1xuXG5cbiAgdXBkYXRlSW5lcnRpYVdvcmxkKGZvcmNlKSB7XG4gICAgY29uc3QgSSA9IHRoaXMuaW52SW5lcnRpYTtcblxuICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIDsgZWxzZSB7XG4gICAgICBjb25zdCBtMSA9IHVpd19tMTtcbiAgICAgIGNvbnN0IG0yID0gdWl3X20yO1xuICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgICAgbTEudHJhbnNwb3NlKG0yKTtcbiAgICAgIG0xLnNjYWxlKEksIG0xKTtcbiAgICAgIG0xLm1tdWx0KG0yLCB0aGlzLmludkluZXJ0aWFXb3JsZCk7XG4gICAgfVxuICB9XG5cbiAgYXBwbHlGb3JjZShmb3JjZSwgcmVsYXRpdmVQb2ludCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykge1xuICAgICAgLy8gTmVlZGVkP1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG5cblxuICAgIGNvbnN0IHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlO1xuICAgIHJlbGF0aXZlUG9pbnQuY3Jvc3MoZm9yY2UsIHJvdEZvcmNlKTsgLy8gQWRkIGxpbmVhciBmb3JjZVxuXG4gICAgdGhpcy5mb3JjZS52YWRkKGZvcmNlLCB0aGlzLmZvcmNlKTsgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcblxuICAgIHRoaXMudG9ycXVlLnZhZGQocm90Rm9yY2UsIHRoaXMudG9ycXVlKTtcbiAgfVxuXG4gIGFwcGx5TG9jYWxGb3JjZShsb2NhbEZvcmNlLCBsb2NhbFBvaW50KSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd29ybGRGb3JjZSA9IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2U7XG4gICAgY29uc3QgcmVsYXRpdmVQb2ludFdvcmxkID0gQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkOyAvLyBUcmFuc2Zvcm0gdGhlIGZvcmNlIHZlY3RvciB0byB3b3JsZCBzcGFjZVxuXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxGb3JjZSwgd29ybGRGb3JjZSk7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTtcbiAgICB0aGlzLmFwcGx5Rm9yY2Uod29ybGRGb3JjZSwgcmVsYXRpdmVQb2ludFdvcmxkKTtcbiAgfVxuXG4gIGFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxhdGl2ZVBvaW50KSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDb21wdXRlIHBvaW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlclxuXG5cbiAgICBjb25zdCByID0gcmVsYXRpdmVQb2ludDsgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcblxuICAgIGNvbnN0IHZlbG8gPSBCb2R5X2FwcGx5SW1wdWxzZV92ZWxvO1xuICAgIHZlbG8uY29weShpbXB1bHNlKTtcbiAgICB2ZWxvLnNjYWxlKHRoaXMuaW52TWFzcywgdmVsbyk7IC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxuXG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpOyAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eVxuXG4gICAgY29uc3Qgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87XG4gICAgci5jcm9zcyhpbXB1bHNlLCByb3RWZWxvKTtcbiAgICAvKlxyXG4gICAgIHJvdFZlbG8ueCAqPSB0aGlzLmludkluZXJ0aWEueDtcclxuICAgICByb3RWZWxvLnkgKj0gdGhpcy5pbnZJbmVydGlhLnk7XHJcbiAgICAgcm90VmVsby56ICo9IHRoaXMuaW52SW5lcnRpYS56O1xyXG4gICAgICovXG5cbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZC52bXVsdChyb3RWZWxvLCByb3RWZWxvKTsgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxuXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkudmFkZChyb3RWZWxvLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG4gIH1cblxuICBhcHBseUxvY2FsSW1wdWxzZShsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZTtcbiAgICBjb25zdCByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3JlbGF0aXZlUG9pbnQ7IC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG5cbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEltcHVsc2UsIHdvcmxkSW1wdWxzZSk7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgcmVsYXRpdmVQb2ludFdvcmxkKTtcbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB5b3UgY2hhbmdlIHRoZSBib2R5IHNoYXBlIG9yIG1hc3MuXHJcbiAgICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xyXG4gICAqL1xuXG5cbiAgdXBkYXRlTWFzc1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgaGFsZkV4dGVudHMgPSBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzO1xuICAgIHRoaXMuaW52TWFzcyA9IHRoaXMubWFzcyA+IDAgPyAxLjAgLyB0aGlzLm1hc3MgOiAwO1xuICAgIGNvbnN0IEkgPSB0aGlzLmluZXJ0aWE7XG4gICAgY29uc3QgZml4ZWQgPSB0aGlzLmZpeGVkUm90YXRpb247IC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcblxuICAgIHRoaXMuY29tcHV0ZUFBQkIoKTtcbiAgICBoYWxmRXh0ZW50cy5zZXQoKHRoaXMuYWFiYi51cHBlckJvdW5kLnggLSB0aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsICh0aGlzLmFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLCAodGhpcy5hYWJiLnVwcGVyQm91bmQueiAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMik7XG4gICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEoaGFsZkV4dGVudHMsIHRoaXMubWFzcywgSSk7XG4gICAgdGhpcy5pbnZJbmVydGlhLnNldChJLnggPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueCA6IDAsIEkueSA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS55IDogMCwgSS56ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnogOiAwKTtcbiAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cclxuICAgKiBAbWV0aG9kIGdldFZlbG9jaXR5QXRXb3JsZFBvaW50XHJcbiAgICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAqL1xuXG5cbiAgZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQod29ybGRQb2ludCwgcmVzdWx0KSB7XG4gICAgY29uc3QgciA9IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaW1lIHN0ZXBcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1YXROb3JtYWxpemUgU2V0IHRvIHRydWUgdG8gbm9ybWFsaXplIHRoZSBib2R5IHF1YXRlcm5pb25cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1YXROb3JtYWxpemVGYXN0IElmIHRoZSBxdWF0ZXJuaW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHVzaW5nIFwiZmFzdFwiIHF1YXRlcm5pb24gbm9ybWFsaXphdGlvblxyXG4gICAqL1xuXG5cbiAgaW50ZWdyYXRlKGR0LCBxdWF0Tm9ybWFsaXplLCBxdWF0Tm9ybWFsaXplRmFzdCkge1xuICAgIC8vIFNhdmUgcHJldmlvdXMgcG9zaXRpb25cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weSh0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG5cbiAgICBpZiAoISh0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSB8fCB0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpIHtcbiAgICAgIC8vIE9ubHkgZm9yIGR5bmFtaWNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB2ZWxvID0gdGhpcy52ZWxvY2l0eTtcbiAgICBjb25zdCBhbmd1bGFyVmVsbyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5O1xuICAgIGNvbnN0IHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgY29uc3QgZm9yY2UgPSB0aGlzLmZvcmNlO1xuICAgIGNvbnN0IHRvcnF1ZSA9IHRoaXMudG9ycXVlO1xuICAgIGNvbnN0IHF1YXQgPSB0aGlzLnF1YXRlcm5pb247XG4gICAgY29uc3QgaW52TWFzcyA9IHRoaXMuaW52TWFzcztcbiAgICBjb25zdCBpbnZJbmVydGlhID0gdGhpcy5pbnZJbmVydGlhV29ybGQ7XG4gICAgY29uc3QgbGluZWFyRmFjdG9yID0gdGhpcy5saW5lYXJGYWN0b3I7XG4gICAgY29uc3QgaU1kdCA9IGludk1hc3MgKiBkdDtcbiAgICB2ZWxvLnggKz0gZm9yY2UueCAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueDtcbiAgICB2ZWxvLnkgKz0gZm9yY2UueSAqIGlNZHQgKiBsaW5lYXJGYWN0b3IueTtcbiAgICB2ZWxvLnogKz0gZm9yY2UueiAqIGlNZHQgKiBsaW5lYXJGYWN0b3IuejtcbiAgICBjb25zdCBlID0gaW52SW5lcnRpYS5lbGVtZW50cztcbiAgICBjb25zdCBhbmd1bGFyRmFjdG9yID0gdGhpcy5hbmd1bGFyRmFjdG9yO1xuICAgIGNvbnN0IHR4ID0gdG9ycXVlLnggKiBhbmd1bGFyRmFjdG9yLng7XG4gICAgY29uc3QgdHkgPSB0b3JxdWUueSAqIGFuZ3VsYXJGYWN0b3IueTtcbiAgICBjb25zdCB0eiA9IHRvcnF1ZS56ICogYW5ndWxhckZhY3Rvci56O1xuICAgIGFuZ3VsYXJWZWxvLnggKz0gZHQgKiAoZVswXSAqIHR4ICsgZVsxXSAqIHR5ICsgZVsyXSAqIHR6KTtcbiAgICBhbmd1bGFyVmVsby55ICs9IGR0ICogKGVbM10gKiB0eCArIGVbNF0gKiB0eSArIGVbNV0gKiB0eik7XG4gICAgYW5ndWxhclZlbG8ueiArPSBkdCAqIChlWzZdICogdHggKyBlWzddICogdHkgKyBlWzhdICogdHopOyAvLyBVc2UgbmV3IHZlbG9jaXR5ICAtIGxlYXAgZnJvZ1xuXG4gICAgcG9zLnggKz0gdmVsby54ICogZHQ7XG4gICAgcG9zLnkgKz0gdmVsby55ICogZHQ7XG4gICAgcG9zLnogKz0gdmVsby56ICogZHQ7XG4gICAgcXVhdC5pbnRlZ3JhdGUodGhpcy5hbmd1bGFyVmVsb2NpdHksIGR0LCB0aGlzLmFuZ3VsYXJGYWN0b3IsIHF1YXQpO1xuXG4gICAgaWYgKHF1YXROb3JtYWxpemUpIHtcbiAgICAgIGlmIChxdWF0Tm9ybWFsaXplRmFzdCkge1xuICAgICAgICBxdWF0Lm5vcm1hbGl6ZUZhc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1YXQubm9ybWFsaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBVcGRhdGUgd29ybGQgaW5lcnRpYVxuXG4gICAgdGhpcy51cGRhdGVJbmVydGlhV29ybGQoKTtcbiAgfVxuXG59XG4vKipcclxuICogRGlzcGF0Y2hlZCBhZnRlciB0d28gYm9kaWVzIGNvbGxpZGUuIFRoaXMgZXZlbnQgaXMgZGlzcGF0Y2hlZCBvbiBlYWNoXHJcbiAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXHJcbiAqIEBldmVudCBjb2xsaWRlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keSBUaGUgYm9keSB0aGF0IHdhcyBpbnZvbHZlZCBpbiB0aGUgY29sbGlzaW9uLlxyXG4gKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdCBUaGUgZGV0YWlscyBvZiB0aGUgY29sbGlzaW9uLlxyXG4gKi9cblxuQm9keS5DT0xMSURFX0VWRU5UX05BTUUgPSAnY29sbGlkZSc7XG4vKipcclxuICogQSBkeW5hbWljIGJvZHkgaXMgZnVsbHkgc2ltdWxhdGVkLiBDYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsIGJ1dCBub3JtYWxseSB0aGV5IG1vdmUgYWNjb3JkaW5nIHRvIGZvcmNlcy4gQSBkeW5hbWljIGJvZHkgY2FuIGNvbGxpZGUgd2l0aCBhbGwgYm9keSB0eXBlcy4gQSBkeW5hbWljIGJvZHkgYWx3YXlzIGhhcyBmaW5pdGUsIG5vbi16ZXJvIG1hc3MuXHJcbiAqIEBzdGF0aWNcclxuICogQHByb3BlcnR5IERZTkFNSUNcclxuICogQHR5cGUge051bWJlcn1cclxuICovXG5cbkJvZHkuRFlOQU1JQyA9IDE7XG4vKipcclxuICogQSBzdGF0aWMgYm9keSBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzaW11bGF0aW9uIGFuZCBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSBzZXR0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZlbG9jaXR5IG9mIGEgc3RhdGljIGJvZHkgaXMgYWx3YXlzIHplcm8uIFN0YXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cclxuICogQHN0YXRpY1xyXG4gKiBAcHJvcGVydHkgU1RBVElDXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xuXG5Cb2R5LlNUQVRJQyA9IDI7XG4vKipcclxuICogQSBraW5lbWF0aWMgYm9keSBtb3ZlcyB1bmRlciBzaW11bGF0aW9uIGFjY29yZGluZyB0byBpdHMgdmVsb2NpdHkuIFRoZXkgZG8gbm90IHJlc3BvbmQgdG8gZm9yY2VzLiBUaGV5IGNhbiBiZSBtb3ZlZCBtYW51YWxseSwgYnV0IG5vcm1hbGx5IGEga2luZW1hdGljIGJvZHkgaXMgbW92ZWQgYnkgc2V0dGluZyBpdHMgdmVsb2NpdHkuIEEga2luZW1hdGljIGJvZHkgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy4gS2luZW1hdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSBLSU5FTUFUSUNcclxuICogQHR5cGUge051bWJlcn1cclxuICovXG5cbkJvZHkuS0lORU1BVElDID0gNDtcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcm9wZXJ0eSBBV0FLRVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxuQm9keS5BV0FLRSA9IEJPRFlfU0xFRVBfU1RBVEVTLkFXQUtFO1xuQm9keS5TTEVFUFkgPSBCT0RZX1NMRUVQX1NUQVRFUy5TTEVFUFk7XG5Cb2R5LlNMRUVQSU5HID0gQk9EWV9TTEVFUF9TVEFURVMuU0xFRVBJTkc7XG5Cb2R5LmlkQ291bnRlciA9IDA7XG4vKipcclxuICogRGlzcGF0Y2hlZCBhZnRlciBhIHNsZWVwaW5nIGJvZHkgaGFzIHdva2VuIHVwLlxyXG4gKiBAZXZlbnQgd2FrZXVwXHJcbiAqL1xuXG5Cb2R5Lndha2V1cEV2ZW50ID0ge1xuICB0eXBlOiAnd2FrZXVwJ1xufTtcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZ29uZSBpbiB0byB0aGUgc2xlZXB5IHN0YXRlLlxyXG4gKiBAZXZlbnQgc2xlZXB5XHJcbiAqL1xuXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICB0eXBlOiAnc2xlZXB5J1xufTtcbi8qKlxyXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZmFsbGVuIGFzbGVlcC5cclxuICogQGV2ZW50IHNsZWVwXHJcbiAqL1xuXG5Cb2R5LnNsZWVwRXZlbnQgPSB7XG4gIHR5cGU6ICdzbGVlcCdcbn07XG5jb25zdCB0bXBWZWMgPSBuZXcgVmVjMygpO1xuY29uc3QgdG1wUXVhdCQxID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IGNvbXB1dGVBQUJCX3NoYXBlQUFCQiA9IG5ldyBBQUJCKCk7XG5jb25zdCB1aXdfbTEgPSBuZXcgTWF0MygpO1xuY29uc3QgdWl3X20yID0gbmV3IE1hdDMoKTtcbi8qKlxyXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS50b3JxdWUuXHJcbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgYW1vdW50IG9mIGZvcmNlIHRvIGFkZC5cclxuICogQHBhcmFtICB7VmVjM30gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xuXG5jb25zdCBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2UgPSBuZXcgVmVjMygpO1xuLyoqXHJcbiAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuXHJcbiAqIEBtZXRob2QgYXBwbHlMb2NhbEZvcmNlXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS5cclxuICogQHBhcmFtICB7VmVjM30gbG9jYWxQb2ludCBBIGxvY2FsIHBvaW50IGluIHRoZSBib2R5IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cclxuICovXG5cbmNvbnN0IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpO1xuY29uc3QgQm9keV9hcHBseUxvY2FsRm9yY2VfcmVsYXRpdmVQb2ludFdvcmxkID0gbmV3IFZlYzMoKTtcbi8qKlxyXG4gKiBBcHBseSBpbXB1bHNlIHRvIGEgd29ybGQgcG9pbnQuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cclxuICogQG1ldGhvZCBhcHBseUltcHVsc2VcclxuICogQHBhcmFtICB7VmVjM30gaW1wdWxzZSBUaGUgYW1vdW50IG9mIGltcHVsc2UgdG8gYWRkLlxyXG4gKiBAcGFyYW0gIHtWZWMzfSByZWxhdGl2ZVBvaW50IEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cclxuICovXG5cbmNvbnN0IEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG8gPSBuZXcgVmVjMygpO1xuY29uc3QgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7XG4vKipcclxuICogQXBwbHkgbG9jYWxseS1kZWZpbmVkIGltcHVsc2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cclxuICogQG1ldGhvZCBhcHBseUxvY2FsSW1wdWxzZVxyXG4gKiBAcGFyYW0gIHtWZWMzfSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFwcGx5LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGJvZHkgZnJhbWUuXHJcbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXHJcbiAqL1xuXG5jb25zdCBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZSA9IG5ldyBWZWMzKCk7XG5jb25zdCBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3JlbGF0aXZlUG9pbnQgPSBuZXcgVmVjMygpO1xuY29uc3QgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnNcbiAqIEBjbGFzcyBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuY2xhc3MgQnJvYWRwaGFzZSB7XG4gIC8vIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbnMgaW4uXG4gIC8vIElmIHNldCB0byB0cnVlLCB0aGUgYnJvYWRwaGFzZSB1c2VzIGJvdW5kaW5nIGJveGVzIGZvciBpbnRlcnNlY3Rpb24gdGVzdCwgZWxzZSBpdCB1c2VzIGJvdW5kaW5nIHNwaGVyZXMuXG4gIC8vIFNldCB0byB0cnVlIGlmIHRoZSBvYmplY3RzIGluIHRoZSB3b3JsZCBtb3ZlZC5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG4gICAgdGhpcy51c2VCb3VuZGluZ0JveGVzID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sbGlzaW9uIHBhaXJzIGZyb20gdGhlIHdvcmxkXG4gICAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAgICogQHBhcmFtIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge0FycmF5fSBwMSBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcbiAgICogQHBhcmFtIHtBcnJheX0gcDIgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXG4gICAqL1xuXG5cbiAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikge1xuICAgIHRocm93IG5ldyBFcnJvcignY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhJyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgYm9keSBwYWlyIG5lZWRzIHRvIGJlIGludGVyc2VjdGlvbiB0ZXN0ZWQgYXQgYWxsLlxuICAgKiBAbWV0aG9kIG5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uXG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgKiBAcmV0dXJuIHtib29sfVxuICAgKi9cblxuXG4gIG5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJvZHlBLCBib2R5Qikge1xuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBmaWx0ZXIgbWFza3NcbiAgICBpZiAoKGJvZHlBLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUIuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHlCLmNvbGxpc2lvbkZpbHRlckdyb3VwICYgYm9keUEuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIHR5cGVzXG5cblxuICAgIGlmICgoKGJvZHlBLnR5cGUgJiBCb2R5LlNUQVRJQykgIT09IDAgfHwgYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykgJiYgKChib2R5Qi50eXBlICYgQm9keS5TVEFUSUMpICE9PSAwIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XG4gICAgICAvLyBCb3RoIGJvZGllcyBhcmUgc3RhdGljIG9yIHNsZWVwaW5nLiBTa2lwLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgdm9sdW1lcyBvZiB0d28gYm9kaWVzIGludGVyc2VjdC5cbiAgICogQG1ldGhvZCBpbnRlcnNlY3Rpb25UZXN0XG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgKiBAcGFyYW0ge2FycmF5fSBwYWlyczFcbiAgICogQHBhcmFtIHthcnJheX0gcGFpcnMyXG4gICAqL1xuXG5cbiAgaW50ZXJzZWN0aW9uVGVzdChib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgaWYgKHRoaXMudXNlQm91bmRpbmdCb3hlcykge1xuICAgICAgdGhpcy5kb0JvdW5kaW5nQm94QnJvYWRwaGFzZShib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZShib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKTtcbiAgICB9XG4gIH1cblxuICBkb0JvdW5kaW5nU3BoZXJlQnJvYWRwaGFzZShib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgY29uc3QgciA9IEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcjtcbiAgICBib2R5Qi5wb3NpdGlvbi52c3ViKGJvZHlBLnBvc2l0aW9uLCByKTtcbiAgICBjb25zdCBib3VuZGluZ1JhZGl1c1N1bTIgPSAoYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cykgKiogMjtcbiAgICBjb25zdCBub3JtMiA9IHIubGVuZ3RoU3F1YXJlZCgpO1xuXG4gICAgaWYgKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKSB7XG4gICAgICBwYWlyczEucHVzaChib2R5QSk7XG4gICAgICBwYWlyczIucHVzaChib2R5Qik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxuICAgKiBAbWV0aG9kIGRvQm91bmRpbmdCb3hCcm9hZHBoYXNlXG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyczFcbiAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gICAqL1xuXG5cbiAgZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMikge1xuICAgIGlmIChib2R5QS5hYWJiTmVlZHNVcGRhdGUpIHtcbiAgICAgIGJvZHlBLmNvbXB1dGVBQUJCKCk7XG4gICAgfVxuXG4gICAgaWYgKGJvZHlCLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgYm9keUIuY29tcHV0ZUFBQkIoKTtcbiAgICB9IC8vIENoZWNrIEFBQkIgLyBBQUJCXG5cblxuICAgIGlmIChib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKSB7XG4gICAgICBwYWlyczEucHVzaChib2R5QSk7XG4gICAgICBwYWlyczIucHVzaChib2R5Qik7XG4gICAgfVxuICB9XG5cbiAgbWFrZVBhaXJzVW5pcXVlKHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgY29uc3QgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXA7XG4gICAgY29uc3QgcDEgPSBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMTtcbiAgICBjb25zdCBwMiA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyO1xuICAgIGNvbnN0IE4gPSBwYWlyczEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgcDFbaV0gPSBwYWlyczFbaV07XG4gICAgICBwMltpXSA9IHBhaXJzMltpXTtcbiAgICB9XG5cbiAgICBwYWlyczEubGVuZ3RoID0gMDtcbiAgICBwYWlyczIubGVuZ3RoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkMSA9IHAxW2ldLmlkO1xuICAgICAgY29uc3QgaWQyID0gcDJbaV0uaWQ7XG4gICAgICBjb25zdCBrZXkgPSBpZDEgPCBpZDIgPyBpZDEgKyBcIixcIiArIGlkMiA6IGlkMiArIFwiLFwiICsgaWQxO1xuICAgICAgdFtrZXldID0gaTtcbiAgICAgIHQua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHQua2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gdC5rZXlzLnBvcCgpO1xuICAgICAgY29uc3QgcGFpckluZGV4ID0gdFtrZXldO1xuICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7XG4gICAgICBwYWlyczIucHVzaChwMltwYWlySW5kZXhdKTtcbiAgICAgIGRlbGV0ZSB0W2tleV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjYXNzZXNcbiAgICogQG1ldGhvZCBzZXRXb3JsZFxuICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgKi9cblxuXG4gIHNldFdvcmxkKHdvcmxkKSB7fVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXG4gICAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gICAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAgICogQHJldHVybiB7YXJyYXl9XG4gICAqL1xuXG5cbiAgYWFiYlF1ZXJ5KHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcbiAgICBjb25zb2xlLndhcm4oJy5hYWJiUXVlcnkgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgQnJvYWRwaGFzZSBzdWJjbGFzcy4nKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXG4gKiBAbWV0aG9kIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczEgYm9keUEgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxuICovXG5cbmNvbnN0IC8vIFRlbXAgb2JqZWN0c1xuQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKTtcbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgcGFpcnMgZnJvbSB0aGUgcGFpciBhcnJheXMuXG4gKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xuXG5jb25zdCBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wID0ge1xuICBrZXlzOiBbXVxufTtcbmNvbnN0IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxID0gW107XG5jb25zdCBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMiA9IFtdO1xuXG5Ccm9hZHBoYXNlLmJvdW5kaW5nU3BoZXJlQ2hlY2sgPSAoYm9keUEsIGJvZHlCKSA9PiB7XG4gIGNvbnN0IGRpc3QgPSBuZXcgVmVjMygpOyAvLyBic2NfZGlzdDtcblxuICBib2R5QS5wb3NpdGlvbi52c3ViKGJvZHlCLnBvc2l0aW9uLCBkaXN0KTtcbiAgY29uc3Qgc2EgPSBib2R5QS5zaGFwZXNbMF07XG4gIGNvbnN0IHNiID0gYm9keUIuc2hhcGVzWzBdO1xuICByZXR1cm4gTWF0aC5wb3coc2EuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzYi5ib3VuZGluZ1NwaGVyZVJhZGl1cywgMikgPiBkaXN0Lmxlbmd0aFNxdWFyZWQoKTtcbn07XG5cbi8qKlxyXG4gKiBBeGlzIGFsaWduZWQgdW5pZm9ybSBncmlkIGJyb2FkcGhhc2UuXHJcbiAqIEBjbGFzcyBHcmlkQnJvYWRwaGFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxyXG4gKiBAdG9kbyBOZWVkcyBzdXBwb3J0IGZvciBtb3JlIHRoYW4ganVzdCBwbGFuZXMgYW5kIHNwaGVyZXMuXHJcbiAqIEBwYXJhbSB7VmVjM30gYWFiYk1pblxyXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNYXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG54IE51bWJlciBvZiBib3hlcyBhbG9uZyB4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBueSBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnogTnVtYmVyIG9mIGJveGVzIGFsb25nIHpcclxuICovXG5jbGFzcyBHcmlkQnJvYWRwaGFzZSBleHRlbmRzIEJyb2FkcGhhc2Uge1xuICBjb25zdHJ1Y3RvcihhYWJiTWluID0gbmV3IFZlYzMoMTAwLCAxMDAsIDEwMCksIGFhYmJNYXggPSBuZXcgVmVjMygtMTAwLCAtMTAwLCAtMTAwKSwgbnggPSAxMCwgbnkgPSAxMCwgbnogPSAxMCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ueCA9IG54O1xuICAgIHRoaXMubnkgPSBueTtcbiAgICB0aGlzLm56ID0gbno7XG4gICAgdGhpcy5hYWJiTWluID0gYWFiYk1pbjtcbiAgICB0aGlzLmFhYmJNYXggPSBhYWJiTWF4O1xuICAgIGNvbnN0IG5iaW5zID0gdGhpcy5ueCAqIHRoaXMubnkgKiB0aGlzLm56O1xuXG4gICAgaWYgKG5iaW5zIDw9IDApIHtcbiAgICAgIHRocm93IFwiR3JpZEJyb2FkcGhhc2U6IEVhY2ggZGltZW5zaW9uJ3MgbiBtdXN0IGJlID4wXCI7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5zID0gW107XG4gICAgdGhpcy5iaW5MZW5ndGhzID0gW107IC8vUmF0aGVyIHRoYW4gY29udGludWFsbHkgcmVzaXppbmcgYXJyYXlzICh0aHJhc2hpbmcgdGhlIG1lbW9yeSksIGp1c3QgcmVjb3JkIGxlbmd0aCBhbmQgYWxsb3cgdGhlbSB0byBncm93XG5cbiAgICB0aGlzLmJpbnMubGVuZ3RoID0gbmJpbnM7XG4gICAgdGhpcy5iaW5MZW5ndGhzLmxlbmd0aCA9IG5iaW5zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYmluczsgaSsrKSB7XG4gICAgICB0aGlzLmJpbnNbaV0gPSBbXTtcbiAgICAgIHRoaXMuYmluTGVuZ3Roc1tpXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgY29sbGlzaW9uUGFpcnMod29ybGQsIHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgY29uc3QgTiA9IHdvcmxkLm51bU9iamVjdHMoKTtcbiAgICBjb25zdCBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5hYWJiTWF4O1xuICAgIGNvbnN0IG1pbiA9IHRoaXMuYWFiYk1pbjtcbiAgICBjb25zdCBueCA9IHRoaXMubng7XG4gICAgY29uc3QgbnkgPSB0aGlzLm55O1xuICAgIGNvbnN0IG56ID0gdGhpcy5uejtcbiAgICBjb25zdCB4c3RlcCA9IG55ICogbno7XG4gICAgY29uc3QgeXN0ZXAgPSBuejtcbiAgICBjb25zdCB6c3RlcCA9IDE7XG4gICAgY29uc3QgeG1heCA9IG1heC54O1xuICAgIGNvbnN0IHltYXggPSBtYXgueTtcbiAgICBjb25zdCB6bWF4ID0gbWF4Lno7XG4gICAgY29uc3QgeG1pbiA9IG1pbi54O1xuICAgIGNvbnN0IHltaW4gPSBtaW4ueTtcbiAgICBjb25zdCB6bWluID0gbWluLno7XG4gICAgY29uc3QgeG11bHQgPSBueCAvICh4bWF4IC0geG1pbik7XG4gICAgY29uc3QgeW11bHQgPSBueSAvICh5bWF4IC0geW1pbik7XG4gICAgY29uc3Qgem11bHQgPSBueiAvICh6bWF4IC0gem1pbik7XG4gICAgY29uc3QgYmluc2l6ZVggPSAoeG1heCAtIHhtaW4pIC8gbng7XG4gICAgY29uc3QgYmluc2l6ZVkgPSAoeW1heCAtIHltaW4pIC8gbnk7XG4gICAgY29uc3QgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XG4gICAgY29uc3QgYmluUmFkaXVzID0gTWF0aC5zcXJ0KGJpbnNpemVYICogYmluc2l6ZVggKyBiaW5zaXplWSAqIGJpbnNpemVZICsgYmluc2l6ZVogKiBiaW5zaXplWikgKiAwLjU7XG4gICAgY29uc3QgdHlwZXMgPSBTaGFwZS50eXBlcztcbiAgICBjb25zdCBTUEhFUkUgPSB0eXBlcy5TUEhFUkU7XG4gICAgY29uc3QgUExBTkUgPSB0eXBlcy5QTEFORTtcbiAgICBjb25zdCBCT1ggPSB0eXBlcy5CT1g7XG4gICAgY29uc3QgQ09NUE9VTkQgPSB0eXBlcy5DT01QT1VORDtcbiAgICBjb25zdCBDT05WRVhQT0xZSEVEUk9OID0gdHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcbiAgICBjb25zdCBiaW5zID0gdGhpcy5iaW5zO1xuICAgIGNvbnN0IGJpbkxlbmd0aHMgPSB0aGlzLmJpbkxlbmd0aHM7XG4gICAgY29uc3QgTmJpbnMgPSB0aGlzLmJpbnMubGVuZ3RoOyAvLyBSZXNldCBiaW5zXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJpbnM7IGkrKykge1xuICAgICAgYmluTGVuZ3Roc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgY29uc3QgY2VpbCA9IE1hdGguY2VpbDtcblxuICAgIGZ1bmN0aW9uIGFkZEJveFRvQmlucyh4MCwgeTAsIHowLCB4MSwgeTEsIHoxLCBiaSkge1xuICAgICAgbGV0IHhvZmYwID0gKHgwIC0geG1pbikgKiB4bXVsdCB8IDA7XG4gICAgICBsZXQgeW9mZjAgPSAoeTAgLSB5bWluKSAqIHltdWx0IHwgMDtcbiAgICAgIGxldCB6b2ZmMCA9ICh6MCAtIHptaW4pICogem11bHQgfCAwO1xuICAgICAgbGV0IHhvZmYxID0gY2VpbCgoeDEgLSB4bWluKSAqIHhtdWx0KTtcbiAgICAgIGxldCB5b2ZmMSA9IGNlaWwoKHkxIC0geW1pbikgKiB5bXVsdCk7XG4gICAgICBsZXQgem9mZjEgPSBjZWlsKCh6MSAtIHptaW4pICogem11bHQpO1xuXG4gICAgICBpZiAoeG9mZjAgPCAwKSB7XG4gICAgICAgIHhvZmYwID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeG9mZjAgPj0gbngpIHtcbiAgICAgICAgeG9mZjAgPSBueCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh5b2ZmMCA8IDApIHtcbiAgICAgICAgeW9mZjAgPSAwO1xuICAgICAgfSBlbHNlIGlmICh5b2ZmMCA+PSBueSkge1xuICAgICAgICB5b2ZmMCA9IG55IC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvZmYwIDwgMCkge1xuICAgICAgICB6b2ZmMCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHpvZmYwID49IG56KSB7XG4gICAgICAgIHpvZmYwID0gbnogLSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoeG9mZjEgPCAwKSB7XG4gICAgICAgIHhvZmYxID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeG9mZjEgPj0gbngpIHtcbiAgICAgICAgeG9mZjEgPSBueCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh5b2ZmMSA8IDApIHtcbiAgICAgICAgeW9mZjEgPSAwO1xuICAgICAgfSBlbHNlIGlmICh5b2ZmMSA+PSBueSkge1xuICAgICAgICB5b2ZmMSA9IG55IC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvZmYxIDwgMCkge1xuICAgICAgICB6b2ZmMSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHpvZmYxID49IG56KSB7XG4gICAgICAgIHpvZmYxID0gbnogLSAxO1xuICAgICAgfVxuXG4gICAgICB4b2ZmMCAqPSB4c3RlcDtcbiAgICAgIHlvZmYwICo9IHlzdGVwO1xuICAgICAgem9mZjAgKj0genN0ZXA7XG4gICAgICB4b2ZmMSAqPSB4c3RlcDtcbiAgICAgIHlvZmYxICo9IHlzdGVwO1xuICAgICAgem9mZjEgKj0genN0ZXA7XG5cbiAgICAgIGZvciAobGV0IHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xuICAgICAgICBmb3IgKGxldCB5b2ZmID0geW9mZjA7IHlvZmYgPD0geW9mZjE7IHlvZmYgKz0geXN0ZXApIHtcbiAgICAgICAgICBmb3IgKGxldCB6b2ZmID0gem9mZjA7IHpvZmYgPD0gem9mZjE7IHpvZmYgKz0genN0ZXApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHhvZmYgKyB5b2ZmICsgem9mZjtcbiAgICAgICAgICAgIGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFB1dCBhbGwgYm9kaWVzIGludG8gdGhlIGJpbnNcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07XG4gICAgICBjb25zdCBzaSA9IGJpLnNoYXBlc1swXTtcblxuICAgICAgc3dpdGNoIChzaS50eXBlKSB7XG4gICAgICAgIGNhc2UgU1BIRVJFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gc2k7IC8vIFB1dCBpbiBiaW5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXG5cbiAgICAgICAgICAgIGNvbnN0IHggPSBiaS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgY29uc3QgeSA9IGJpLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBjb25zdCB6ID0gYmkucG9zaXRpb24uejtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBzaGFwZS5yYWRpdXM7XG4gICAgICAgICAgICBhZGRCb3hUb0JpbnMoeCAtIHIsIHkgLSByLCB6IC0gciwgeCArIHIsIHkgKyByLCB6ICsgciwgYmkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUExBTkU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBzaTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgc2hhcGUuY29tcHV0ZVdvcmxkTm9ybWFsKGJpLnF1YXRlcm5pb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwbGFuZU5vcm1hbCA9IHNoYXBlLndvcmxkTm9ybWFsOyAvL1JlbGF0aXZlIHBvc2l0aW9uIGZyb20gb3JpZ2luIG9mIHBsYW5lIG9iamVjdCB0byB0aGUgZmlyc3QgYmluXG4gICAgICAgICAgICAvL0luY3JlbWVudGVkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYmluc1xuXG4gICAgICAgICAgICBjb25zdCB4cmVzZXQgPSB4bWluICsgYmluc2l6ZVggKiAwLjUgLSBiaS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgY29uc3QgeXJlc2V0ID0geW1pbiArIGJpbnNpemVZICogMC41IC0gYmkucG9zaXRpb24ueTtcbiAgICAgICAgICAgIGNvbnN0IHpyZXNldCA9IHptaW4gKyBiaW5zaXplWiAqIDAuNSAtIGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICBjb25zdCBkID0gR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZDtcbiAgICAgICAgICAgIGQuc2V0KHhyZXNldCwgeXJlc2V0LCB6cmVzZXQpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB4aSA9IDAsIHhvZmYgPSAwOyB4aSAhPT0gbng7IHhpKyssIHhvZmYgKz0geHN0ZXAsIGQueSA9IHlyZXNldCwgZC54ICs9IGJpbnNpemVYKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHlpID0gMCwgeW9mZiA9IDA7IHlpICE9PSBueTsgeWkrKywgeW9mZiArPSB5c3RlcCwgZC56ID0genJlc2V0LCBkLnkgKz0gYmluc2l6ZVkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB6aSA9IDAsIHpvZmYgPSAwOyB6aSAhPT0gbno7IHppKyssIHpvZmYgKz0genN0ZXAsIGQueiArPSBiaW5zaXplWikge1xuICAgICAgICAgICAgICAgICAgaWYgKGQuZG90KHBsYW5lTm9ybWFsKSA8IGJpblJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XG4gICAgICAgICAgICAgICAgICAgIGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICBiaS5jb21wdXRlQUFCQigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRCb3hUb0JpbnMoYmkuYWFiYi5sb3dlckJvdW5kLngsIGJpLmFhYmIubG93ZXJCb3VuZC55LCBiaS5hYWJiLmxvd2VyQm91bmQueiwgYmkuYWFiYi51cHBlckJvdW5kLngsIGJpLmFhYmIudXBwZXJCb3VuZC55LCBiaS5hYWJiLnVwcGVyQm91bmQueiwgYmkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgZWFjaCBiaW5cblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5iaW5zOyBpKyspIHtcbiAgICAgIGNvbnN0IGJpbkxlbmd0aCA9IGJpbkxlbmd0aHNbaV07IC8vU2tpcCBiaW5zIHdpdGggbm8gcG90ZW50aWFsIGNvbGxpc2lvbnNcblxuICAgICAgaWYgKGJpbkxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgYmluID0gYmluc1tpXTsgLy8gRG8gTl4yIGJyb2FkcGhhc2UgaW5zaWRlXG5cbiAgICAgICAgZm9yIChsZXQgeGkgPSAwOyB4aSAhPT0gYmluTGVuZ3RoOyB4aSsrKSB7XG4gICAgICAgICAgY29uc3QgYmkgPSBiaW5beGldO1xuXG4gICAgICAgICAgZm9yIChsZXQgeWkgPSAwOyB5aSAhPT0geGk7IHlpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJqID0gYmluW3lpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksIGJqKSkge1xuICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksIGJqLCBwYWlyczEsIHBhaXJzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvL1x0Zm9yIChsZXQgemkgPSAwLCB6b2ZmPTA7IHppIDwgbno7IHppKyssIHpvZmYrPSB6c3RlcCkge1xuICAgIC8vXHRcdGNvbnNvbGUubG9nKFwibGF5ZXIgXCIremkpO1xuICAgIC8vXHRcdGZvciAobGV0IHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XG4gICAgLy9cdFx0XHRjb25zdCByb3cgPSAnJztcbiAgICAvL1x0XHRcdGZvciAobGV0IHhpID0gMCwgeG9mZj0wOyB4aSA8IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwKSB7XG4gICAgLy9cdFx0XHRcdGNvbnN0IGlkeCA9IHhvZmYgKyB5b2ZmICsgem9mZjtcbiAgICAvL1x0XHRcdFx0cm93ICs9ICcgJyArIGJpbkxlbmd0aHNbaWR4XTtcbiAgICAvL1x0XHRcdH1cbiAgICAvL1x0XHRcdGNvbnNvbGUubG9nKHJvdyk7XG4gICAgLy9cdFx0fVxuICAgIC8vXHR9XG5cblxuICAgIHRoaXMubWFrZVBhaXJzVW5pcXVlKHBhaXJzMSwgcGFpcnMyKTtcbiAgfVxuXG59XG4vKipcclxuICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXHJcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcclxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMlxyXG4gKi9cblxuY29uc3QgR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxyXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLCB1c2VkIGluIGxhY2sgb2YgYmV0dGVyIG9uZXMuXHJcbiAqIEBjbGFzcyBOYWl2ZUJyb2FkcGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBkZXNjcmlwdGlvbiBUaGUgbmFpdmUgYnJvYWRwaGFzZSBsb29rcyBhdCBhbGwgcG9zc2libGUgcGFpcnMgd2l0aG91dCByZXN0cmljdGlvbiwgdGhlcmVmb3JlIGl0IGhhcyBjb21wbGV4aXR5IE5eMiAod2hpY2ggaXMgYmFkKVxyXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAqL1xuY2xhc3MgTmFpdmVCcm9hZHBoYXNlIGV4dGVuZHMgQnJvYWRwaGFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXHJcbiAgICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xyXG4gICAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXHJcbiAgICovXG5cblxuICBjb2xsaXNpb25QYWlycyh3b3JsZCwgcGFpcnMxLCBwYWlyczIpIHtcbiAgICBjb25zdCBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgY29uc3QgbiA9IGJvZGllcy5sZW5ndGg7XG4gICAgbGV0IGJpO1xuICAgIGxldCBiajsgLy8gTmFpdmUgTl4yIGZ0dyFcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBpOyBqKyspIHtcbiAgICAgICAgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksIGJqLCBwYWlyczEsIHBhaXJzMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICovXG5cblxuICBhYWJiUXVlcnkod29ybGQsIGFhYmIsIHJlc3VsdCA9IFtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JsZC5ib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGIgPSB3b3JsZC5ib2RpZXNbaV07XG5cbiAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICBiLmNvbXB1dGVBQUJCKCk7XG4gICAgICB9IC8vIFVnbHkgaGFjayB1bnRpbCBCb2R5IGdldHMgYWFiYlxuXG5cbiAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhLlxyXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBSYXljYXN0UmVzdWx0IHtcbiAgLy8gVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaC5cbiAgLy8gRGlzdGFuY2UgdG8gdGhlIGhpdC4gV2lsbCBiZSBzZXQgdG8gLTEgaWYgdGhlcmUgd2FzIG5vIGhpdC5cbiAgLy8gSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmF5RnJvbVdvcmxkID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnJheVRvV29ybGQgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcbiAgICB0aGlzLnNoYXBlID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG4gICAgdGhpcy5kaXN0YW5jZSA9IC0xO1xuICAgIHRoaXMuc2hvdWxkU3RvcCA9IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cclxuICAgKiBAbWV0aG9kIHJlc2V0XHJcbiAgICovXG5cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7XG4gICAgdGhpcy5yYXlUb1dvcmxkLnNldFplcm8oKTtcbiAgICB0aGlzLmhpdE5vcm1hbFdvcmxkLnNldFplcm8oKTtcbiAgICB0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpO1xuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICB0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuICAgIHRoaXMuZGlzdGFuY2UgPSAtMTtcbiAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIGFib3J0XHJcbiAgICovXG5cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLnNob3VsZFN0b3AgPSB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2V0XHJcbiAgICogQHBhcmFtIHtWZWMzfSByYXlGcm9tV29ybGRcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGhpdE5vcm1hbFdvcmxkXHJcbiAgICogQHBhcmFtIHtWZWMzfSBoaXRQb2ludFdvcmxkXHJcbiAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcclxuICAgKi9cblxuXG4gIHNldChyYXlGcm9tV29ybGQsIHJheVRvV29ybGQsIGhpdE5vcm1hbFdvcmxkLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpIHtcbiAgICB0aGlzLnJheUZyb21Xb3JsZC5jb3B5KHJheUZyb21Xb3JsZCk7XG4gICAgdGhpcy5yYXlUb1dvcmxkLmNvcHkocmF5VG9Xb3JsZCk7XG4gICAgdGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KGhpdE5vcm1hbFdvcmxkKTtcbiAgICB0aGlzLmhpdFBvaW50V29ybGQuY29weShoaXRQb2ludFdvcmxkKTtcbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cblxufVxuXG5jb25zdCBSQVlfTU9ERVMgPSB7XG4gIENMT1NFU1Q6IDEsXG4gIEFOWTogMixcbiAgQUxMOiA0XG59O1xuXG4vKipcclxuICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuXHJcbiAqIEBjbGFzcyBSYXlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VmVjM30gZnJvbVxyXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXHJcbiAqL1xuY2xhc3MgUmF5IHtcbiAgLy8gVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLlxuICAvLyBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgLy8gSWYgc2V0IHRvIHRydWUsIHRoZSByYXkgc2tpcHMgYW55IGhpdHMgd2l0aCBub3JtYWwuZG90KHJheURpcmVjdGlvbikgPCAwLlxuICAvLyBUaGUgaW50ZXJzZWN0aW9uIG1vZGUuIFNob3VsZCBiZSBSYXkuQU5ZLCBSYXkuQUxMIG9yIFJheS5DTE9TRVNULlxuICAvLyBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gIC8vIFdpbGwgYmUgc2V0IHRvIHRydWUgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuXG4gIC8vIFVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICBjb25zdHJ1Y3Rvcihmcm9tID0gbmV3IFZlYzMoKSwgdG8gPSBuZXcgVmVjMygpKSB7XG4gICAgdGhpcy5mcm9tID0gZnJvbS5jbG9uZSgpO1xuICAgIHRoaXMudG8gPSB0by5jbG9uZSgpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IDAuMDAwMTtcbiAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSAtMTtcbiAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYWxsYmFjayA9IHJlc3VsdCA9PiB7fTtcbiAgfVxuICAvKipcclxuICAgKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLlxyXG4gICAqIEBtZXRob2QgaW50ZXJzZWN0V29ybGRcclxuICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICovXG5cblxuICBpbnRlcnNlY3RXb3JsZCh3b3JsZCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCBSYXkuQU5ZO1xuICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTtcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Ygb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogLTE7XG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgOiB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMuZnJvbSkge1xuICAgICAgdGhpcy5mcm9tLmNvcHkob3B0aW9ucy5mcm9tKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bykge1xuICAgICAgdGhpcy50by5jb3B5KG9wdGlvbnMudG8pO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8ICgoKSA9PiB7fSk7XG5cbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB0aGlzLmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xuICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTtcbiAgICByZXR1cm4gdGhpcy5oYXNIaXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxyXG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cclxuICAgKi9cblxuXG4gIGludGVyc2VjdEJvZHkoYm9keSwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgodGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHkuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeGkgPSBpbnRlcnNlY3RCb2R5X3hpO1xuICAgIGNvbnN0IHFpID0gaW50ZXJzZWN0Qm9keV9xaTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xuXG4gICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2UpIHtcbiAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgIH1cblxuICAgICAgYm9keS5xdWF0ZXJuaW9uLm11bHQoYm9keS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xuICAgICAgYm9keS5xdWF0ZXJuaW9uLnZtdWx0KGJvZHkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7XG4gICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcbiAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoc2hhcGUsIHFpLCB4aSwgYm9keSk7XG5cbiAgICAgIGlmICh0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXHJcbiAgICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkXHJcbiAgICovXG5cblxuICBpbnRlcnNlY3RCb2RpZXMoYm9kaWVzLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmludGVyc2VjdEJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3Rvci5cclxuICAgKi9cblxuXG4gIHVwZGF0ZURpcmVjdGlvbigpIHtcbiAgICB0aGlzLnRvLnZzdWIodGhpcy5mcm9tLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gIH1cblxuICBpbnRlcnNlY3RTaGFwZShzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tOyAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgdGhpcy5kaXJlY3Rpb24sIHBvc2l0aW9uKTtcblxuICAgIGlmIChkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJzZWN0TWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcblxuICAgIGlmIChpbnRlcnNlY3RNZXRob2QpIHtcbiAgICAgIGludGVyc2VjdE1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgc2hhcGUpO1xuICAgIH1cbiAgfVxuXG4gIF9pbnRlcnNlY3RCb3goYm94LCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnNlY3RDb252ZXgoYm94LmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpO1xuICB9XG5cbiAgX2ludGVyc2VjdFBsYW5lKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207XG4gICAgY29uc3QgdG8gPSB0aGlzLnRvO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uOyAvLyBHZXQgcGxhbmUgbm9ybWFsXG5cbiAgICBjb25zdCB3b3JsZE5vcm1hbCA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuICAgIHF1YXQudm11bHQod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICBjb25zdCBsZW4gPSBuZXcgVmVjMygpO1xuICAgIGZyb20udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICBjb25zdCBwbGFuZVRvRnJvbSA9IGxlbi5kb3Qod29ybGROb3JtYWwpO1xuICAgIHRvLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgY29uc3QgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7XG4gICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmcm9tLmRpc3RhbmNlVG8odG8pIDwgcGxhbmVUb0Zyb20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuX2RvdF9kaXIgPSB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIGlmIChNYXRoLmFicyhuX2RvdF9kaXIpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYW5lUG9pbnRUb0Zyb20gPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IGRpcl9zY2FsZWRfd2l0aF90ID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBoaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTtcbiAgICBmcm9tLnZzdWIocG9zaXRpb24sIHBsYW5lUG9pbnRUb0Zyb20pO1xuICAgIGNvbnN0IHQgPSAtd29ybGROb3JtYWwuZG90KHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyO1xuICAgIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XG4gICAgZnJvbS52YWRkKGRpcl9zY2FsZWRfd2l0aF90LCBoaXRQb2ludFdvcmxkKTtcbiAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LlxyXG4gICAqL1xuXG5cbiAgZ2V0QUFCQihhYWJiKSB7XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXJCb3VuZCxcbiAgICAgIHVwcGVyQm91bmRcbiAgICB9ID0gYWFiYjtcbiAgICBjb25zdCB0byA9IHRoaXMudG87XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICBsb3dlckJvdW5kLnggPSBNYXRoLm1pbih0by54LCBmcm9tLngpO1xuICAgIGxvd2VyQm91bmQueSA9IE1hdGgubWluKHRvLnksIGZyb20ueSk7XG4gICAgbG93ZXJCb3VuZC56ID0gTWF0aC5taW4odG8ueiwgZnJvbS56KTtcbiAgICB1cHBlckJvdW5kLnggPSBNYXRoLm1heCh0by54LCBmcm9tLngpO1xuICAgIHVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRvLnksIGZyb20ueSk7XG4gICAgdXBwZXJCb3VuZC56ID0gTWF0aC5tYXgodG8ueiwgZnJvbS56KTtcbiAgfVxuXG4gIF9pbnRlcnNlY3RIZWlnaHRmaWVsZChzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHtcbiAgICBjb25zdCBkYXRhID0gc2hhcGUuZGF0YTtcbiAgICBjb25zdCB3ID0gc2hhcGUuZWxlbWVudFNpemU7IC8vIENvbnZlcnQgdGhlIHJheSB0byBsb2NhbCBoZWlnaHRmaWVsZCBjb29yZGluYXRlc1xuXG4gICAgY29uc3QgbG9jYWxSYXkgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFJheTsgLy9uZXcgUmF5KHRoaXMuZnJvbSwgdGhpcy50byk7XG5cbiAgICBsb2NhbFJheS5mcm9tLmNvcHkodGhpcy5mcm9tKTtcbiAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkuZnJvbSwgbG9jYWxSYXkuZnJvbSk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS50bywgbG9jYWxSYXkudG8pO1xuICAgIGxvY2FsUmF5LnVwZGF0ZURpcmVjdGlvbigpOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcblxuICAgIGNvbnN0IGluZGV4ID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXg7XG4gICAgbGV0IGlNaW5YO1xuICAgIGxldCBpTWluWTtcbiAgICBsZXQgaU1heFg7XG4gICAgbGV0IGlNYXhZOyAvLyBTZXQgdG8gbWF4XG5cbiAgICBpTWluWCA9IGlNaW5ZID0gMDtcbiAgICBpTWF4WCA9IGlNYXhZID0gc2hhcGUuZGF0YS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGFhYmIgPSBuZXcgQUFCQigpO1xuICAgIGxvY2FsUmF5LmdldEFBQkIoYWFiYik7XG4gICAgc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGFhYmIubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSwgaW5kZXgsIHRydWUpO1xuICAgIGlNaW5YID0gTWF0aC5tYXgoaU1pblgsIGluZGV4WzBdKTtcbiAgICBpTWluWSA9IE1hdGgubWF4KGlNaW5ZLCBpbmRleFsxXSk7XG4gICAgc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGFhYmIudXBwZXJCb3VuZC54LCBhYWJiLnVwcGVyQm91bmQueSwgaW5kZXgsIHRydWUpO1xuICAgIGlNYXhYID0gTWF0aC5taW4oaU1heFgsIGluZGV4WzBdICsgMSk7XG4gICAgaU1heFkgPSBNYXRoLm1pbihpTWF4WSwgaW5kZXhbMV0gKyAxKTtcblxuICAgIGZvciAobGV0IGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZS5nZXRBYWJiQXRJbmRleChpLCBqLCBhYWJiKTtcblxuICAgICAgICBpZiAoIWFhYmIub3ZlcmxhcHNSYXkobG9jYWxSYXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gTG93ZXIgdHJpYW5nbGVcblxuXG4gICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcblxuICAgICAgICB0aGlzLl9pbnRlcnNlY3RDb252ZXgoc2hhcGUucGlsbGFyQ29udmV4LCBxdWF0LCB3b3JsZFBpbGxhck9mZnNldCwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgaW50ZXJzZWN0Q29udmV4T3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnNob3VsZFN0b3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGVcblxuXG4gICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuXG4gICAgICAgIHRoaXMuX2ludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCByZXBvcnRlZFNoYXBlLCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tO1xuICAgIGNvbnN0IHRvID0gdGhpcy50bztcbiAgICBjb25zdCByID0gc3BoZXJlLnJhZGl1cztcbiAgICBjb25zdCBhID0gKHRvLnggLSBmcm9tLngpICoqIDIgKyAodG8ueSAtIGZyb20ueSkgKiogMiArICh0by56IC0gZnJvbS56KSAqKiAyO1xuICAgIGNvbnN0IGIgPSAyICogKCh0by54IC0gZnJvbS54KSAqIChmcm9tLnggLSBwb3NpdGlvbi54KSArICh0by55IC0gZnJvbS55KSAqIChmcm9tLnkgLSBwb3NpdGlvbi55KSArICh0by56IC0gZnJvbS56KSAqIChmcm9tLnogLSBwb3NpdGlvbi56KSk7XG4gICAgY29uc3QgYyA9IChmcm9tLnggLSBwb3NpdGlvbi54KSAqKiAyICsgKGZyb20ueSAtIHBvc2l0aW9uLnkpICoqIDIgKyAoZnJvbS56IC0gcG9zaXRpb24ueikgKiogMiAtIHIgKiogMjtcbiAgICBjb25zdCBkZWx0YSA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XG4gICAgY29uc3Qgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XG5cbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICBmcm9tLmxlcnAodG8sIGRlbHRhLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkMSA9ICgtYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcbiAgICAgIGNvbnN0IGQyID0gKC1iICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAoZDEgPj0gMCAmJiBkMSA8PSAxKSB7XG4gICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlc3VsdC5zaG91bGRTdG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGQyID49IDAgJiYgZDIgPD0gMSkge1xuICAgICAgICBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9pbnRlcnNlY3RDb252ZXgoc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICBjb25zdCB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yO1xuICAgIGNvbnN0IGZhY2VMaXN0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmZhY2VMaXN0IHx8IG51bGw7IC8vIENoZWNraW5nIGZhY2VzXG5cbiAgICBjb25zdCBmYWNlcyA9IHNoYXBlLmZhY2VzO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gc2hhcGUudmVydGljZXM7XG4gICAgY29uc3Qgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207XG4gICAgY29uc3QgdG8gPSB0aGlzLnRvO1xuICAgIGNvbnN0IGZyb21Ub0Rpc3RhbmNlID0gZnJvbS5kaXN0YW5jZVRvKHRvKTtcbiAgICBjb25zdCBOZmFjZXMgPSBmYWNlTGlzdCA/IGZhY2VMaXN0Lmxlbmd0aCA6IGZhY2VzLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIGZvciAobGV0IGogPSAwOyAhcmVzdWx0LnNob3VsZFN0b3AgJiYgaiA8IE5mYWNlczsgaisrKSB7XG4gICAgICBjb25zdCBmaSA9IGZhY2VMaXN0ID8gZmFjZUxpc3Rbal0gOiBqO1xuICAgICAgY29uc3QgZmFjZSA9IGZhY2VzW2ZpXTtcbiAgICAgIGNvbnN0IGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTtcbiAgICAgIGNvbnN0IHEgPSBxdWF0O1xuICAgICAgY29uc3QgeCA9IHBvc2l0aW9uOyAvLyBkZXRlcm1pbmUgaWYgcmF5IGludGVyc2VjdHMgdGhlIHBsYW5lIG9mIHRoZSBmYWNlXG4gICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWxcbiAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLlxuXG4gICAgICB2ZWN0b3IuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XG4gICAgICBxLnZtdWx0KHZlY3RvciwgdmVjdG9yKTtcbiAgICAgIHZlY3Rvci52YWRkKHgsIHZlY3Rvcik7IC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXG5cbiAgICAgIHZlY3Rvci52c3ViKGZyb20sIHZlY3Rvcik7IC8vIEdldCBwbGFuZSBub3JtYWxcblxuICAgICAgcS52bXVsdChmYWNlTm9ybWFsLCBub3JtYWwpOyAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xuXG4gICAgICBjb25zdCBkb3QgPSBkaXJlY3Rpb24uZG90KG5vcm1hbCk7IC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG5cbiAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcblxuXG4gICAgICBjb25zdCBzY2FsYXIgPSBub3JtYWwuZG90KHZlY3RvcikgLyBkb3Q7IC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcblxuICAgICAgaWYgKHNjYWxhciA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGlmIChkb3QgPCAwKSB7XG4gICAgICAvLyBJbnRlcnNlY3Rpb24gcG9pbnQgaXMgZnJvbSArIGRpcmVjdGlvbiAqIHNjYWxhclxuXG5cbiAgICAgIGRpcmVjdGlvbi5zY2FsZShzY2FsYXIsIGludGVyc2VjdFBvaW50KTtcbiAgICAgIGludGVyc2VjdFBvaW50LnZhZGQoZnJvbSwgaW50ZXJzZWN0UG9pbnQpOyAvLyBhIGlzIHRoZSBwb2ludCB3ZSBjb21wYXJlIHBvaW50cyBiIGFuZCBjIHdpdGguXG5cbiAgICAgIGEuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XG4gICAgICBxLnZtdWx0KGEsIGEpO1xuICAgICAgeC52YWRkKGEsIGEpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgIXJlc3VsdC5zaG91bGRTdG9wICYmIGkgPCBmYWNlLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAvLyBUcmFuc2Zvcm0gMyB2ZXJ0aWNlcyB0byB3b3JsZCBjb29yZHNcbiAgICAgICAgYi5jb3B5KHZlcnRpY2VzW2ZhY2VbaV1dKTtcbiAgICAgICAgYy5jb3B5KHZlcnRpY2VzW2ZhY2VbaSArIDFdXSk7XG4gICAgICAgIHEudm11bHQoYiwgYik7XG4gICAgICAgIHEudm11bHQoYywgYyk7XG4gICAgICAgIHgudmFkZChiLCBiKTtcbiAgICAgICAgeC52YWRkKGMsIGMpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oZnJvbSk7XG5cbiAgICAgICAgaWYgKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpKSB8fCBkaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdFBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCBmaSk7XG4gICAgICB9IC8vIH1cblxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxyXG4gICAqIEB0b2RvIFVzZSBPY3RyZWUgbG9va3VwXHJcbiAgICovXG5cblxuICBfaW50ZXJzZWN0VHJpbWVzaChtZXNoLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsO1xuICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGludGVyc2VjdFRyaW1lc2hfdHJpYW5nbGVzO1xuICAgIGNvbnN0IHRyZWVUcmFuc2Zvcm0gPSBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm07XG4gICAgY29uc3QgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICBjb25zdCBsb2NhbERpcmVjdGlvbiA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb247XG4gICAgY29uc3QgbG9jYWxGcm9tID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb207XG4gICAgY29uc3QgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcbiAgICBjb25zdCB3b3JsZEludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50O1xuICAgIGNvbnN0IHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbDtcbiAgICBjb25zdCBmYWNlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCB8fCBudWxsOyAvLyBDaGVja2luZyBmYWNlc1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IG1lc2guaW5kaWNlcztcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG1lc2gudmVydGljZXM7IC8vIGNvbnN0IG5vcm1hbHMgPSBtZXNoLmZhY2VOb3JtYWxzXG5cbiAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tO1xuICAgIGNvbnN0IHRvID0gdGhpcy50bztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpOyAvLyBUcmFuc2Zvcm0gcmF5IHRvIGxvY2FsIHNwYWNlIVxuXG4gICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZGlyZWN0aW9uLCBsb2NhbERpcmVjdGlvbik7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBmcm9tLCBsb2NhbEZyb20pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgdG8sIGxvY2FsVG8pO1xuICAgIGxvY2FsVG8ueCAqPSBtZXNoLnNjYWxlLng7XG4gICAgbG9jYWxUby55ICo9IG1lc2guc2NhbGUueTtcbiAgICBsb2NhbFRvLnogKj0gbWVzaC5zY2FsZS56O1xuICAgIGxvY2FsRnJvbS54ICo9IG1lc2guc2NhbGUueDtcbiAgICBsb2NhbEZyb20ueSAqPSBtZXNoLnNjYWxlLnk7XG4gICAgbG9jYWxGcm9tLnogKj0gbWVzaC5zY2FsZS56O1xuICAgIGxvY2FsVG8udnN1Yihsb2NhbEZyb20sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICBsb2NhbERpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBjb25zdCBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xuICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlc0luZGV4ID0gdHJpYW5nbGVzW2ldO1xuICAgICAgbWVzaC5nZXROb3JtYWwodHJpYW5nbGVzSW5kZXgsIG5vcm1hbCk7IC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxuICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG5cbiAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzXSwgYSk7IC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXG5cbiAgICAgIGEudnN1Yihsb2NhbEZyb20sIHZlY3Rvcik7IC8vIElmIHRoaXMgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIGhhdmUgc29tZXRoaW5nIGludGVyZXN0aW5nXG5cbiAgICAgIGNvbnN0IGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpOyAvLyBCYWlsIG91dCBpZiByYXkgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxuICAgICAgLy8gaWYgKE1hdGguYWJzKCBkb3QgKSA8IHRoaXMucHJlY2lzaW9uKXtcbiAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcblxuICAgICAgY29uc3Qgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90OyAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5XG5cbiAgICAgIGlmIChzY2FsYXIgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbnRlcnNlY3Rpb24gcG9pbnQgaXMgZnJvbSArIGRpcmVjdGlvbiAqIHNjYWxhclxuXG5cbiAgICAgIGxvY2FsRGlyZWN0aW9uLnNjYWxlKHNjYWxhciwgaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChsb2NhbEZyb20sIGludGVyc2VjdFBvaW50KTsgLy8gR2V0IHRyaWFuZ2xlIHZlcnRpY2VzXG5cbiAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzICsgMV0sIGIpO1xuICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XG4gICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVNxdWFyZWQobG9jYWxGcm9tKTtcblxuICAgICAgaWYgKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpKSB8fCBzcXVhcmVkRGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHRyYW5zZm9ybSBpbnRlcnNlY3Rwb2ludCBhbmQgbm9ybWFsIHRvIHdvcmxkXG5cblxuICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgaW50ZXJzZWN0UG9pbnQsIHdvcmxkSW50ZXJzZWN0UG9pbnQpO1xuICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIHdvcmxkSW50ZXJzZWN0UG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIHRyaWFuZ2xlc0luZGV4KTtcbiAgICB9XG5cbiAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZVxyXG4gICAqL1xuXG5cbiAgcmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGhpdEZhY2VJbmRleCkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb207XG4gICAgY29uc3QgdG8gPSB0aGlzLnRvO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gZnJvbS5kaXN0YW5jZVRvKGhpdFBvaW50V29ybGQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0OyAvLyBTa2lwIGJhY2sgZmFjZXM/XG5cbiAgICBpZiAodGhpcy5za2lwQmFja2ZhY2VzICYmIG5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdC5oaXRGYWNlSW5kZXggPSB0eXBlb2YgaGl0RmFjZUluZGV4ICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgIGNhc2UgUmF5LkFMTDpcbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuc2V0KGZyb20sIHRvLCBub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBkaXN0YW5jZSk7XG4gICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJheS5DTE9TRVNUOlxuICAgICAgICAvLyBTdG9yZSBpZiBjbG9zZXIgdGhhbiBjdXJyZW50IGNsb3Nlc3RcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KSB7XG4gICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdC5zZXQoZnJvbSwgdG8sIG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGRpc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJheS5BTlk6XG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChmcm9tLCB0bywgbm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgZGlzdGFuY2UpO1xuICAgICAgICByZXN1bHQuc2hvdWxkU3RvcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG59XG5SYXkuQ0xPU0VTVCA9IDE7XG5SYXkuQU5ZID0gMjtcblJheS5BTEwgPSA0O1xuY29uc3QgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG5jb25zdCB0bXBBcnJheSA9IFtdO1xuY29uc3QgdjEgPSBuZXcgVmVjMygpO1xuY29uc3QgdjIgPSBuZXcgVmVjMygpO1xuLypcclxuICogQXMgcGVyIFwiQmFyeWNlbnRyaWMgVGVjaG5pcXVlXCIgYXMgbmFtZWQgaGVyZSBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sIEJ1dCB3aXRob3V0IHRoZSBkaXZpc2lvblxyXG4gKi9cblxuUmF5LnBvaW50SW5UcmlhbmdsZSA9IHBvaW50SW5UcmlhbmdsZTtcblxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKHAsIGEsIGIsIGMpIHtcbiAgYy52c3ViKGEsIHYwKTtcbiAgYi52c3ViKGEsIHYxKTtcbiAgcC52c3ViKGEsIHYyKTtcbiAgY29uc3QgZG90MDAgPSB2MC5kb3QodjApO1xuICBjb25zdCBkb3QwMSA9IHYwLmRvdCh2MSk7XG4gIGNvbnN0IGRvdDAyID0gdjAuZG90KHYyKTtcbiAgY29uc3QgZG90MTEgPSB2MS5kb3QodjEpO1xuICBjb25zdCBkb3QxMiA9IHYxLmRvdCh2Mik7XG4gIGxldCB1O1xuICBsZXQgdjtcbiAgcmV0dXJuICh1ID0gZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpID49IDAgJiYgKHYgPSBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgPj0gMCAmJiB1ICsgdiA8IGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxO1xufVxuXG5jb25zdCBpbnRlcnNlY3RCb2R5X3hpID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdEJvZHlfcWkgPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuY29uc3QgYSA9IG5ldyBWZWMzKCk7XG5jb25zdCBiID0gbmV3IFZlYzMoKTtcbmNvbnN0IGMgPSBuZXcgVmVjMygpO1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1hdID0gUmF5LnByb3RvdHlwZS5faW50ZXJzZWN0Qm94O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORV0gPSBSYXkucHJvdG90eXBlLl9pbnRlcnNlY3RQbGFuZTtcbmNvbnN0IGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7XG4gIGZhY2VMaXN0OiBbMF1cbn07XG5jb25zdCB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5jb25zdCBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFJheSA9IG5ldyBSYXkoKTtcbmNvbnN0IGludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4ID0gW107XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9IFJheS5wcm90b3R5cGUuX2ludGVyc2VjdEhlaWdodGZpZWxkO1xuY29uc3QgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBWZWMzKCk7XG5jb25zdCBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRV0gPSBSYXkucHJvdG90eXBlLl9pbnRlcnNlY3RTcGhlcmU7XG5jb25zdCBpbnRlcnNlY3RDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpO1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9IFJheS5wcm90b3R5cGUuX2ludGVyc2VjdENvbnZleDtcbmNvbnN0IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb24gPSBuZXcgVmVjMygpO1xuY29uc3QgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb20gPSBuZXcgVmVjMygpO1xuY29uc3QgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdFRyaW1lc2hfd29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuY29uc3QgaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcbmNvbnN0IGludGVyc2VjdFRyaW1lc2hfdHJpYW5nbGVzID0gW107XG5jb25zdCBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlRSSU1FU0hdID0gUmF5LnByb3RvdHlwZS5faW50ZXJzZWN0VHJpbWVzaDtcbmNvbnN0IHYwID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludGVyc2VjdCA9IG5ldyBWZWMzKCk7XG5cbmZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG4gIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cbiAgcG9zaXRpb24udnN1Yihmcm9tLCB2MCk7XG4gIGNvbnN0IGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pOyAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbVxuXG4gIGRpcmVjdGlvbi5zY2FsZShkb3QsIGludGVyc2VjdCk7XG4gIGludGVyc2VjdC52YWRkKGZyb20sIGludGVyc2VjdCk7XG4gIGNvbnN0IGRpc3RhbmNlID0gcG9zaXRpb24uZGlzdGFuY2VUbyhpbnRlcnNlY3QpO1xuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbi8qKlxyXG4gKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cclxuICpcclxuICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7V29ybGR9IFt3b3JsZF1cclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxyXG4gKi9cbmNsYXNzIFNBUEJyb2FkcGhhc2UgZXh0ZW5kcyBCcm9hZHBoYXNlIHtcbiAgLy8gTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAvLyBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICAvLyBBeGlzIHRvIHNvcnQgdGhlIGJvZGllcyBhbG9uZy4gU2V0IHRvIDAgZm9yIHggYXhpcywgYW5kIDEgZm9yIHkgYXhpcy4gRm9yIGJlc3QgcGVyZm9ybWFuY2UsIGNob29zZSBhbiBheGlzIHRoYXQgdGhlIGJvZGllcyBhcmUgc3ByZWFkIG91dCBtb3JlIG9uLlxuICBjb25zdHJ1Y3Rvcih3b3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcbiAgICBjb25zdCBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG5cbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgIGF4aXNMaXN0LnB1c2goZXZlbnQuYm9keSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihldmVudC5ib2R5KTtcblxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXhpc0xpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh3b3JsZCkge1xuICAgICAgdGhpcy5zZXRXb3JsZCh3b3JsZCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgd29ybGRcclxuICAgKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAgICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAgICovXG5cblxuICBzZXRXb3JsZCh3b3JsZCkge1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDsgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5heGlzTGlzdC5wdXNoKHdvcmxkLmJvZGllc1tpXSk7XG4gICAgfSAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcblxuXG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkQm9keScsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmVCb2R5JywgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpOyAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cblxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZEJvZHknLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7XG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZlQm9keScsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29sbGVjdCBhbGwgY29sbGlzaW9uIHBhaXJzXHJcbiAgICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xyXG4gICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAqIEBwYXJhbSAge0FycmF5fSBwMVxyXG4gICAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gICAqL1xuXG5cbiAgY29sbGlzaW9uUGFpcnMod29ybGQsIHAxLCBwMikge1xuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYXhpc0xpc3Q7XG4gICAgY29uc3QgTiA9IGJvZGllcy5sZW5ndGg7XG4gICAgY29uc3QgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG5cbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgdGhpcy5zb3J0TGlzdCgpO1xuICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH0gLy8gTG9vayB0aHJvdWdoIHRoZSBsaXN0XG5cblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgTjsgaisrKSB7XG4gICAgICAgIGNvbnN0IGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVNBUEJyb2FkcGhhc2UuY2hlY2tCb3VuZHMoYmksIGJqLCBheGlzSW5kZXgpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksIGJqLCBwMSwgcDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvcnRMaXN0KCkge1xuICAgIGNvbnN0IGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICBjb25zdCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICBjb25zdCBOID0gYXhpc0xpc3QubGVuZ3RoOyAvLyBVcGRhdGUgQUFCQnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IGJpID0gYXhpc0xpc3RbaV07XG5cbiAgICAgIGlmIChiaS5hYWJiTmVlZHNVcGRhdGUpIHtcbiAgICAgICAgYmkuY29tcHV0ZUFBQkIoKTtcbiAgICAgIH1cbiAgICB9IC8vIFNvcnQgdGhlIGxpc3RcblxuXG4gICAgaWYgKGF4aXNJbmRleCA9PT0gMCkge1xuICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WChheGlzTGlzdCk7XG4gICAgfSBlbHNlIGlmIChheGlzSW5kZXggPT09IDEpIHtcbiAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpO1xuICAgIH0gZWxzZSBpZiAoYXhpc0luZGV4ID09PSAyKSB7XG4gICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRaKGF4aXNMaXN0KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcHV0ZXMgdGhlIHZhcmlhbmNlIG9mIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgZXN0aW1hdGVzIHRoZSBiZXN0XHJcbiAgICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cclxuICAgKiBAbWV0aG9kIGF1dG9EZXRlY3RBeGlzXHJcbiAgICovXG5cblxuICBhdXRvRGV0ZWN0QXhpcygpIHtcbiAgICBsZXQgc3VtWCA9IDA7XG4gICAgbGV0IHN1bVgyID0gMDtcbiAgICBsZXQgc3VtWSA9IDA7XG4gICAgbGV0IHN1bVkyID0gMDtcbiAgICBsZXQgc3VtWiA9IDA7XG4gICAgbGV0IHN1bVoyID0gMDtcbiAgICBjb25zdCBib2RpZXMgPSB0aGlzLmF4aXNMaXN0O1xuICAgIGNvbnN0IE4gPSBib2RpZXMubGVuZ3RoO1xuICAgIGNvbnN0IGludk4gPSAxIC8gTjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IGIgPSBib2RpZXNbaV07XG4gICAgICBjb25zdCBjZW50ZXJYID0gYi5wb3NpdGlvbi54O1xuICAgICAgc3VtWCArPSBjZW50ZXJYO1xuICAgICAgc3VtWDIgKz0gY2VudGVyWCAqIGNlbnRlclg7XG4gICAgICBjb25zdCBjZW50ZXJZID0gYi5wb3NpdGlvbi55O1xuICAgICAgc3VtWSArPSBjZW50ZXJZO1xuICAgICAgc3VtWTIgKz0gY2VudGVyWSAqIGNlbnRlclk7XG4gICAgICBjb25zdCBjZW50ZXJaID0gYi5wb3NpdGlvbi56O1xuICAgICAgc3VtWiArPSBjZW50ZXJaO1xuICAgICAgc3VtWjIgKz0gY2VudGVyWiAqIGNlbnRlclo7XG4gICAgfVxuXG4gICAgY29uc3QgdmFyaWFuY2VYID0gc3VtWDIgLSBzdW1YICogc3VtWCAqIGludk47XG4gICAgY29uc3QgdmFyaWFuY2VZID0gc3VtWTIgLSBzdW1ZICogc3VtWSAqIGludk47XG4gICAgY29uc3QgdmFyaWFuY2VaID0gc3VtWjIgLSBzdW1aICogc3VtWiAqIGludk47XG5cbiAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VZKSB7XG4gICAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VaKSB7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhcmlhbmNlWSA+IHZhcmlhbmNlWikge1xuICAgICAgdGhpcy5heGlzSW5kZXggPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF4aXNJbmRleCA9IDI7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICovXG5cblxuICBhYWJiUXVlcnkod29ybGQsIGFhYmIsIHJlc3VsdCA9IFtdKSB7XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuc29ydExpc3QoKTtcbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICBsZXQgYXhpcyA9ICd4JztcblxuICAgIGlmIChheGlzSW5kZXggPT09IDEpIHtcbiAgICAgIGF4aXMgPSAneSc7XG4gICAgfVxuXG4gICAgaWYgKGF4aXNJbmRleCA9PT0gMikge1xuICAgICAgYXhpcyA9ICd6JztcbiAgICB9XG5cbiAgICBjb25zdCBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG4gICAgY29uc3QgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XG4gICAgY29uc3QgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiID0gYXhpc0xpc3RbaV07XG5cbiAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICBiLmNvbXB1dGVBQUJCKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59XG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRYXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cblxuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WCA9IGEgPT4ge1xuICBmb3IgKGxldCBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgdiA9IGFbaV07XG4gICAgbGV0IGo7XG5cbiAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGFbaiArIDFdID0gYVtqXTtcbiAgICB9XG5cbiAgICBhW2ogKyAxXSA9IHY7XG4gIH1cblxuICByZXR1cm4gYTtcbn07XG4vKipcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRZXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cblxuXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZID0gYSA9PiB7XG4gIGZvciAobGV0IGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCB2ID0gYVtpXTtcbiAgICBsZXQgajtcblxuICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kLnkgPD0gdi5hYWJiLmxvd2VyQm91bmQueSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYVtqICsgMV0gPSBhW2pdO1xuICAgIH1cblxuICAgIGFbaiArIDFdID0gdjtcbiAgfVxuXG4gIHJldHVybiBhO1xufTtcbi8qKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFpcclxuICogQHBhcmFtICB7QXJyYXl9IGFcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xuXG5cblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFogPSBhID0+IHtcbiAgZm9yIChsZXQgaSA9IDEsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHYgPSBhW2ldO1xuICAgIGxldCBqO1xuXG4gICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoYVtqXS5hYWJiLmxvd2VyQm91bmQueiA8PSB2LmFhYmIubG93ZXJCb3VuZC56KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhW2ogKyAxXSA9IGFbal07XG4gICAgfVxuXG4gICAgYVtqICsgMV0gPSB2O1xuICB9XG5cbiAgcmV0dXJuIGE7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBib3VuZHMgb2YgdHdvIGJvZGllcyBvdmVybGFwLCBhbG9uZyB0aGUgZ2l2ZW4gU0FQIGF4aXMuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0JvdW5kc1xyXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxyXG4gKiBAcGFyYW0gIHtCb2R5fSBialxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cblxuXG5TQVBCcm9hZHBoYXNlLmNoZWNrQm91bmRzID0gKGJpLCBiaiwgYXhpc0luZGV4KSA9PiB7XG4gIGxldCBiaVBvcztcbiAgbGV0IGJqUG9zO1xuXG4gIGlmIChheGlzSW5kZXggPT09IDApIHtcbiAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLng7XG4gICAgYmpQb3MgPSBiai5wb3NpdGlvbi54O1xuICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMSkge1xuICAgIGJpUG9zID0gYmkucG9zaXRpb24ueTtcbiAgICBialBvcyA9IGJqLnBvc2l0aW9uLnk7XG4gIH0gZWxzZSBpZiAoYXhpc0luZGV4ID09PSAyKSB7XG4gICAgYmlQb3MgPSBiaS5wb3NpdGlvbi56O1xuICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcbiAgfVxuXG4gIGNvbnN0IHJpID0gYmkuYm91bmRpbmdSYWRpdXMsXG4gICAgICAgIHJqID0gYmouYm91bmRpbmdSYWRpdXMsXG4gICAgICAgIC8vIGJvdW5kQTEgPSBiaVBvcyAtIHJpLFxuICBib3VuZEEyID0gYmlQb3MgKyByaSxcbiAgICAgICAgYm91bmRCMSA9IGJqUG9zIC0gcmo7IC8vIGJvdW5kQjIgPSBialBvcyArIHJqO1xuXG4gIHJldHVybiBib3VuZEIxIDwgYm91bmRBMjtcbn07XG5cbmZ1bmN0aW9uIFV0aWxzKCkge31cbi8qKlxyXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGRlZmF1bHRzXHJcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSAge29iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmYXVsdCB2YWx1ZXMuXHJcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxyXG4gKi9cblxuVXRpbHMuZGVmYXVsdHMgPSAob3B0aW9ucyA9IHt9LCBkZWZhdWx0cykgPT4ge1xuICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShrZXkgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnNba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcclxuICogQ29uc3RyYWludCBiYXNlIGNsYXNzXHJcbiAqIEBjbGFzcyBDb25zdHJhaW50XHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndha2VVcEJvZGllcz10cnVlXVxyXG4gKi9cbmNsYXNzIENvbnN0cmFpbnQge1xuICAvLyBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludC5cbiAgLy8gU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIGJvZGllcyB0byBjb2xsaWRlIHdoZW4gdGhleSBhcmUgY29ubmVjdGVkLlxuICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgd2FrZVVwQm9kaWVzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuICAgIHRoaXMuaWQgPSBDb25zdHJhaW50LmlkQ291bnRlcisrO1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIGlmIChvcHRpb25zLndha2VVcEJvZGllcykge1xuICAgICAgaWYgKGJvZHlBKSB7XG4gICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9keUIpIHtcbiAgICAgICAgYm9keUIud2FrZVVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuXHJcbiAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgKi9cblxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyEnKTtcbiAgfVxuICAvKipcclxuICAgKiBFbmFibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXHJcbiAgICogQG1ldGhvZCBlbmFibGVcclxuICAgKi9cblxuXG4gIGVuYWJsZSgpIHtcbiAgICBjb25zdCBlcXMgPSB0aGlzLmVxdWF0aW9ucztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlcXNbaV0uZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIERpc2FibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXHJcbiAgICogQG1ldGhvZCBkaXNhYmxlXHJcbiAgICovXG5cblxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVxc1tpXS5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbn1cbkNvbnN0cmFpbnQuaWRDb3VudGVyID0gMDtcblxuLyoqXHJcbiAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS5cclxuICovXG5cbmNsYXNzIEphY29iaWFuRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3BhdGlhbCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5yb3RhdGlvbmFsID0gbmV3IFZlYzMoKTtcbiAgfVxuICAvKipcclxuICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudFxyXG4gICAqL1xuXG5cbiAgbXVsdGlwbHlFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgZWxlbWVudC5yb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xuICB9XG4gIC8qKlxyXG4gICAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnNcclxuICAgKi9cblxuXG4gIG11bHRpcGx5VmVjdG9ycyhzcGF0aWFsLCByb3RhdGlvbmFsKSB7XG4gICAgcmV0dXJuIHNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyByb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIEVxdWF0aW9uIGJhc2UgY2xhc3NcclxuICogQGNsYXNzIEVxdWF0aW9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYmlcclxuICogQHBhcmFtIHtCb2R5fSBialxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWluRm9yY2UgTWluaW11bSAocmVhZDogbmVnYXRpdmUgbWF4KSBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSAocmVhZDogcG9zaXRpdmUgbWF4KSBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50LlxyXG4gKi9cbmNsYXNzIEVxdWF0aW9uIHtcbiAgLy8gU1BPT0sgcGFyYW1ldGVyXG4gIC8vIFNQT09LIHBhcmFtZXRlclxuICAvLyBTUE9PSyBwYXJhbWV0ZXJcbiAgLy8gQSBudW1iZXIsIHByb3BvcnRpb25hbCB0byB0aGUgZm9yY2UgYWRkZWQgdG8gdGhlIGJvZGllcy5cbiAgY29uc3RydWN0b3IoYmksIGJqLCBtaW5Gb3JjZSA9IC0xZTYsIG1heEZvcmNlID0gMWU2KSB7XG4gICAgdGhpcy5pZCA9IEVxdWF0aW9uLmlkKys7XG4gICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlO1xuICAgIHRoaXMubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICB0aGlzLmJpID0gYmk7XG4gICAgdGhpcy5iaiA9IGJqO1xuICAgIHRoaXMuYSA9IDAuMDsgLy8gU1BPT0sgcGFyYW1ldGVyXG5cbiAgICB0aGlzLmIgPSAwLjA7IC8vIFNQT09LIHBhcmFtZXRlclxuXG4gICAgdGhpcy5lcHMgPSAwLjA7IC8vIFNQT09LIHBhcmFtZXRlclxuXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QiA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMubXVsdGlwbGllciA9IDA7XG4gICAgdGhpcy5zZXRTcG9va1BhcmFtcygxZTcsIDQsIDEgLyA2MCk7IC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xuICB9XG4gIC8qKlxyXG4gICAqIFJlY2FsY3VsYXRlcyBhLGIsZXBzLlxyXG4gICAqIEBtZXRob2Qgc2V0U3Bvb2tQYXJhbXNcclxuICAgKi9cblxuXG4gIHNldFNwb29rUGFyYW1zKHN0aWZmbmVzcywgcmVsYXhhdGlvbiwgdGltZVN0ZXApIHtcbiAgICBjb25zdCBkID0gcmVsYXhhdGlvbjtcbiAgICBjb25zdCBrID0gc3RpZmZuZXNzO1xuICAgIGNvbnN0IGggPSB0aW1lU3RlcDtcbiAgICB0aGlzLmEgPSA0LjAgLyAoaCAqICgxICsgNCAqIGQpKTtcbiAgICB0aGlzLmIgPSA0LjAgKiBkIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGVzIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIFNQT09LIGVxdWF0aW9uXHJcbiAgICogQG1ldGhvZCBjb21wdXRlQlxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGNvbXB1dGVCKGEsIGIsIGgpIHtcbiAgICBjb25zdCBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgY29uc3QgR3EgPSB0aGlzLmNvbXB1dGVHcSgpO1xuICAgIGNvbnN0IEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC1HcSAqIGEgLSBHVyAqIGIgLSBHaU1mICogaDtcbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlcyBHKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXHJcbiAgICogQG1ldGhvZCBjb21wdXRlR3FcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICovXG5cblxuICBjb21wdXRlR3EoKSB7XG4gICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7XG4gICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG4gICAgY29uc3QgYmkgPSB0aGlzLmJpO1xuICAgIGNvbnN0IGJqID0gdGhpcy5iajtcbiAgICBjb25zdCB4aSA9IGJpLnBvc2l0aW9uO1xuICAgIGNvbnN0IHhqID0gYmoucG9zaXRpb247XG4gICAgcmV0dXJuIEdBLnNwYXRpYWwuZG90KHhpKSArIEdCLnNwYXRpYWwuZG90KHhqKTtcbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlcyBHKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcclxuICAgKiBAbWV0aG9kIGNvbXB1dGVHV1xyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGNvbXB1dGVHVygpIHtcbiAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTtcbiAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICBjb25zdCBiaSA9IHRoaXMuYmk7XG4gICAgY29uc3QgYmogPSB0aGlzLmJqO1xuICAgIGNvbnN0IHZpID0gYmkudmVsb2NpdHk7XG4gICAgY29uc3QgdmogPSBiai52ZWxvY2l0eTtcbiAgICBjb25zdCB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICBjb25zdCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTtcbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcclxuICAgKiBAbWV0aG9kIGNvbXB1dGVHV2xhbWJkYVxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cblxuXG4gIGNvbXB1dGVHV2xhbWJkYSgpIHtcbiAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTtcbiAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICBjb25zdCBiaSA9IHRoaXMuYmk7XG4gICAgY29uc3QgYmogPSB0aGlzLmJqO1xuICAgIGNvbnN0IHZpID0gYmkudmxhbWJkYTtcbiAgICBjb25zdCB2aiA9IGJqLnZsYW1iZGE7XG4gICAgY29uc3Qgd2kgPSBiaS53bGFtYmRhO1xuICAgIGNvbnN0IHdqID0gYmoud2xhbWJkYTtcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTtcbiAgfVxuXG4gIGNvbXB1dGVHaU1mKCkge1xuICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBO1xuICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuICAgIGNvbnN0IGJpID0gdGhpcy5iaTtcbiAgICBjb25zdCBiaiA9IHRoaXMuYmo7XG4gICAgY29uc3QgZmkgPSBiaS5mb3JjZTtcbiAgICBjb25zdCB0aSA9IGJpLnRvcnF1ZTtcbiAgICBjb25zdCBmaiA9IGJqLmZvcmNlO1xuICAgIGNvbnN0IHRqID0gYmoudG9ycXVlO1xuICAgIGNvbnN0IGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlO1xuICAgIGNvbnN0IGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlO1xuICAgIGZpLnNjYWxlKGludk1hc3NpLCBpTWZpKTtcbiAgICBmai5zY2FsZShpbnZNYXNzaiwgaU1maik7XG4gICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGksIGludklpX3ZtdWx0X3RhdWkpO1xuICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRqLCBpbnZJal92bXVsdF90YXVqKTtcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksIGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosIGludklqX3ZtdWx0X3RhdWopO1xuICB9XG5cbiAgY29tcHV0ZUdpTUd0KCkge1xuICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBO1xuICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuICAgIGNvbnN0IGJpID0gdGhpcy5iaTtcbiAgICBjb25zdCBiaiA9IHRoaXMuYmo7XG4gICAgY29uc3QgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmU7XG4gICAgY29uc3QgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XG4gICAgY29uc3QgaW52SWkgPSBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZTtcbiAgICBjb25zdCBpbnZJaiA9IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlO1xuICAgIGxldCByZXN1bHQgPSBpbnZNYXNzaSArIGludk1hc3NqO1xuICAgIGludklpLnZtdWx0KEdBLnJvdGF0aW9uYWwsIHRtcCQxKTtcbiAgICByZXN1bHQgKz0gdG1wJDEuZG90KEdBLnJvdGF0aW9uYWwpO1xuICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRtcCQxKTtcbiAgICByZXN1bHQgKz0gdG1wJDEuZG90KEdCLnJvdGF0aW9uYWwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGNvbnN0cmFpbnQgdmVsb2NpdHkgdG8gdGhlIGJvZGllcy5cclxuICAgKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxyXG4gICAqL1xuXG5cbiAgYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKSB7XG4gICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7XG4gICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG4gICAgY29uc3QgYmkgPSB0aGlzLmJpO1xuICAgIGNvbnN0IGJqID0gdGhpcy5iajtcbiAgICBjb25zdCB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7IC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHlcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcblxuICAgIGJpLnZsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGJpLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLCBHQS5zcGF0aWFsLCBiaS52bGFtYmRhKTtcbiAgICBiai52bGFtYmRhLmFkZFNjYWxlZFZlY3Rvcihiai5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgR0Iuc3BhdGlhbCwgYmoudmxhbWJkYSk7IC8vIEFkZCB0byBhbmd1bGFyIHZlbG9jaXR5XG5cbiAgICBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChHQS5yb3RhdGlvbmFsLCB0ZW1wKTtcbiAgICBiaS53bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihkZWx0YWxhbWJkYSwgdGVtcCwgYmkud2xhbWJkYSk7XG4gICAgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Iucm90YXRpb25hbCwgdGVtcCk7XG4gICAgYmoud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IoZGVsdGFsYW1iZGEsIHRlbXAsIGJqLndsYW1iZGEpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHNcclxuICAgKiBAbWV0aG9kIGNvbXB1dGVJbnZDXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBlcHNcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICovXG5cblxuICBjb21wdXRlQygpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlR2lNR3QoKSArIHRoaXMuZXBzO1xuICB9XG5cbn1cbkVxdWF0aW9uLmlkID0gMDtcbi8qKlxyXG4gKiBDb21wdXRlcyBHKmludihNKSpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLlxyXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1mXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXG5cbmNvbnN0IGlNZmkgPSBuZXcgVmVjMygpO1xuY29uc3QgaU1maiA9IG5ldyBWZWMzKCk7XG5jb25zdCBpbnZJaV92bXVsdF90YXVpID0gbmV3IFZlYzMoKTtcbmNvbnN0IGludklqX3ZtdWx0X3RhdWogPSBuZXcgVmVjMygpO1xuLyoqXHJcbiAqIENvbXB1dGVzIEcqaW52KE0pKkcnXHJcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXG5cbmNvbnN0IHRtcCQxID0gbmV3IFZlYzMoKTtcbmNvbnN0IGFkZFRvV2xhbWJkYV90ZW1wID0gbmV3IFZlYzMoKTtcblxuLyoqXHJcbiAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cclxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQGV4dGVuZHMgRXF1YXRpb25cclxuICovXG5jbGFzcyBDb250YWN0RXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7XG4gIC8vIFwiYm91bmNpbmVzc1wiOiB1MSA9IC1lKnUwXG4gIC8vIFdvcmxkLW9yaWVudGVkIHZlY3RvciB0aGF0IGdvZXMgZnJvbSB0aGUgY2VudGVyIG9mIGJpIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAvLyBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBzdGFydHMgaW4gYm9keSBqIHBvc2l0aW9uIGFuZCBnb2VzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAvLyBDb250YWN0IG5vcm1hbCwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaS5cbiAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBtYXhGb3JjZSA9IDFlNikge1xuICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgMCwgbWF4Rm9yY2UpO1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7XG4gICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5yaiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5uaSA9IG5ldyBWZWMzKCk7XG4gIH1cblxuICBjb21wdXRlQihoKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGJpID0gdGhpcy5iaTtcbiAgICBjb25zdCBiaiA9IHRoaXMuYmo7XG4gICAgY29uc3QgcmkgPSB0aGlzLnJpO1xuICAgIGNvbnN0IHJqID0gdGhpcy5yajtcbiAgICBjb25zdCByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxO1xuICAgIGNvbnN0IHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDI7XG4gICAgY29uc3QgdmkgPSBiaS52ZWxvY2l0eTtcbiAgICBjb25zdCB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICBjb25zdCBmaSA9IGJpLmZvcmNlO1xuICAgIGNvbnN0IHRhdWkgPSBiaS50b3JxdWU7XG4gICAgY29uc3QgdmogPSBiai52ZWxvY2l0eTtcbiAgICBjb25zdCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICBjb25zdCBmaiA9IGJqLmZvcmNlO1xuICAgIGNvbnN0IHRhdWogPSBiai50b3JxdWU7XG4gICAgY29uc3QgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDM7XG4gICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7XG4gICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG4gICAgY29uc3QgbiA9IHRoaXMubmk7IC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuXG4gICAgcmkuY3Jvc3Mobiwgcml4bik7XG4gICAgcmouY3Jvc3Mobiwgcmp4bik7IC8vIGcgPSB4aityaiAtKHhpK3JpKVxuICAgIC8vIEcgPSBbIC1uaSAgLXJpeG4gIG5pICByanhuIF1cblxuICAgIG4ubmVnYXRlKEdBLnNwYXRpYWwpO1xuICAgIHJpeG4ubmVnYXRlKEdBLnJvdGF0aW9uYWwpO1xuICAgIEdCLnNwYXRpYWwuY29weShuKTtcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkocmp4bik7IC8vIENhbGN1bGF0ZSB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXG5cbiAgICBwZW5ldHJhdGlvblZlYy5jb3B5KGJqLnBvc2l0aW9uKTtcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLCBwZW5ldHJhdGlvblZlYyk7XG4gICAgcGVuZXRyYXRpb25WZWMudnN1YihiaS5wb3NpdGlvbiwgcGVuZXRyYXRpb25WZWMpO1xuICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIocmksIHBlbmV0cmF0aW9uVmVjKTtcbiAgICBjb25zdCBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpOyAvLyBDb21wdXRlIGl0ZXJhdGlvblxuXG4gICAgY29uc3QgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTtcbiAgICBjb25zdCBHVyA9IGVQbHVzT25lICogdmouZG90KG4pIC0gZVBsdXNPbmUgKiB2aS5kb3QobikgKyB3ai5kb3Qocmp4bikgLSB3aS5kb3Qocml4bik7XG4gICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7XG4gICAgcmV0dXJuIEI7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IHJlbGF0aXZlIHZlbG9jaXR5IGluIHRoZSBjb250YWN0IHBvaW50LlxyXG4gICAqIEBtZXRob2QgZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbFxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cblxuXG4gIGdldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWwoKSB7XG4gICAgY29uc3QgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTtcbiAgICBjb25zdCB2aiA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqO1xuICAgIGNvbnN0IHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XG4gICAgY29uc3QgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajtcbiAgICBjb25zdCByZWxWZWwgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWw7XG4gICAgdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIHhpKTtcbiAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopO1xuICAgIHRoaXMuYmkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGksIHZpKTtcbiAgICB0aGlzLmJqLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhqLCB2aik7XG4gICAgdmkudnN1Yih2aiwgcmVsVmVsKTtcbiAgICByZXR1cm4gdGhpcy5uaS5kb3QocmVsVmVsKTtcbiAgfVxuXG59XG5jb25zdCBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnNcblxuY29uc3QgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTtcbmNvbnN0IENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMyA9IG5ldyBWZWMzKCk7XG5jb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aSA9IG5ldyBWZWMzKCk7XG5jb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aiA9IG5ldyBWZWMzKCk7XG5jb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XG5jb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aiA9IG5ldyBWZWMzKCk7XG5jb25zdCBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF9yZWxWZWwgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLlxyXG4gKiBAY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUIgQm9keSB0aGF0IHdpbGwgYmUgY29uc3RyYWluZWQgaW4gYSBzaW1pbGFyIHdheSB0byB0aGUgc2FtZSBwb2ludCBhcyBib2R5QS4gV2Ugd2lsbCB0aGVyZWZvcmUgZ2V0IGEgbGluayBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5Qi4gSWYgbm90IHNwZWNpZmllZCwgYm9keUEgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBhIHN0YXRpYyBwb2ludC5cclxuICogQHBhcmFtIHtWZWMzfSBwaXZvdEIgU2VlIHBpdm90QS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBjb25zdCBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICogICAgIGNvbnN0IGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gKiAgICAgYm9keUEucG9zaXRpb24uc2V0KC0xLCAwLCAwKTtcclxuICogICAgIGJvZHlCLnBvc2l0aW9uLnNldCgxLCAwLCAwKTtcclxuICogICAgIGJvZHlBLmFkZFNoYXBlKHNoYXBlQSk7XHJcbiAqICAgICBib2R5Qi5hZGRTaGFwZShzaGFwZUIpO1xyXG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5QSk7XHJcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlCKTtcclxuICogICAgIGNvbnN0IGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCk7XHJcbiAqICAgICBjb25zdCBsb2NhbFBpdm90QiA9IG5ldyBWZWMzKC0xLCAwLCAwKTtcclxuICogICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSwgbG9jYWxQaXZvdEEsIGJvZHlCLCBsb2NhbFBpdm90Qik7XHJcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gKi9cbmNsYXNzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgZXh0ZW5kcyBDb25zdHJhaW50IHtcbiAgLy8gUGl2b3QsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cbiAgLy8gUGl2b3QsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgY29uc3RydWN0b3IoYm9keUEsIHBpdm90QSA9IG5ldyBWZWMzKCksIGJvZHlCLCBwaXZvdEIgPSBuZXcgVmVjMygpLCBtYXhGb3JjZSA9IDFlNikge1xuICAgIHN1cGVyKGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5waXZvdEEgPSBwaXZvdEEuY2xvbmUoKTtcbiAgICB0aGlzLnBpdm90QiA9IHBpdm90Qi5jbG9uZSgpO1xuICAgIGNvbnN0IHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTtcbiAgICBjb25zdCB5ID0gdGhpcy5lcXVhdGlvblkgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG4gICAgY29uc3QgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpOyAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcblxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgeik7IC8vIE1ha2UgdGhlIGVxdWF0aW9ucyBiaWRpcmVjdGlvbmFsXG5cbiAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeC5tYXhGb3JjZSA9IHkubWF4Rm9yY2UgPSB6Lm1heEZvcmNlID0gbWF4Rm9yY2U7XG4gICAgeC5uaS5zZXQoMSwgMCwgMCk7XG4gICAgeS5uaS5zZXQoMCwgMSwgMCk7XG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIGNvbnN0IGJvZHlCID0gdGhpcy5ib2R5QjtcbiAgICBjb25zdCB4ID0gdGhpcy5lcXVhdGlvblg7XG4gICAgY29uc3QgeSA9IHRoaXMuZXF1YXRpb25ZO1xuICAgIGNvbnN0IHogPSB0aGlzLmVxdWF0aW9uWjsgLy8gUm90YXRlIHRoZSBwaXZvdHMgdG8gd29ybGQgc3BhY2VcblxuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEEsIHgucmkpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEIsIHgucmopO1xuICAgIHkucmkuY29weSh4LnJpKTtcbiAgICB5LnJqLmNvcHkoeC5yaik7XG4gICAgei5yaS5jb3B5KHgucmkpO1xuICAgIHoucmouY29weSh4LnJqKTtcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci5cclxuICogQGNsYXNzIENvbmVFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV0gTG9jYWwgYXhpcyBpbiBBXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdIExvY2FsIGF4aXMgaW4gQlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ2xlXSBUaGUgXCJjb25lIGFuZ2xlXCIgdG8ga2VlcFxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cbmNsYXNzIENvbmVFcXVhdGlvbiBleHRlbmRzIEVxdWF0aW9uIHtcbiAgLy8gVGhlIGNvbmUgYW5nbGUgdG8ga2VlcC5cbiAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgc3VwZXIoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTtcbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZiBvcHRpb25zLmFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuICB9XG5cbiAgY29tcHV0ZUIoaCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgYiA9IHRoaXMuYjtcbiAgICBjb25zdCBuaSA9IHRoaXMuYXhpc0E7XG4gICAgY29uc3QgbmogPSB0aGlzLmF4aXNCO1xuICAgIGNvbnN0IG5peG5qID0gdG1wVmVjMTtcbiAgICBjb25zdCBuanhuaSA9IHRtcFZlYzI7XG4gICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7XG4gICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7IC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuXG4gICAgbmkuY3Jvc3MobmosIG5peG5qKTtcbiAgICBuai5jcm9zcyhuaSwgbmp4bmkpOyAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOlxuICAgIC8vIGNvcyh0aGV0YSkgPSBhICogYiAvIChsZW5ndGgoYSkgKiBsZW5ndGgoYikgPSB7IGxlbihhKSA9IGxlbihiKSA9IDEgfSA9IGEgKiBiXG4gICAgLy8gZyA9IGEgKiBiXG4gICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3alxuICAgIC8vIEcgPSBbMCBieGEgMCBheGJdXG4gICAgLy8gVyA9IFt2aSB3aSB2aiB3al1cblxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcbiAgICBjb25zdCBnID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLSBuaS5kb3QobmopO1xuICAgIGNvbnN0IEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIGNvbnN0IEIgPSAtZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcbiAgICByZXR1cm4gQjtcbiAgfVxuXG59XG5jb25zdCB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogUm90YXRpb25hbCBjb25zdHJhaW50LiBXb3JrcyB0byBrZWVwIHRoZSBsb2NhbCB2ZWN0b3JzIG9ydGhvZ29uYWwgdG8gZWFjaCBvdGhlciBpbiB3b3JsZCBzcGFjZS5cclxuICogQGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxyXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gKi9cbmNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvbiBleHRlbmRzIEVxdWF0aW9uIHtcbiAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgc3VwZXIoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTtcbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG4gICAgdGhpcy5tYXhBbmdsZSA9IE1hdGguUEkgLyAyO1xuICB9XG5cbiAgY29tcHV0ZUIoaCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgYiA9IHRoaXMuYjtcbiAgICBjb25zdCBuaSA9IHRoaXMuYXhpc0E7XG4gICAgY29uc3QgbmogPSB0aGlzLmF4aXNCO1xuICAgIGNvbnN0IG5peG5qID0gdG1wVmVjMSQxO1xuICAgIGNvbnN0IG5qeG5pID0gdG1wVmVjMiQxO1xuICAgIGNvbnN0IEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBO1xuICAgIGNvbnN0IEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCOyAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcblxuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTsgLy8gZyA9IG5pICogbmpcbiAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3alxuICAgIC8vIEcgPSBbMCBuanhuaSAwIG5peG5qXVxuICAgIC8vIFcgPSBbdmkgd2kgdmogd2pdXG5cbiAgICBHQS5yb3RhdGlvbmFsLmNvcHkobmp4bmkpO1xuICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7XG4gICAgY29uc3QgZyA9IE1hdGguY29zKHRoaXMubWF4QW5nbGUpIC0gbmkuZG90KG5qKTtcbiAgICBjb25zdCBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICBjb25zdCBCID0gLWcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7XG4gICAgcmV0dXJuIEI7XG4gIH1cblxufVxuY29uc3QgdG1wVmVjMSQxID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRtcFZlYzIkMSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxyXG4gKiBAY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXHJcbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcclxuICovXG5jbGFzcyBDb25lVHdpc3RDb25zdHJhaW50IGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludCB7XG4gIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgbWF4Rm9yY2UgPSB0eXBlb2Ygb3B0aW9ucy5tYXhGb3JjZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2OyAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlblxuXG4gICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICBjb25zdCBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHN1cGVyKGJvZHlBLCBwaXZvdEEsIGJvZHlCLCBwaXZvdEIsIG1heEZvcmNlKTtcbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9ICEhb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy5hbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcbiAgICBjb25zdCBjID0gdGhpcy5jb25lRXF1YXRpb24gPSBuZXcgQ29uZUVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG4gICAgY29uc3QgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcbiAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Ygb3B0aW9ucy50d2lzdEFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMudHdpc3RBbmdsZSA6IDA7IC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxuXG4gICAgYy5tYXhGb3JjZSA9IDA7XG4gICAgYy5taW5Gb3JjZSA9IC1tYXhGb3JjZTsgLy8gTWFrZSB0aGUgdHdpc3QgZXF1YXRpb24gYWRkIHRvcnF1ZSB0b3dhcmQgdGhlIGluaXRpYWwgcG9zaXRpb25cblxuICAgIHQubWF4Rm9yY2UgPSAwO1xuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChjLCB0KTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIGNvbnN0IGNvbmUgPSB0aGlzLmNvbmVFcXVhdGlvbjtcbiAgICBjb25zdCB0d2lzdCA9IHRoaXMudHdpc3RFcXVhdGlvbjtcbiAgICBzdXBlci51cGRhdGUoKTsgLy8gVXBkYXRlIHRoZSBheGVzIHRvIHRoZSBjb25lIGNvbnN0cmFpbnRcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLCBjb25lLmF4aXNBKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQiwgY29uZS5heGlzQik7IC8vIFVwZGF0ZSB0aGUgd29ybGQgYXhlcyBpbiB0aGUgdHdpc3QgY29uc3RyYWludFxuXG4gICAgdGhpcy5heGlzQS50YW5nZW50cyh0d2lzdC5heGlzQSwgdHdpc3QuYXhpc0EpO1xuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0d2lzdC5heGlzQSwgdHdpc3QuYXhpc0EpO1xuICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcbiAgICBjb25lLmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICB0d2lzdC5tYXhBbmdsZSA9IHRoaXMudHdpc3RBbmdsZTtcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBDb25zdHJhaW5zIHR3byBib2RpZXMgdG8gYmUgYXQgYSBjb25zdGFudCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXJzIGNlbnRlciBvZiBtYXNzLlxyXG4gKiBAY2xhc3MgRGlzdGFuY2VDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2Rpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcC4gSWYgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW21heEZvcmNlPTFlNl1cclxuICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gKi9cbmNsYXNzIERpc3RhbmNlQ29uc3RyYWludCBleHRlbmRzIENvbnN0cmFpbnQge1xuICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIGRpc3RhbmNlLCBtYXhGb3JjZSA9IDFlNikge1xuICAgIHN1cGVyKGJvZHlBLCBib2R5Qik7XG5cbiAgICBpZiAodHlwZW9mIGRpc3RhbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGlzdGFuY2UgPSBib2R5QS5wb3NpdGlvbi5kaXN0YW5jZVRvKGJvZHlCLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY29uc3QgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7IC8vIE1ha2UgaXQgYmlkaXJlY3Rpb25hbFxuXG4gICAgZXEubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgZXEubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIGNvbnN0IGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uO1xuICAgIGNvbnN0IGhhbGZEaXN0ID0gdGhpcy5kaXN0YW5jZSAqIDAuNTtcbiAgICBjb25zdCBub3JtYWwgPSBlcS5uaTtcbiAgICBib2R5Qi5wb3NpdGlvbi52c3ViKGJvZHlBLnBvc2l0aW9uLCBub3JtYWwpO1xuICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICBub3JtYWwuc2NhbGUoaGFsZkRpc3QsIGVxLnJpKTtcbiAgICBub3JtYWwuc2NhbGUoLWhhbGZEaXN0LCBlcS5yaik7XG4gIH1cblxufVxuXG4vKipcclxuICogTG9jayBjb25zdHJhaW50LiBXaWxsIHJlbW92ZSBhbGwgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGJvZGllcy5cclxuICogQGNsYXNzIExvY2tDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXHJcbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcclxuICovXG5jbGFzcyBMb2NrQ29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQge1xuICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG1heEZvcmNlID0gdHlwZW9mIG9wdGlvbnMubWF4Rm9yY2UgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjsgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cblxuICAgIGNvbnN0IHBpdm90QSA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgcGl2b3RCID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBoYWxmV2F5ID0gbmV3IFZlYzMoKTtcbiAgICBib2R5QS5wb3NpdGlvbi52YWRkKGJvZHlCLnBvc2l0aW9uLCBoYWxmV2F5KTtcbiAgICBoYWxmV2F5LnNjYWxlKDAuNSwgaGFsZldheSk7XG4gICAgYm9keUIucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RCKTtcbiAgICBib2R5QS5wb2ludFRvTG9jYWxGcmFtZShoYWxmV2F5LCBwaXZvdEEpOyAvLyBUaGUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludCB3aWxsIGtlZXAgYSBwb2ludCBzaGFyZWQgYmV0d2VlbiB0aGUgYm9kaWVzXG5cbiAgICBzdXBlcihib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7IC8vIFN0b3JlIGluaXRpYWwgcm90YXRpb24gb2YgdGhlIGJvZGllcyBhcyB1bml0IHZlY3RvcnMgaW4gdGhlIGxvY2FsIGJvZHkgc3BhY2VzXG5cbiAgICB0aGlzLnhBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9YKTtcbiAgICB0aGlzLnhCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9YKTtcbiAgICB0aGlzLnlBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcbiAgICB0aGlzLnlCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9ZKTtcbiAgICB0aGlzLnpBID0gYm9keUEudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTtcbiAgICB0aGlzLnpCID0gYm9keUIudmVjdG9yVG9Mb2NhbEZyYW1lKFZlYzMuVU5JVF9aKTsgLy8gLi4uYW5kIHRoZSBmb2xsb3dpbmcgcm90YXRpb25hbCBlcXVhdGlvbnMgd2lsbCBrZWVwIGFsbCByb3RhdGlvbmFsIERPRidzIGluIHBsYWNlXG5cbiAgICBjb25zdCByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcbiAgICBjb25zdCByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcbiAgICBjb25zdCByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICBjb25zdCBib2R5QiA9IHRoaXMuYm9keUI7XG4gICAgY29uc3QgbW90b3IgPSB0aGlzLm1vdG9yRXF1YXRpb247XG4gICAgY29uc3QgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjE7XG4gICAgY29uc3QgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjI7XG4gICAgY29uc3QgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjM7XG4gICAgc3VwZXIudXBkYXRlKCk7IC8vIFRoZXNlIHZlY3RvciBwYWlycyBtdXN0IGJlIG9ydGhvZ29uYWxcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhBLCByMS5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMueUIsIHIxLmF4aXNCKTtcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy55QSwgcjIuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpCLCByMi5heGlzQik7XG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuekEsIHIzLmF4aXNBKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy54QiwgcjMuYXhpc0IpO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIFJvdGF0aW9uYWwgbW90b3IgY29uc3RyYWludC4gVHJpZXMgdG8ga2VlcCB0aGUgcmVsYXRpdmUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9kaWVzIHRvIGEgZ2l2ZW4gdmFsdWUuXHJcbiAqIEBjbGFzcyBSb3RhdGlvbmFsTW90b3JFcXVhdGlvblxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXHJcbiAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAqL1xuY2xhc3MgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gZXh0ZW5kcyBFcXVhdGlvbiB7XG4gIC8vIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpcy5cbiAgLy8gV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzLlxuICAvLyBNb3RvciB2ZWxvY2l0eS5cbiAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBtYXhGb3JjZSA9IDFlNikge1xuICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7XG4gICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5heGlzQiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50YXJnZXRWZWxvY2l0eSA9IDA7XG4gIH1cblxuICBjb21wdXRlQihoKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGJpID0gdGhpcy5iaTtcbiAgICBjb25zdCBiaiA9IHRoaXMuYmo7XG4gICAgY29uc3QgYXhpc0EgPSB0aGlzLmF4aXNBO1xuICAgIGNvbnN0IGF4aXNCID0gdGhpcy5heGlzQjtcbiAgICBjb25zdCBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QTtcbiAgICBjb25zdCBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjsgLy8gZyA9IDBcbiAgICAvLyBnZG90ID0gYXhpc0EgKiB3aSAtIGF4aXNCICogd2pcbiAgICAvLyBnZG90ID0gRyAqIFcgPSBHICogW3ZpIHdpIHZqIHdqXVxuICAgIC8vID0+XG4gICAgLy8gRyA9IFswIGF4aXNBIDAgLWF4aXNCXVxuXG4gICAgR0Eucm90YXRpb25hbC5jb3B5KGF4aXNBKTtcbiAgICBheGlzQi5uZWdhdGUoR0Iucm90YXRpb25hbCk7XG4gICAgY29uc3QgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eTtcbiAgICBjb25zdCBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIGNvbnN0IEIgPSAtR1cgKiBiIC0gaCAqIEdpTWY7XG4gICAgcmV0dXJuIEI7XG4gIH1cblxufVxuXG4vKipcclxuICogSGluZ2UgY29uc3RyYWludC4gVGhpbmsgb2YgaXQgYXMgYSBkb29yIGhpbmdlLiBJdCB0cmllcyB0byBrZWVwIHRoZSBkb29yIGluIHRoZSBjb3JyZWN0IHBsYWNlIGFuZCB3aXRoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxyXG4gKiBAY2xhc3MgSGluZ2VDb25zdHJhaW50XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RBXSBBIHBvaW50IGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS4gVGhpcyBkZWZpbmVzIHRoZSBvZmZzZXQgb2YgYXhpc0EuXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIEFuIGF4aXMgdGhhdCBib2R5QSBjYW4gcm90YXRlIGFyb3VuZCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90Ql1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cclxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxyXG4gKi9cbmNsYXNzIEhpbmdlQ29uc3RyYWludCBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnQge1xuICAvLyBSb3RhdGlvbiBheGlzLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuXG4gIC8vIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgY29uc3RydWN0b3IoYm9keUEsIGJvZHlCLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtYXhGb3JjZSA9IHR5cGVvZiBvcHRpb25zLm1heEZvcmNlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgY29uc3QgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICBjb25zdCBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHN1cGVyKGJvZHlBLCBwaXZvdEEsIGJvZHlCLCBwaXZvdEIsIG1heEZvcmNlKTtcbiAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7XG4gICAgYXhpc0Eubm9ybWFsaXplKCk7XG4gICAgY29uc3QgYXhpc0IgPSB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIGF4aXNCLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9ICEhb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuICAgIGNvbnN0IHJvdGF0aW9uYWwxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJvdGF0aW9uYWwyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpO1xuICAgIG1vdG9yLmVuYWJsZWQgPSBmYWxzZTsgLy8gTm90IGVuYWJsZWQgYnkgZGVmYXVsdFxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3RhdGlvbmFsMSwgcm90YXRpb25hbDIsIG1vdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIGVuYWJsZU1vdG9yXHJcbiAgICovXG5cblxuICBlbmFibGVNb3RvcigpIHtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICAgKi9cblxuXG4gIGRpc2FibGVNb3RvcigpIHtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxyXG4gICAqL1xuXG5cbiAgc2V0TW90b3JTcGVlZChzcGVlZCkge1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eSA9IHNwZWVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2Qgc2V0TW90b3JNYXhGb3JjZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZVxyXG4gICAqL1xuXG5cbiAgc2V0TW90b3JNYXhGb3JjZShtYXhGb3JjZSkge1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIGNvbnN0IG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uO1xuICAgIGNvbnN0IHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xO1xuICAgIGNvbnN0IHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yO1xuICAgIGNvbnN0IHdvcmxkQXhpc0EgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzE7XG4gICAgY29uc3Qgd29ybGRBeGlzQiA9IEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMjtcbiAgICBjb25zdCBheGlzQSA9IHRoaXMuYXhpc0E7XG4gICAgY29uc3QgYXhpc0IgPSB0aGlzLmF4aXNCO1xuICAgIHN1cGVyLnVwZGF0ZSgpOyAvLyBHZXQgd29ybGQgYXhlc1xuXG4gICAgYm9keUEucXVhdGVybmlvbi52bXVsdChheGlzQSwgd29ybGRBeGlzQSk7XG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7XG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xuICAgIHIxLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XG4gICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcblxuICAgIGlmICh0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCkge1xuICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNBLCBtb3Rvci5heGlzQSk7XG4gICAgICBib2R5Qi5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMuYXhpc0IsIG1vdG9yLmF4aXNCKTtcbiAgICB9XG4gIH1cblxufVxuY29uc3QgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbmNvbnN0IEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxyXG4gKiBDb25zdHJhaW5zIHRoZSBzbGlwcGluZyBpbiBhIGNvbnRhY3QgYWxvbmcgYSB0YW5nZW50XHJcbiAqIEBjbGFzcyBGcmljdGlvbkVxdWF0aW9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlIHNob3VsZCBiZSArLUZfZnJpY3Rpb24gPSArLW11ICogRl9ub3JtYWwgPSArLW11ICogbSAqIGdcclxuICogQGV4dGVuZHMgRXF1YXRpb25cclxuICovXG5jbGFzcyBGcmljdGlvbkVxdWF0aW9uIGV4dGVuZHMgRXF1YXRpb24ge1xuICAvLyBUYW5nZW50LlxuICBjb25zdHJ1Y3Rvcihib2R5QSwgYm9keUIsIHNsaXBGb3JjZSkge1xuICAgIHN1cGVyKGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTtcbiAgICB0aGlzLnJpID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnQgPSBuZXcgVmVjMygpO1xuICB9XG5cbiAgY29tcHV0ZUIoaCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgY29uc3QgYiA9IHRoaXMuYjtcbiAgICBjb25zdCBiaSA9IHRoaXMuYmk7XG4gICAgY29uc3QgYmogPSB0aGlzLmJqO1xuICAgIGNvbnN0IHJpID0gdGhpcy5yaTtcbiAgICBjb25zdCByaiA9IHRoaXMucmo7XG4gICAgY29uc3Qgcml4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDE7XG4gICAgY29uc3Qgcmp4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDI7XG4gICAgY29uc3QgdCA9IHRoaXMudDsgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG5cbiAgICByaS5jcm9zcyh0LCByaXh0KTtcbiAgICByai5jcm9zcyh0LCByanh0KTsgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdXG4gICAgLy8gQW5kIHJlbWVtYmVyLCB0aGlzIGlzIGEgcHVyZSB2ZWxvY2l0eSBjb25zdHJhaW50LCBnIGlzIGFsd2F5cyB6ZXJvIVxuXG4gICAgY29uc3QgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEE7XG4gICAgY29uc3QgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG4gICAgdC5uZWdhdGUoR0Euc3BhdGlhbCk7XG4gICAgcml4dC5uZWdhdGUoR0Eucm90YXRpb25hbCk7XG4gICAgR0Iuc3BhdGlhbC5jb3B5KHQpO1xuICAgIEdCLnJvdGF0aW9uYWwuY29weShyanh0KTtcbiAgICBjb25zdCBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgY29uc3QgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICBjb25zdCBCID0gLUdXICogYiAtIGggKiBHaU1mO1xuICAgIHJldHVybiBCO1xuICB9XG5cbn1cbmNvbnN0IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpO1xuY29uc3QgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uPTAuM11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wLjNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uPTNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcz0xZTddXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cbiAqIEB0b2RvIFJlZmFjdG9yIG1hdGVyaWFscyB0byBtYXRlcmlhbEEgYW5kIG1hdGVyaWFsQlxuICovXG5jbGFzcyBDb250YWN0TWF0ZXJpYWwge1xuICAvLyBJZGVudGlmaWVyIG9mIHRoaXMgbWF0ZXJpYWwuXG4gIC8vIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzLlxuICAvLyBGcmljdGlvbiBjb2VmZmljaWVudC5cbiAgLy8gUmVzdGl0dXRpb24gY29lZmZpY2llbnQuXG4gIC8vIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnMuXG4gIC8vIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgY29udGFjdCBlcXVhdGlvbnMuXG4gIC8vIFN0aWZmbmVzcyBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAvLyBSZWxheGF0aW9uIHRpbWUgb2YgdGhlIHByb2R1Y2VkIGZyaWN0aW9uIGVxdWF0aW9uc1xuICBjb25zdHJ1Y3RvcihtMSwgbTIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgIHJlc3RpdHV0aW9uOiAwLjMsXG4gICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogM1xuICAgIH0pO1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG4gICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTtcbiAgICB0aGlzLmZyaWN0aW9uID0gb3B0aW9ucy5mcmljdGlvbjtcbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gb3B0aW9ucy5yZXN0aXR1dGlvbjtcbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzO1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjtcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MgPSBvcHRpb25zLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M7XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247XG4gIH1cblxufVxuQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cclxuICogQGNsYXNzIE1hdGVyaWFsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBhdXRob3Igc2NodGVwcGVcclxuICovXG5jbGFzcyBNYXRlcmlhbCB7XG4gIC8vIE1hdGVyaWFsIG5hbWUuXG4gIC8vIE1hdGVyaWFsIGlkLlxuICAvLyBGcmljdGlvbiBmb3IgdGhpcyBtYXRlcmlhbC4gSWYgbm9uLW5lZ2F0aXZlLCBpdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZnJpY3Rpb24gZ2l2ZW4gYnkgQ29udGFjdE1hdGVyaWFscy4gSWYgdGhlcmUncyBubyBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIHRoZSB2YWx1ZSBmcm9tIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsIGluIHRoZSBXb3JsZCB3aWxsIGJlIHVzZWQuXG4gIC8vIFJlc3RpdHV0aW9uIGZvciB0aGlzIG1hdGVyaWFsLiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IG5hbWUgPSAnJzsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZml4XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaWQgPSBNYXRlcmlhbC5pZENvdW50ZXIrKztcbiAgICB0aGlzLmZyaWN0aW9uID0gdHlwZW9mIG9wdGlvbnMuZnJpY3Rpb24gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5mcmljdGlvbiA6IC0xO1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSB0eXBlb2Ygb3B0aW9ucy5yZXN0aXR1dGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogLTE7XG4gIH1cblxufVxuTWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcblxuLyoqXHJcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXHJcbiAqXHJcbiAqIEBjbGFzcyBTcHJpbmdcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzXSAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxMDBcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmddICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxyXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXHJcbiAqIEBwYXJhbSB7VmVjM30gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxyXG4gKi9cbmNsYXNzIFNwcmluZyB7XG4gIC8vIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuXG4gIC8vIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxuICAvLyBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXG4gIC8vIEZpcnN0IGNvbm5lY3RlZCBib2R5LlxuICAvLyBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gIC8vIEFuY2hvciBmb3IgYm9keUEgaW4gbG9jYWwgYm9keUEgY29vcmRpbmF0ZXMuXG4gIC8vIEFuY2hvciBmb3IgYm9keUIgaW4gbG9jYWwgYm9keUIgY29vcmRpbmF0ZXMuXG4gIGNvbnN0cnVjdG9yKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5yZXN0TGVuZ3RoID0gdHlwZW9mIG9wdGlvbnMucmVzdExlbmd0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnJlc3RMZW5ndGggOiAxO1xuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3MgfHwgMTAwO1xuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZyB8fCAxO1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IFZlYzMoKTtcblxuICAgIGlmIChvcHRpb25zLmxvY2FsQW5jaG9yQSkge1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuY29weShvcHRpb25zLmxvY2FsQW5jaG9yQSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9jYWxBbmNob3JCKSB7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53b3JsZEFuY2hvckEpIHtcbiAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JBKG9wdGlvbnMud29ybGRBbmNob3JBKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53b3JsZEFuY2hvckIpIHtcbiAgICAgIHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxyXG4gICAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JBXHJcbiAgICovXG5cblxuICBzZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKSB7XG4gICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsIHRoaXMubG9jYWxBbmNob3JBKTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXHJcbiAgICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckJcclxuICAgKi9cblxuXG4gIHNldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpIHtcbiAgICB0aGlzLmJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQiwgdGhpcy5sb2NhbEFuY2hvckIpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICovXG5cblxuICBnZXRXb3JsZEFuY2hvckEocmVzdWx0KSB7XG4gICAgdGhpcy5ib2R5QS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSwgcmVzdWx0KTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXHJcbiAgICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAqL1xuXG5cbiAgZ2V0V29ybGRBbmNob3JCKHJlc3VsdCkge1xuICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHJlc3VsdCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cclxuICAgKiBAbWV0aG9kIGFwcGx5Rm9yY2VcclxuICAgKi9cblxuXG4gIGFwcGx5Rm9yY2UoKSB7XG4gICAgY29uc3QgayA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIGNvbnN0IGQgPSB0aGlzLmRhbXBpbmc7XG4gICAgY29uc3QgbCA9IHRoaXMucmVzdExlbmd0aDtcbiAgICBjb25zdCBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgY29uc3QgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIGNvbnN0IHIgPSBhcHBseUZvcmNlX3I7XG4gICAgY29uc3Qgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQ7XG4gICAgY29uc3QgdSA9IGFwcGx5Rm9yY2VfdTtcbiAgICBjb25zdCBmID0gYXBwbHlGb3JjZV9mO1xuICAgIGNvbnN0IHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuICAgIGNvbnN0IHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBO1xuICAgIGNvbnN0IHdvcmxkQW5jaG9yQiA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCO1xuICAgIGNvbnN0IHJpID0gYXBwbHlGb3JjZV9yaTtcbiAgICBjb25zdCByaiA9IGFwcGx5Rm9yY2Vfcmo7XG4gICAgY29uc3QgcmlfeF9mID0gYXBwbHlGb3JjZV9yaV94X2Y7XG4gICAgY29uc3QgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7IC8vIEdldCB3b3JsZCBhbmNob3JzXG5cbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JCKHdvcmxkQW5jaG9yQik7IC8vIEdldCBvZmZzZXQgcG9pbnRzXG5cbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbiwgcmkpO1xuICAgIHdvcmxkQW5jaG9yQi52c3ViKGJvZHlCLnBvc2l0aW9uLCByaik7IC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xuXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLCByKTtcbiAgICBjb25zdCBybGVuID0gci5sZW5ndGgoKTtcbiAgICByX3VuaXQuY29weShyKTtcbiAgICByX3VuaXQubm9ybWFsaXplKCk7IC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcblxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksIHUpOyAvLyBBZGQgcm90YXRpb25hbCB2ZWxvY2l0eVxuXG4gICAgYm9keUIuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJqLCB0bXApO1xuICAgIHUudmFkZCh0bXAsIHUpO1xuICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaSwgdG1wKTtcbiAgICB1LnZzdWIodG1wLCB1KTsgLy8gRiA9IC0gayAqICggeCAtIEwgKSAtIEQgKiAoIHUgKVxuXG4gICAgcl91bml0LnNjYWxlKC1rICogKHJsZW4gLSBsKSAtIGQgKiB1LmRvdChyX3VuaXQpLCBmKTsgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcblxuICAgIGJvZHlBLmZvcmNlLnZzdWIoZiwgYm9keUEuZm9yY2UpO1xuICAgIGJvZHlCLmZvcmNlLnZhZGQoZiwgYm9keUIuZm9yY2UpOyAvLyBBbmd1bGFyIGZvcmNlXG5cbiAgICByaS5jcm9zcyhmLCByaV94X2YpO1xuICAgIHJqLmNyb3NzKGYsIHJqX3hfZik7XG4gICAgYm9keUEudG9ycXVlLnZzdWIocmlfeF9mLCBib2R5QS50b3JxdWUpO1xuICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZiwgYm9keUIudG9ycXVlKTtcbiAgfVxuXG59XG5jb25zdCBhcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xuY29uc3QgYXBwbHlGb3JjZV9yX3VuaXQgPSBuZXcgVmVjMygpO1xuY29uc3QgYXBwbHlGb3JjZV91ID0gbmV3IFZlYzMoKTtcbmNvbnN0IGFwcGx5Rm9yY2VfZiA9IG5ldyBWZWMzKCk7XG5jb25zdCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9IG5ldyBWZWMzKCk7XG5jb25zdCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiA9IG5ldyBWZWMzKCk7XG5jb25zdCBhcHBseUZvcmNlX3JpID0gbmV3IFZlYzMoKTtcbmNvbnN0IGFwcGx5Rm9yY2VfcmogPSBuZXcgVmVjMygpO1xuY29uc3QgYXBwbHlGb3JjZV9yaV94X2YgPSBuZXcgVmVjMygpO1xuY29uc3QgYXBwbHlGb3JjZV9yal94X2YgPSBuZXcgVmVjMygpO1xuY29uc3QgYXBwbHlGb3JjZV90bXAgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogQGNsYXNzIFdoZWVsSW5mb1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKlxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbF1cclxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uTG9jYWxdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uV29ybGRdXHJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4bGVXb3JsZF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZXN0TGVuZ3RoPTFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M9MTAwXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb249MTBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvblNsaXA9MTAwMDBdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucm90YXRpb249MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlbHRhUm90YXRpb249MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFN1c3BlbnNpb25Gb3JjZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWw9dHJ1ZV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk9MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25Gb3JjZT0wXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25MZW5ndGg9MF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw9MV1cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZD0tMC4xXVxyXG4gKi9cbmNsYXNzIFdoZWVsSW5mbyB7XG4gIC8vIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cbiAgLy8gU3BlZWQgdG8gYXBwbHkgdG8gdGhlIHdoZWVsIHJvdGF0aW9uIHdoZW4gdGhlIHdoZWVsIGlzIHNsaWRpbmcuXG4gIC8vIElmIHRoZSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkIHNob3VsZCBiZSB1c2VkLlxuICAvLyBDb25uZWN0aW9uIHBvaW50LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keSBmcmFtZS5cbiAgLy8gUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXG4gIC8vIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nLlxuICAvLyBXaGVlbCB3b3JsZCB0cmFuc2Zvcm0uXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWw6IG5ldyBWZWMzKCksXG4gICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQ6IG5ldyBWZWMzKCksXG4gICAgICBkaXJlY3Rpb25Mb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgIGRpcmVjdGlvbldvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgYXhsZUxvY2FsOiBuZXcgVmVjMygpLFxuICAgICAgYXhsZVdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgc3VzcGVuc2lvblJlc3RMZW5ndGg6IDEsXG4gICAgICBzdXNwZW5zaW9uTWF4TGVuZ3RoOiAyLFxuICAgICAgcmFkaXVzOiAxLFxuICAgICAgc3VzcGVuc2lvblN0aWZmbmVzczogMTAwLFxuICAgICAgZGFtcGluZ0NvbXByZXNzaW9uOiAxMCxcbiAgICAgIGRhbXBpbmdSZWxheGF0aW9uOiAxMCxcbiAgICAgIGZyaWN0aW9uU2xpcDogMTAwMDAsXG4gICAgICBzdGVlcmluZzogMCxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgZGVsdGFSb3RhdGlvbjogMCxcbiAgICAgIHJvbGxJbmZsdWVuY2U6IDAuMDEsXG4gICAgICBtYXhTdXNwZW5zaW9uRm9yY2U6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICBpc0Zyb250V2hlZWw6IHRydWUsXG4gICAgICBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb246IDEsXG4gICAgICBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTogMCxcbiAgICAgIHN1c3BlbnNpb25Gb3JjZTogMCxcbiAgICAgIHNsaXBJbmZvOiAwLFxuICAgICAgc2tpZEluZm86IDAsXG4gICAgICBzdXNwZW5zaW9uTGVuZ3RoOiAwLFxuICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcbiAgICAgIHVzZUN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IGZhbHNlLFxuICAgICAgY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogLTAuMVxuICAgIH0pO1xuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICB0aGlzLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgPSBvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ7XG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwuY2xvbmUoKTtcbiAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLmNsb25lKCk7XG4gICAgdGhpcy5kaXJlY3Rpb25Mb2NhbCA9IG9wdGlvbnMuZGlyZWN0aW9uTG9jYWwuY2xvbmUoKTtcbiAgICB0aGlzLmRpcmVjdGlvbldvcmxkID0gb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZC5jbG9uZSgpO1xuICAgIHRoaXMuYXhsZUxvY2FsID0gb3B0aW9ucy5heGxlTG9jYWwuY2xvbmUoKTtcbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XG4gICAgdGhpcy5zdXNwZW5zaW9uUmVzdExlbmd0aCA9IG9wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgdGhpcy5zdXNwZW5zaW9uU3RpZmZuZXNzID0gb3B0aW9ucy5zdXNwZW5zaW9uU3RpZmZuZXNzO1xuICAgIHRoaXMuZGFtcGluZ0NvbXByZXNzaW9uID0gb3B0aW9ucy5kYW1waW5nQ29tcHJlc3Npb247XG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgdGhpcy5mcmljdGlvblNsaXAgPSBvcHRpb25zLmZyaWN0aW9uU2xpcDtcbiAgICB0aGlzLnN0ZWVyaW5nID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwO1xuICAgIHRoaXMucm9sbEluZmx1ZW5jZSA9IG9wdGlvbnMucm9sbEluZmx1ZW5jZTtcbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xuICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwO1xuICAgIHRoaXMuYnJha2UgPSAwO1xuICAgIHRoaXMuaXNGcm9udFdoZWVsID0gb3B0aW9ucy5pc0Zyb250V2hlZWw7XG4gICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxO1xuICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcbiAgICB0aGlzLnNsaXBJbmZvID0gMDtcbiAgICB0aGlzLnNraWRJbmZvID0gMDtcbiAgICB0aGlzLnN1c3BlbnNpb25MZW5ndGggPSAwO1xuICAgIHRoaXMuc2lkZUltcHVsc2UgPSAwO1xuICAgIHRoaXMuZm9yd2FyZEltcHVsc2UgPSAwO1xuICAgIHRoaXMucmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmlzSW5Db250YWN0ID0gZmFsc2U7XG4gIH1cblxuICB1cGRhdGVXaGVlbChjaGFzc2lzKSB7XG4gICAgY29uc3QgcmF5Y2FzdFJlc3VsdCA9IHRoaXMucmF5Y2FzdFJlc3VsdDtcblxuICAgIGlmICh0aGlzLmlzSW5Db250YWN0KSB7XG4gICAgICBjb25zdCBwcm9qZWN0ID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICByYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1YihjaGFzc2lzLnBvc2l0aW9uLCByZWxwb3MpO1xuICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTtcbiAgICAgIGNvbnN0IHByb2pWZWwgPSByYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLmRvdChjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG5cbiAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgdGhpcy5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgdGhpcy5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjAgLyAwLjE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSBwcm9qVmVsICogaW52O1xuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IGludjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90IGluIGNvbnRhY3QgOiBwb3NpdGlvbiB3aGVlbCBpbiBhIG5pY2UgKHJlc3QgbGVuZ3RoKSBwb3NpdGlvblxuICAgICAgcmF5Y2FzdFJlc3VsdC5zdXNwZW5zaW9uTGVuZ3RoID0gdGhpcy5zdXNwZW5zaW9uUmVzdExlbmd0aDtcbiAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICByYXljYXN0UmVzdWx0LmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCByYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTtcbiAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMS4wO1xuICAgIH1cbiAgfVxuXG59XG5jb25zdCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG5jb25zdCByZWxwb3MgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogVmVoaWNsZSBoZWxwZXIgY2xhc3MgdGhhdCBjYXN0cyByYXlzIGZyb20gdGhlIHdoZWVsIHBvc2l0aW9ucyB0b3dhcmRzIHRoZSBncm91bmQgYW5kIGFwcGxpZXMgZm9yY2VzLlxyXG4gKiBAY2xhc3MgUmF5Y2FzdFZlaGljbGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV0gVGhlIGNhciBjaGFzc2lzIGJvZHkuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmluZGV4TGVmdEF4aXNdXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhVcEF4aXNdXHJcbiAqL1xuY2xhc3MgUmF5Y2FzdFZlaGljbGUge1xuICAvLyBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgLy8gSW5kZXggb2YgdGhlIHJpZ2h0IGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgLy8gSW5kZXggb2YgdGhlIGZvcndhcmQgYXhpcywgMD14LCAxPXksIDI9elxuICAvLyBJbmRleCBvZiB0aGUgdXAgYXhpcywgMD14LCAxPXksIDI9elxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4UmlnaHRBeGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhSaWdodEF4aXMgOiAxO1xuICAgIHRoaXMuaW5kZXhGb3J3YXJkQXhpcyA9IHR5cGVvZiBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDtcbiAgICB0aGlzLmluZGV4VXBBeGlzID0gdHlwZW9mIG9wdGlvbnMuaW5kZXhVcEF4aXMgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleFVwQXhpcyA6IDI7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgdGhpcy5wcmVTdGVwQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciA9IDA7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGEgd2hlZWwuIEZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucywgc2VlIFdoZWVsSW5mby5cclxuICAgKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xuXG5cbiAgYWRkV2hlZWwob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaW5mbyA9IG5ldyBXaGVlbEluZm8ob3B0aW9ucyk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLndoZWVsSW5mb3MubGVuZ3RoO1xuICAgIHRoaXMud2hlZWxJbmZvcy5wdXNoKGluZm8pO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXHJcbiAgICogQG1ldGhvZCBzZXRTdGVlcmluZ1ZhbHVlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAgICovXG5cblxuICBzZXRTdGVlcmluZ1ZhbHVlKHZhbHVlLCB3aGVlbEluZGV4KSB7XG4gICAgY29uc3Qgd2hlZWwgPSB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF07XG4gICAgd2hlZWwuc3RlZXJpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXHJcbiAgICogQG1ldGhvZCBhcHBseUVuZ2luZUZvcmNlXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICAgKi9cblxuXG4gIGFwcGx5RW5naW5lRm9yY2UodmFsdWUsIHdoZWVsSW5kZXgpIHtcbiAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uZW5naW5lRm9yY2UgPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIGJyYWtpbmcgZm9yY2Ugb2YgYSB3aGVlbFxyXG4gICAqIEBtZXRob2Qgc2V0QnJha2VcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnJha2VcclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcclxuICAgKi9cblxuXG4gIHNldEJyYWtlKGJyYWtlLCB3aGVlbEluZGV4KSB7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmJyYWtlID0gYnJha2U7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLlxyXG4gICAqIEBtZXRob2QgYWRkVG9Xb3JsZFxyXG4gICAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAgICovXG5cblxuICBhZGRUb1dvcmxkKHdvcmxkKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIHdvcmxkLmFkZEJvZHkodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoYXQudXBkYXRlVmVoaWNsZSh3b3JsZC5kdCk7XG4gICAgfTtcblxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBvbmUgb2YgdGhlIHdoZWVsIGF4bGVzLCB3b3JsZC1vcmllbnRlZC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2QgZ2V0VmVoaWNsZUF4aXNXb3JsZFxyXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGF4aXNJbmRleFxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxyXG4gICAqL1xuXG5cbiAgZ2V0VmVoaWNsZUF4aXNXb3JsZChheGlzSW5kZXgsIHJlc3VsdCkge1xuICAgIHJlc3VsdC5zZXQoYXhpc0luZGV4ID09PSAwID8gMSA6IDAsIGF4aXNJbmRleCA9PT0gMSA/IDEgOiAwLCBheGlzSW5kZXggPT09IDIgPyAxIDogMCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVzdWx0LCByZXN1bHQpO1xuICB9XG5cbiAgdXBkYXRlVmVoaWNsZSh0aW1lU3RlcCkge1xuICAgIGNvbnN0IHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XG4gICAgY29uc3QgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgY29uc3QgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybShpKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgPSAzLjYgKiBjaGFzc2lzQm9keS52ZWxvY2l0eS5sZW5ndGgoKTtcbiAgICBjb25zdCBmb3J3YXJkV29ybGQgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZvcndhcmRXb3JsZCk7XG5cbiAgICBpZiAoZm9yd2FyZFdvcmxkLmRvdChjaGFzc2lzQm9keS52ZWxvY2l0eSkgPCAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgKj0gLTE7XG4gICAgfSAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uXG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN1c3BlbnNpb24odGltZVN0ZXApO1xuICAgIGNvbnN0IGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAvL2FwcGx5IHN1c3BlbnNpb24gZm9yY2VcbiAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgIGxldCBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2U7XG5cbiAgICAgIGlmIChzdXNwZW5zaW9uRm9yY2UgPiB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2UpIHtcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlID0gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlO1xuICAgICAgfVxuXG4gICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLnNjYWxlKHN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwLCBpbXB1bHNlKTtcbiAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xuICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbHBvcyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVGcmljdGlvbih0aW1lU3RlcCk7XG4gICAgY29uc3QgaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgZndkID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCB2ZWwgPSBuZXcgVmVjMygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldOyAvL2NvbnN0IHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAvL3doZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xuXG4gICAgICBjaGFzc2lzQm9keS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQsIHZlbCk7IC8vIEhhY2sgdG8gZ2V0IHRoZSByb3RhdGlvbiBpbiB0aGUgY29ycmVjdCBkaXJlY3Rpb25cblxuICAgICAgbGV0IG0gPSAxO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5kZXhVcEF4aXMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG0gPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHdoZWVsLmlzSW5Db250YWN0KSB7XG4gICAgICAgIHRoaXMuZ2V0VmVoaWNsZUF4aXNXb3JsZCh0aGlzLmluZGV4Rm9yd2FyZEF4aXMsIGZ3ZCk7XG4gICAgICAgIGNvbnN0IHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLnNjYWxlKHByb2osIGhpdE5vcm1hbFdvcmxkU2NhbGVkV2l0aFByb2opO1xuICAgICAgICBmd2QudnN1YihoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qLCBmd2QpO1xuICAgICAgICBjb25zdCBwcm9qMiA9IGZ3ZC5kb3QodmVsKTtcbiAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKSB7XG4gICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xuICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gKHdoZWVsLmVuZ2luZUZvcmNlID4gMCA/IDEgOiAtMSkgKiB3aGVlbC5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkICogdGltZVN0ZXA7XG4gICAgICB9IC8vIExvY2sgd2hlZWxzXG5cblxuICAgICAgaWYgKE1hdGguYWJzKHdoZWVsLmJyYWtlKSA+IE1hdGguYWJzKHdoZWVsLmVuZ2luZUZvcmNlKSkge1xuICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcblxuICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiAqPSAwLjk5OyAvLyBkYW1waW5nIG9mIHJvdGF0aW9uIHdoZW4gbm90IGluIGNvbnRhY3RcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdXNwZW5zaW9uKGRlbHRhVGltZSkge1xuICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICBjb25zdCBjaGFzc2lzTWFzcyA9IGNoYXNzaXNCb2R5Lm1hc3M7XG4gICAgY29uc3Qgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICBjb25zdCBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHdfaXQgPSAwOyB3X2l0IDwgbnVtV2hlZWxzOyB3X2l0KyspIHtcbiAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgaWYgKHdoZWVsLmlzSW5Db250YWN0KSB7XG4gICAgICAgIGxldCBmb3JjZTsgLy8gU3ByaW5nXG5cbiAgICAgICAgY29uc3Qgc3VzcF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aDtcbiAgICAgICAgY29uc3QgY3VycmVudF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICBjb25zdCBsZW5ndGhfZGlmZiA9IHN1c3BfbGVuZ3RoIC0gY3VycmVudF9sZW5ndGg7XG4gICAgICAgIGZvcmNlID0gd2hlZWwuc3VzcGVuc2lvblN0aWZmbmVzcyAqIGxlbmd0aF9kaWZmICogd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOyAvLyBEYW1wZXJcblxuICAgICAgICBjb25zdCBwcm9qZWN0ZWRfcmVsX3ZlbCA9IHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5O1xuICAgICAgICBsZXQgc3VzcF9kYW1waW5nO1xuXG4gICAgICAgIGlmIChwcm9qZWN0ZWRfcmVsX3ZlbCA8IDApIHtcbiAgICAgICAgICBzdXNwX2RhbXBpbmcgPSB3aGVlbC5kYW1waW5nQ29tcHJlc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBmb3JjZSAtPSBzdXNwX2RhbXBpbmcgKiBwcm9qZWN0ZWRfcmVsX3ZlbDtcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzcztcblxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkge1xuICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxyXG4gICAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXHJcbiAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgKi9cblxuXG4gIHJlbW92ZUZyb21Xb3JsZCh3b3JsZCkge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5yZW1vdmVCb2R5KHRoaXMuY2hhc3Npc0JvZHkpO1xuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG4gIH1cblxuICBjYXN0UmF5KHdoZWVsKSB7XG4gICAgY29uc3QgcmF5dmVjdG9yID0gY2FzdFJheV9yYXl2ZWN0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcbiAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgbGV0IGRlcHRoID0gLTE7XG4gICAgY29uc3QgcmF5bGVuID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggKyB3aGVlbC5yYWRpdXM7XG4gICAgd2hlZWwuZGlyZWN0aW9uV29ybGQuc2NhbGUocmF5bGVuLCByYXl2ZWN0b3IpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDtcbiAgICBzb3VyY2UudmFkZChyYXl2ZWN0b3IsIHRhcmdldCk7XG4gICAgY29uc3QgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XG4gICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpOyAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHlcblxuICAgIGNvbnN0IG9sZFN0YXRlID0gY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBmYWxzZTsgLy8gQ2FzdCByYXkgYWdhaW5zdCB3b3JsZFxuXG4gICAgdGhpcy53b3JsZC5yYXlUZXN0KHNvdXJjZSwgdGFyZ2V0LCByYXljYXN0UmVzdWx0KTtcbiAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IG9sZFN0YXRlO1xuICAgIGNvbnN0IG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTtcbiAgICB3aGVlbC5yYXljYXN0UmVzdWx0Lmdyb3VuZE9iamVjdCA9IDA7XG5cbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBkZXB0aCA9IHJheWNhc3RSZXN1bHQuZGlzdGFuY2U7XG4gICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcbiAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGhpdERpc3RhbmNlID0gcmF5Y2FzdFJlc3VsdC5kaXN0YW5jZTtcbiAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBoaXREaXN0YW5jZSAtIHdoZWVsLnJhZGl1czsgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG5cbiAgICAgIGNvbnN0IG1pblN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCAtIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICBjb25zdCBtYXhTdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggKyB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuXG4gICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA8IG1pblN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IG1pblN1c3BlbnNpb25MZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID4gbWF4U3VzcGVuc2lvbkxlbmd0aCkge1xuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWF4U3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZW5vbWluYXRvciA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KHdoZWVsLmRpcmVjdGlvbldvcmxkKTtcbiAgICAgIGNvbnN0IGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuICAgICAgY29uc3QgcHJvalZlbCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuZG90KGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTtcblxuICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHtcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxIC8gMC4xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW52ID0gLTEgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSBwcm9qVmVsICogaW52O1xuICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcHV0IHdoZWVsIGluZm8gYXMgaW4gcmVzdCBwb3NpdGlvblxuICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgMCAqIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcbiAgICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKC0xLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkKTtcbiAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICB1cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKSB7XG4gICAgd2hlZWwuaXNJbkNvbnRhY3QgPSBmYWxzZTtcbiAgICBjb25zdCBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxyXG4gICAqIE5vdGUgd2hlbiByZW5kZXJpbmcgd2hlZWxzOiBkdXJpbmcgZWFjaCBzdGVwLCB3aGVlbCB0cmFuc2Zvcm1zIGFyZSB1cGRhdGVkIEJFRk9SRSB0aGUgY2hhc3NpczsgaWUuIHRoZWlyIHBvc2l0aW9uIGJlY29tZXMgaW52YWxpZCBhZnRlciB0aGUgc3RlcC4gVGh1cyB3aGVuIHlvdSByZW5kZXIgd2hlZWxzLCB5b3UgbXVzdCB1cGRhdGUgd2hlZWwgdHJhbnNmb3JtcyBiZWZvcmUgcmVuZGVyaW5nIHRoZW0uIFNlZSByYXljYXN0VmVoaWNsZSBkZW1vIGZvciBhbiBleGFtcGxlLlxyXG4gICAqIEBtZXRob2QgdXBkYXRlV2hlZWxUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cclxuICAgKi9cblxuXG4gIHVwZGF0ZVdoZWVsVHJhbnNmb3JtKHdoZWVsSW5kZXgpIHtcbiAgICBjb25zdCB1cCA9IHRtcFZlYzQ7XG4gICAgY29uc3QgcmlnaHQgPSB0bXBWZWM1O1xuICAgIGNvbnN0IGZ3ZCA9IHRtcFZlYzY7XG4gICAgY29uc3Qgd2hlZWwgPSB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF07XG4gICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xuICAgIHJpZ2h0LmNvcHkod2hlZWwuYXhsZUxvY2FsKTtcbiAgICB1cC5jcm9zcyhyaWdodCwgZndkKTtcbiAgICBmd2Qubm9ybWFsaXplKCk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7IC8vIFJvdGF0ZSBhcm91bmQgc3RlZXJpbmcgb3ZlciB0aGUgd2hlZWxBeGxlXG5cbiAgICBjb25zdCBzdGVlcmluZyA9IHdoZWVsLnN0ZWVyaW5nO1xuICAgIGNvbnN0IHN0ZWVyaW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICBzdGVlcmluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHVwLCBzdGVlcmluZyk7XG4gICAgY29uc3Qgcm90YXRpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHJvdGF0aW5nT3JuLnNldEZyb21BeGlzQW5nbGUocmlnaHQsIHdoZWVsLnJvdGF0aW9uKTsgLy8gV29ybGQgcm90YXRpb24gb2YgdGhlIHdoZWVsXG5cbiAgICBjb25zdCBxID0gd2hlZWwud29ybGRUcmFuc2Zvcm0ucXVhdGVybmlvbjtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7XG4gICAgcS5tdWx0KHJvdGF0aW5nT3JuLCBxKTtcbiAgICBxLm5vcm1hbGl6ZSgpOyAvLyB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgd2hlZWxcblxuICAgIGNvbnN0IHAgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XG4gICAgcC52YWRkKHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgcCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2Ygb25lIG9mIHRoZSB3aGVlbHNcclxuICAgKiBAbWV0aG9kIGdldFdoZWVsVHJhbnNmb3JtV29ybGRcclxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAgICogQHJldHVybiB7VHJhbnNmb3JtfVxyXG4gICAqL1xuXG5cbiAgZ2V0V2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XS53b3JsZFRyYW5zZm9ybTtcbiAgfVxuXG4gIHVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKSB7XG4gICAgY29uc3Qgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qID0gdXBkYXRlRnJpY3Rpb25fc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qOyAvL2NhbGN1bGF0ZSB0aGUgaW1wdWxzZSwgc28gdGhhdCB0aGUgd2hlZWxzIGRvbid0IG1vdmUgc2lkZXdhcmRzXG5cbiAgICBjb25zdCB3aGVlbEluZm9zID0gdGhpcy53aGVlbEluZm9zO1xuICAgIGNvbnN0IG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoO1xuICAgIGNvbnN0IGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICBjb25zdCBmb3J3YXJkV1MgPSB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1M7XG4gICAgY29uc3QgYXhsZSA9IHVwZGF0ZUZyaWN0aW9uX2F4bGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICBjb25zdCB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICBjb25zdCBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gMDtcbiAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcblxuICAgICAgaWYgKCFmb3J3YXJkV1NbaV0pIHtcbiAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFheGxlW2ldKSB7XG4gICAgICAgIGF4bGVbaV0gPSBuZXcgVmVjMygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgIGNvbnN0IGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xuICAgICAgICBjb25zdCBheGxlaSA9IGF4bGVbaV07XG4gICAgICAgIGNvbnN0IHdoZWVsVHJhbnMgPSB0aGlzLmdldFdoZWVsVHJhbnNmb3JtV29ybGQoaSk7IC8vIEdldCB3b3JsZCBheGxlXG5cbiAgICAgICAgd2hlZWxUcmFucy52ZWN0b3JUb1dvcmxkRnJhbWUoZGlyZWN0aW9uc1t0aGlzLmluZGV4UmlnaHRBeGlzXSwgYXhsZWkpO1xuICAgICAgICBjb25zdCBzdXJmTm9ybWFsV1MgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkO1xuICAgICAgICBjb25zdCBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7XG4gICAgICAgIHN1cmZOb3JtYWxXUy5zY2FsZShwcm9qLCBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2opO1xuICAgICAgICBheGxlaS52c3ViKHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiwgYXhsZWkpO1xuICAgICAgICBheGxlaS5ub3JtYWxpemUoKTtcbiAgICAgICAgc3VyZk5vcm1hbFdTLmNyb3NzKGF4bGVpLCBmb3J3YXJkV1NbaV0pO1xuICAgICAgICBmb3J3YXJkV1NbaV0ubm9ybWFsaXplKCk7XG4gICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChjaGFzc2lzQm9keSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBncm91bmRPYmplY3QsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgYXhsZWkpO1xuICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSAqPSBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNpZGVGYWN0b3IgPSAxO1xuICAgIGNvbnN0IGZ3ZEZhY3RvciA9IDAuNTtcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgIGNvbnN0IHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgIGNvbnN0IGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcbiAgICAgIGxldCByb2xsaW5nRnJpY3Rpb24gPSAwO1xuICAgICAgd2hlZWwuc2xpcEluZm8gPSAxO1xuXG4gICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRSb2xsaW5nRnJpY3Rpb25JbXB1bHNlID0gMDtcbiAgICAgICAgY29uc3QgbWF4SW1wdWxzZSA9IHdoZWVsLmJyYWtlID8gd2hlZWwuYnJha2UgOiBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZTsgLy8gYnRXaGVlbENvbnRhY3RQb2ludCBjb250YWN0UHQoY2hhc3Npc0JvZHksZ3JvdW5kT2JqZWN0LHdoZWVsSW5mcmF5Y2FzdEluZm8uaGl0UG9pbnRXb3JsZCxmb3J3YXJkV1Nbd2hlZWxdLG1heEltcHVsc2UpO1xuICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSBjYWxjUm9sbGluZ0ZyaWN0aW9uKGNvbnRhY3RQdCk7XG5cbiAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XG4gICAgICAgIHJvbGxpbmdGcmljdGlvbiArPSB3aGVlbC5lbmdpbmVGb3JjZSAqIHRpbWVTdGVwOyAvLyByb2xsaW5nRnJpY3Rpb24gPSAwO1xuXG4gICAgICAgIGNvbnN0IGZhY3RvciA9IG1heEltcHVsc2UgLyByb2xsaW5nRnJpY3Rpb247XG4gICAgICAgIHdoZWVsLnNsaXBJbmZvICo9IGZhY3RvcjtcbiAgICAgIH0gLy9zd2l0Y2ggYmV0d2VlbiBhY3RpdmUgcm9sbGluZyAodGhyb3R0bGUpLCBicmFraW5nIGFuZCBub24tYWN0aXZlIHJvbGxpbmcgZnJpY3Rpb24gKG50aHJvdHRsZS9icmVhaylcblxuXG4gICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICB3aGVlbC5za2lkSW5mbyA9IDE7XG5cbiAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xuICAgICAgICBjb25zdCBtYXhpbXAgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCAqIHdoZWVsLmZyaWN0aW9uU2xpcDtcbiAgICAgICAgY29uc3QgbWF4aW1wU2lkZSA9IG1heGltcDtcbiAgICAgICAgY29uc3QgbWF4aW1wU3F1YXJlZCA9IG1heGltcCAqIG1heGltcFNpZGU7XG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gcm9sbGluZ0ZyaWN0aW9uOyAvL3doZWVsSW5mby5lbmdpbmVGb3JjZSogdGltZVN0ZXA7XG5cbiAgICAgICAgY29uc3QgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xuICAgICAgICBjb25zdCB5ID0gd2hlZWwuc2lkZUltcHVsc2UgKiBzaWRlRmFjdG9yO1xuICAgICAgICBjb25zdCBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgIHdoZWVsLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaW1wdWxzZVNxdWFyZWQgPiBtYXhpbXBTcXVhcmVkKSB7XG4gICAgICAgICAgdGhpcy5zbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBmYWN0b3IgPSBtYXhpbXAgLyBNYXRoLnNxcnQoaW1wdWxzZVNxdWFyZWQpO1xuICAgICAgICAgIHdoZWVsLnNraWRJbmZvICo9IGZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNsaWRpbmcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgIGlmICh3aGVlbC5zaWRlSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgIGlmICh3aGVlbC5za2lkSW5mbyA8IDEpIHtcbiAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvO1xuICAgICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBhcHBseSB0aGUgaW1wdWxzZXNcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgY29uc3Qgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuICAgICAgY29uc3QgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XG4gICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVsX3Bvcyk7IC8vIGNhbm5vbnMgYXBwbHlpbXB1bHNlIGlzIHVzaW5nIHdvcmxkIGNvb3JkIGZvciB0aGUgcG9zaXRpb25cbiAgICAgIC8vcmVsX3Bvcy5jb3B5KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCk7XG5cbiAgICAgIGlmICh3aGVlbC5mb3J3YXJkSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICBjb25zdCBpbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgZm9yd2FyZFdTW2ldLnNjYWxlKHdoZWVsLmZvcndhcmRJbXB1bHNlLCBpbXB1bHNlKTtcbiAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbF9wb3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHtcbiAgICAgICAgY29uc3QgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuICAgICAgICBjb25zdCByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGdyb3VuZE9iamVjdC5wb3NpdGlvbiwgcmVsX3BvczIpOyAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcblxuICAgICAgICBjb25zdCBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgYXhsZVtpXS5zY2FsZSh3aGVlbC5zaWRlSW1wdWxzZSwgc2lkZUltcCk7IC8vIFNjYWxlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGUgdXAgZGlyZWN0aW9uIHdpdGggcm9sbEluZmx1ZW5jZS5cbiAgICAgICAgLy8gSWYgcm9sbEluZmx1ZW5jZSBpcyAxLCB0aGUgaW1wdWxzZSB3aWxsIGJlIGFwcGxpZWQgb24gdGhlIGhpdFBvaW50IChlYXN5IHRvIHJvbGwgb3ZlciksIGlmIGl0IGlzIHplcm8gaXQgd2lsbCBiZSBhcHBsaWVkIGluIHRoZSBzYW1lIHBsYW5lIGFzIHRoZSBjZW50ZXIgb2YgbWFzcyAobm90IGVhc3kgdG8gcm9sbCBvdmVyKS5cblxuICAgICAgICBjaGFzc2lzQm9keS52ZWN0b3JUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgIHJlbF9wb3NbJ3h5eidbdGhpcy5pbmRleFVwQXhpc11dICo9IHdoZWVsLnJvbGxJbmZsdWVuY2U7XG4gICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxfcG9zLCByZWxfcG9zKTtcbiAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MpOyAvL2FwcGx5IGZyaWN0aW9uIGltcHVsc2Ugb24gdGhlIGdyb3VuZFxuXG4gICAgICAgIHNpZGVJbXAuc2NhbGUoLTEsIHNpZGVJbXApO1xuICAgICAgICBncm91bmRPYmplY3QuYXBwbHlJbXB1bHNlKHNpZGVJbXAsIHJlbF9wb3MyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuY29uc3QgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBWZWM1ID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRtcFZlYzYgPSBuZXcgVmVjMygpO1xuY29uc3QgdG1wUmF5ID0gbmV3IFJheSgpO1xuY29uc3QgY2FzdFJheV9yYXl2ZWN0b3IgPSBuZXcgVmVjMygpO1xuY29uc3QgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuY29uc3QgZGlyZWN0aW9ucyA9IFtuZXcgVmVjMygxLCAwLCAwKSwgbmV3IFZlYzMoMCwgMSwgMCksIG5ldyBWZWMzKDAsIDAsIDEpXTtcbmNvbnN0IHVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiA9IG5ldyBWZWMzKCk7XG5jb25zdCB1cGRhdGVGcmljdGlvbl9heGxlID0gW107XG5jb25zdCB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbmNvbnN0IHNpZGVGcmljdGlvblN0aWZmbmVzczIgPSAxO1xuY29uc3QgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMiA9IG5ldyBWZWMzKCk7XG5jb25zdCBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbCA9IG5ldyBWZWMzKCk7XG5cbmZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XG4gIGxldCBqMSA9IDA7XG4gIGNvbnN0IGNvbnRhY3RQb3NXb3JsZCA9IGZyaWN0aW9uUG9zV29ybGQ7IC8vIGNvbnN0IHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgLy8gY29uc3QgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuXG4gIGNvbnN0IHZlbDEgPSBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDE7XG4gIGNvbnN0IHZlbDIgPSBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDI7XG4gIGNvbnN0IHZlbCA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsOyAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpO1xuICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gIGJvZHkwLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMSk7XG4gIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMik7XG4gIHZlbDEudnN1Yih2ZWwyLCB2ZWwpO1xuICBjb25zdCB2cmVsID0gZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZC5kb3QodmVsKTtcbiAgY29uc3QgZGVub20wID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5MCwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCk7XG4gIGNvbnN0IGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICBjb25zdCByZWxheGF0aW9uID0gMTtcbiAgY29uc3QgamFjRGlhZ0FCSW52ID0gcmVsYXhhdGlvbiAvIChkZW5vbTAgKyBkZW5vbTEpOyAvLyBjYWxjdWxhdGUgaiB0aGF0IG1vdmVzIHVzIHRvIHplcm8gcmVsYXRpdmUgdmVsb2NpdHlcblxuICBqMSA9IC12cmVsICogamFjRGlhZ0FCSW52O1xuXG4gIGlmIChtYXhJbXB1bHNlIDwgajEpIHtcbiAgICBqMSA9IG1heEltcHVsc2U7XG4gIH1cblxuICBpZiAoajEgPCAtbWF4SW1wdWxzZSkge1xuICAgIGoxID0gLW1heEltcHVsc2U7XG4gIH1cblxuICByZXR1cm4gajE7XG59XG5cbmNvbnN0IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjAgPSBuZXcgVmVjMygpO1xuY29uc3QgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9jMCA9IG5ldyBWZWMzKCk7XG5jb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7XG5jb25zdCBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX20gPSBuZXcgVmVjMygpO1xuXG5mdW5jdGlvbiBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHksIHBvcywgbm9ybWFsKSB7XG4gIGNvbnN0IHIwID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9yMDtcbiAgY29uc3QgYzAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwO1xuICBjb25zdCB2ZWMgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYztcbiAgY29uc3QgbSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfbTtcbiAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApO1xuICByMC5jcm9zcyhub3JtYWwsIGMwKTtcbiAgYm9keS5pbnZJbmVydGlhV29ybGQudm11bHQoYzAsIG0pO1xuICBtLmNyb3NzKHIwLCB2ZWMpO1xuICByZXR1cm4gYm9keS5pbnZNYXNzICsgbm9ybWFsLmRvdCh2ZWMpO1xufVxuXG5jb25zdCByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEgPSBuZXcgVmVjMygpO1xuY29uc3QgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyID0gbmV3IFZlYzMoKTtcbmNvbnN0IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTsgLy9iaWxhdGVyYWwgY29uc3RyYWludCBiZXR3ZWVuIHR3byBkeW5hbWljIG9iamVjdHNcblxuZnVuY3Rpb24gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChib2R5MSwgcG9zMSwgYm9keTIsIHBvczIsIG5vcm1hbCkge1xuICBjb25zdCBub3JtYWxMZW5TcXIgPSBub3JtYWwubGVuZ3RoU3F1YXJlZCgpO1xuXG4gIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpIHtcbiAgICByZXR1cm4gMDsgLy8gbm8gaW1wdWxzZVxuICB9IC8vIGNvbnN0IHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgLy8gY29uc3QgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAvLyBwb3MxLnZzdWIoYm9keTEucG9zaXRpb24sIHJlbF9wb3MxKTtcbiAgLy8gcG9zMi52c3ViKGJvZHkyLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cblxuICBjb25zdCB2ZWwxID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwxO1xuICBjb25zdCB2ZWwyID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwyO1xuICBjb25zdCB2ZWwgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDtcbiAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XG4gIGJvZHkyLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczIsIHZlbDIpO1xuICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcbiAgY29uc3QgcmVsX3ZlbCA9IG5vcm1hbC5kb3QodmVsKTtcbiAgY29uc3QgY29udGFjdERhbXBpbmcgPSAwLjI7XG4gIGNvbnN0IG1hc3NUZXJtID0gMSAvIChib2R5MS5pbnZNYXNzICsgYm9keTIuaW52TWFzcyk7XG4gIGNvbnN0IGltcHVsc2UgPSAtY29udGFjdERhbXBpbmcgKiByZWxfdmVsICogbWFzc1Rlcm07XG4gIHJldHVybiBpbXB1bHNlO1xufVxuXG4vKipcclxuICogU3BoZXJpY2FsIHNoYXBlXHJcbiAqIEBjbGFzcyBTcGhlcmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFNoYXBlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXHJcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cbmNsYXNzIFNwaGVyZSBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IocmFkaXVzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogU2hhcGUudHlwZXMuU1BIRVJFXG4gICAgfSk7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgIT09IHVuZGVmaW5lZCA/IHJhZGl1cyA6IDEuMDtcblxuICAgIGlmICh0aGlzLnJhZGl1cyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgY29uc3QgSSA9IDIuMCAqIG1hc3MgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzIC8gNS4wO1xuICAgIHRhcmdldC54ID0gSTtcbiAgICB0YXJnZXQueSA9IEk7XG4gICAgdGFyZ2V0LnogPSBJO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2b2x1bWUoKSB7XG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMykgLyAzLjA7XG4gIH1cblxuICB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIHtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gIH1cblxuICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCBheGVzID0gWyd4JywgJ3knLCAneiddO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheCA9IGF4ZXNbaV07XG4gICAgICBtaW5bYXhdID0gcG9zW2F4XSAtIHI7XG4gICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXHJcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cclxuICogQGNsYXNzIFJpZ2lkVmVoaWNsZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cclxuICovXG5jbGFzcyBSaWdpZFZlaGljbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLndoZWVsQm9kaWVzID0gW107XG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mIG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvb3JkaW5hdGVTeXN0ZW0uY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDIsIDMpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hhc3Npc0JvZHkpIHtcbiAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGFzc2lzIGJvZHkgZ2l2ZW4uIENyZWF0ZSBpdCFcbiAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICAgIG1hc3M6IDEsXG4gICAgICAgIHNoYXBlOiBuZXcgQm94KG5ldyBWZWMzKDUsIDIsIDAuNSkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG4gICAgdGhpcy53aGVlbEF4ZXMgPSBbXTtcbiAgICB0aGlzLndoZWVsRm9yY2VzID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGEgd2hlZWxcclxuICAgKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbF1cclxuICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbl0gU2xpZGUgZGlyZWN0aW9uIG9mIHRoZSB3aGVlbCBhbG9uZyB0aGUgc3VzcGVuc2lvbi5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNdIEF4aXMgb2Ygcm90YXRpb24gb2YgdGhlIHdoZWVsLCBsb2NhbGx5IGRlZmluZWQgaW4gdGhlIGNoYXNzaXMuXHJcbiAgICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cclxuICAgKi9cblxuXG4gIGFkZFdoZWVsKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB3aGVlbEJvZHk7XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICB3aGVlbEJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIHdoZWVsIGJvZHkgZ2l2ZW4uIENyZWF0ZSBpdCFcbiAgICAgIHdoZWVsQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgICAgbWFzczogMSxcbiAgICAgICAgc2hhcGU6IG5ldyBTcGhlcmUoMS4yKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy53aGVlbEJvZGllcy5wdXNoKHdoZWVsQm9keSk7XG4gICAgdGhpcy53aGVlbEZvcmNlcy5wdXNoKDApOyAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgY29uc3QgcG9zaXRpb24gPSB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvc2l0aW9uLmNsb25lKCkgOiBuZXcgVmVjMygpOyAvLyBTZXQgcG9zaXRpb24gbG9jYWxseSB0byB0aGUgY2hhc3Npc1xuXG4gICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTsgLy8gQ29uc3RyYWluIHdoZWVsXG5cbiAgICBjb25zdCBheGlzID0gdHlwZW9mIG9wdGlvbnMuYXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmF4aXMuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xuICAgIHRoaXMud2hlZWxBeGVzLnB1c2goYXhpcyk7XG4gICAgY29uc3QgaGluZ2VDb25zdHJhaW50ID0gbmV3IEhpbmdlQ29uc3RyYWludCh0aGlzLmNoYXNzaXNCb2R5LCB3aGVlbEJvZHksIHtcbiAgICAgIHBpdm90QTogcG9zaXRpb24sXG4gICAgICBheGlzQTogYXhpcyxcbiAgICAgIHBpdm90QjogVmVjMy5aRVJPLFxuICAgICAgYXhpc0I6IGF4aXMsXG4gICAgICBjb2xsaWRlQ29ubmVjdGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChoaW5nZUNvbnN0cmFpbnQpO1xuICAgIHJldHVybiB0aGlzLndoZWVsQm9kaWVzLmxlbmd0aCAtIDE7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzdGVlcmluZyB2YWx1ZSBvZiBhIHdoZWVsLlxyXG4gICAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gICAqIEB0b2RvIGNoZWNrIGNvb3JkaW5hdGVTeXN0ZW1cclxuICAgKi9cblxuXG4gIHNldFN0ZWVyaW5nVmFsdWUodmFsdWUsIHdoZWVsSW5kZXgpIHtcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcbiAgICBjb25zdCBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XG4gICAgY29uc3QgYyA9IE1hdGguY29zKHZhbHVlKTtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4odmFsdWUpO1xuICAgIGNvbnN0IHggPSBheGlzLng7XG4gICAgY29uc3QgeSA9IGF4aXMueTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzW3doZWVsSW5kZXhdLmF4aXNBLnNldChjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5LCAwKTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxyXG4gICAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gICAqL1xuXG5cbiAgc2V0TW90b3JTcGVlZCh2YWx1ZSwgd2hlZWxJbmRleCkge1xuICAgIGNvbnN0IGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmVuYWJsZU1vdG9yKCk7XG4gICAgaGluZ2VDb25zdHJhaW50Lm1vdG9yVGFyZ2V0VmVsb2NpdHkgPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxyXG4gICAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAgICovXG5cblxuICBkaXNhYmxlTW90b3Iod2hlZWxJbmRleCkge1xuICAgIGNvbnN0IGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCB0aGUgd2hlZWwgZm9yY2UgdG8gYXBwbHkgb24gb25lIG9mIHRoZSB3aGVlbHMgZWFjaCB0aW1lIHN0ZXBcclxuICAgKiBAbWV0aG9kIHNldFdoZWVsRm9yY2VcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gd2hlZWxJbmRleFxyXG4gICAqL1xuXG5cbiAgc2V0V2hlZWxGb3JjZSh2YWx1ZSwgd2hlZWxJbmRleCkge1xuICAgIHRoaXMud2hlZWxGb3JjZXNbd2hlZWxJbmRleF0gPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBBcHBseSBhIHRvcnF1ZSBvbiBvbmUgb2YgdGhlIHdoZWVscy5cclxuICAgKiBAbWV0aG9kIGFwcGx5V2hlZWxGb3JjZVxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcclxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAgICovXG5cblxuICBhcHBseVdoZWVsRm9yY2UodmFsdWUsIHdoZWVsSW5kZXgpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XG4gICAgY29uc3Qgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICBjb25zdCBib2R5VG9ycXVlID0gd2hlZWxCb2R5LnRvcnF1ZTtcbiAgICBheGlzLnNjYWxlKHZhbHVlLCB0b3JxdWUpO1xuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cclxuICAgKiBAbWV0aG9kIGFkZFRvV29ybGRcclxuICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gICAqL1xuXG5cbiAgYWRkVG9Xb3JsZCh3b3JsZCkge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBjb25zdCBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdvcmxkLmFkZEJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICBjb25zdCB3aGVlbEZvcmNlcyA9IHRoaXMud2hlZWxGb3JjZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdoZWVsRm9yY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFwcGx5V2hlZWxGb3JjZSh3aGVlbEZvcmNlc1tpXSwgaSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxyXG4gICAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXHJcbiAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgKi9cblxuXG4gIHJlbW92ZUZyb21Xb3JsZCh3b3JsZCkge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBjb25zdCBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdvcmxkLnJlbW92ZUJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiBhIHdoZWVsXHJcbiAgICogQG1ldGhvZCBnZXRXaGVlbFNwZWVkXHJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XHJcbiAgICovXG5cblxuICBnZXRXaGVlbFNwZWVkKHdoZWVsSW5kZXgpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XG4gICAgY29uc3Qgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICBjb25zdCB3ID0gd2hlZWxCb2R5LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShheGlzLCB3b3JsZEF4aXMpO1xuICAgIHJldHVybiB3LmRvdCh3b3JsZEF4aXMpO1xuICB9XG5cbn1cbmNvbnN0IHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5jb25zdCB3b3JsZEF4aXMgPSBuZXcgVmVjMygpO1xuXG4vKipcclxuICogU21vb3RoZWQtcGFydGljbGUgaHlkcm9keW5hbWljcyBzeXN0ZW1cclxuICogQGNsYXNzIFNQSFN5c3RlbVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBTUEhTeXN0ZW0ge1xuICAvLyBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cbiAgLy8gRGlzdGFuY2UgYmVsb3cgd2hpY2ggdHdvIHBhcnRpY2xlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBuZWlnaGJvcnMuIEl0IHNob3VsZCBiZSBhZGp1c3RlZCBzbyB0aGVyZSBhcmUgYWJvdXQgMTUtMjAgbmVpZ2hib3IgcGFydGljbGVzIHdpdGhpbiB0aGlzIHJhZGl1cy5cbiAgLy8gVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGFydGljbGVzID0gW107XG4gICAgdGhpcy5kZW5zaXR5ID0gMTtcbiAgICB0aGlzLnNtb290aGluZ1JhZGl1cyA9IDE7XG4gICAgdGhpcy5zcGVlZE9mU291bmQgPSAxO1xuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxOyAvLyBTdHVmZiBDb21wdXRlZCBwZXIgcGFydGljbGVcblxuICAgIHRoaXMucHJlc3N1cmVzID0gW107XG4gICAgdGhpcy5kZW5zaXRpZXMgPSBbXTtcbiAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBhIHBhcnRpY2xlIHRvIHRoZSBzeXN0ZW0uXHJcbiAgICogQG1ldGhvZCBhZGRcclxuICAgKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXHJcbiAgICovXG5cblxuICBhZGQocGFydGljbGUpIHtcbiAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcblxuICAgIGlmICh0aGlzLm5laWdoYm9ycy5sZW5ndGggPCB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubmVpZ2hib3JzLnB1c2goW10pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgYSBwYXJ0aWNsZSBmcm9tIHRoZSBzeXN0ZW0uXHJcbiAgICogQG1ldGhvZCByZW1vdmVcclxuICAgKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXHJcbiAgICovXG5cblxuICByZW1vdmUocGFydGljbGUpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnBhcnRpY2xlcy5pbmRleE9mKHBhcnRpY2xlKTtcblxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzLnBhcnRpY2xlcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA+IHRoaXMucGFydGljbGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm5laWdoYm9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXROZWlnaGJvcnMocGFydGljbGUsIG5laWdoYm9ycykge1xuICAgIGNvbnN0IE4gPSB0aGlzLnBhcnRpY2xlcy5sZW5ndGg7XG4gICAgY29uc3QgaWQgPSBwYXJ0aWNsZS5pZDtcbiAgICBjb25zdCBSMiA9IHRoaXMuc21vb3RoaW5nUmFkaXVzICogdGhpcy5zbW9vdGhpbmdSYWRpdXM7XG4gICAgY29uc3QgZGlzdCA9IFNQSFN5c3RlbV9nZXROZWlnaGJvcnNfZGlzdDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgIHAucG9zaXRpb24udnN1YihwYXJ0aWNsZS5wb3NpdGlvbiwgZGlzdCk7XG5cbiAgICAgIGlmIChpZCAhPT0gcC5pZCAmJiBkaXN0Lmxlbmd0aFNxdWFyZWQoKSA8IFIyKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGRpc3QgPSBTUEhTeXN0ZW1fdXBkYXRlX2Rpc3Q7XG4gICAgY29uc3QgY3MgPSB0aGlzLnNwZWVkT2ZTb3VuZDtcbiAgICBjb25zdCBlcHMgPSB0aGlzLmVwcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuXG4gICAgICBjb25zdCBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9yc1tpXTsgLy8gR2V0IG5laWdoYm9yc1xuXG4gICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuZ2V0TmVpZ2hib3JzKHAsIG5laWdoYm9ycyk7XG4gICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLnBhcnRpY2xlc1tpXSk7IC8vIEFkZCBjdXJyZW50IHRvb1xuXG4gICAgICBjb25zdCBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoOyAvLyBBY2N1bXVsYXRlIGRlbnNpdHkgZm9yIHRoZSBwYXJ0aWNsZVxuXG4gICAgICBsZXQgc3VtID0gMC4wO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gbnVtTmVpZ2hib3JzOyBqKyspIHtcbiAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcbiAgICAgICAgcC5wb3NpdGlvbi52c3ViKG5laWdoYm9yc1tqXS5wb3NpdGlvbiwgZGlzdCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRpc3QubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHRoaXMudyhsZW4pO1xuICAgICAgICBzdW0gKz0gbmVpZ2hib3JzW2pdLm1hc3MgKiB3ZWlnaHQ7XG4gICAgICB9IC8vIFNhdmVcblxuXG4gICAgICB0aGlzLmRlbnNpdGllc1tpXSA9IHN1bTtcbiAgICAgIHRoaXMucHJlc3N1cmVzW2ldID0gY3MgKiBjcyAqICh0aGlzLmRlbnNpdGllc1tpXSAtIHRoaXMuZGVuc2l0eSk7XG4gICAgfSAvLyBBZGQgZm9yY2VzXG4gICAgLy8gU3VtIHRvIHRoZXNlIGFjY2VsZXJhdGlvbnNcblxuXG4gICAgY29uc3QgYV9wcmVzc3VyZSA9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcbiAgICBjb25zdCBhX3Zpc2MgPSBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYztcbiAgICBjb25zdCBncmFkVyA9IFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XG4gICAgY29uc3Qgcl92ZWMgPSBTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjO1xuICAgIGNvbnN0IHUgPSBTUEhTeXN0ZW1fdXBkYXRlX3U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGVzW2ldO1xuICAgICAgYV9wcmVzc3VyZS5zZXQoMCwgMCwgMCk7XG4gICAgICBhX3Zpc2Muc2V0KDAsIDAsIDApOyAvLyBJbml0IHZhcnNcblxuICAgICAgbGV0IFBpajtcbiAgICAgIGxldCBuYWJsYTtcblxuICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG4gICAgICBjb25zdCBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoOyAvL3ByaW50ZihcIk5laWdoYm9yczogXCIpO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gbnVtTmVpZ2hib3JzOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmVpZ2hib3IgPSBuZWlnaGJvcnNbal07IC8vcHJpbnRmKFwiJWQgXCIsbmopO1xuICAgICAgICAvLyBHZXQgciBvbmNlIGZvciBhbGwuLlxuXG4gICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnZzdWIobmVpZ2hib3IucG9zaXRpb24sIHJfdmVjKTtcbiAgICAgICAgY29uc3QgciA9IHJfdmVjLmxlbmd0aCgpOyAvLyBQcmVzc3VyZSBjb250cmlidXRpb25cblxuICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2ldICsgZXBzKSArIHRoaXMucHJlc3N1cmVzW2pdIC8gKHRoaXMuZGVuc2l0aWVzW2pdICogdGhpcy5kZW5zaXRpZXNbal0gKyBlcHMpKTtcbiAgICAgICAgdGhpcy5ncmFkdyhyX3ZlYywgZ3JhZFcpOyAvLyBBZGQgdG8gcHJlc3N1cmUgYWNjZWxlcmF0aW9uXG5cbiAgICAgICAgZ3JhZFcuc2NhbGUoUGlqLCBncmFkVyk7XG4gICAgICAgIGFfcHJlc3N1cmUudmFkZChncmFkVywgYV9wcmVzc3VyZSk7IC8vIFZpc2Nvc2l0eSBjb250cmlidXRpb25cblxuICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgdS5zY2FsZSgxLjAgLyAoMC4wMDAxICsgdGhpcy5kZW5zaXRpZXNbaV0gKiB0aGlzLmRlbnNpdGllc1tqXSkgKiB0aGlzLnZpc2Nvc2l0eSAqIG5laWdoYm9yLm1hc3MsIHUpO1xuICAgICAgICBuYWJsYSA9IHRoaXMubmFibGF3KHIpO1xuICAgICAgICB1LnNjYWxlKG5hYmxhLCB1KTsgLy8gQWRkIHRvIHZpc2Nvc2l0eSBhY2NlbGVyYXRpb25cblxuICAgICAgICBhX3Zpc2MudmFkZCh1LCBhX3Zpc2MpO1xuICAgICAgfSAvLyBDYWxjdWxhdGUgZm9yY2VcblxuXG4gICAgICBhX3Zpc2Muc2NhbGUocGFydGljbGUubWFzcywgYV92aXNjKTtcbiAgICAgIGFfcHJlc3N1cmUuc2NhbGUocGFydGljbGUubWFzcywgYV9wcmVzc3VyZSk7IC8vIEFkZCBmb3JjZSB0byBwYXJ0aWNsZXNcblxuICAgICAgcGFydGljbGUuZm9yY2UudmFkZChhX3Zpc2MsIHBhcnRpY2xlLmZvcmNlKTtcbiAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xuICAgIH1cbiAgfSAvLyBDYWxjdWxhdGUgdGhlIHdlaWdodCB1c2luZyB0aGUgVyhyKSB3ZWlnaHRmdW5jdGlvblxuXG5cbiAgdyhyKSB7XG4gICAgLy8gMzE1XG4gICAgY29uc3QgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJldHVybiAzMTUuMCAvICg2NC4wICogTWF0aC5QSSAqIGggKiogOSkgKiAoaCAqIGggLSByICogcikgKiogMztcbiAgfSAvLyBjYWxjdWxhdGUgZ3JhZGllbnQgb2YgdGhlIHdlaWdodCBmdW5jdGlvblxuXG5cbiAgZ3JhZHcoclZlYywgcmVzdWx0VmVjKSB7XG4gICAgY29uc3QgciA9IHJWZWMubGVuZ3RoKCk7XG4gICAgY29uc3QgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJWZWMuc2NhbGUoOTQ1LjAgLyAoMzIuMCAqIE1hdGguUEkgKiBoICoqIDkpICogKGggKiBoIC0gciAqIHIpICoqIDIsIHJlc3VsdFZlYyk7XG4gIH0gLy8gQ2FsY3VsYXRlIG5hYmxhKFcpXG5cblxuICBuYWJsYXcocikge1xuICAgIGNvbnN0IGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICBjb25zdCBuYWJsYSA9IDk0NS4wIC8gKDMyLjAgKiBNYXRoLlBJICogaCAqKiA5KSAqIChoICogaCAtIHIgKiByKSAqICg3ICogciAqIHIgLSAzICogaCAqIGgpO1xuICAgIHJldHVybiBuYWJsYTtcbiAgfVxuXG59XG4vKipcclxuICogR2V0IG5laWdoYm9ycyB3aXRoaW4gc21vb3RoaW5nIHZvbHVtZSwgc2F2ZSBpbiB0aGUgYXJyYXkgbmVpZ2hib3JzXHJcbiAqIEBtZXRob2QgZ2V0TmVpZ2hib3JzXHJcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcclxuICogQHBhcmFtIHtBcnJheX0gbmVpZ2hib3JzXHJcbiAqL1xuXG5jb25zdCBTUEhTeXN0ZW1fZ2V0TmVpZ2hib3JzX2Rpc3QgPSBuZXcgVmVjMygpOyAvLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXG5cbmNvbnN0IFNQSFN5c3RlbV91cGRhdGVfZGlzdCA9IG5ldyBWZWMzKCk7IC8vIFJlbGF0aXZlIHZlbG9jaXR5XG5cbmNvbnN0IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZSA9IG5ldyBWZWMzKCk7XG5jb25zdCBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYyA9IG5ldyBWZWMzKCk7XG5jb25zdCBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKTtcbmNvbnN0IFNQSFN5c3RlbV91cGRhdGVfcl92ZWMgPSBuZXcgVmVjMygpO1xuY29uc3QgU1BIU3lzdGVtX3VwZGF0ZV91ID0gbmV3IFZlYzMoKTtcblxuLyoqXHJcbiAqIEBjbGFzcyBDeWxpbmRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQ29udmV4UG9seWhlZHJvblxyXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JvdHRvbVxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWdtZW50cyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2ZcclxuICovXG5cbmNsYXNzIEN5bGluZGVyIGV4dGVuZHMgQ29udmV4UG9seWhlZHJvbiB7XG4gIGNvbnN0cnVjdG9yKHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIG51bVNlZ21lbnRzKSB7XG4gICAgY29uc3QgTiA9IG51bVNlZ21lbnRzO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgYXhlcyA9IFtdO1xuICAgIGNvbnN0IGZhY2VzID0gW107XG4gICAgY29uc3QgYm90dG9tZmFjZSA9IFtdO1xuICAgIGNvbnN0IHRvcGZhY2UgPSBbXTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcztcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbjsgLy8gRmlyc3QgYm90dG9tIHBvaW50XG5cbiAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSAqIGNvcygwKSwgcmFkaXVzQm90dG9tICogc2luKDApLCAtaGVpZ2h0ICogMC41KSk7XG4gICAgYm90dG9tZmFjZS5wdXNoKDApOyAvLyBGaXJzdCB0b3AgcG9pbnRcblxuICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wICogY29zKDApLCByYWRpdXNUb3AgKiBzaW4oMCksIGhlaWdodCAqIDAuNSkpO1xuICAgIHRvcGZhY2UucHVzaCgxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBjb25zdCB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gTiAqIChpICsgMSk7XG4gICAgICBjb25zdCB0aGV0YU4gPSAyICogTWF0aC5QSSAvIE4gKiAoaSArIDAuNSk7XG5cbiAgICAgIGlmIChpIDwgTiAtIDEpIHtcbiAgICAgICAgLy8gQm90dG9tXG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlYzMocmFkaXVzQm90dG9tICogY29zKHRoZXRhKSwgcmFkaXVzQm90dG9tICogc2luKHRoZXRhKSwgLWhlaWdodCAqIDAuNSkpO1xuICAgICAgICBib3R0b21mYWNlLnB1c2goMiAqIGkgKyAyKTsgLy8gVG9wXG5cbiAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjMyhyYWRpdXNUb3AgKiBjb3ModGhldGEpLCByYWRpdXNUb3AgKiBzaW4odGhldGEpLCBoZWlnaHQgKiAwLjUpKTtcbiAgICAgICAgdG9wZmFjZS5wdXNoKDIgKiBpICsgMyk7IC8vIEZhY2VcblxuICAgICAgICBmYWNlcy5wdXNoKFsyICogaSArIDIsIDIgKiBpICsgMywgMiAqIGkgKyAxLCAyICogaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjZXMucHVzaChbMCwgMSwgMiAqIGkgKyAxLCAyICogaV0pOyAvLyBDb25uZWN0XG4gICAgICB9IC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzXG5cblxuICAgICAgaWYgKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMikge1xuICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoY29zKHRoZXRhTiksIHNpbih0aGV0YU4pLCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFjZXMucHVzaCh0b3BmYWNlKTtcbiAgICBheGVzLnB1c2gobmV3IFZlYzMoMCwgMCwgMSkpOyAvLyBSZW9yZGVyIGJvdHRvbSBmYWNlXG5cbiAgICBjb25zdCB0ZW1wID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdHRvbWZhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRlbXAucHVzaChib3R0b21mYWNlW2JvdHRvbWZhY2UubGVuZ3RoIC0gaSAtIDFdKTtcbiAgICB9XG5cbiAgICBmYWNlcy5wdXNoKHRlbXApO1xuICAgIHN1cGVyKHtcbiAgICAgIHZlcnRpY2VzLFxuICAgICAgZmFjZXMsXG4gICAgICBheGVzXG4gICAgfSk7XG4gIH1cblxufVxuXG4vKipcclxuICogUGFydGljbGUgc2hhcGUuXHJcbiAqIEBjbGFzcyBQYXJ0aWNsZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKiBAZXh0ZW5kcyBTaGFwZVxyXG4gKi9cbmNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiBTaGFwZS50eXBlcy5QQVJUSUNMRVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXHJcbiAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7VmVjM31cclxuICAgKi9cblxuXG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdm9sdW1lKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSB7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7XG4gIH1cblxuICBjYWxjdWxhdGVXb3JsZEFBQkIocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XG4gICAgbWluLmNvcHkocG9zKTtcbiAgICBtYXguY29weShwb3MpO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIEEgcGxhbmUsIGZhY2luZyBpbiB0aGUgWiBkaXJlY3Rpb24uIFRoZSBwbGFuZSBoYXMgaXRzIHN1cmZhY2UgYXQgej0wIGFuZCBldmVyeXRoaW5nIGJlbG93IHo9MCBpcyBhc3N1bWVkIHRvIGJlIHNvbGlkIHBsYW5lLiBUbyBtYWtlIHRoZSBwbGFuZSBmYWNlIGluIHNvbWUgb3RoZXIgZGlyZWN0aW9uIHRoYW4geiwgeW91IG11c3QgcHV0IGl0IGluc2lkZSBhIEJvZHkgYW5kIHJvdGF0ZSB0aGF0IGJvZHkuIFNlZSB0aGUgZGVtb3MuXHJcbiAqIEBjbGFzcyBQbGFuZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgU2hhcGVcclxuICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gKi9cbmNsYXNzIFBsYW5lIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiBTaGFwZS50eXBlcy5QTEFORVxuICAgIH0pOyAvLyBXb3JsZCBvcmllbnRlZCBub3JtYWxcblxuICAgIHRoaXMud29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG4gIH1cblxuICBjb21wdXRlV29ybGROb3JtYWwocXVhdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLndvcmxkTm9ybWFsO1xuICAgIG4uc2V0KDAsIDAsIDEpO1xuICAgIHF1YXQudm11bHQobiwgbik7XG4gICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICBjYWxjdWxhdGVMb2NhbEluZXJ0aWEobWFzcywgdGFyZ2V0ID0gbmV3IFZlYzMoKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2b2x1bWUoKSB7XG4gICAgcmV0dXJuICgvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi5cbiAgICAgIE51bWJlci5NQVhfVkFMVUVcbiAgICApO1xuICB9XG5cbiAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHtcbiAgICAvLyBUaGUgcGxhbmUgQUFCQiBpcyBpbmZpbml0ZSwgZXhjZXB0IGlmIHRoZSBub3JtYWwgaXMgcG9pbnRpbmcgYWxvbmcgYW55IGF4aXNcbiAgICB0ZW1wTm9ybWFsLnNldCgwLCAwLCAxKTsgLy8gRGVmYXVsdCBwbGFuZSBub3JtYWwgaXMgelxuXG4gICAgcXVhdC52bXVsdCh0ZW1wTm9ybWFsLCB0ZW1wTm9ybWFsKTtcbiAgICBjb25zdCBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1pbi5zZXQoLW1heFZhbCwgLW1heFZhbCwgLW1heFZhbCk7XG4gICAgbWF4LnNldChtYXhWYWwsIG1heFZhbCwgbWF4VmFsKTtcblxuICAgIGlmICh0ZW1wTm9ybWFsLnggPT09IDEpIHtcbiAgICAgIG1heC54ID0gcG9zLng7XG4gICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnggPT09IC0xKSB7XG4gICAgICBtaW4ueCA9IHBvcy54O1xuICAgIH1cblxuICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IDEpIHtcbiAgICAgIG1heC55ID0gcG9zLnk7XG4gICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnkgPT09IC0xKSB7XG4gICAgICBtaW4ueSA9IHBvcy55O1xuICAgIH1cblxuICAgIGlmICh0ZW1wTm9ybWFsLnogPT09IDEpIHtcbiAgICAgIG1heC56ID0gcG9zLno7XG4gICAgfSBlbHNlIGlmICh0ZW1wTm9ybWFsLnogPT09IC0xKSB7XG4gICAgICBtaW4ueiA9IHBvcy56O1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkge1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG5cbn1cbmNvbnN0IHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50U2l6ZT0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKiBAdG9kbyBzaG91bGQgYmUgcG9zc2libGUgdG8gc2NhbGUgYWxvbmcgYWxsIGF4ZXNcbiAqIEB0b2RvIFJlZmFjdG9yIGVsZW1lbnRTaXplIHRvIGVsZW1lbnRTaXplWCBhbmQgZWxlbWVudFNpemVZXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgY29uc3QgZGF0YSA9IFtdO1xuICogICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICBjb25zdCB5ID0gMC41ICogTWF0aC5jb3MoMC4yICogaSk7XG4gKiAgICAgICAgIGRhdGEucHVzaCh5KTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGVcbiAqICAgICBjb25zdCBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcbiAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zXG4gKiAgICAgfSk7XG4gKiAgICAgY29uc3QgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICovXG5jbGFzcyBIZWlnaHRmaWVsZCBleHRlbmRzIFNoYXBlIHtcbiAgLy8gQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAvLyBNYXggdmFsdWUgb2YgdGhlIGRhdGEuXG4gIC8vIE1heCB2YWx1ZSBvZiB0aGUgZGF0YS5cbiAgLy8gVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudC4gVG8gZG86IGVsZW1lbnRTaXplWCBhbmQgWVxuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgbWF4VmFsdWU6IG51bGwsXG4gICAgICBtaW5WYWx1ZTogbnVsbCxcbiAgICAgIGVsZW1lbnRTaXplOiAxXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogU2hhcGUudHlwZXMuSEVJR0hURklFTERcbiAgICB9KTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlO1xuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSBvcHRpb25zLmVsZW1lbnRTaXplO1xuXG4gICAgaWYgKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlTWluVmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVNYXhWYWx1ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY2FjaGVFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBpbGxhckNvbnZleCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG4gICAgdGhpcy5waWxsYXJPZmZzZXQgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTsgLy8gXCJpX2pfaXNVcHBlclwiID0+IHsgY29udmV4OiAuLi4sIG9mZnNldDogLi4uIH1cbiAgICAvLyBmb3IgZXhhbXBsZTpcbiAgICAvLyBfY2FjaGVkUGlsbGFyc1tcIjBfMl8xXCJdXG5cbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS5cbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICovXG5cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fY2FjaGVkUGlsbGFycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIC5taW5WYWx1ZSBwcm9wZXJ0eVxuICAgKiBAbWV0aG9kIHVwZGF0ZU1pblZhbHVlXG4gICAqL1xuXG5cbiAgdXBkYXRlTWluVmFsdWUoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgbWluVmFsdWUgPSBkYXRhWzBdWzBdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBkYXRhW2ldW2pdO1xuXG4gICAgICAgIGlmICh2IDwgbWluVmFsdWUpIHtcbiAgICAgICAgICBtaW5WYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1pblZhbHVlID0gbWluVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgLm1heFZhbHVlIHByb3BlcnR5XG4gICAqIEBtZXRob2QgdXBkYXRlTWF4VmFsdWVcbiAgICovXG5cblxuICB1cGRhdGVNYXhWYWx1ZSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGxldCBtYXhWYWx1ZSA9IGRhdGFbMF1bMF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGRhdGFbaV1bal07XG5cbiAgICAgICAgaWYgKHYgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgIG1heFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBoZWlnaHQgdmFsdWUgYXQgYW4gaW5kZXguIERvbid0IGZvcmdldCB0byB1cGRhdGUgbWF4VmFsdWUgYW5kIG1pblZhbHVlIGFmdGVyIHlvdSdyZSBkb25lLlxuICAgKiBAbWV0aG9kIHNldEhlaWdodFZhbHVlQXRJbmRleFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHhpXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0geWlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqL1xuXG5cbiAgc2V0SGVpZ2h0VmFsdWVBdEluZGV4KHhpLCB5aSwgdmFsdWUpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGRhdGFbeGldW3lpXSA9IHZhbHVlOyAvLyBJbnZhbGlkYXRlIGNhY2hlXG5cbiAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7XG5cbiAgICBpZiAoeGkgPiAwKSB7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgdHJ1ZSk7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh5aSA+IDApIHtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCB0cnVlKTtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHlpID4gMCAmJiB4aSA+IDApIHtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpIC0gMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgbWF4L21pbiBpbiBhIHJlY3RhbmdsZSBpbiB0aGUgbWF0cml4IGRhdGFcbiAgICogQG1ldGhvZCBnZXRSZWN0TWluTWF4XG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5YXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5ZXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhYXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhZXG4gICAqIEBwYXJhbSAge2FycmF5fSBbcmVzdWx0XSBBbiBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi5cbiAgICogQHJldHVybiB7YXJyYXl9IFRoZSByZXN1bHQgYXJyYXksIGlmIGl0IHdhcyBwYXNzZWQgaW4uIE1pbmltdW0gd2lsbCBiZSBhdCBwb3NpdGlvbiAwIGFuZCBtYXggYXQgMS5cbiAgICovXG5cblxuICBnZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCByZXN1bHQgPSBbXSkge1xuICAgIC8vIEdldCBtYXggYW5kIG1pbiBvZiB0aGUgZGF0YVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7IC8vIFNldCBmaXJzdCB2YWx1ZVxuXG4gICAgbGV0IG1heCA9IHRoaXMubWluVmFsdWU7XG5cbiAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGlNaW5ZOyBqIDw9IGlNYXhZOyBqKyspIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZGF0YVtpXVtqXTtcblxuICAgICAgICBpZiAoaGVpZ2h0ID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTtcbiAgICByZXN1bHRbMV0gPSBtYXg7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgYSBsb2NhbCBwb3NpdGlvbiBvbiB0aGUgaGVpZ2h0ZmllbGQuIFRoZSBpbmRleGVzIGluZGljYXRlIHRoZSByZWN0YW5nbGVzLCBzbyBpZiB5b3VyIHRlcnJhaW4gaXMgbWFkZSBvZiBOIHggTiBoZWlnaHQgZGF0YSBwb2ludHMsIHlvdSB3aWxsIGhhdmUgcmVjdGFuZ2xlIGluZGV4ZXMgcmFuZ2luZyBmcm9tIDAgdG8gTi0xLlxuICAgKiBAbWV0aG9kIGdldEluZGV4T2ZQb3NpdGlvblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXlcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXAgSWYgdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBjbGFtcGVkIHRvIHRoZSBoZWlnaHRmaWVsZCBlZGdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIGdldEluZGV4T2ZQb3NpdGlvbih4LCB5LCByZXN1bHQsIGNsYW1wKSB7XG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgY29uc3QgdyA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgeGkgPSBNYXRoLmZsb29yKHggLyB3KTtcbiAgICBsZXQgeWkgPSBNYXRoLmZsb29yKHkgLyB3KTtcbiAgICByZXN1bHRbMF0gPSB4aTtcbiAgICByZXN1bHRbMV0gPSB5aTtcblxuICAgIGlmIChjbGFtcCkge1xuICAgICAgLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcbiAgICAgIGlmICh4aSA8IDApIHtcbiAgICAgICAgeGkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeWkgPCAwKSB7XG4gICAgICAgIHlpID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHhpID49IGRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB4aSA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHlpID49IGRhdGFbMF0ubGVuZ3RoIC0gMSkge1xuICAgICAgICB5aSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cblxuXG4gICAgaWYgKHhpIDwgMCB8fCB5aSA8IDAgfHwgeGkgPj0gZGF0YS5sZW5ndGggLSAxIHx8IHlpID49IGRhdGFbMF0ubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0VHJpYW5nbGVBdCh4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpIHtcbiAgICBjb25zdCBpZHggPSBnZXRIZWlnaHRBdF9pZHg7XG4gICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xuICAgIGxldCB4aSA9IGlkeFswXTtcbiAgICBsZXQgeWkgPSBpZHhbMV07XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChlZGdlQ2xhbXApIHtcbiAgICAgIHhpID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB4aSkpO1xuICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xuICAgIGNvbnN0IGxvd2VyRGlzdDIgPSAoeCAvIGVsZW1lbnRTaXplIC0geGkpICoqIDIgKyAoeSAvIGVsZW1lbnRTaXplIC0geWkpICoqIDI7XG4gICAgY29uc3QgdXBwZXJEaXN0MiA9ICh4IC8gZWxlbWVudFNpemUgLSAoeGkgKyAxKSkgKiogMiArICh5IC8gZWxlbWVudFNpemUgLSAoeWkgKyAxKSkgKiogMjtcbiAgICBjb25zdCB1cHBlciA9IGxvd2VyRGlzdDIgPiB1cHBlckRpc3QyO1xuICAgIHRoaXMuZ2V0VHJpYW5nbGUoeGksIHlpLCB1cHBlciwgYSwgYiwgYyk7XG4gICAgcmV0dXJuIHVwcGVyO1xuICB9XG5cbiAgZ2V0Tm9ybWFsQXQoeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpIHtcbiAgICBjb25zdCBhID0gZ2V0Tm9ybWFsQXRfYTtcbiAgICBjb25zdCBiID0gZ2V0Tm9ybWFsQXRfYjtcbiAgICBjb25zdCBjID0gZ2V0Tm9ybWFsQXRfYztcbiAgICBjb25zdCBlMCA9IGdldE5vcm1hbEF0X2UwO1xuICAgIGNvbnN0IGUxID0gZ2V0Tm9ybWFsQXRfZTE7XG4gICAgdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7XG4gICAgYi52c3ViKGEsIGUwKTtcbiAgICBjLnZzdWIoYSwgZTEpO1xuICAgIGUwLmNyb3NzKGUxLCByZXN1bHQpO1xuICAgIHJlc3VsdC5ub3JtYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuIEFBQkIgb2YgYSBzcXVhcmUgaW4gdGhlIGhlaWdodGZpZWxkXG4gICAqIEBwYXJhbSAge251bWJlcn0geGlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5aVxuICAgKiBAcGFyYW0gIHtBQUJCfSByZXN1bHRcbiAgICovXG5cblxuICBnZXRBYWJiQXRJbmRleCh4aSwgeWksIHtcbiAgICBsb3dlckJvdW5kLFxuICAgIHVwcGVyQm91bmRcbiAgfSkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLmVsZW1lbnRTaXplO1xuICAgIGxvd2VyQm91bmQuc2V0KHhpICogZWxlbWVudFNpemUsIHlpICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpXSk7XG4gICAgdXBwZXJCb3VuZC5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlaWdodCBpbiB0aGUgaGVpZ2h0ZmllbGQgYXQgYSBnaXZlbiBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGVkZ2VDbGFtcFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgZ2V0SGVpZ2h0QXQoeCwgeSwgZWRnZUNsYW1wKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBhID0gZ2V0SGVpZ2h0QXRfYTtcbiAgICBjb25zdCBiID0gZ2V0SGVpZ2h0QXRfYjtcbiAgICBjb25zdCBjID0gZ2V0SGVpZ2h0QXRfYztcbiAgICBjb25zdCBpZHggPSBnZXRIZWlnaHRBdF9pZHg7XG4gICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xuICAgIGxldCB4aSA9IGlkeFswXTtcbiAgICBsZXQgeWkgPSBpZHhbMV07XG5cbiAgICBpZiAoZWRnZUNsYW1wKSB7XG4gICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTtcbiAgICAgIHlpID0gTWF0aC5taW4oZGF0YVswXS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB5aSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHVwcGVyID0gdGhpcy5nZXRUcmlhbmdsZUF0KHgsIHksIGVkZ2VDbGFtcCwgYSwgYiwgYyk7XG4gICAgYmFyeWNlbnRyaWNXZWlnaHRzKHgsIHksIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIGdldEhlaWdodEF0X3dlaWdodHMpO1xuICAgIGNvbnN0IHcgPSBnZXRIZWlnaHRBdF93ZWlnaHRzO1xuXG4gICAgaWYgKHVwcGVyKSB7XG4gICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgIHJldHVybiBkYXRhW3hpICsgMV1beWkgKyAxXSAqIHcueCArIGRhdGFbeGldW3lpICsgMV0gKiB3LnkgKyBkYXRhW3hpICsgMV1beWldICogdy56O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgIHJldHVybiBkYXRhW3hpXVt5aV0gKiB3LnggKyBkYXRhW3hpICsgMV1beWldICogdy55ICsgZGF0YVt4aV1beWkgKyAxXSAqIHcuejtcbiAgICB9XG4gIH1cblxuICBnZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSkge1xuICAgIHJldHVybiB4aSArIFwiX1wiICsgeWkgKyBcIl9cIiArIChnZXRVcHBlclRyaWFuZ2xlID8gMSA6IDApO1xuICB9XG5cbiAgZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xuICB9XG5cbiAgc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCkge1xuICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0ge1xuICAgICAgY29udmV4LFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB0cmlhbmdsZSBmcm9tIHRoZSBoZWlnaHRmaWVsZFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpXG4gICAqIEBwYXJhbSAge251bWJlcn0geWlcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gdXBwZXJcbiAgICogQHBhcmFtICB7VmVjM30gYVxuICAgKiBAcGFyYW0gIHtWZWMzfSBiXG4gICAqIEBwYXJhbSAge1ZlYzN9IGNcbiAgICovXG5cblxuICBnZXRUcmlhbmdsZSh4aSwgeWksIHVwcGVyLCBhLCBiLCBjKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XG5cbiAgICBpZiAodXBwZXIpIHtcbiAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgYS5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0pO1xuICAgICAgYi5zZXQoeGkgKiBlbGVtZW50U2l6ZSwgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSk7XG4gICAgICBjLnNldCgoeGkgKyAxKSAqIGVsZW1lbnRTaXplLCB5aSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpICsgMV1beWldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICBhLnNldCh4aSAqIGVsZW1lbnRTaXplLCB5aSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aV0pO1xuICAgICAgYi5zZXQoKHhpICsgMSkgKiBlbGVtZW50U2l6ZSwgeWkgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpXSk7XG4gICAgICBjLnNldCh4aSAqIGVsZW1lbnRTaXplLCAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLCBkYXRhW3hpXVt5aSArIDFdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHRyaWFuZ2xlIGluIHRoZSB0ZXJyYWluIGluIHRoZSBmb3JtIG9mIGEgdHJpYW5ndWxhciBjb252ZXggc2hhcGUuXG4gICAqIEBtZXRob2QgZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gaVxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGdldFVwcGVyVHJpYW5nbGVcbiAgICovXG5cblxuICBnZXRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5waWxsYXJDb252ZXg7XG4gICAgbGV0IG9mZnNldFJlc3VsdCA9IHRoaXMucGlsbGFyT2Zmc2V0O1xuXG4gICAgaWYgKHRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IGRhdGEuY29udmV4O1xuICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IGRhdGEub2Zmc2V0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG4gICAgICBvZmZzZXRSZXN1bHQgPSBuZXcgVmVjMygpO1xuICAgICAgdGhpcy5waWxsYXJDb252ZXggPSByZXN1bHQ7XG4gICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG9mZnNldFJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICBjb25zdCBmYWNlcyA9IHJlc3VsdC5mYWNlczsgLy8gUmV1c2UgdmVydHMgaWYgcG9zc2libGVcblxuICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGlmICghcmVzdWx0LnZlcnRpY2VzW2ldKSB7XG4gICAgICAgIHJlc3VsdC52ZXJ0aWNlc1tpXSA9IG5ldyBWZWMzKCk7XG4gICAgICB9XG4gICAgfSAvLyBSZXVzZSBmYWNlcyBpZiBwb3NzaWJsZVxuXG5cbiAgICBmYWNlcy5sZW5ndGggPSA1O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIGlmICghZmFjZXNbaV0pIHtcbiAgICAgICAgZmFjZXNbaV0gPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0cyA9IHJlc3VsdC52ZXJ0aWNlcztcbiAgICBjb25zdCBoID0gKE1hdGgubWluKGRhdGFbeGldW3lpXSwgZGF0YVt4aSArIDFdW3lpXSwgZGF0YVt4aV1beWkgKyAxXSwgZGF0YVt4aSArIDFdW3lpICsgMV0pIC0gdGhpcy5taW5WYWx1ZSkgLyAyICsgdGhpcy5taW5WYWx1ZTtcblxuICAgIGlmICghZ2V0VXBwZXJUcmlhbmdsZSkge1xuICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXG4gICAgICBvZmZzZXRSZXN1bHQuc2V0KCh4aSArIDAuMjUpICogZWxlbWVudFNpemUsIC8vIHNvcnQgb2YgY2VudGVyIG9mIGEgdHJpYW5nbGVcbiAgICAgICh5aSArIDAuMjUpICogZWxlbWVudFNpemUsIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICApOyAvLyBUb3AgdHJpYW5nbGUgdmVydHNcblxuICAgICAgdmVydHNbMF0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpXSAtIGgpO1xuICAgICAgdmVydHNbMV0uc2V0KDAuNzUgKiBlbGVtZW50U2l6ZSwgLTAuMjUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpXSAtIGgpO1xuICAgICAgdmVydHNbMl0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIDAuNzUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aV1beWkgKyAxXSAtIGgpOyAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcblxuICAgICAgdmVydHNbM10uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIC0wLjI1ICogZWxlbWVudFNpemUsIC1oIC0gMSk7XG4gICAgICB2ZXJ0c1s0XS5zZXQoMC43NSAqIGVsZW1lbnRTaXplLCAtMC4yNSAqIGVsZW1lbnRTaXplLCAtaCAtIDEpO1xuICAgICAgdmVydHNbNV0uc2V0KC0wLjI1ICogZWxlbWVudFNpemUsIDAuNzUgKiBlbGVtZW50U2l6ZSwgLWggLSAxKTsgLy8gdG9wIHRyaWFuZ2xlXG5cbiAgICAgIGZhY2VzWzBdWzBdID0gMDtcbiAgICAgIGZhY2VzWzBdWzFdID0gMTtcbiAgICAgIGZhY2VzWzBdWzJdID0gMjsgLy8gYm90dG9tIHRyaWFuZ2xlXG5cbiAgICAgIGZhY2VzWzFdWzBdID0gNTtcbiAgICAgIGZhY2VzWzFdWzFdID0gNDtcbiAgICAgIGZhY2VzWzFdWzJdID0gMzsgLy8gLXggZmFjaW5nIHF1YWRcblxuICAgICAgZmFjZXNbMl1bMF0gPSAwO1xuICAgICAgZmFjZXNbMl1bMV0gPSAyO1xuICAgICAgZmFjZXNbMl1bMl0gPSA1O1xuICAgICAgZmFjZXNbMl1bM10gPSAzOyAvLyAteSBmYWNpbmcgcXVhZFxuXG4gICAgICBmYWNlc1szXVswXSA9IDE7XG4gICAgICBmYWNlc1szXVsxXSA9IDA7XG4gICAgICBmYWNlc1szXVsyXSA9IDM7XG4gICAgICBmYWNlc1szXVszXSA9IDQ7IC8vICt4eSBmYWNpbmcgcXVhZFxuXG4gICAgICBmYWNlc1s0XVswXSA9IDQ7XG4gICAgICBmYWNlc1s0XVsxXSA9IDU7XG4gICAgICBmYWNlc1s0XVsyXSA9IDI7XG4gICAgICBmYWNlc1s0XVszXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgb2Zmc2V0UmVzdWx0LnNldCgoeGkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXG4gICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCBoIC8vIHZlcnRpY2FsIGNlbnRlclxuICAgICAgKTsgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG5cbiAgICAgIHZlcnRzWzBdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgZGF0YVt4aSArIDFdW3lpICsgMV0gLSBoKTtcbiAgICAgIHZlcnRzWzFdLnNldCgtMC43NSAqIGVsZW1lbnRTaXplLCAwLjI1ICogZWxlbWVudFNpemUsIGRhdGFbeGldW3lpICsgMV0gLSBoKTtcbiAgICAgIHZlcnRzWzJdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIC0wLjc1ICogZWxlbWVudFNpemUsIGRhdGFbeGkgKyAxXVt5aV0gLSBoKTsgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG5cbiAgICAgIHZlcnRzWzNdLnNldCgwLjI1ICogZWxlbWVudFNpemUsIDAuMjUgKiBlbGVtZW50U2l6ZSwgLWggLSAxKTtcbiAgICAgIHZlcnRzWzRdLnNldCgtMC43NSAqIGVsZW1lbnRTaXplLCAwLjI1ICogZWxlbWVudFNpemUsIC1oIC0gMSk7XG4gICAgICB2ZXJ0c1s1XS5zZXQoMC4yNSAqIGVsZW1lbnRTaXplLCAtMC43NSAqIGVsZW1lbnRTaXplLCAtaCAtIDEpOyAvLyBUb3AgdHJpYW5nbGVcblxuICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgZmFjZXNbMF1bMV0gPSAxO1xuICAgICAgZmFjZXNbMF1bMl0gPSAyOyAvLyBib3R0b20gdHJpYW5nbGVcblxuICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgZmFjZXNbMV1bMV0gPSA0O1xuICAgICAgZmFjZXNbMV1bMl0gPSAzOyAvLyAreCBmYWNpbmcgcXVhZFxuXG4gICAgICBmYWNlc1syXVswXSA9IDI7XG4gICAgICBmYWNlc1syXVsxXSA9IDU7XG4gICAgICBmYWNlc1syXVsyXSA9IDM7XG4gICAgICBmYWNlc1syXVszXSA9IDA7IC8vICt5IGZhY2luZyBxdWFkXG5cbiAgICAgIGZhY2VzWzNdWzBdID0gMztcbiAgICAgIGZhY2VzWzNdWzFdID0gNDtcbiAgICAgIGZhY2VzWzNdWzJdID0gMTtcbiAgICAgIGZhY2VzWzNdWzNdID0gMDsgLy8gLXh5IGZhY2luZyBxdWFkXG5cbiAgICAgIGZhY2VzWzRdWzBdID0gMTtcbiAgICAgIGZhY2VzWzRdWzFdID0gNDtcbiAgICAgIGZhY2VzWzRdWzJdID0gNTtcbiAgICAgIGZhY2VzWzRdWzNdID0gMjtcbiAgICB9XG5cbiAgICByZXN1bHQuY29tcHV0ZU5vcm1hbHMoKTtcbiAgICByZXN1bHQuY29tcHV0ZUVkZ2VzKCk7XG4gICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgdGhpcy5zZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIHJlc3VsdCwgb2Zmc2V0UmVzdWx0KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCB0YXJnZXQgPSBuZXcgVmVjMygpKSB7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdm9sdW1lKCkge1xuICAgIHJldHVybiAoLy8gVGhlIHRlcnJhaW4gaXMgaW5maW5pdGVcbiAgICAgIE51bWJlci5NQVhfVkFMVUVcbiAgICApO1xuICB9XG5cbiAgY2FsY3VsYXRlV29ybGRBQUJCKHBvcywgcXVhdCwgbWluLCBtYXgpIHtcbiAgICAvLyBUT0RPOiBkbyBpdCBwcm9wZXJseVxuICAgIG1pbi5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgbWF4LnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkge1xuICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgcyA9IHRoaXMuZWxlbWVudFNpemU7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IG5ldyBWZWMzKGRhdGEubGVuZ3RoICogcywgZGF0YVswXS5sZW5ndGggKiBzLCBNYXRoLm1heChNYXRoLmFicyh0aGlzLm1heFZhbHVlKSwgTWF0aC5hYnModGhpcy5taW5WYWx1ZSkpKS5sZW5ndGgoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaGVpZ2h0IHZhbHVlcyBmcm9tIGFuIGltYWdlLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3Nlci5cbiAgICogQG1ldGhvZCBzZXRIZWlnaHRzRnJvbUltYWdlXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAqIEBwYXJhbSB7VmVjM30gc2NhbGVcbiAgICovXG5cblxuICBzZXRIZWlnaHRzRnJvbUltYWdlKGltYWdlLCBzY2FsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB6LFxuICAgICAgeVxuICAgIH0gPSBzY2FsZTtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5kYXRhO1xuICAgIG1hdHJpeC5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSBNYXRoLmFicyh4KSAvIGltYWdlRGF0YS53aWR0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VEYXRhLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbWFnZURhdGEud2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBhID0gaW1hZ2VEYXRhLmRhdGFbKGkgKiBpbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0XTtcbiAgICAgICAgY29uc3QgYiA9IGltYWdlRGF0YS5kYXRhWyhpICogaW1hZ2VEYXRhLmhlaWdodCArIGopICogNCArIDFdO1xuICAgICAgICBjb25zdCBjID0gaW1hZ2VEYXRhLmRhdGFbKGkgKiBpbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IChhICsgYiArIGMpIC8gNCAvIDI1NSAqIHo7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgcm93LnB1c2goaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICBtYXRyaXgudW5zaGlmdChyb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0cml4LnB1c2gocm93KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XG4gICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuY29uc3QgZ2V0SGVpZ2h0QXRfaWR4ID0gW107XG5jb25zdCBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTtcbmNvbnN0IGdldEhlaWdodEF0X2EgPSBuZXcgVmVjMygpO1xuY29uc3QgZ2V0SGVpZ2h0QXRfYiA9IG5ldyBWZWMzKCk7XG5jb25zdCBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTtcbmNvbnN0IGdldE5vcm1hbEF0X2EgPSBuZXcgVmVjMygpO1xuY29uc3QgZ2V0Tm9ybWFsQXRfYiA9IG5ldyBWZWMzKCk7XG5jb25zdCBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTtcbmNvbnN0IGdldE5vcm1hbEF0X2UwID0gbmV3IFZlYzMoKTtcbmNvbnN0IGdldE5vcm1hbEF0X2UxID0gbmV3IFZlYzMoKTsgLy8gZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXJ5Y2VudHJpY19jb29yZGluYXRlX3N5c3RlbVxuXG5mdW5jdGlvbiBiYXJ5Y2VudHJpY1dlaWdodHMoeCwgeSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcmVzdWx0KSB7XG4gIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7XG4gIHJlc3VsdC55ID0gKChjeSAtIGF5KSAqICh4IC0gY3gpICsgKGF4IC0gY3gpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7XG4gIHJlc3VsdC56ID0gMSAtIHJlc3VsdC54IC0gcmVzdWx0Lnk7XG59XG5cbi8qKlxyXG4gKiBAY2xhc3MgT2N0cmVlTm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge09jdHJlZX0gW29wdGlvbnMucm9vdF1cclxuICogQHBhcmFtIHtBQUJCfSBbb3B0aW9ucy5hYWJiXVxyXG4gKi9cbmNsYXNzIE9jdHJlZU5vZGUge1xuICAvLyBUaGUgcm9vdCBub2RlXG4gIC8vIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxuICAvLyBDb250YWluZWQgZGF0YSBhdCB0aGUgY3VycmVudCBub2RlIGxldmVsXG4gIC8vIENoaWxkcmVuIHRvIHRoaXMgbm9kZVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcbiAgICB0aGlzLmFhYmIgPSBvcHRpb25zLmFhYmIgPyBvcHRpb25zLmFhYmIuY2xvbmUoKSA6IG5ldyBBQUJCKCk7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZVxyXG4gICAqIEBtZXRob2QgaW5zZXJ0XHJcbiAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudERhdGFcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAqL1xuXG5cbiAgaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCA9IDApIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuZGF0YTsgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxuXG4gICAgaWYgKCF0aGlzLmFhYmIuY29udGFpbnMoYWFiYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZFxuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCBtYXhEZXB0aCA9IHRoaXMubWF4RGVwdGggfHwgdGhpcy5yb290Lm1heERlcHRoO1xuXG4gICAgaWYgKGxldmVsIDwgbWF4RGVwdGgpIHtcbiAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XG4gICAgICBsZXQgc3ViZGl2aWRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnN1YmRpdmlkZSgpO1xuICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gYWRkIHRvIHdoaWNoZXZlciBub2RlIHdpbGwgYWNjZXB0IGl0XG5cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IDg7IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRyZW5baV0uaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCArIDEpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1YmRpdmlkZWQpIHtcbiAgICAgICAgLy8gTm8gY2hpbGRyZW4gYWNjZXB0ZWQhIE1pZ2h0IGFzIHdlbGwganVzdCByZW1vdmUgZW0gc2luY2UgdGhleSBjb250YWluIG5vbmVcbiAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIFRvbyBkZWVwLCBvciBjaGlsZHJlbiBkaWRudCB3YW50IGl0LiBhZGQgaXQgaW4gY3VycmVudCBub2RlXG5cblxuICAgIG5vZGVEYXRhLnB1c2goZWxlbWVudERhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSA4IGVxdWFsbHkgc2l6ZWQgY2hpbGRyZW4gbm9kZXMgYW5kIHB1dCB0aGVtIGluIHRoZSAuY2hpbGRyZW4gYXJyYXkuXHJcbiAgICogQG1ldGhvZCBzdWJkaXZpZGVcclxuICAgKi9cblxuXG4gIHN1YmRpdmlkZSgpIHtcbiAgICBjb25zdCBhYWJiID0gdGhpcy5hYWJiO1xuICAgIGNvbnN0IGwgPSBhYWJiLmxvd2VyQm91bmQ7XG4gICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgY2hpbGRyZW4ucHVzaChuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDApXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDAsIDApXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDApXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDEpXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDEsIDEpXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDEpXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDAsIDEpXG4gICAgICB9KVxuICAgIH0pLCBuZXcgT2N0cmVlTm9kZSh7XG4gICAgICBhYWJiOiBuZXcgQUFCQih7XG4gICAgICAgIGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDEsIDApXG4gICAgICB9KVxuICAgIH0pKTtcbiAgICB1LnZzdWIobCwgaGFsZkRpYWdvbmFsKTtcbiAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07IC8vIFNldCBjdXJyZW50IG5vZGUgYXMgcm9vdFxuXG4gICAgICBjaGlsZC5yb290ID0gcm9vdDsgLy8gQ29tcHV0ZSBib3VuZHNcblxuICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IGNoaWxkLmFhYmIubG93ZXJCb3VuZDtcbiAgICAgIGxvd2VyQm91bmQueCAqPSBoYWxmRGlhZ29uYWwueDtcbiAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcbiAgICAgIGxvd2VyQm91bmQueiAqPSBoYWxmRGlhZ29uYWwuejtcbiAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTsgLy8gVXBwZXIgYm91bmQgaXMgYWx3YXlzIGxvd2VyIGJvdW5kICsgaGFsZkRpYWdvbmFsXG5cbiAgICAgIGxvd2VyQm91bmQudmFkZChoYWxmRGlhZ29uYWwsIGNoaWxkLmFhYmIudXBwZXJCb3VuZCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcclxuICAgKiBAbWV0aG9kIGFhYmJRdWVyeVxyXG4gICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XHJcbiAgICogQHJldHVybiB7YXJyYXl9IFRoZSBcInJlc3VsdFwiIG9iamVjdFxyXG4gICAqL1xuXG5cbiAgYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5kYXRhOyAvLyBhYm9ydCBpZiB0aGUgcmFuZ2UgZG9lcyBub3QgaW50ZXJzZWN0IHRoaXMgbm9kZVxuICAgIC8vIGlmICghdGhpcy5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAvLyAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyB9XG4gICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbFxuICAgIC8vIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZURhdGEpO1xuICAgIC8vIEFkZCBjaGlsZCBkYXRhXG4gICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTXG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47IC8vIGZvciAobGV0IGkgPSAwLCBOID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgIT09IE47IGkrKykge1xuICAgIC8vICAgICBjaGlsZHJlbltpXS5hYWJiUXVlcnkoYWFiYiwgcmVzdWx0KTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCBxdWV1ZSA9IFt0aGlzXTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5wb3AoKTtcblxuICAgICAgaWYgKG5vZGUuYWFiYi5vdmVybGFwcyhhYWJiKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHF1ZXVlLCBub2RlLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgaW50ZXJzZWN0ZWQgYnkgYSByYXkuXHJcbiAgICogQG1ldGhvZCByYXlRdWVyeVxyXG4gICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtfSB0cmVlVHJhbnNmb3JtXHJcbiAgICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdFxyXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgXCJyZXN1bHRcIiBvYmplY3RcclxuICAgKi9cblxuXG4gIHJheVF1ZXJ5KHJheSwgdHJlZVRyYW5zZm9ybSwgcmVzdWx0KSB7XG4gICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cbiAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXG4gICAgcmF5LmdldEFBQkIodG1wQUFCQiQxKTtcbiAgICB0bXBBQUJCJDEudG9Mb2NhbEZyYW1lKHRyZWVUcmFuc2Zvcm0sIHRtcEFBQkIkMSk7XG4gICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiQxLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCByZW1vdmVFbXB0eU5vZGVzXHJcbiAgICovXG5cblxuICByZW1vdmVFbXB0eU5vZGVzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbW92ZUVtcHR5Tm9kZXMoKTtcblxuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuW2ldLmNoaWxkcmVuLmxlbmd0aCAmJiAhdGhpcy5jaGlsZHJlbltpXS5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIEBjbGFzcyBPY3RyZWVcclxuICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heERlcHRoPThdIE1heGltdW0gc3ViZGl2aXNpb24gZGVwdGhcclxuICogQGV4dGVuZHMgT2N0cmVlTm9kZVxyXG4gKi9cblxuXG5jbGFzcyBPY3RyZWUgZXh0ZW5kcyBPY3RyZWVOb2RlIHtcbiAgLy8gTWF4aW11bSBzdWJkaXZpc2lvbiBkZXB0aFxuICBjb25zdHJ1Y3RvcihhYWJiLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICByb290OiBudWxsLFxuICAgICAgYWFiYlxuICAgIH0pO1xuICAgIHRoaXMubWF4RGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5tYXhEZXB0aCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heERlcHRoIDogODtcbiAgfVxuXG59XG5jb25zdCBoYWxmRGlhZ29uYWwgPSBuZXcgVmVjMygpO1xuY29uc3QgdG1wQUFCQiQxID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBAY2xhc3MgVHJpbWVzaFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2FycmF5fSB2ZXJ0aWNlc1xuICogQHBhcmFtIHthcnJheX0gaW5kaWNlc1xuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSG93IHRvIG1ha2UgYSBtZXNoIHdpdGggYSBzaW5nbGUgdHJpYW5nbGVcbiAqICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtcbiAqICAgICAgICAgMCwgMCwgMCwgLy8gdmVydGV4IDBcbiAqICAgICAgICAgMSwgMCwgMCwgLy8gdmVydGV4IDFcbiAqICAgICAgICAgMCwgMSwgMCAgLy8gdmVydGV4IDJcbiAqICAgICBdO1xuICogICAgIGNvbnN0IGluZGljZXMgPSBbXG4gKiAgICAgICAgIDAsIDEsIDIgIC8vIHRyaWFuZ2xlIDBcbiAqICAgICBdO1xuICogICAgIGNvbnN0IHRyaW1lc2hTaGFwZSA9IG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAqL1xuY2xhc3MgVHJpbWVzaCBleHRlbmRzIFNoYXBlIHtcbiAgLy8gQXJyYXkgb2YgaW50ZWdlcnMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCB0cmlhbmdsZSBjb25zaXN0cyBvZi4gVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IGlzIHRodXMgMyB0aW1lcyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cbiAgLy8gVGhlIG5vcm1hbHMgZGF0YS5cbiAgLy8gVGhlIGxvY2FsIEFBQkIgb2YgdGhlIG1lc2guXG4gIC8vIFJlZmVyZW5jZXMgdG8gdmVydGV4IHBhaXJzLCBtYWtpbmcgdXAgYWxsIHVuaXF1ZSBlZGdlcyBpbiB0aGUgdHJpbWVzaC5cbiAgLy8gTG9jYWwgc2NhbGluZyBvZiB0aGUgbWVzaC4gVXNlIC5zZXRTY2FsZSgpIHRvIHNldCBpdC5cbiAgLy8gVGhlIGluZGV4ZWQgdHJpYW5nbGVzLiBVc2UgLnVwZGF0ZVRyZWUoKSB0byB1cGRhdGUgaXQuXG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogU2hhcGUudHlwZXMuVFJJTUVTSFxuICAgIH0pO1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTtcbiAgICB0aGlzLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMubGVuZ3RoKTtcbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgIHRoaXMuZWRnZXMgPSBudWxsO1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcbiAgICB0aGlzLnRyZWUgPSBuZXcgT2N0cmVlKCk7XG4gICAgdGhpcy51cGRhdGVFZGdlcygpO1xuICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xuICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZVRyZWUoKTtcbiAgfVxuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVUcmVlXG4gICAqL1xuXG5cbiAgdXBkYXRlVHJlZSgpIHtcbiAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlO1xuICAgIHRyZWUucmVzZXQoKTtcbiAgICB0cmVlLmFhYmIuY29weSh0aGlzLmFhYmIpO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkXG5cbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueiAqPSAxIC8gc2NhbGUuejsgLy8gSW5zZXJ0IGFsbCB0cmlhbmdsZXNcblxuICAgIGNvbnN0IHRyaWFuZ2xlQUFCQiA9IG5ldyBBQUJCKCk7XG4gICAgY29uc3QgYSA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgYiA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgYyA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgcG9pbnRzID0gW2EsIGIsIGNdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICAvL3RoaXMuZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCBhLCBiLCBjKTtcbiAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgY29uc3QgaTMgPSBpICogMztcblxuICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG5cbiAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcblxuICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xuXG4gICAgICB0cmlhbmdsZUFBQkIuc2V0RnJvbVBvaW50cyhwb2ludHMpO1xuICAgICAgdHJlZS5pbnNlcnQodHJpYW5nbGVBQUJCLCBpKTtcbiAgICB9XG5cbiAgICB0cmVlLnJlbW92ZUVtcHR5Tm9kZXMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cbiAgICogQG1ldGhvZCBnZXRUcmlhbmdsZXNJbkFBQkJcbiAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICAgKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXG4gICAqL1xuXG5cbiAgZ2V0VHJpYW5nbGVzSW5BQUJCKGFhYmIsIHJlc3VsdCkge1xuICAgIHVuc2NhbGVkQUFCQi5jb3B5KGFhYmIpOyAvLyBTY2FsZSBpdCB0byBsb2NhbFxuXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGNvbnN0IGlzeCA9IHNjYWxlLng7XG4gICAgY29uc3QgaXN5ID0gc2NhbGUueTtcbiAgICBjb25zdCBpc3ogPSBzY2FsZS56O1xuICAgIGNvbnN0IGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDtcbiAgICBjb25zdCB1ID0gdW5zY2FsZWRBQUJCLnVwcGVyQm91bmQ7XG4gICAgbC54IC89IGlzeDtcbiAgICBsLnkgLz0gaXN5O1xuICAgIGwueiAvPSBpc3o7XG4gICAgdS54IC89IGlzeDtcbiAgICB1LnkgLz0gaXN5O1xuICAgIHUueiAvPSBpc3o7XG4gICAgcmV0dXJuIHRoaXMudHJlZS5hYWJiUXVlcnkodW5zY2FsZWRBQUJCLCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFNjYWxlXG4gICAqIEBwYXJhbSB7VmVjM30gc2NhbGVcbiAgICovXG5cblxuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IHdhc1VuaWZvcm0gPSB0aGlzLnNjYWxlLnggPT09IHRoaXMuc2NhbGUueSAmJiB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcbiAgICBjb25zdCBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ICYmIHNjYWxlLnkgPT09IHNjYWxlLno7XG5cbiAgICBpZiAoISh3YXNVbmlmb3JtICYmIGlzVW5pZm9ybSkpIHtcbiAgICAgIC8vIE5vbi11bmlmb3JtIHNjYWxpbmcuIE5lZWQgdG8gdXBkYXRlIG5vcm1hbHMuXG4gICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNjYWxlLmNvcHkoc2NhbGUpO1xuICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgfVxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgc2F2ZSBpbiB0aGUgLm5vcm1hbHMgYXJyYXkuXG4gICAqIEBtZXRob2QgdXBkYXRlTm9ybWFsc1xuICAgKi9cblxuXG4gIHVwZGF0ZU5vcm1hbHMoKSB7XG4gICAgY29uc3QgbiA9IGNvbXB1dGVOb3JtYWxzX247IC8vIEdlbmVyYXRlIG5vcm1hbHNcblxuICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIGNvbnN0IGkzID0gaSAqIDM7XG4gICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTtcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmluZGljZXNbaTMgKyAxXTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmluZGljZXNbaTMgKyAyXTtcbiAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTtcbiAgICAgIHRoaXMuZ2V0VmVydGV4KGIsIHZiKTtcbiAgICAgIHRoaXMuZ2V0VmVydGV4KGMsIHZjKTtcbiAgICAgIFRyaW1lc2guY29tcHV0ZU5vcm1hbCh2YiwgdmEsIHZjLCBuKTtcbiAgICAgIG5vcm1hbHNbaTNdID0gbi54O1xuICAgICAgbm9ybWFsc1tpMyArIDFdID0gbi55O1xuICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSAuZWRnZXMgcHJvcGVydHlcbiAgICogQG1ldGhvZCB1cGRhdGVFZGdlc1xuICAgKi9cblxuXG4gIHVwZGF0ZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0ge307XG5cbiAgICBjb25zdCBhZGQgPSAoYSwgYikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYSA8IGIgPyBhICsgXCJfXCIgKyBiIDogYiArIFwiX1wiICsgYTtcbiAgICAgIGVkZ2VzW2tleV0gPSB0cnVlO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIGNvbnN0IGkzID0gaSAqIDM7XG4gICAgICBjb25zdCBhID0gdGhpcy5pbmRpY2VzW2kzXTtcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmluZGljZXNbaTMgKyAxXTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmluZGljZXNbaTMgKyAyXTtcbiAgICAgIGFkZChhLCBiKTtcbiAgICAgIGFkZChiLCBjKTtcbiAgICAgIGFkZChjLCBhKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpO1xuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0ga2V5c1tpXS5zcGxpdCgnXycpO1xuICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XG4gICAgICB0aGlzLmVkZ2VzWzIgKiBpICsgMV0gPSBwYXJzZUludChpbmRpY2VzWzFdLCAxMCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgYW4gZWRnZSB2ZXJ0ZXhcbiAgICogQG1ldGhvZCBnZXRFZGdlVmVydGV4XG4gICAqIEBwYXJhbSAge251bWJlcn0gZWRnZUluZGV4XG4gICAqIEBwYXJhbSAge251bWJlcn0gZmlyc3RPclNlY29uZCAwIG9yIDEsIGRlcGVuZGluZyBvbiB3aGljaCBvbmUgb2YgdGhlIHZlcnRpY2VzIHlvdSBuZWVkLlxuICAgKiBAcGFyYW0gIHtWZWMzfSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqL1xuXG5cbiAgZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKSB7XG4gICAgY29uc3QgdmVydGV4SW5kZXggPSB0aGlzLmVkZ2VzW2VkZ2VJbmRleCAqIDIgKyAoZmlyc3RPclNlY29uZCA/IDEgOiAwKV07XG4gICAgdGhpcy5nZXRWZXJ0ZXgodmVydGV4SW5kZXgsIHZlcnRleFN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdmVjdG9yIGFsb25nIGFuIGVkZ2UuXG4gICAqIEBtZXRob2QgZ2V0RWRnZVZlY3RvclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVkZ2VJbmRleFxuICAgKiBAcGFyYW0gIHtWZWMzfSB2ZWN0b3JTdG9yZVxuICAgKi9cblxuXG4gIGdldEVkZ2VWZWN0b3IoZWRnZUluZGV4LCB2ZWN0b3JTdG9yZSkge1xuICAgIGNvbnN0IHZhID0gZ2V0RWRnZVZlY3Rvcl92YTtcbiAgICBjb25zdCB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7XG4gICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMCwgdmEpO1xuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcbiAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB2ZXJ0ZXggaS5cbiAgICogQG1ldGhvZCBnZXRWZXJ0ZXhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpXG4gICAqIEBwYXJhbSAge1ZlYzN9IG91dFxuICAgKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gICAqL1xuXG5cbiAgZ2V0VmVydGV4KGksIG91dCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7XG5cbiAgICBvdXQueCAqPSBzY2FsZS54O1xuICAgIG91dC55ICo9IHNjYWxlLnk7XG4gICAgb3V0LnogKj0gc2NhbGUuejtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcmF3IHZlcnRleCBpXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX2dldFVuc2NhbGVkVmVydGV4XG4gICAqIEBwYXJhbSAge251bWJlcn0gaVxuICAgKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAgICogQHJldHVybiB7VmVjM30gVGhlIFwib3V0XCIgdmVjdG9yIG9iamVjdFxuICAgKi9cblxuXG4gIF9nZXRVbnNjYWxlZFZlcnRleChpLCBvdXQpIHtcbiAgICBjb25zdCBpMyA9IGkgKiAzO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICByZXR1cm4gb3V0LnNldCh2ZXJ0aWNlc1tpM10sIHZlcnRpY2VzW2kzICsgMV0sIHZlcnRpY2VzW2kzICsgMl0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXG4gICAqIEBtZXRob2QgZ2V0V29ybGRWZXJ0ZXhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpXG4gICAqIEBwYXJhbSAge1ZlYzN9IHBvc1xuICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAqIEBwYXJhbSAge1ZlYzN9IG91dFxuICAgKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gICAqL1xuXG5cbiAgZ2V0V29ybGRWZXJ0ZXgoaSwgcG9zLCBxdWF0LCBvdXQpIHtcbiAgICB0aGlzLmdldFZlcnRleChpLCBvdXQpO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3MsIHF1YXQsIG91dCwgb3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRocmVlIHZlcnRpY2VzIGZvciB0cmlhbmdsZSBpLlxuICAgKiBAbWV0aG9kIGdldFRyaWFuZ2xlVmVydGljZXNcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpXG4gICAqIEBwYXJhbSAge1ZlYzN9IGFcbiAgICogQHBhcmFtICB7VmVjM30gYlxuICAgKiBAcGFyYW0gIHtWZWMzfSBjXG4gICAqL1xuXG5cbiAgZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCBhLCBiLCBjKSB7XG4gICAgY29uc3QgaTMgPSBpICogMztcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTNdLCBhKTtcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgdHJpYW5nbGUgaS5cbiAgICogQG1ldGhvZCBnZXROb3JtYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSBpXG4gICAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XG4gICAqL1xuXG5cbiAgZ2V0Tm9ybWFsKGksIHRhcmdldCkge1xuICAgIGNvbnN0IGkzID0gaSAqIDM7XG4gICAgcmV0dXJuIHRhcmdldC5zZXQodGhpcy5ub3JtYWxzW2kzXSwgdGhpcy5ub3JtYWxzW2kzICsgMV0sIHRoaXMubm9ybWFsc1tpMyArIDJdKTtcbiAgfVxuICAvKipcbiAgICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gICAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XG4gICAqL1xuXG5cbiAgY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRhcmdldCkge1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpO1xuICAgIGNvbnN0IHggPSBjbGlfYWFiYi51cHBlckJvdW5kLnggLSBjbGlfYWFiYi5sb3dlckJvdW5kLng7XG4gICAgY29uc3QgeSA9IGNsaV9hYWJiLnVwcGVyQm91bmQueSAtIGNsaV9hYWJiLmxvd2VyQm91bmQueTtcbiAgICBjb25zdCB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56O1xuICAgIHJldHVybiB0YXJnZXQuc2V0KDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB5ICogMiAqIHkgKyAyICogeiAqIDIgKiB6KSwgMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHggKiAyICogeCArIDIgKiB6ICogMiAqIHopLCAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHggKiAyICogeCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsb2NhbCBBQUJCIGZvciB0aGUgdHJpbWVzaFxuICAgKiBAbWV0aG9kIGNvbXB1dGVMb2NhbEFBQkJcbiAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICAgKi9cblxuXG4gIGNvbXB1dGVMb2NhbEFBQkIoYWFiYikge1xuICAgIGNvbnN0IGwgPSBhYWJiLmxvd2VyQm91bmQ7XG4gICAgY29uc3QgdSA9IGFhYmIudXBwZXJCb3VuZDtcbiAgICBjb25zdCBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGNvbnN0IHYgPSBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydDtcbiAgICB0aGlzLmdldFZlcnRleCgwLCB2KTtcbiAgICBsLmNvcHkodik7XG4gICAgdS5jb3B5KHYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IG47IGkrKykge1xuICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XG5cbiAgICAgIGlmICh2LnggPCBsLngpIHtcbiAgICAgICAgbC54ID0gdi54O1xuICAgICAgfSBlbHNlIGlmICh2LnggPiB1LngpIHtcbiAgICAgICAgdS54ID0gdi54O1xuICAgICAgfVxuXG4gICAgICBpZiAodi55IDwgbC55KSB7XG4gICAgICAgIGwueSA9IHYueTtcbiAgICAgIH0gZWxzZSBpZiAodi55ID4gdS55KSB7XG4gICAgICAgIHUueSA9IHYueTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYueiA8IGwueikge1xuICAgICAgICBsLnogPSB2Lno7XG4gICAgICB9IGVsc2UgaWYgKHYueiA+IHUueikge1xuICAgICAgICB1LnogPSB2Lno7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIC5hYWJiIHByb3BlcnR5XG4gICAqIEBtZXRob2QgdXBkYXRlQUFCQlxuICAgKi9cblxuXG4gIHVwZGF0ZUFBQkIoKSB7XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKHRoaXMuYWFiYik7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgdXBkYXRlIHRoZSAuYm91bmRpbmdTcGhlcmVSYWRpdXMgcHJvcGVydHlcbiAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICAgKi9cblxuXG4gIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkge1xuICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXJcbiAgICBsZXQgbWF4MiA9IDA7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGNvbnN0IHYgPSBuZXcgVmVjMygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIE4gPSB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuICAgICAgY29uc3Qgbm9ybTIgPSB2Lmxlbmd0aFNxdWFyZWQoKTtcblxuICAgICAgaWYgKG5vcm0yID4gbWF4Mikge1xuICAgICAgICBtYXgyID0gbm9ybTI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTtcbiAgfVxuICAvKipcbiAgICogQG1ldGhvZCBjYWxjdWxhdGVXb3JsZEFBQkJcbiAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcbiAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWluXG4gICAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxuICAgKi9cblxuXG4gIGNhbGN1bGF0ZVdvcmxkQUFCQihwb3MsIHF1YXQsIG1pbiwgbWF4KSB7XG4gICAgLypcbiAgICAgICAgY29uc3QgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC8gMyxcbiAgICAgICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgY29uc3QgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XG4gICAgICAgICBjb25zdCB2ID0gdGVtcFdvcmxkVmVydGV4O1xuICAgICAgICBmb3IobGV0IGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoaSwgdik7XG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsIHYpO1xuICAgICAgICAgICAgcG9zLnZhZGQodiwgdik7XG4gICAgICAgICAgICBpZiAodi54IDwgbWlueCB8fCBtaW54PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBtaW54ID0gdi54O1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHYueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBpZiAodi55IDwgbWlueSB8fCBtaW55PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHYueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICBtaW56ID0gdi56O1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcbiAgICAgICAgbWF4LnNldChtYXh4LG1heHksbWF4eik7XG4gICAgICAgICovXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxuICAgIGNvbnN0IGZyYW1lID0gY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lO1xuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiO1xuICAgIGZyYW1lLnBvc2l0aW9uID0gcG9zO1xuICAgIGZyYW1lLnF1YXRlcm5pb24gPSBxdWF0O1xuICAgIHRoaXMuYWFiYi50b1dvcmxkRnJhbWUoZnJhbWUsIHJlc3VsdCk7XG4gICAgbWluLmNvcHkocmVzdWx0Lmxvd2VyQm91bmQpO1xuICAgIG1heC5jb3B5KHJlc3VsdC51cHBlckJvdW5kKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFwcHJveGltYXRlIHZvbHVtZVxuICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuXG5cbiAgdm9sdW1lKCkge1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbiAgfVxuXG59XG5jb25zdCBjb21wdXRlTm9ybWFsc19uID0gbmV3IFZlYzMoKTtcbmNvbnN0IHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XG5jb25zdCBnZXRFZGdlVmVjdG9yX3ZhID0gbmV3IFZlYzMoKTtcbmNvbnN0IGdldEVkZ2VWZWN0b3JfdmIgPSBuZXcgVmVjMygpO1xuLyoqXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb21wdXRlTm9ybWFsXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXG4gKiBAcGFyYW0ge1ZlYzN9IHZiXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG5cbmNvbnN0IGNiID0gbmV3IFZlYzMoKTtcbmNvbnN0IGFiID0gbmV3IFZlYzMoKTtcblxuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gKHZhLCB2YiwgdmMsIHRhcmdldCkgPT4ge1xuICB2Yi52c3ViKHZhLCBhYik7XG4gIHZjLnZzdWIodmIsIGNiKTtcbiAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7XG5cbiAgaWYgKCF0YXJnZXQuaXNaZXJvKCkpIHtcbiAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gIH1cbn07XG5cbmNvbnN0IHZhID0gbmV3IFZlYzMoKTtcbmNvbnN0IHZiID0gbmV3IFZlYzMoKTtcbmNvbnN0IHZjID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNsaV9hYWJiID0gbmV3IEFBQkIoKTtcbmNvbnN0IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0ID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSA9IG5ldyBUcmFuc2Zvcm0oKTtcbmNvbnN0IGNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiID0gbmV3IEFBQkIoKTtcbi8qKlxuICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVRvcnVzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpdXM9MV1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02XVxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxuICogQHJldHVybiB7VHJpbWVzaH0gQSB0b3J1c1xuICovXG5cblRyaW1lc2guY3JlYXRlVG9ydXMgPSAocmFkaXVzID0gMSwgdHViZSA9IDAuNSwgcmFkaWFsU2VnbWVudHMgPSA4LCB0dWJ1bGFyU2VnbWVudHMgPSA2LCBhcmMgPSBNYXRoLlBJICogMikgPT4ge1xuICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICBjb25zdCBpbmRpY2VzID0gW107XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrKSB7XG4gICAgICBjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcbiAgICAgIGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcbiAgICAgIGNvbnN0IHggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuICAgICAgY29uc3QgeSA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5zaW4odSk7XG4gICAgICBjb25zdCB6ID0gdHViZSAqIE1hdGguc2luKHYpO1xuICAgICAgdmVydGljZXMucHVzaCh4LCB5LCB6KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaSAtIDE7XG4gICAgICBjb25zdCBiID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGkgLSAxO1xuICAgICAgY29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuICAgICAgY29uc3QgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIGogKyBpO1xuICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XG59O1xuXG4vKipcclxuICogQ29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIgYmFzZSBjbGFzcy5cclxuICogQGNsYXNzIFNvbHZlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKi9cbmNsYXNzIFNvbHZlciB7XG4gIC8vIEFsbCBlcXVhdGlvbnMgdG8gYmUgc29sdmVkXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXMhXHJcbiAgICogQG1ldGhvZCBzb2x2ZVxyXG4gICAqIEBwYXJhbSAge051bWJlcn0gZHRcclxuICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG51bWJlciBvZiBpdGVyYXRpb25zIHBlcmZvcm1lZFxyXG4gICAqL1xuXG5cbiAgc29sdmUoZHQsIHdvcmxkKSB7XG4gICAgcmV0dXJuICgvLyBTaG91bGQgcmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBkb25lIVxuICAgICAgMFxuICAgICk7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGFuIGVxdWF0aW9uXHJcbiAgICogQG1ldGhvZCBhZGRFcXVhdGlvblxyXG4gICAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAgICovXG5cblxuICBhZGRFcXVhdGlvbihlcSkge1xuICAgIGlmIChlcS5lbmFibGVkKSB7XG4gICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGVxdWF0aW9uXHJcbiAgICogQG1ldGhvZCByZW1vdmVFcXVhdGlvblxyXG4gICAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAgICovXG5cblxuICByZW1vdmVFcXVhdGlvbihlcSkge1xuICAgIGNvbnN0IGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGNvbnN0IGkgPSBlcXMuaW5kZXhPZihlcSk7XG5cbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIGVxcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBhbGwgZXF1YXRpb25zXHJcbiAgICogQG1ldGhvZCByZW1vdmVBbGxFcXVhdGlvbnNcclxuICAgKi9cblxuXG4gIHJlbW92ZUFsbEVxdWF0aW9ucygpIHtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIENvbnN0cmFpbnQgZXF1YXRpb24gR2F1c3MtU2VpZGVsIHNvbHZlci5cclxuICogQGNsYXNzIEdTU29sdmVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdG9kbyBUaGUgc3Bvb2sgcGFyYW1ldGVycyBzaG91bGQgYmUgc3BlY2lmaWVkIGZvciBlYWNoIGNvbnN0cmFpbnQsIG5vdCBnbG9iYWxseS5cclxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxyXG4gKiBAc2VlIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXHJcbiAqIEBleHRlbmRzIFNvbHZlclxyXG4gKi9cbmNsYXNzIEdTU29sdmVyIGV4dGVuZHMgU29sdmVyIHtcbiAgLy8gVGhlIG51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyBkZXRlcm1pbmVzIHF1YWxpdHkgb2YgdGhlIGNvbnN0cmFpbnRzIGluIHRoZSB3b3JsZC4gVGhlIG1vcmUgaXRlcmF0aW9ucywgdGhlIG1vcmUgY29ycmVjdCBzaW11bGF0aW9uLiBNb3JlIGl0ZXJhdGlvbnMgbmVlZCBtb3JlIGNvbXB1dGF0aW9ucyB0aG91Z2guIElmIHlvdSBoYXZlIGEgbGFyZ2UgZ3Jhdml0eSBmb3JjZSBpbiB5b3VyIHdvcmxkLCB5b3Ugd2lsbCBuZWVkIG1vcmUgaXRlcmF0aW9ucy5cbiAgLy8gV2hlbiB0b2xlcmFuY2UgaXMgcmVhY2hlZCwgdGhlIHN5c3RlbSBpcyBhc3N1bWVkIHRvIGJlIGNvbnZlcmdlZC5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XG4gIH1cbiAgLyoqXHJcbiAgICogU29sdmVcclxuICAgKiBAbWV0aG9kIHNvbHZlXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkdFxyXG4gICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgcGVyZm9ybWVkXHJcbiAgICovXG5cblxuICBzb2x2ZShkdCwgd29ybGQpIHtcbiAgICBsZXQgaXRlciA9IDA7XG4gICAgY29uc3QgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9ucztcbiAgICBjb25zdCB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UgKiB0aGlzLnRvbGVyYW5jZTtcbiAgICBjb25zdCBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBjb25zdCBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllcztcbiAgICBjb25zdCBOYm9kaWVzID0gYm9kaWVzLmxlbmd0aDtcbiAgICBjb25zdCBoID0gZHQ7XG4gICAgbGV0IEI7XG4gICAgbGV0IGludkM7XG4gICAgbGV0IGRlbHRhbGFtYmRhO1xuICAgIGxldCBkZWx0YWxhbWJkYVRvdDtcbiAgICBsZXQgR1dsYW1iZGE7XG4gICAgbGV0IGxhbWJkYWo7IC8vIFVwZGF0ZSBzb2x2ZSBtYXNzXG5cbiAgICBpZiAoTmVxICE9PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XG4gICAgICAgIGJvZGllc1tpXS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuXG5cbiAgICBjb25zdCBpbnZDcyA9IEdTU29sdmVyX3NvbHZlX2ludkNzO1xuICAgIGNvbnN0IEJzID0gR1NTb2x2ZXJfc29sdmVfQnM7XG4gICAgY29uc3QgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhO1xuICAgIGludkNzLmxlbmd0aCA9IE5lcTtcbiAgICBCcy5sZW5ndGggPSBOZXE7XG4gICAgbGFtYmRhLmxlbmd0aCA9IE5lcTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOZXE7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgIGxhbWJkYVtpXSA9IDAuMDtcbiAgICAgIEJzW2ldID0gYy5jb21wdXRlQihoKTtcbiAgICAgIGludkNzW2ldID0gMS4wIC8gYy5jb21wdXRlQygpO1xuICAgIH1cblxuICAgIGlmIChOZXEgIT09IDApIHtcbiAgICAgIC8vIFJlc2V0IHZsYW1iZGFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgY29uc3QgdmxhbWJkYSA9IGIudmxhbWJkYTtcbiAgICAgICAgY29uc3Qgd2xhbWJkYSA9IGIud2xhbWJkYTtcbiAgICAgICAgdmxhbWJkYS5zZXQoMCwgMCwgMCk7XG4gICAgICAgIHdsYW1iZGEuc2V0KDAsIDAsIDApO1xuICAgICAgfSAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXG5cblxuICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4SXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogIT09IE5lcTsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGVxdWF0aW9uc1tqXTsgLy8gQ29tcHV0ZSBpdGVyYXRpb25cblxuICAgICAgICAgIEIgPSBCc1tqXTtcbiAgICAgICAgICBpbnZDID0gaW52Q3Nbal07XG4gICAgICAgICAgbGFtYmRhaiA9IGxhbWJkYVtqXTtcbiAgICAgICAgICBHV2xhbWJkYSA9IGMuY29tcHV0ZUdXbGFtYmRhKCk7XG4gICAgICAgICAgZGVsdGFsYW1iZGEgPSBpbnZDICogKEIgLSBHV2xhbWJkYSAtIGMuZXBzICogbGFtYmRhaik7IC8vIENsYW1wIGlmIHdlIGFyZSBub3Qgd2l0aGluIHRoZSBtaW4vbWF4IGludGVydmFsXG5cbiAgICAgICAgICBpZiAobGFtYmRhaiArIGRlbHRhbGFtYmRhIDwgYy5taW5Gb3JjZSkge1xuICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1pbkZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2UpIHtcbiAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5tYXhGb3JjZSAtIGxhbWJkYWo7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSlcblxuICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgfSAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG5cblxuICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XG5cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xuICAgICAgICBjb25zdCBiID0gYm9kaWVzW2ldO1xuICAgICAgICBjb25zdCB2ID0gYi52ZWxvY2l0eTtcbiAgICAgICAgY29uc3QgdyA9IGIuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTtcbiAgICAgICAgdi52YWRkKGIudmxhbWJkYSwgdik7XG4gICAgICAgIGIud2xhbWJkYS52bXVsKGIuYW5ndWxhckZhY3RvciwgYi53bGFtYmRhKTtcbiAgICAgICAgdy52YWRkKGIud2xhbWJkYSwgdyk7XG4gICAgICB9IC8vIFNldCB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuXG5cbiAgICAgIGxldCBsID0gZXF1YXRpb25zLmxlbmd0aDtcbiAgICAgIGNvbnN0IGludkR0ID0gMSAvIGg7XG5cbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgZXF1YXRpb25zW2xdLm11bHRpcGxpZXIgPSBsYW1iZGFbbF0gKiBpbnZEdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG59XG5jb25zdCBHU1NvbHZlcl9zb2x2ZV9sYW1iZGEgPSBbXTsgLy8gSnVzdCB0ZW1wb3JhcnkgbnVtYmVyIGhvbGRlcnMgdGhhdCB3ZSB3YW50IHRvIHJldXNlIGVhY2ggc29sdmUuXG5cbmNvbnN0IEdTU29sdmVyX3NvbHZlX2ludkNzID0gW107XG5jb25zdCBHU1NvbHZlcl9zb2x2ZV9CcyA9IFtdO1xuXG4vKipcclxuICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS5cclxuICogQGNsYXNzIFNwbGl0U29sdmVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcclxuICogQHBhcmFtIHtTb2x2ZXJ9IHN1YnNvbHZlclxyXG4gKi9cbmNsYXNzIFNwbGl0U29sdmVyIGV4dGVuZHMgU29sdmVyIHtcbiAgLy8gVGhlIG51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyBkZXRlcm1pbmVzIHF1YWxpdHkgb2YgdGhlIGNvbnN0cmFpbnRzIGluIHRoZSB3b3JsZC4gVGhlIG1vcmUgaXRlcmF0aW9ucywgdGhlIG1vcmUgY29ycmVjdCBzaW11bGF0aW9uLiBNb3JlIGl0ZXJhdGlvbnMgbmVlZCBtb3JlIGNvbXB1dGF0aW9ucyB0aG91Z2guIElmIHlvdSBoYXZlIGEgbGFyZ2UgZ3Jhdml0eSBmb3JjZSBpbiB5b3VyIHdvcmxkLCB5b3Ugd2lsbCBuZWVkIG1vcmUgaXRlcmF0aW9ucy5cbiAgLy8gV2hlbiB0b2xlcmFuY2UgaXMgcmVhY2hlZCwgdGhlIHN5c3RlbSBpcyBhc3N1bWVkIHRvIGJlIGNvbnZlcmdlZC5cbiAgY29uc3RydWN0b3Ioc3Vic29sdmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XG4gICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMubm9kZVBvb2wgPSBbXTsgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcblxuICAgIHdoaWxlICh0aGlzLm5vZGVQb29sLmxlbmd0aCA8IDEyOCkge1xuICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVOb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgZXFzOiBbXSxcbiAgICAgIHZpc2l0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBTb2x2ZSB0aGUgc3Vic3lzdGVtc1xyXG4gICAqIEBtZXRob2Qgc29sdmVcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XHJcbiAgICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBudW1iZXIgb2YgaXRlcmF0aW9ucyBwZXJmb3JtZWRcclxuICAgKi9cblxuXG4gIHNvbHZlKGR0LCB3b3JsZCkge1xuICAgIGNvbnN0IG5vZGVzID0gU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXM7XG4gICAgY29uc3Qgbm9kZVBvb2wgPSB0aGlzLm5vZGVQb29sO1xuICAgIGNvbnN0IGJvZGllcyA9IHdvcmxkLmJvZGllcztcbiAgICBjb25zdCBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBjb25zdCBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoO1xuICAgIGNvbnN0IHN1YnNvbHZlciA9IHRoaXMuc3Vic29sdmVyOyAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxuXG4gICAgd2hpbGUgKG5vZGVQb29sLmxlbmd0aCA8IE5ib2RpZXMpIHtcbiAgICAgIG5vZGVQb29sLnB1c2godGhpcy5jcmVhdGVOb2RlKCkpO1xuICAgIH1cblxuICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykge1xuICAgICAgbm9kZXNbaV0gPSBub2RlUG9vbFtpXTtcbiAgICB9IC8vIFJlc2V0IG5vZGUgdmFsdWVzXG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgIG5vZGUuZXFzLmxlbmd0aCA9IDA7XG4gICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBrID0gMDsgayAhPT0gTmVxOyBrKyspIHtcbiAgICAgIGNvbnN0IGVxID0gZXF1YXRpb25zW2tdO1xuICAgICAgY29uc3QgaSA9IGJvZGllcy5pbmRleE9mKGVxLmJpKTtcbiAgICAgIGNvbnN0IGogPSBib2RpZXMuaW5kZXhPZihlcS5iaik7XG4gICAgICBjb25zdCBuaSA9IG5vZGVzW2ldO1xuICAgICAgY29uc3QgbmogPSBub2Rlc1tqXTtcbiAgICAgIG5pLmNoaWxkcmVuLnB1c2gobmopO1xuICAgICAgbmkuZXFzLnB1c2goZXEpO1xuICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7XG4gICAgICBuai5lcXMucHVzaChlcSk7XG4gICAgfVxuXG4gICAgbGV0IGNoaWxkO1xuICAgIGxldCBuID0gMDtcbiAgICBsZXQgZXFzID0gU3BsaXRTb2x2ZXJfc29sdmVfZXFzO1xuICAgIHN1YnNvbHZlci50b2xlcmFuY2UgPSB0aGlzLnRvbGVyYW5jZTtcbiAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucztcbiAgICBjb25zdCBkdW1teVdvcmxkID0gU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZDtcblxuICAgIHdoaWxlIChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZXMpKSB7XG4gICAgICBlcXMubGVuZ3RoID0gMDtcbiAgICAgIGR1bW15V29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgICBiZnMoY2hpbGQsIHZpc2l0RnVuYywgZHVtbXlXb3JsZC5ib2RpZXMsIGVxcyk7XG4gICAgICBjb25zdCBOZXFzID0gZXFzLmxlbmd0aDtcbiAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5lcXM7IGkrKykge1xuICAgICAgICBzdWJzb2x2ZXIuYWRkRXF1YXRpb24oZXFzW2ldKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlciA9IHN1YnNvbHZlci5zb2x2ZShkdCwgZHVtbXlXb3JsZCk7XG4gICAgICBzdWJzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgICBuKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH1cblxufSAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3Vic3lzdGVtc1xuXG5jb25zdCBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xuXG5jb25zdCBTcGxpdFNvbHZlcl9zb2x2ZV9lcXMgPSBbXTsgLy8gVGVtcCBhcnJheVxuXG5jb25zdCBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkID0ge1xuICBib2RpZXM6IFtdXG59OyAvLyBUZW1wIG9iamVjdFxuXG5jb25zdCBTVEFUSUMgPSBCb2R5LlNUQVRJQztcblxuZnVuY3Rpb24gZ2V0VW52aXNpdGVkTm9kZShub2Rlcykge1xuICBjb25zdCBObm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgIT09IE5ub2RlczsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgcXVldWUgPSBbXTtcblxuZnVuY3Rpb24gYmZzKHJvb3QsIHZpc2l0RnVuYywgYmRzLCBlcXMpIHtcbiAgcXVldWUucHVzaChyb290KTtcbiAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgdmlzaXRGdW5jKHJvb3QsIGJkcywgZXFzKTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnBvcCgpOyAvLyBMb29wIG92ZXIgdW52aXNpdGVkIGNoaWxkIG5vZGVzXG5cbiAgICBsZXQgY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgIHZpc2l0RnVuYyhjaGlsZCwgYmRzLCBlcXMpO1xuICAgICAgcXVldWUucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZpc2l0RnVuYyhub2RlLCBiZHMsIGVxcykge1xuICBiZHMucHVzaChub2RlLmJvZHkpO1xuICBjb25zdCBOZXFzID0gbm9kZS5lcXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpICE9PSBOZXFzOyBpKyspIHtcbiAgICBjb25zdCBlcSA9IG5vZGUuZXFzW2ldO1xuXG4gICAgaWYgKCFlcXMuaW5jbHVkZXMoZXEpKSB7XG4gICAgICBlcXMucHVzaChlcSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpIHtcbiAgcmV0dXJuIGIuaWQgLSBhLmlkO1xufVxuXG4vKipcclxuICogRm9yIHBvb2xpbmcgb2JqZWN0cyB0aGF0IGNhbiBiZSByZXVzZWQuXHJcbiAqIEBjbGFzcyBQb29sXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cbmNsYXNzIFBvb2wge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcbiAgICB0aGlzLnR5cGUgPSBPYmplY3Q7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVsZWFzZSBhbiBvYmplY3QgYWZ0ZXIgdXNlXHJcbiAgICogQG1ldGhvZCByZWxlYXNlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAqL1xuXG5cbiAgcmVsZWFzZSguLi5hcmdzKSB7XG4gICAgY29uc3QgTmFyZ3MgPSBhcmdzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBOYXJnczsgaSsrKSB7XG4gICAgICB0aGlzLm9iamVjdHMucHVzaChhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYW4gb2JqZWN0XHJcbiAgICogQG1ldGhvZCBnZXRcclxuICAgKiBAcmV0dXJuIHttaXhlZH1cclxuICAgKi9cblxuXG4gIGdldCgpIHtcbiAgICBpZiAodGhpcy5vYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0T2JqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdHMucG9wKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhbiBvYmplY3QuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzLlxyXG4gICAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XHJcbiAgICogQHJldHVybiB7bWl4ZWR9XHJcbiAgICovXG5cblxuICBjb25zdHJ1Y3RPYmplY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCEnKTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIHJlc2l6ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICogQHJldHVybiB7UG9vbH0gU2VsZiwgZm9yIGNoYWluaW5nXHJcbiAgICovXG5cblxuICByZXNpemUoc2l6ZSkge1xuICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG5cbiAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XG4gICAgICBvYmplY3RzLnBvcCgpO1xuICAgIH1cblxuICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIG9iamVjdHMucHVzaCh0aGlzLmNvbnN0cnVjdE9iamVjdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbi8qKlxyXG4gKiBAY2xhc3MgVmVjM1Bvb2xcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFBvb2xcclxuICovXG5cbmNsYXNzIFZlYzNQb29sIGV4dGVuZHMgUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50eXBlID0gVmVjMztcbiAgfVxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSB2ZWN0b3JcclxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxyXG4gICAqIEByZXR1cm4ge1ZlYzN9XHJcbiAgICovXG5cblxuICBjb25zdHJ1Y3RPYmplY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWMzKCk7XG4gIH1cblxufVxuXG5jb25zdCBDT0xMSVNJT05fVFlQRVMgPSB7XG4gIHNwaGVyZVNwaGVyZTogU2hhcGUudHlwZXMuU1BIRVJFLFxuICBzcGhlcmVQbGFuZTogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuUExBTkUsXG4gIGJveEJveDogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQk9YLFxuICBzcGhlcmVCb3g6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkJPWCxcbiAgcGxhbmVCb3g6IFNoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQk9YLFxuICBjb252ZXhDb252ZXg6IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sXG4gIHNwaGVyZUNvbnZleDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTixcbiAgcGxhbmVDb252ZXg6IFNoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTixcbiAgYm94Q29udmV4OiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OLFxuICBzcGhlcmVIZWlnaHRmaWVsZDogU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTEQsXG4gIGJveEhlaWdodGZpZWxkOiBTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRCxcbiAgY29udmV4SGVpZ2h0ZmllbGQ6IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04gfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRCxcbiAgc3BoZXJlUGFydGljbGU6IFNoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFLFxuICBwbGFuZVBhcnRpY2xlOiBTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFLFxuICBib3hQYXJ0aWNsZTogU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuUEFSVElDTEUsXG4gIGNvbnZleFBhcnRpY2xlOiBTaGFwZS50eXBlcy5QQVJUSUNMRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST04sXG4gIHNwaGVyZVRyaW1lc2g6IFNoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlRSSU1FU0gsXG4gIHBsYW5lVHJpbWVzaDogU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXG59O1xuXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciB0aGUgV29ybGQuIEdlbmVyYXRlcyBDb250YWN0RXF1YXRpb25zLlxyXG4gKiBAY2xhc3MgTmFycm93cGhhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEB0b2RvIFNwaGVyZS1Db252ZXhQb2x5aGVkcm9uIGNvbnRhY3RzXHJcbiAqIEB0b2RvIENvbnRhY3QgcmVkdWN0aW9uXHJcbiAqIEB0b2RvIHNob3VsZCBtb3ZlIG1ldGhvZHMgdG8gcHJvdG90eXBlXHJcbiAqL1xuY2xhc3MgTmFycm93cGhhc2Uge1xuICAvLyBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cbiAgLy8gUG9vbGVkIHZlY3RvcnMuXG4gIGNvbnN0cnVjdG9yKHdvcmxkKSB7XG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdO1xuICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdO1xuICAgIHRoaXMudjNwb29sID0gbmV3IFZlYzNQb29sKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiA9IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIE1ha2UgYSBjb250YWN0IG9iamVjdCwgYnkgdXNpbmcgdGhlIGludGVybmFsIHBvb2wgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXHJcbiAgICogQHBhcmFtIHtCb2R5fSBiaVxyXG4gICAqIEBwYXJhbSB7Qm9keX0gYmpcclxuICAgKiBAcGFyYW0ge1NoYXBlfSBzaVxyXG4gICAqIEBwYXJhbSB7U2hhcGV9IHNqXHJcbiAgICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUFcclxuICAgKiBAcGFyYW0ge1NoYXBlfSBvdmVycmlkZVNoYXBlQlxyXG4gICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cclxuICAgKi9cblxuXG4gIGNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgb3ZlcnJpZGVTaGFwZUEsIG92ZXJyaWRlU2hhcGVCKSB7XG4gICAgbGV0IGM7XG5cbiAgICBpZiAodGhpcy5jb250YWN0UG9pbnRQb29sLmxlbmd0aCkge1xuICAgICAgYyA9IHRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKTtcbiAgICAgIGMuYmkgPSBiaTtcbiAgICAgIGMuYmogPSBiajtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IG5ldyBDb250YWN0RXF1YXRpb24oYmksIGJqKTtcbiAgICB9XG5cbiAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcbiAgICBjb25zdCBjbSA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcbiAgICBjLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG4gICAgYy5zZXRTcG9va1BhcmFtcyhjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsIGNtLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24sIHRoaXMud29ybGQuZHQpO1xuICAgIGNvbnN0IG1hdEEgPSBzaS5tYXRlcmlhbCB8fCBiaS5tYXRlcmlhbDtcbiAgICBjb25zdCBtYXRCID0gc2oubWF0ZXJpYWwgfHwgYmoubWF0ZXJpYWw7XG5cbiAgICBpZiAobWF0QSAmJiBtYXRCICYmIG1hdEEucmVzdGl0dXRpb24gPj0gMCAmJiBtYXRCLnJlc3RpdHV0aW9uID49IDApIHtcbiAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjtcbiAgICB9XG5cbiAgICBjLnNpID0gb3ZlcnJpZGVTaGFwZUEgfHwgc2k7XG4gICAgYy5zaiA9IG92ZXJyaWRlU2hhcGVCIHx8IHNqO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjb250YWN0RXF1YXRpb24sIG91dEFycmF5KSB7XG4gICAgY29uc3QgYm9keUEgPSBjb250YWN0RXF1YXRpb24uYmk7XG4gICAgY29uc3QgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7XG4gICAgY29uc3Qgc2hhcGVBID0gY29udGFjdEVxdWF0aW9uLnNpO1xuICAgIGNvbnN0IHNoYXBlQiA9IGNvbnRhY3RFcXVhdGlvbi5zajtcbiAgICBjb25zdCB3b3JsZCA9IHRoaXMud29ybGQ7XG4gICAgY29uc3QgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7IC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW1cblxuICAgIGxldCBmcmljdGlvbiA9IGNtLmZyaWN0aW9uO1xuICAgIGNvbnN0IG1hdEEgPSBzaGFwZUEubWF0ZXJpYWwgfHwgYm9keUEubWF0ZXJpYWw7XG4gICAgY29uc3QgbWF0QiA9IHNoYXBlQi5tYXRlcmlhbCB8fCBib2R5Qi5tYXRlcmlhbDtcblxuICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCkge1xuICAgICAgZnJpY3Rpb24gPSBtYXRBLmZyaWN0aW9uICogbWF0Qi5mcmljdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoZnJpY3Rpb24gPiAwKSB7XG4gICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuICAgICAgY29uc3QgbXVnID0gZnJpY3Rpb24gKiB3b3JsZC5ncmF2aXR5Lmxlbmd0aCgpO1xuICAgICAgbGV0IHJlZHVjZWRNYXNzID0gYm9keUEuaW52TWFzcyArIGJvZHlCLmludk1hc3M7XG5cbiAgICAgIGlmIChyZWR1Y2VkTWFzcyA+IDApIHtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAxIC8gcmVkdWNlZE1hc3M7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sO1xuICAgICAgY29uc3QgYzEgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIG11ZyAqIHJlZHVjZWRNYXNzKTtcbiAgICAgIGNvbnN0IGMyID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtdWcgKiByZWR1Y2VkTWFzcyk7XG4gICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7XG4gICAgICBjMS5iaiA9IGMyLmJqID0gYm9keUI7XG4gICAgICBjMS5taW5Gb3JjZSA9IGMyLm1pbkZvcmNlID0gLW11ZyAqIHJlZHVjZWRNYXNzO1xuICAgICAgYzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZyAqIHJlZHVjZWRNYXNzOyAvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcblxuICAgICAgYzEucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgYzEucmouY29weShjb250YWN0RXF1YXRpb24ucmopO1xuICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgYzIucmouY29weShjb250YWN0RXF1YXRpb24ucmopOyAvLyBDb25zdHJ1Y3QgdGFuZ2VudHNcblxuICAgICAgY29udGFjdEVxdWF0aW9uLm5pLnRhbmdlbnRzKGMxLnQsIGMyLnQpOyAvLyBTZXQgc3Bvb2sgcGFyYW1zXG5cbiAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG4gICAgICBjMi5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgd29ybGQuZHQpO1xuICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcbiAgICAgIG91dEFycmF5LnB1c2goYzEsIGMyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxuXG5cbiAgY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykge1xuICAgIC8vIFRoZSBsYXN0IGNvbnRhY3RFcXVhdGlvblxuICAgIGxldCBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07IC8vIENyZWF0ZSB0aGUgcmVzdWx0OiB0d28gXCJhdmVyYWdlXCIgZnJpY3Rpb24gZXF1YXRpb25zXG5cbiAgICBpZiAoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjLCB0aGlzLmZyaWN0aW9uUmVzdWx0KSB8fCBudW1Db250YWN0cyA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGYyID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgIGF2ZXJhZ2VOb3JtYWwuc2V0WmVybygpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTtcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zZXRaZXJvKCk7XG4gICAgY29uc3QgYm9keUEgPSBjLmJpO1xuICAgIGNvbnN0IGJvZHlCID0gYy5iajtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBudW1Db250YWN0czsgaSsrKSB7XG4gICAgICBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMSAtIGldO1xuXG4gICAgICBpZiAoYy5iaSAhPT0gYm9keUEpIHtcbiAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpO1xuICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRBKTtcbiAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdmVyYWdlTm9ybWFsLnZzdWIoYy5uaSwgYXZlcmFnZU5vcm1hbCk7XG4gICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEEpO1xuICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmksIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZOdW1Db250YWN0cyA9IDEgLyBudW1Db250YWN0cztcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50QS5zY2FsZShpbnZOdW1Db250YWN0cywgZjEucmkpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaik7XG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxuXG4gICAgZjIucmouY29weShmMS5yaik7XG4gICAgYXZlcmFnZU5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICBhdmVyYWdlTm9ybWFsLnRhbmdlbnRzKGYxLnQsIGYyLnQpOyAvLyByZXR1cm4gZXE7XG4gIH1cbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYWxsIGNvbnRhY3RzIGJldHdlZW4gYSBsaXN0IG9mIGJvZHkgcGFpcnNcclxuICAgKiBAbWV0aG9kIGdldENvbnRhY3RzXHJcbiAgICogQHBhcmFtIHthcnJheX0gcDEgQXJyYXkgb2YgYm9keSBpbmRpY2VzXHJcbiAgICogQHBhcmFtIHthcnJheX0gcDIgQXJyYXkgb2YgYm9keSBpbmRpY2VzXHJcbiAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgZ2VuZXJhdGVkIGNvbnRhY3RzXHJcbiAgICogQHBhcmFtIHthcnJheX0gb2xkY29udGFjdHMgT3B0aW9uYWwuIEFycmF5IG9mIHJldXNhYmxlIGNvbnRhY3Qgb2JqZWN0c1xyXG4gICAqL1xuXG5cbiAgZ2V0Q29udGFjdHMocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCkge1xuICAgIC8vIFNhdmUgb2xkIGNvbnRhY3Qgb2JqZWN0c1xuICAgIHRoaXMuY29udGFjdFBvaW50UG9vbCA9IG9sZGNvbnRhY3RzO1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBmcmljdGlvblBvb2w7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IGZyaWN0aW9uUmVzdWx0O1xuICAgIGNvbnN0IHFpID0gdG1wUXVhdDE7XG4gICAgY29uc3QgcWogPSB0bXBRdWF0MjtcbiAgICBjb25zdCB4aSA9IHRtcFZlYzEkMjtcbiAgICBjb25zdCB4aiA9IHRtcFZlYzIkMjtcblxuICAgIGZvciAobGV0IGsgPSAwLCBOID0gcDEubGVuZ3RoOyBrICE9PSBOOyBrKyspIHtcbiAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcbiAgICAgIGNvbnN0IGJpID0gcDFba107XG4gICAgICBjb25zdCBiaiA9IHAyW2tdOyAvLyBHZXQgY29udGFjdCBtYXRlcmlhbFxuXG4gICAgICBsZXQgYm9keUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XG5cbiAgICAgIGlmIChiaS5tYXRlcmlhbCAmJiBiai5tYXRlcmlhbCkge1xuICAgICAgICBib2R5Q29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLCBiai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QganVzdFRlc3QgPSBiaS50eXBlICYgQm9keS5LSU5FTUFUSUMgJiYgYmoudHlwZSAmIEJvZHkuU1RBVElDIHx8IGJpLnR5cGUgJiBCb2R5LlNUQVRJQyAmJiBiai50eXBlICYgQm9keS5LSU5FTUFUSUMgfHwgYmkudHlwZSAmIEJvZHkuS0lORU1BVElDICYmIGJqLnR5cGUgJiBCb2R5LktJTkVNQVRJQztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaS5zaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmkucXVhdGVybmlvbi5tdWx0KGJpLnNoYXBlT3JpZW50YXRpb25zW2ldLCBxaSk7XG4gICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7XG4gICAgICAgIHhpLnZhZGQoYmkucG9zaXRpb24sIHhpKTtcbiAgICAgICAgY29uc3Qgc2kgPSBiaS5zaGFwZXNbaV07XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiai5zaGFwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXNcbiAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcbiAgICAgICAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KGJqLnNoYXBlT2Zmc2V0c1tqXSwgeGopO1xuICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTtcbiAgICAgICAgICBjb25zdCBzaiA9IGJqLnNoYXBlc1tqXTtcblxuICAgICAgICAgIGlmICghKHNpLmNvbGxpc2lvbkZpbHRlck1hc2sgJiBzai5jb2xsaXNpb25GaWx0ZXJHcm91cCAmJiBzai5jb2xsaXNpb25GaWx0ZXJNYXNrICYgc2kuY29sbGlzaW9uRmlsdGVyR3JvdXApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIEdldCBjb2xsaXNpb24gbWF0ZXJpYWxcblxuXG4gICAgICAgICAgbGV0IHNoYXBlQ29udGFjdE1hdGVyaWFsID0gbnVsbDtcblxuICAgICAgICAgIGlmIChzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCkge1xuICAgICAgICAgICAgc2hhcGVDb250YWN0TWF0ZXJpYWwgPSB3b3JsZC5nZXRDb250YWN0TWF0ZXJpYWwoc2kubWF0ZXJpYWwsIHNqLm1hdGVyaWFsKSB8fCBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDsgLy8gR2V0IGNvbnRhY3RzXG5cbiAgICAgICAgICBjb25zdCByZXNvbHZlckluZGV4ID0gc2kudHlwZSB8IHNqLnR5cGU7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzW3Jlc29sdmVySW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICBsZXQgcmV0dmFsID0gZmFsc2U7IC8vIFRPIERPOiBpbnZlc3RpZ2F0ZSB3aHkgc3BoZXJlUGFydGljbGUgYW5kIGNvbnZleFBhcnRpY2xlXG4gICAgICAgICAgICAvLyByZXNvbHZlcnMgZXhwZWN0IHNpIGFuZCBzaiBzaGFwZXMgdG8gYmUgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgICAgLy8gKGkuZS4gbGFyZ2VyIGludGVnZXIgdmFsdWUgdHlwZSBmaXJzdCBpbnN0ZWFkIG9mIHNtYWxsZXIgZmlyc3QpXG5cbiAgICAgICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xuICAgICAgICAgICAgICByZXR2YWwgPSByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqLCBqdXN0VGVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR2YWwgPSByZXNvbHZlci5jYWxsKHRoaXMsIHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgc2ksIHNqLCBqdXN0VGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXR2YWwgJiYganVzdFRlc3QpIHtcbiAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgb3ZlcmxhcFxuICAgICAgICAgICAgICB3b3JsZC5zaGFwZU92ZXJsYXBLZWVwZXIuc2V0KHNpLmlkLCBzai5pZCk7XG4gICAgICAgICAgICAgIHdvcmxkLmJvZHlPdmVybGFwS2VlcGVyLnNldChiaS5pZCwgYmouaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNwaGVyZVNwaGVyZShzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgcmV0dXJuIHhpLmRpc3RhbmNlU3F1YXJlZCh4aikgPCAoc2kucmFkaXVzICsgc2oucmFkaXVzKSAqKiAyO1xuICAgIH0gLy8gV2Ugd2lsbCBoYXZlIG9ubHkgb25lIGNvbnRhY3QgaW4gdGhpcyBjYXNlXG5cblxuICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOyAvLyBDb250YWN0IG5vcm1hbFxuXG4gICAgeGoudnN1Yih4aSwgci5uaSk7XG4gICAgci5uaS5ub3JtYWxpemUoKTsgLy8gQ29udGFjdCBwb2ludCBsb2NhdGlvbnNcblxuICAgIHIucmkuY29weShyLm5pKTtcbiAgICByLnJqLmNvcHkoci5uaSk7XG4gICAgci5yaS5zY2FsZShzaS5yYWRpdXMsIHIucmkpO1xuICAgIHIucmouc2NhbGUoLXNqLnJhZGl1cywgci5yaik7XG4gICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcbiAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgfVxuXG4gIHNwaGVyZVBsYW5lKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opOyAvLyBDb250YWN0IG5vcm1hbFxuXG4gICAgci5uaS5zZXQoMCwgMCwgMSk7XG4gICAgcWoudm11bHQoci5uaSwgci5uaSk7XG4gICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIGJvZHkgaSBpcyB0aGUgc3BoZXJlLCBmbGlwIG5vcm1hbFxuXG4gICAgci5uaS5ub3JtYWxpemUoKTsgLy8gTmVlZGVkP1xuICAgIC8vIFZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludFxuXG4gICAgci5uaS5zY2FsZShzaS5yYWRpdXMsIHIucmkpOyAvLyBQcm9qZWN0IGRvd24gc3BoZXJlIG9uIHBsYW5lXG5cbiAgICB4aS52c3ViKHhqLCBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUpO1xuICAgIHIubmkuc2NhbGUoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTtcbiAgICBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUudnN1YihwbGFuZV90b19zcGhlcmVfb3J0aG8sIHIucmopOyAvLyBUaGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byBwbGFuZVxuXG4gICAgaWYgKC1wb2ludF9vbl9wbGFuZV90b19zcGhlcmUuZG90KHIubmkpIDw9IHNpLnJhZGl1cykge1xuICAgICAgaWYgKGp1c3RUZXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG5cblxuICAgICAgY29uc3QgcmkgPSByLnJpO1xuICAgICAgY29uc3QgcmogPSByLnJqO1xuICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBib3hCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzai5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzai5jb2xsaXNpb25SZXNwb25zZTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHNpLCBzaiwganVzdFRlc3QpO1xuICB9XG5cbiAgc3BoZXJlQm94KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgY29uc3QgdjNwb29sID0gdGhpcy52M3Bvb2w7IC8vIHdlIHJlZmVyIHRvIHRoZSBib3ggYXMgYm9keSBqXG5cbiAgICBjb25zdCBzaWRlcyA9IHNwaGVyZUJveF9zaWRlcztcbiAgICB4aS52c3ViKHhqLCBib3hfdG9fc3BoZXJlKTtcbiAgICBzai5nZXRTaWRlTm9ybWFscyhzaWRlcywgcWopO1xuICAgIGNvbnN0IFIgPSBzaS5yYWRpdXM7XG5cbiAgICBsZXQgZm91bmQgPSBmYWxzZTsgLy8gU3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIHBlbmV0cmF0aW9uIGluZm9cblxuICAgIGNvbnN0IHNpZGVfbnMgPSBzcGhlcmVCb3hfc2lkZV9ucztcbiAgICBjb25zdCBzaWRlX25zMSA9IHNwaGVyZUJveF9zaWRlX25zMTtcbiAgICBjb25zdCBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjtcbiAgICBsZXQgc2lkZV9oID0gbnVsbDtcbiAgICBsZXQgc2lkZV9wZW5ldHJhdGlvbnMgPSAwO1xuICAgIGxldCBzaWRlX2RvdDEgPSAwO1xuICAgIGxldCBzaWRlX2RvdDIgPSAwO1xuICAgIGxldCBzaWRlX2Rpc3RhbmNlID0gbnVsbDtcblxuICAgIGZvciAobGV0IGlkeCA9IDAsIG5zaWRlcyA9IHNpZGVzLmxlbmd0aDsgaWR4ICE9PSBuc2lkZXMgJiYgZm91bmQgPT09IGZhbHNlOyBpZHgrKykge1xuICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpXG4gICAgICBjb25zdCBucyA9IHNwaGVyZUJveF9ucztcbiAgICAgIG5zLmNvcHkoc2lkZXNbaWR4XSk7XG4gICAgICBjb25zdCBoID0gbnMubGVuZ3RoKCk7XG4gICAgICBucy5ub3JtYWxpemUoKTsgLy8gVGhlIG5vcm1hbC9kaXN0YW5jZSBkb3QgcHJvZHVjdCB0ZWxscyB3aGljaCBzaWRlIG9mIHRoZSBwbGFuZSB3ZSBhcmVcblxuICAgICAgY29uc3QgZG90ID0gYm94X3RvX3NwaGVyZS5kb3QobnMpO1xuXG4gICAgICBpZiAoZG90IDwgaCArIFIgJiYgZG90ID4gMCkge1xuICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgdGhlIG90aGVyIHR3byBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IG5zMSA9IHNwaGVyZUJveF9uczE7XG4gICAgICAgIGNvbnN0IG5zMiA9IHNwaGVyZUJveF9uczI7XG4gICAgICAgIG5zMS5jb3B5KHNpZGVzWyhpZHggKyAxKSAlIDNdKTtcbiAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCArIDIpICUgM10pO1xuICAgICAgICBjb25zdCBoMSA9IG5zMS5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgaDIgPSBuczIubGVuZ3RoKCk7XG4gICAgICAgIG5zMS5ub3JtYWxpemUoKTtcbiAgICAgICAgbnMyLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBkb3QxID0gYm94X3RvX3NwaGVyZS5kb3QobnMxKTtcbiAgICAgICAgY29uc3QgZG90MiA9IGJveF90b19zcGhlcmUuZG90KG5zMik7XG5cbiAgICAgICAgaWYgKGRvdDEgPCBoMSAmJiBkb3QxID4gLWgxICYmIGRvdDIgPCBoMiAmJiBkb3QyID4gLWgyKSB7XG4gICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguYWJzKGRvdCAtIGggLSBSKTtcblxuICAgICAgICAgIGlmIChzaWRlX2Rpc3RhbmNlID09PSBudWxsIHx8IGRpc3QgPCBzaWRlX2Rpc3RhbmNlKSB7XG4gICAgICAgICAgICBzaWRlX2Rpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7XG4gICAgICAgICAgICBzaWRlX2RvdDIgPSBkb3QyO1xuICAgICAgICAgICAgc2lkZV9oID0gaDtcbiAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7XG4gICAgICAgICAgICBzaWRlX25zMS5jb3B5KG5zMSk7XG4gICAgICAgICAgICBzaWRlX25zMi5jb3B5KG5zMik7XG4gICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrO1xuXG4gICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpZGVfcGVuZXRyYXRpb25zKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTtcbiAgICAgIHNpZGVfbnMuc2NhbGUoLVIsIHIucmkpOyAvLyBTcGhlcmUgclxuXG4gICAgICByLm5pLmNvcHkoc2lkZV9ucyk7XG4gICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHNob3VsZCBiZSBvdXQgb2Ygc3BoZXJlXG5cbiAgICAgIHNpZGVfbnMuc2NhbGUoc2lkZV9oLCBzaWRlX25zKTtcbiAgICAgIHNpZGVfbnMxLnNjYWxlKHNpZGVfZG90MSwgc2lkZV9uczEpO1xuICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLCBzaWRlX25zKTtcbiAgICAgIHNpZGVfbnMyLnNjYWxlKHNpZGVfZG90Miwgc2lkZV9uczIpO1xuICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMyLCByLnJqKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcblxuICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcbiAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfSAvLyBDaGVjayBjb3JuZXJzXG5cblxuICAgIGxldCByaiA9IHYzcG9vbC5nZXQoKTtcbiAgICBjb25zdCBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gMiAmJiAhZm91bmQ7IGorKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IDIgJiYgIWZvdW5kOyBrKyspIHtcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgIT09IDIgJiYgIWZvdW5kOyBsKyspIHtcbiAgICAgICAgICByai5zZXQoMCwgMCwgMCk7XG5cbiAgICAgICAgICBpZiAoaikge1xuICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSwgcmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByai52c3ViKHNpZGVzWzBdLCByaik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMV0sIHJqKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmoudnN1YihzaWRlc1sxXSwgcmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICByai52YWRkKHNpZGVzWzJdLCByaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMl0sIHJqKTtcbiAgICAgICAgICB9IC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuXG5cbiAgICAgICAgICB4ai52YWRkKHJqLCBzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICBzcGhlcmVfdG9fY29ybmVyLnZzdWIoeGksIHNwaGVyZV90b19jb3JuZXIpO1xuXG4gICAgICAgICAgaWYgKHNwaGVyZV90b19jb3JuZXIubGVuZ3RoU3F1YXJlZCgpIDwgUiAqIFIpIHtcbiAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7XG4gICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgci5uaS5jb3B5KHIucmkpO1xuICAgICAgICAgICAgci5yaS5zY2FsZShSLCByLnJpKTtcbiAgICAgICAgICAgIHIucmouY29weShyaik7IC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG5cbiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHYzcG9vbC5yZWxlYXNlKHJqKTtcbiAgICByaiA9IG51bGw7IC8vIENoZWNrIGVkZ2VzXG5cbiAgICBjb25zdCBlZGdlVGFuZ2VudCA9IHYzcG9vbC5nZXQoKTtcbiAgICBjb25zdCBlZGdlQ2VudGVyID0gdjNwb29sLmdldCgpO1xuICAgIGNvbnN0IHIgPSB2M3Bvb2wuZ2V0KCk7IC8vIHIgPSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyXG5cbiAgICBjb25zdCBvcnRob2dvbmFsID0gdjNwb29sLmdldCgpO1xuICAgIGNvbnN0IGRpc3QgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgY29uc3QgTnNpZGVzID0gc2lkZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogIT09IE5zaWRlcyAmJiAhZm91bmQ7IGorKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgIT09IE5zaWRlcyAmJiAhZm91bmQ7IGsrKykge1xuICAgICAgICBpZiAoaiAlIDMgIT09IGsgJSAzKSB7XG4gICAgICAgICAgLy8gR2V0IGVkZ2UgdGFuZ2VudFxuICAgICAgICAgIHNpZGVzW2tdLmNyb3NzKHNpZGVzW2pdLCBlZGdlVGFuZ2VudCk7XG4gICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7XG4gICAgICAgICAgc2lkZXNbal0udmFkZChzaWRlc1trXSwgZWRnZUNlbnRlcik7XG4gICAgICAgICAgci5jb3B5KHhpKTtcbiAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlciwgcik7XG4gICAgICAgICAgci52c3ViKHhqLCByKTtcbiAgICAgICAgICBjb25zdCBvcnRob25vcm0gPSByLmRvdChlZGdlVGFuZ2VudCk7IC8vIGRpc3RhbmNlIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cblxuICAgICAgICAgIGVkZ2VUYW5nZW50LnNjYWxlKG9ydGhvbm9ybSwgb3J0aG9nb25hbCk7IC8vIFZlY3RvciBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIgaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lXG5cbiAgICAgICAgICBsZXQgbCA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAobCA9PT0gaiAlIDMgfHwgbCA9PT0gayAlIDMpIHtcbiAgICAgICAgICAgIGwrKztcbiAgICAgICAgICB9IC8vIHZlYyBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBwcm9qZWN0ZWQgdG8gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gdGhlIGVkZ2UgdGFuZ2VudFxuXG5cbiAgICAgICAgICBkaXN0LmNvcHkoeGkpO1xuICAgICAgICAgIGRpc3QudnN1YihvcnRob2dvbmFsLCBkaXN0KTtcbiAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlciwgZGlzdCk7XG4gICAgICAgICAgZGlzdC52c3ViKHhqLCBkaXN0KTsgLy8gRGlzdGFuY2VzIGluIHRhbmdlbnQgZGlyZWN0aW9uIGFuZCBkaXN0YW5jZSBpbiB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byBpdFxuXG4gICAgICAgICAgY29uc3QgdGRpc3QgPSBNYXRoLmFicyhvcnRob25vcm0pO1xuICAgICAgICAgIGNvbnN0IG5kaXN0ID0gZGlzdC5sZW5ndGgoKTtcblxuICAgICAgICAgIGlmICh0ZGlzdCA8IHNpZGVzW2xdLmxlbmd0aCgpICYmIG5kaXN0IDwgUikge1xuICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opO1xuICAgICAgICAgICAgZWRnZUNlbnRlci52YWRkKG9ydGhvZ29uYWwsIHJlcy5yaik7IC8vIGJveCByalxuXG4gICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xuICAgICAgICAgICAgZGlzdC5uZWdhdGUocmVzLm5pKTtcbiAgICAgICAgICAgIHJlcy5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHJlcy5yaS5jb3B5KHJlcy5yaik7XG4gICAgICAgICAgICByZXMucmkudmFkZCh4aiwgcmVzLnJpKTtcbiAgICAgICAgICAgIHJlcy5yaS52c3ViKHhpLCByZXMucmkpO1xuICAgICAgICAgICAgcmVzLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgcmVzLnJpLnNjYWxlKFIsIHJlcy5yaSk7IC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG5cbiAgICAgICAgICAgIHJlcy5yaS52YWRkKHhpLCByZXMucmkpO1xuICAgICAgICAgICAgcmVzLnJpLnZzdWIoYmkucG9zaXRpb24sIHJlcy5yaSk7XG4gICAgICAgICAgICByZXMucmoudmFkZCh4aiwgcmVzLnJqKTtcbiAgICAgICAgICAgIHJlcy5yai52c3ViKGJqLnBvc2l0aW9uLCByZXMucmopO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHJlcywgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdjNwb29sLnJlbGVhc2UoZWRnZVRhbmdlbnQsIGVkZ2VDZW50ZXIsIHIsIG9ydGhvZ29uYWwsIGRpc3QpO1xuICB9XG5cbiAgcGxhbmVCb3goc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzai5tYXRlcmlhbDtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzai5jb2xsaXNpb25SZXNwb25zZTtcbiAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uaWQgPSBzai5pZDtcbiAgICByZXR1cm4gdGhpcy5wbGFuZUNvbnZleChzaSwgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTtcbiAgfVxuXG4gIGNvbnZleENvbnZleChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCwgZmFjZUxpc3RBLCBmYWNlTGlzdEIpIHtcbiAgICBjb25zdCBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XG5cbiAgICBpZiAoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpLmZpbmRTZXBhcmF0aW5nQXhpcyhzaiwgeGksIHFpLCB4aiwgcWosIHNlcEF4aXMsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKSkge1xuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBjb25zdCBxID0gY29udmV4Q29udmV4X3E7XG4gICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGksIHFpLCBzaiwgeGosIHFqLCBzZXBBeGlzLCAtMTAwLCAxMDAsIHJlcyk7XG4gICAgICBsZXQgbnVtQ29udGFjdHMgPSAwO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7XG4gICAgICAgIGNvbnN0IHJpID0gci5yaTtcbiAgICAgICAgY29uc3QgcmogPSByLnJqO1xuICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgcmVzW2pdLm5vcm1hbC5uZWdhdGUocSk7XG4gICAgICAgIHEuc2NhbGUocmVzW2pdLmRlcHRoLCBxKTtcbiAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpO1xuICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7IC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcblxuICAgICAgICByaS52c3ViKHhpLCByaSk7XG4gICAgICAgIHJqLnZzdWIoeGosIHJqKTsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcblxuICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcbiAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3BoZXJlQ29udmV4KHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgY29uc3QgdjNwb29sID0gdGhpcy52M3Bvb2w7XG4gICAgeGkudnN1Yih4aiwgY29udmV4X3RvX3NwaGVyZSk7XG4gICAgY29uc3Qgbm9ybWFscyA9IHNqLmZhY2VOb3JtYWxzO1xuICAgIGNvbnN0IGZhY2VzID0gc2ouZmFjZXM7XG4gICAgY29uc3QgdmVydHMgPSBzai52ZXJ0aWNlcztcbiAgICBjb25zdCBSID0gc2kucmFkaXVzO1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7IC8vIENoZWNrIGNvcm5lcnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2ZXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdiA9IHZlcnRzW2ldOyAvLyBXb3JsZCBwb3NpdGlvbiBvZiBjb3JuZXJcblxuICAgICAgY29uc3Qgd29ybGRDb3JuZXIgPSBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXI7XG4gICAgICBxai52bXVsdCh2LCB3b3JsZENvcm5lcik7XG4gICAgICB4ai52YWRkKHdvcmxkQ29ybmVyLCB3b3JsZENvcm5lcik7XG4gICAgICBjb25zdCBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyO1xuICAgICAgd29ybGRDb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7XG5cbiAgICAgIGlmIChzcGhlcmVfdG9fY29ybmVyLmxlbmd0aFNxdWFyZWQoKSA8IFIgKiBSKSB7XG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTtcbiAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgIHIucmkuc2NhbGUoUiwgci5yaSk7XG4gICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosIHIucmopOyAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG5cbiAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuXG4gICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgc2lkZSAocGxhbmUpIGludGVyc2VjdGlvbnNcblxuXG4gICAgZm9yIChsZXQgaSA9IDAsIG5mYWNlcyA9IGZhY2VzLmxlbmd0aDsgaSAhPT0gbmZhY2VzICYmIGZvdW5kID09PSBmYWxzZTsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWwgPSBub3JtYWxzW2ldO1xuICAgICAgY29uc3QgZmFjZSA9IGZhY2VzW2ldOyAvLyBHZXQgd29ybGQtdHJhbnNmb3JtZWQgbm9ybWFsIG9mIHRoZSBmYWNlXG5cbiAgICAgIGNvbnN0IHdvcmxkTm9ybWFsID0gc3BoZXJlQ29udmV4X3dvcmxkTm9ybWFsO1xuICAgICAgcWoudm11bHQobm9ybWFsLCB3b3JsZE5vcm1hbCk7IC8vIEdldCBhIHdvcmxkIHZlcnRleCBmcm9tIHRoZSBmYWNlXG5cbiAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDtcbiAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbMF1dLCB3b3JsZFBvaW50KTtcbiAgICAgIHdvcmxkUG9pbnQudmFkZCh4aiwgd29ybGRQb2ludCk7IC8vIEdldCBhIHBvaW50IG9uIHRoZSBzcGhlcmUsIGNsb3Nlc3QgdG8gdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgIGNvbnN0IHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSA9IHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmU7XG4gICAgICB3b3JsZE5vcm1hbC5zY2FsZSgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcbiAgICAgIHhpLnZhZGQod29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lLCB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUpOyAvLyBWZWN0b3IgZnJvbSBhIGZhY2UgcG9pbnQgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNwaGVyZVxuXG4gICAgICBjb25zdCBwZW5ldHJhdGlvblZlYyA9IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYztcbiAgICAgIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZS52c3ViKHdvcmxkUG9pbnQsIHBlbmV0cmF0aW9uVmVjKTsgLy8gVGhlIHBlbmV0cmF0aW9uLiBOZWdhdGl2ZSB2YWx1ZSBtZWFucyBvdmVybGFwLlxuXG4gICAgICBjb25zdCBwZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uVmVjLmRvdCh3b3JsZE5vcm1hbCk7XG4gICAgICBjb25zdCB3b3JsZFBvaW50VG9TcGhlcmUgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50O1xuICAgICAgeGkudnN1Yih3b3JsZFBvaW50LCB3b3JsZFBvaW50VG9TcGhlcmUpO1xuXG4gICAgICBpZiAocGVuZXRyYXRpb24gPCAwICYmIHdvcmxkUG9pbnRUb1NwaGVyZS5kb3Qod29ybGROb3JtYWwpID4gMCkge1xuICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgaWYgdGhlIHNwaGVyZSBpcyBpbnNpZGUgdGhlIGZhY2UgcG9seWdvblxuICAgICAgICBjb25zdCBmYWNlVmVydHMgPSBbXTsgLy8gRmFjZSB2ZXJ0aWNlcywgaW4gd29ybGQgY29vcmRzXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIE52ZXJ0cyA9IGZhY2UubGVuZ3RoOyBqICE9PSBOdmVydHM7IGorKykge1xuICAgICAgICAgIGNvbnN0IHdvcmxkVmVydGV4ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2Vbal1dLCB3b3JsZFZlcnRleCk7XG4gICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgIGZhY2VWZXJ0cy5wdXNoKHdvcmxkVmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludEluUG9seWdvbihmYWNlVmVydHMsIHdvcmxkTm9ybWFsLCB4aSkpIHtcbiAgICAgICAgICAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uP1xuICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opO1xuICAgICAgICAgIHdvcmxkTm9ybWFsLnNjYWxlKC1SLCByLnJpKTsgLy8gQ29udGFjdCBvZmZzZXQsIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0XG5cbiAgICAgICAgICB3b3JsZE5vcm1hbC5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBwb2ludGluZyBvdXQgb2Ygc3BoZXJlXG5cbiAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvblZlYzIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLXBlbmV0cmF0aW9uLCBwZW5ldHJhdGlvblZlYzIpO1xuICAgICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgd29ybGROb3JtYWwuc2NhbGUoLVIsIHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpOyAvL3hpLnZzdWIoeGopLnZhZGQocGVuZXRyYXRpb25TcGhlcmVQb2ludCkudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcblxuICAgICAgICAgIHhpLnZzdWIoeGosIHIucmopO1xuICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LCByLnJqKTtcbiAgICAgICAgICByLnJqLnZhZGQocGVuZXRyYXRpb25WZWMyLCByLnJqKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuXG4gICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopOyAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG5cbiAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgdjNwb29sLnJlbGVhc2UocGVuZXRyYXRpb25WZWMyKTtcbiAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcbiAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTsgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHtcbiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFZGdlP1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBmYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBHZXQgdHdvIHdvcmxkIHRyYW5zZm9ybWVkIHZlcnRpY2VzXG4gICAgICAgICAgICBjb25zdCB2MSA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaiArIDEpICUgZmFjZS5sZW5ndGhdXSwgdjEpO1xuICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaiArIDIpICUgZmFjZS5sZW5ndGhdXSwgdjIpO1xuICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xuICAgICAgICAgICAgeGoudmFkZCh2MiwgdjIpOyAvLyBDb25zdHJ1Y3QgZWRnZSB2ZWN0b3JcblxuICAgICAgICAgICAgY29uc3QgZWRnZSA9IHNwaGVyZUNvbnZleF9lZGdlO1xuICAgICAgICAgICAgdjIudnN1Yih2MSwgZWRnZSk7IC8vIENvbnN0cnVjdCB0aGUgc2FtZSB2ZWN0b3IsIGJ1dCBub3JtYWxpemVkXG5cbiAgICAgICAgICAgIGNvbnN0IGVkZ2VVbml0ID0gc3BoZXJlQ29udmV4X2VkZ2VVbml0O1xuICAgICAgICAgICAgZWRnZS51bml0KGVkZ2VVbml0KTsgLy8gcCBpcyB4aSBwcm9qZWN0ZWQgb250byB0aGUgZWRnZVxuXG4gICAgICAgICAgICBjb25zdCBwID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgY29uc3QgdjFfdG9feGkgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICB4aS52c3ViKHYxLCB2MV90b194aSk7XG4gICAgICAgICAgICBjb25zdCBkb3QgPSB2MV90b194aS5kb3QoZWRnZVVuaXQpO1xuICAgICAgICAgICAgZWRnZVVuaXQuc2NhbGUoZG90LCBwKTtcbiAgICAgICAgICAgIHAudmFkZCh2MSwgcCk7IC8vIENvbXB1dGUgYSB2ZWN0b3IgZnJvbSBwIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuXG4gICAgICAgICAgICBjb25zdCB4aV90b19wID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgLy8gQU5EIGlmIHAgaXMgaW4gYmV0d2VlbiB2MSBhbmQgdjJcblxuICAgICAgICAgICAgaWYgKGRvdCA+IDAgJiYgZG90ICogZG90IDwgZWRnZS5sZW5ndGhTcXVhcmVkKCkgJiYgeGlfdG9fcC5sZW5ndGhTcXVhcmVkKCkgPCBSICogUikge1xuICAgICAgICAgICAgICAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXG4gICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCFcbiAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTtcbiAgICAgICAgICAgICAgcC52c3ViKHhqLCByLnJqKTtcbiAgICAgICAgICAgICAgcC52c3ViKHhpLCByLm5pKTtcbiAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgci5uaS5zY2FsZShSLCByLnJpKTsgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuXG4gICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7IC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cblxuICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7IC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcblxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgTmZhY2V2ZXJ0cyA9IGZhY2VWZXJ0cy5sZW5ndGg7IGogIT09IE5mYWNldmVydHM7IGorKykge1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MSk7XG4gICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7XG4gICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHhpX3RvX3ApO1xuICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xuICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xuICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocCk7XG4gICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcbiAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHtcbiAgICAgICAgICB2M3Bvb2wucmVsZWFzZShmYWNlVmVydHNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGxhbmVDb252ZXgocGxhbmVTaGFwZSwgY29udmV4U2hhcGUsIHBsYW5lUG9zaXRpb24sIGNvbnZleFBvc2l0aW9uLCBwbGFuZVF1YXQsIGNvbnZleFF1YXQsIHBsYW5lQm9keSwgY29udmV4Qm9keSwgc2ksIHNqLCBqdXN0VGVzdCkge1xuICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLlxuICAgIGNvbnN0IHdvcmxkVmVydGV4ID0gcGxhbmVDb252ZXhfdjtcbiAgICBjb25zdCB3b3JsZE5vcm1hbCA9IHBsYW5lQ29udmV4X25vcm1hbDtcbiAgICB3b3JsZE5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvblxuXG4gICAgbGV0IG51bUNvbnRhY3RzID0gMDtcbiAgICBjb25zdCByZWxwb3MgPSBwbGFuZUNvbnZleF9yZWxwb3M7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4XG4gICAgICB3b3JsZFZlcnRleC5jb3B5KGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldKTtcbiAgICAgIGNvbnZleFF1YXQudm11bHQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgIHdvcmxkVmVydGV4LnZzdWIocGxhbmVQb3NpdGlvbiwgcmVscG9zKTtcbiAgICAgIGNvbnN0IGRvdCA9IHdvcmxkTm9ybWFsLmRvdChyZWxwb3MpO1xuXG4gICAgICBpZiAoZG90IDw9IDAuMCkge1xuICAgICAgICBpZiAoanVzdFRlc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNvbnZleEJvZHksIHBsYW5lU2hhcGUsIGNvbnZleFNoYXBlLCBzaSwgc2opOyAvLyBHZXQgdmVydGV4IHBvc2l0aW9uIHByb2plY3RlZCBvbiBwbGFuZVxuXG4gICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHBsYW5lQ29udmV4X3Byb2plY3RlZDtcbiAgICAgICAgd29ybGROb3JtYWwuc2NhbGUod29ybGROb3JtYWwuZG90KHJlbHBvcyksIHByb2plY3RlZCk7XG4gICAgICAgIHdvcmxkVmVydGV4LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xuICAgICAgICBwcm9qZWN0ZWQudnN1YihwbGFuZVBvc2l0aW9uLCByLnJpKTsgLy8gRnJvbSBwbGFuZSB0byB2ZXJ0ZXggcHJvamVjdGVkIG9uIHBsYW5lXG5cbiAgICAgICAgci5uaS5jb3B5KHdvcmxkTm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbCBvdXQgZnJvbSBwbGFuZVxuICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleFxuXG4gICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopOyAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG5cbiAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpO1xuICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgci5yai52YWRkKGNvbnZleFBvc2l0aW9uLCByLnJqKTtcbiAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICBudW1Db250YWN0cysrO1xuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xuICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKSB7XG4gICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpO1xuICAgIH1cbiAgfVxuXG4gIGJveENvbnZleChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHJldHVybiB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTtcbiAgfVxuXG4gIHNwaGVyZUhlaWdodGZpZWxkKHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBzcGhlcmVQb3MsIGhmUG9zLCBzcGhlcmVRdWF0LCBoZlF1YXQsIHNwaGVyZUJvZHksIGhmQm9keSwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgY29uc3QgZGF0YSA9IGhmU2hhcGUuZGF0YTtcbiAgICBjb25zdCByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7XG4gICAgY29uc3QgdyA9IGhmU2hhcGUuZWxlbWVudFNpemU7XG4gICAgY29uc3Qgd29ybGRQaWxsYXJPZmZzZXQgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAyOyAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuXG4gICAgY29uc3QgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG5cbiAgICBsZXQgaU1pblggPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy54IC0gcmFkaXVzKSAvIHcpIC0gMTtcbiAgICBsZXQgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnggKyByYWRpdXMpIC8gdykgKyAxO1xuICAgIGxldCBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnkgLSByYWRpdXMpIC8gdykgLSAxO1xuICAgIGxldCBpTWF4WSA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueSArIHJhZGl1cykgLyB3KSArIDE7IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cblxuICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcblxuXG4gICAgaWYgKGlNaW5YIDwgMCkge1xuICAgICAgaU1pblggPSAwO1xuICAgIH1cblxuICAgIGlmIChpTWF4WCA8IDApIHtcbiAgICAgIGlNYXhYID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaU1pblkgPCAwKSB7XG4gICAgICBpTWluWSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlNYXhZIDwgMCkge1xuICAgICAgaU1heFkgPSAwO1xuICAgIH1cblxuICAgIGlmIChpTWluWCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgaWYgKGlNYXhYID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHtcbiAgICAgIGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGlmIChpTWluWSA+PSBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgY29uc3QgbWluTWF4ID0gW107XG4gICAgaGZTaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpO1xuICAgIGNvbnN0IG1pbiA9IG1pbk1heFswXTtcbiAgICBjb25zdCBtYXggPSBtaW5NYXhbMV07IC8vIEJhaWwgb3V0IGlmIHdlIGNhbid0IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG5cbiAgICBpZiAobG9jYWxTcGhlcmVQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbFNwaGVyZVBvcy56ICsgcmFkaXVzIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKSB7XG4gICAgICAgIGNvbnN0IG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGludGVyc2VjdGluZyA9IGZhbHNlOyAvLyBMb3dlciB0cmlhbmdsZVxuXG4gICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcblxuICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHksIHNwaGVyZVNoYXBlLCBoZlNoYXBlLCBqdXN0VGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gVXBwZXIgdHJpYW5nbGVcblxuXG4gICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XG4gICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuXG4gICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW5nID0gdGhpcy5zcGhlcmVDb252ZXgoc3BoZXJlU2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBzcGhlcmVQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBzcGhlcmVRdWF0LCBoZlF1YXQsIHNwaGVyZUJvZHksIGhmQm9keSwgc3BoZXJlU2hhcGUsIGhmU2hhcGUsIGp1c3RUZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqdXN0VGVzdCAmJiBpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG51bUNvbnRhY3RzID0gcmVzdWx0Lmxlbmd0aCAtIG51bUNvbnRhY3RzQmVmb3JlO1xuXG4gICAgICAgIGlmIChudW1Db250YWN0cyA+IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcclxuICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxXHJcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG51bUNvbnRhY3RzIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICovXG5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBib3hIZWlnaHRmaWVsZChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHJldHVybiB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHNpLCBzaiwganVzdFRlc3QpO1xuICB9XG5cbiAgY29udmV4SGVpZ2h0ZmllbGQoY29udmV4U2hhcGUsIGhmU2hhcGUsIGNvbnZleFBvcywgaGZQb3MsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCByc2ksIHJzaiwganVzdFRlc3QpIHtcbiAgICBjb25zdCBkYXRhID0gaGZTaGFwZS5kYXRhO1xuICAgIGNvbnN0IHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplO1xuICAgIGNvbnN0IHJhZGl1cyA9IGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzO1xuICAgIGNvbnN0IHdvcmxkUGlsbGFyT2Zmc2V0ID0gY29udmV4SGVpZ2h0ZmllbGRfdG1wMjtcbiAgICBjb25zdCBmYWNlTGlzdCA9IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0OyAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuXG4gICAgY29uc3QgbG9jYWxDb252ZXhQb3MgPSBjb252ZXhIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG5cbiAgICBsZXQgaU1pblggPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy54IC0gcmFkaXVzKSAvIHcpIC0gMTtcbiAgICBsZXQgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnggKyByYWRpdXMpIC8gdykgKyAxO1xuICAgIGxldCBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnkgLSByYWRpdXMpIC8gdykgLSAxO1xuICAgIGxldCBpTWF4WSA9IE1hdGguY2VpbCgobG9jYWxDb252ZXhQb3MueSArIHJhZGl1cykgLyB3KSArIDE7IC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cblxuICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcblxuXG4gICAgaWYgKGlNaW5YIDwgMCkge1xuICAgICAgaU1pblggPSAwO1xuICAgIH1cblxuICAgIGlmIChpTWF4WCA8IDApIHtcbiAgICAgIGlNYXhYID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaU1pblkgPCAwKSB7XG4gICAgICBpTWluWSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlNYXhZIDwgMCkge1xuICAgICAgaU1heFkgPSAwO1xuICAgIH1cblxuICAgIGlmIChpTWluWCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgaWYgKGlNYXhYID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHtcbiAgICAgIGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGlmIChpTWluWSA+PSBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgY29uc3QgbWluTWF4ID0gW107XG4gICAgaGZTaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpO1xuICAgIGNvbnN0IG1pbiA9IG1pbk1heFswXTtcbiAgICBjb25zdCBtYXggPSBtaW5NYXhbMV07IC8vIEJhaWwgb3V0IGlmIHdlJ3JlIGNhbnQgdG91Y2ggdGhlIGJvdW5kaW5nIGhlaWdodCBib3hcblxuICAgIGlmIChsb2NhbENvbnZleFBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsQ29udmV4UG9zLnogKyByYWRpdXMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3RpbmcgPSBmYWxzZTsgLy8gTG93ZXIgdHJpYW5nbGVcblxuICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG5cbiAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICBpbnRlcnNlY3RpbmcgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBqdXN0VGVzdCwgZmFjZUxpc3QsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGp1c3RUZXN0ICYmIGludGVyc2VjdGluZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIFVwcGVyIHRyaWFuZ2xlXG5cblxuICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcblxuICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgIGludGVyc2VjdGluZyA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleFNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgY29udmV4UG9zLCB3b3JsZFBpbGxhck9mZnNldCwgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIG51bGwsIG51bGwsIGp1c3RUZXN0LCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoanVzdFRlc3QgJiYgaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzcGhlcmVQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIC8vIFRoZSBub3JtYWwgaXMgdGhlIHVuaXQgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBwYXJ0aWNsZSBjZW50ZXJcbiAgICBjb25zdCBub3JtYWwgPSBwYXJ0aWNsZVNwaGVyZV9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLCAwLCAxKTtcbiAgICB4aS52c3ViKHhqLCBub3JtYWwpO1xuICAgIGNvbnN0IGxlbmd0aFNxdWFyZWQgPSBub3JtYWwubGVuZ3RoU3F1YXJlZCgpO1xuXG4gICAgaWYgKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKSB7XG4gICAgICBpZiAoanVzdFRlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaiwgcnNpLCByc2opO1xuICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgci5yai5jb3B5KG5vcm1hbCk7XG4gICAgICByLnJqLnNjYWxlKHNqLnJhZGl1cywgci5yaik7XG4gICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWxcblxuICAgICAgci5uaS5uZWdhdGUoci5uaSk7XG4gICAgICByLnJpLnNldCgwLCAwLCAwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG5cbiAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcGxhbmVQYXJ0aWNsZShzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmksIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIGNvbnN0IG5vcm1hbCA9IHBhcnRpY2xlUGxhbmVfbm9ybWFsO1xuICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgYmoucXVhdGVybmlvbi52bXVsdChub3JtYWwsIG5vcm1hbCk7IC8vIFR1cm4gbm9ybWFsIGFjY29yZGluZyB0byBwbGFuZSBvcmllbnRhdGlvblxuXG4gICAgY29uc3QgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7XG4gICAgeGkudnN1Yihiai5wb3NpdGlvbiwgcmVscG9zKTtcbiAgICBjb25zdCBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG5cbiAgICBpZiAoZG90IDw9IDAuMCkge1xuICAgICAgaWYgKGp1c3RUZXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKTtcbiAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsXG5cbiAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuICAgICAgci5yaS5zZXQoMCwgMCwgMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuICAgICAgLy8gR2V0IHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCBvbiBwbGFuZVxuXG4gICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZDtcbiAgICAgIG5vcm1hbC5zY2FsZShub3JtYWwuZG90KHhpKSwgcHJvamVjdGVkKTtcbiAgICAgIHhpLnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpOyAvL3Byb2plY3RlZC52YWRkKGJqLnBvc2l0aW9uLHByb2plY3RlZCk7XG4gICAgICAvLyByaiBpcyBub3cgdGhlIHByb2plY3RlZCB3b3JsZCBwb3NpdGlvbiBtaW51cyBwbGFuZSBwb3NpdGlvblxuXG4gICAgICByLnJqLmNvcHkocHJvamVjdGVkKTtcbiAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgYm94UGFydGljbGUoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCByc2ksIHJzaiwganVzdFRlc3QpIHtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICByZXR1cm4gdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqLCBzaSwgc2osIGp1c3RUZXN0KTtcbiAgfVxuXG4gIGNvbnZleFBhcnRpY2xlKHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgbGV0IHBlbmV0cmF0ZWRGYWNlSW5kZXggPSAtMTtcbiAgICBjb25zdCBwZW5ldHJhdGVkRmFjZU5vcm1hbCA9IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsO1xuICAgIGNvbnN0IHdvcmxkUGVuZXRyYXRpb25WZWMgPSBjb252ZXhQYXJ0aWNsZV93b3JsZFBlbmV0cmF0aW9uVmVjO1xuICAgIGxldCBtaW5QZW5ldHJhdGlvbiA9IG51bGw7XG5cbiAgICBjb25zdCBsb2NhbCA9IGNvbnZleFBhcnRpY2xlX2xvY2FsO1xuICAgIGxvY2FsLmNvcHkoeGkpO1xuICAgIGxvY2FsLnZzdWIoeGosIGxvY2FsKTsgLy8gQ29udmVydCBwb3NpdGlvbiB0byByZWxhdGl2ZSB0aGUgY29udmV4IG9yaWdpblxuXG4gICAgcWouY29uanVnYXRlKGNxaik7XG4gICAgY3FqLnZtdWx0KGxvY2FsLCBsb2NhbCk7XG5cbiAgICBpZiAoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpIHtcbiAgICAgIGlmIChzai53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUpIHtcbiAgICAgICAgc2ouY29tcHV0ZVdvcmxkVmVydGljZXMoeGosIHFqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNqLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSkge1xuICAgICAgICBzai5jb21wdXRlV29ybGRGYWNlTm9ybWFscyhxaik7XG4gICAgICB9IC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxuXG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZmFjZXMgPSBzai5mYWNlcy5sZW5ndGg7IGkgIT09IG5mYWNlczsgaSsrKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCB3b3JsZCBmYWNlIHZlcnRpY2VzXG4gICAgICAgIGNvbnN0IHZlcnRzID0gW3NqLndvcmxkVmVydGljZXNbc2ouZmFjZXNbaV1bMF1dXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTsgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuXG5cbiAgICAgICAgeGkudnN1Yih2ZXJ0c1swXSwgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG4gICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG5cbiAgICAgICAgaWYgKG1pblBlbmV0cmF0aW9uID09PSBudWxsIHx8IE1hdGguYWJzKHBlbmV0cmF0aW9uKSA8IE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSkge1xuICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICAgICAgICBwZW5ldHJhdGVkRmFjZUluZGV4ID0gaTtcbiAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBlbmV0cmF0ZWRGYWNlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIFNldHVwIGNvbnRhY3RcbiAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqLCByc2ksIHJzaik7XG4gICAgICAgIHBlbmV0cmF0ZWRGYWNlTm9ybWFsLnNjYWxlKG1pblBlbmV0cmF0aW9uLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTsgLy8gcmogaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZmFjZVxuXG4gICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudmFkZCh4aSwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aiwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgIHIucmouY29weSh3b3JsZFBlbmV0cmF0aW9uVmVjKTsgLy9jb25zdCBwcm9qZWN0ZWRUb0ZhY2UgPSB4aS52c3ViKHhqKS52YWRkKHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xuICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7XG5cbiAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubmVnYXRlKHIubmkpOyAvLyBDb250YWN0IG5vcm1hbFxuXG4gICAgICAgIHIucmkuc2V0KDAsIDAsIDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICBjb25zdCByaSA9IHIucmk7XG4gICAgICAgIGNvbnN0IHJqID0gci5yajsgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcblxuICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcbiAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNwaGVyZVRyaW1lc2goc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgc3BoZXJlUG9zLCB0cmltZXNoUG9zLCBzcGhlcmVRdWF0LCB0cmltZXNoUXVhdCwgc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHJzaSwgcnNqLCBqdXN0VGVzdCkge1xuICAgIGNvbnN0IGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTtcbiAgICBjb25zdCBlZGdlVmVydGV4QiA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEI7XG4gICAgY29uc3QgZWRnZVZlY3RvciA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvcjtcbiAgICBjb25zdCBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7XG4gICAgY29uc3QgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zO1xuICAgIGNvbnN0IHRtcCA9IHNwaGVyZVRyaW1lc2hfdG1wO1xuICAgIGNvbnN0IGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCO1xuICAgIGNvbnN0IHYyID0gc3BoZXJlVHJpbWVzaF92MjtcbiAgICBjb25zdCByZWxwb3MgPSBzcGhlcmVUcmltZXNoX3JlbHBvcztcbiAgICBjb25zdCB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlczsgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2hcblxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7IC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2hcblxuICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1cztcbiAgICBsb2NhbFNwaGVyZUFBQkIubG93ZXJCb3VuZC5zZXQobG9jYWxTcGhlcmVQb3MueCAtIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueSAtIHNwaGVyZVJhZGl1cywgbG9jYWxTcGhlcmVQb3MueiAtIHNwaGVyZVJhZGl1cyk7XG4gICAgbG9jYWxTcGhlcmVBQUJCLnVwcGVyQm91bmQuc2V0KGxvY2FsU3BoZXJlUG9zLnggKyBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnkgKyBzcGhlcmVSYWRpdXMsIGxvY2FsU3BoZXJlUG9zLnogKyBzcGhlcmVSYWRpdXMpO1xuICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpOyAvL2ZvciAobGV0IGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsXG4gICAgLy8gVmVydGljZXNcblxuICAgIGNvbnN0IHYgPSBzcGhlcmVUcmltZXNoX3Y7XG4gICAgY29uc3QgcmFkaXVzU3F1YXJlZCA9IHNwaGVyZVNoYXBlLnJhZGl1cyAqIHNwaGVyZVNoYXBlLnJhZGl1cztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyBqXSwgdik7IC8vIENoZWNrIHZlcnRleCBvdmVybGFwIGluIHNwaGVyZVxuXG4gICAgICAgIHYudnN1Yihsb2NhbFNwaGVyZVBvcywgcmVscG9zKTtcblxuICAgICAgICBpZiAocmVscG9zLmxlbmd0aFNxdWFyZWQoKSA8PSByYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICAgIHYyLmNvcHkodik7XG4gICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB2Miwgdik7XG4gICAgICAgICAgdi52c3ViKHNwaGVyZVBvcywgcmVscG9zKTtcblxuICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opO1xuICAgICAgICAgIHIubmkuY29weShyZWxwb3MpO1xuICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZVxuXG4gICAgICAgICAgci5yaS5jb3B5KHIubmkpO1xuICAgICAgICAgIHIucmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcbiAgICAgICAgICByLnJpLnZhZGQoc3BoZXJlUG9zLCByLnJpKTtcbiAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7IC8vIFN0b3JlIHJlc3VsdFxuXG4gICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGFsbCBlZGdlc1xuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIGVkZ2VWZXJ0ZXhBKTtcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgKGogKyAxKSAlIDNdLCBlZGdlVmVydGV4Qik7XG4gICAgICAgIGVkZ2VWZXJ0ZXhCLnZzdWIoZWRnZVZlcnRleEEsIGVkZ2VWZWN0b3IpOyAvLyBQcm9qZWN0IHNwaGVyZSBwb3NpdGlvbiB0byB0aGUgZWRnZVxuXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQWxvbmdFZGdlQiA9IHRtcC5kb3QoZWRnZVZlY3Rvcik7XG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEEsIHRtcCk7XG4gICAgICAgIGxldCBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApIHtcbiAgICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIG9ydGhvZ29uYWwgZGlzdGFuY2UgZnJvbSBlZGdlIHRvIHNwaGVyZSBjZW50ZXJcbiAgICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKGVkZ2VWZXJ0ZXhBLCB0bXApO1xuICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7XG4gICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG4gICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApO1xuICAgICAgICAgIHRtcC52YWRkKGVkZ2VWZXJ0ZXhBLCB0bXApOyAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG5cbiAgICAgICAgICBjb25zdCBkaXN0ID0gdG1wLmRpc3RhbmNlVG8obG9jYWxTcGhlcmVQb3MpO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPCBzcGhlcmVTaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHNwaGVyZUJvZHksIHRyaW1lc2hCb2R5LCBzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlLCByc2ksIHJzaik7XG4gICAgICAgICAgICB0bXAudnN1Yihsb2NhbFNwaGVyZVBvcywgci5uaSk7XG4gICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuICAgICAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHRtcCwgdG1wKTtcbiAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5yaSwgci5yaSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVHJpYW5nbGUgZmFjZXNcblxuXG4gICAgY29uc3QgdmEgPSBzcGhlcmVUcmltZXNoX3ZhO1xuICAgIGNvbnN0IHZiID0gc3BoZXJlVHJpbWVzaF92YjtcbiAgICBjb25zdCB2YyA9IHNwaGVyZVRyaW1lc2hfdmM7XG4gICAgY29uc3Qgbm9ybWFsID0gc3BoZXJlVHJpbWVzaF9ub3JtYWw7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKykge1xuICAgICAgdHJpbWVzaFNoYXBlLmdldFRyaWFuZ2xlVmVydGljZXModHJpYW5nbGVzW2ldLCB2YSwgdmIsIHZjKTtcbiAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xuICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTtcbiAgICAgIGxldCBkaXN0ID0gdG1wLmRvdChub3JtYWwpO1xuICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XG4gICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTsgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmVcblxuICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTtcblxuICAgICAgaWYgKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSwgcnNpLCByc2opO1xuICAgICAgICB0bXAudnN1Yihsb2NhbFNwaGVyZVBvcywgci5uaSk7XG4gICAgICAgIHIubmkubm9ybWFsaXplKCk7XG4gICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcbiAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgIHIucmkudnN1YihzcGhlcmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7XG4gICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcbiAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBwbGFuZVRyaW1lc2gocGxhbmVTaGFwZSwgdHJpbWVzaFNoYXBlLCBwbGFuZVBvcywgdHJpbWVzaFBvcywgcGxhbmVRdWF0LCB0cmltZXNoUXVhdCwgcGxhbmVCb2R5LCB0cmltZXNoQm9keSwgcnNpLCByc2osIGp1c3RUZXN0KSB7XG4gICAgLy8gTWFrZSBjb250YWN0cyFcbiAgICBjb25zdCB2ID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBub3JtYWwgPSBwbGFuZVRyaW1lc2hfbm9ybWFsO1xuICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCwgbm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaW1lc2hTaGFwZS52ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXG4gICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpOyAvLyBTYWZlIHVwXG5cbiAgICAgIGNvbnN0IHYyID0gbmV3IFZlYzMoKTtcbiAgICAgIHYyLmNvcHkodik7XG4gICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTsgLy8gQ2hlY2sgcGxhbmUgc2lkZVxuXG4gICAgICBjb25zdCByZWxwb3MgPSBwbGFuZVRyaW1lc2hfcmVscG9zO1xuICAgICAgdi52c3ViKHBsYW5lUG9zLCByZWxwb3MpO1xuICAgICAgY29uc3QgZG90ID0gbm9ybWFsLmRvdChyZWxwb3MpO1xuXG4gICAgICBpZiAoZG90IDw9IDAuMCkge1xuICAgICAgICBpZiAoanVzdFRlc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIHRyaW1lc2hCb2R5LCBwbGFuZVNoYXBlLCB0cmltZXNoU2hhcGUsIHJzaSwgcnNqKTtcbiAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWxcbiAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcblxuICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkO1xuICAgICAgICBub3JtYWwuc2NhbGUocmVscG9zLmRvdChub3JtYWwpLCBwcm9qZWN0ZWQpO1xuICAgICAgICB2LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpOyAvLyByaSBpcyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXG5cbiAgICAgICAgci5yaS5jb3B5KHByb2plY3RlZCk7XG4gICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICByLnJqLmNvcHkodik7XG4gICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7IC8vIFN0b3JlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gY29udmV4VHJpbWVzaChcbiAgLy8gICBzaTogQ29udmV4UG9seWhlZHJvbiwgc2o6IFRyaW1lc2gsIHhpOiBWZWMzLCB4ajogVmVjMywgcWk6IFF1YXRlcm5pb24sIHFqOiBRdWF0ZXJuaW9uLFxuICAvLyAgIGJpOiBCb2R5LCBiajogQm9keSwgcnNpPzogU2hhcGUgfCBudWxsLCByc2o/OiBTaGFwZSB8IG51bGwsXG4gIC8vICAgZmFjZUxpc3RBPzogbnVtYmVyW10gfCBudWxsLCBmYWNlTGlzdEI/OiBudW1iZXJbXSB8IG51bGwsXG4gIC8vICkge1xuICAvLyAgIGNvbnN0IHNlcEF4aXMgPSBjb252ZXhDb252ZXhfc2VwQXhpcztcbiAgLy8gICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAvLyAgICAgICByZXR1cm47XG4gIC8vICAgfVxuICAvLyAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZVxuICAvLyAgIGNvbnN0IGh1bGxCID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgLy8gICBodWxsQi5mYWNlcyA9IFtbMCwxLDJdXTtcbiAgLy8gICBjb25zdCB2YSA9IG5ldyBWZWMzKCk7XG4gIC8vICAgY29uc3QgdmIgPSBuZXcgVmVjMygpO1xuICAvLyAgIGNvbnN0IHZjID0gbmV3IFZlYzMoKTtcbiAgLy8gICBodWxsQi52ZXJ0aWNlcyA9IFtcbiAgLy8gICAgICAgdmEsXG4gIC8vICAgICAgIHZiLFxuICAvLyAgICAgICB2Y1xuICAvLyAgIF07XG4gIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzai5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuICAvLyAgICAgICBjb25zdCB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gIC8vICAgICAgIHNqLmdldE5vcm1hbChpLCB0cmlhbmdsZU5vcm1hbCk7XG4gIC8vICAgICAgIGh1bGxCLmZhY2VOb3JtYWxzID0gW3RyaWFuZ2xlTm9ybWFsXTtcbiAgLy8gICAgICAgc2ouZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCB2YSwgdmIsIHZjKTtcbiAgLy8gICAgICAgbGV0IGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcbiAgLy8gICAgICAgaWYoIWQpe1xuICAvLyAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTtcbiAgLy8gICAgICAgICAgIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcbiAgLy8gICAgICAgICAgIGlmKCFkKXtcbiAgLy8gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgLy8gICAgICAgICAgIH1cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBjb25zdCByZXM6IENvbnZleFBvbHloZWRyb25Db250YWN0UG9pbnRbXSA9IFtdO1xuICAvLyAgICAgICBjb25zdCBxID0gY29udmV4Q29udmV4X3E7XG4gIC8vICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxodWxsQix4aixxaix0cmlhbmdsZU5vcm1hbCwtMTAwLDEwMCxyZXMpO1xuICAvLyAgICAgICBmb3IobGV0IGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspe1xuICAvLyAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opLFxuICAvLyAgICAgICAgICAgICAgIHJpID0gci5yaSxcbiAgLy8gICAgICAgICAgICAgICByaiA9IHIucmo7XG4gIC8vICAgICAgICAgICByLm5pLmNvcHkodHJpYW5nbGVOb3JtYWwpO1xuICAvLyAgICAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7XG4gIC8vICAgICAgICAgICByZXNbal0ubm9ybWFsLm5lZ2F0ZShxKTtcbiAgLy8gICAgICAgICAgIHEubXVsdChyZXNbal0uZGVwdGgsIHEpO1xuICAvLyAgICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpO1xuICAvLyAgICAgICAgICAgcmouY29weShyZXNbal0ucG9pbnQpO1xuICAvLyAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxuICAvLyAgICAgICAgICAgcmkudnN1Yih4aSxyaSk7XG4gIC8vICAgICAgICAgICByai52c3ViKHhqLHJqKTtcbiAgLy8gICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gIC8vICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gIC8vICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gIC8vICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4gIC8vICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG4gIC8vICAgICAgICAgICByZXN1bHQucHVzaChyKTtcbiAgLy8gICAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuXG5cbn1cbmNvbnN0IGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpO1xuY29uc3QgYXZlcmFnZUNvbnRhY3RQb2ludEEgPSBuZXcgVmVjMygpO1xuY29uc3QgYXZlcmFnZUNvbnRhY3RQb2ludEIgPSBuZXcgVmVjMygpO1xuY29uc3QgdG1wVmVjMSQyID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRtcFZlYzIkMiA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBRdWF0MSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCB0bXBRdWF0MiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuYm94Qm94XSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hCb3g7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLmJveENvbnZleF0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94Q29udmV4O1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5ib3hQYXJ0aWNsZV0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94UGFydGljbGU7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVNwaGVyZV0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlU3BoZXJlO1xuY29uc3QgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5jb25zdCBwbGFuZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbmNvbnN0IHBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5wbGFuZVRyaW1lc2hdID0gTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lVHJpbWVzaDtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfdiA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVUcmltZXNoX3YyID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEEgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QiA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yVW5pdCA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfdG1wID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfdmEgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlVHJpbWVzaF92YiA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVUcmltZXNoX3ZjID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCID0gbmV3IEFBQkIoKTtcbmNvbnN0IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzID0gW107XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLnNwaGVyZVRyaW1lc2hdID0gTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVRyaW1lc2g7XG5jb25zdCBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xuY29uc3QgcGxhbmVfdG9fc3BoZXJlX29ydGhvID0gbmV3IFZlYzMoKTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuc3BoZXJlUGxhbmVdID0gTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBsYW5lOyAvLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbFxuXG5jb25zdCBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTtcbmNvbnN0IHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xuY29uc3QgcG9pbnRJblBvbHlnb25fdnRwID0gbmV3IFZlYzMoKTtcblxuZnVuY3Rpb24gcG9pbnRJblBvbHlnb24odmVydHMsIG5vcm1hbCwgcCkge1xuICBsZXQgcG9zaXRpdmVSZXN1bHQgPSBudWxsO1xuICBjb25zdCBOID0gdmVydHMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICBjb25zdCB2ID0gdmVydHNbaV07IC8vIEdldCBlZGdlIHRvIHRoZSBuZXh0IHZlcnRleFxuXG4gICAgY29uc3QgZWRnZSA9IHBvaW50SW5Qb2x5Z29uX2VkZ2U7XG4gICAgdmVydHNbKGkgKyAxKSAlIE5dLnZzdWIodiwgZWRnZSk7IC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlXG5cbiAgICBjb25zdCBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDsgLy9jb25zdCBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcblxuICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLCBlZGdlX3hfbm9ybWFsKTsgLy8gR2V0IHZlY3RvciBiZXR3ZWVuIHBvaW50IGFuZCBjdXJyZW50IHZlcnRleFxuXG4gICAgY29uc3QgdmVydGV4X3RvX3AgPSBwb2ludEluUG9seWdvbl92dHA7XG4gICAgcC52c3ViKHYsIHZlcnRleF90b19wKTsgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXG5cbiAgICBjb25zdCByID0gZWRnZV94X25vcm1hbC5kb3QodmVydGV4X3RvX3ApOyAvLyBJZiBhbGwgc3VjaCBkb3QgcHJvZHVjdHMgaGF2ZSBzYW1lIHNpZ24sIHdlIGFyZSBpbnNpZGUgdGhlIHBvbHlnb24uXG5cbiAgICBpZiAocG9zaXRpdmVSZXN1bHQgPT09IG51bGwgfHwgciA+IDAgJiYgcG9zaXRpdmVSZXN1bHQgPT09IHRydWUgfHwgciA8PSAwICYmIHBvc2l0aXZlUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgaWYgKHBvc2l0aXZlUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gciA+IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICB9XG4gIH0gLy8gSWYgd2UgZ290IGhlcmUsIGFsbCBkb3QgcHJvZHVjdHMgd2VyZSBvZiB0aGUgc2FtZSBzaWduLlxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IGJveF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlQm94X25zID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUJveF9uczEgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlQm94X25zMiA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVCb3hfc2lkZXMgPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07XG5jb25zdCBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVCb3hfc2lkZV9ucyA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlQm94X3NpZGVfbnMyID0gbmV3IFZlYzMoKTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQm94XSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVCb3g7XG5jb25zdCBjb252ZXhfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUNvbnZleF9lZGdlID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXIgPSBuZXcgVmVjMygpO1xuY29uc3Qgc3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVDb252ZXhfd29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG5jb25zdCBzcGhlcmVDb252ZXhfc3BoZXJlVG9Xb3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuc3BoZXJlQ29udmV4XSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVDb252ZXg7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLnBsYW5lQm94XSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUJveDtcbmNvbnN0IHBsYW5lQ29udmV4X3YgPSBuZXcgVmVjMygpO1xuY29uc3QgcGxhbmVDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcbmNvbnN0IHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XG5jb25zdCBwbGFuZUNvbnZleF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5wbGFuZUNvbnZleF0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXg7XG5jb25zdCBjb252ZXhDb252ZXhfc2VwQXhpcyA9IG5ldyBWZWMzKCk7XG5jb25zdCBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLmNvbnZleENvbnZleF0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4OyAvLyBOYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLmNvbnZleFRyaW1lc2hdID0gTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleFRyaW1lc2hcblxuY29uc3QgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xuY29uc3QgcGFydGljbGVQbGFuZV9yZWxwb3MgPSBuZXcgVmVjMygpO1xuY29uc3QgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5wbGFuZVBhcnRpY2xlXSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlO1xuY29uc3QgcGFydGljbGVTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuc3BoZXJlUGFydGljbGVdID0gTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBhcnRpY2xlOyAvLyBXSVBcblxuY29uc3QgY3FqID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IGNvbnZleFBhcnRpY2xlX2xvY2FsID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUgPSBuZXcgVmVjMygpO1xuY29uc3QgY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbQ09MTElTSU9OX1RZUEVTLmNvbnZleFBhcnRpY2xlXSA9IE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhQYXJ0aWNsZTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtDT0xMSVNJT05fVFlQRVMuYm94SGVpZ2h0ZmllbGRdID0gTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkO1xuY29uc3QgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG5jb25zdCBjb252ZXhIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcbmNvbnN0IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0ID0gWzBdO1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5jb252ZXhIZWlnaHRmaWVsZF0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQ7XG5jb25zdCBzcGhlcmVIZWlnaHRmaWVsZF90bXAxID0gbmV3IFZlYzMoKTtcbmNvbnN0IHNwaGVyZUhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpO1xuTmFycm93cGhhc2UucHJvdG90eXBlW0NPTExJU0lPTl9UWVBFUy5zcGhlcmVIZWlnaHRmaWVsZF0gPSBOYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlSGVpZ2h0ZmllbGQ7XG5cbi8qKlxyXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBPdmVybGFwS2VlcGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gW107XG4gICAgdGhpcy5wcmV2aW91cyA9IFtdO1xuICB9XG5cbiAgZ2V0S2V5KGksIGopIHtcbiAgICBpZiAoaiA8IGkpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBqO1xuICAgICAgaiA9IGk7XG4gICAgICBpID0gdGVtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gaSA8PCAxNiB8IGo7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzZXRcclxuICAgKiBAcGFyYW0ge051bWJlcn0gaVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBqXHJcbiAgICovXG5cblxuICBzZXQoaSwgaikge1xuICAgIC8vIEluc2VydGlvbiBzb3J0LiBUaGlzIHdheSB0aGUgZGlmZiB3aWxsIGhhdmUgbGluZWFyIGNvbXBsZXhpdHkuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoaSwgaik7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGtleSA+IGN1cnJlbnRbaW5kZXhdKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IGN1cnJlbnRbaW5kZXhdKSB7XG4gICAgICByZXR1cm47IC8vIFBhaXIgd2FzIGFscmVhZHkgYWRkZWRcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gY3VycmVudC5sZW5ndGggLSAxOyBqID49IGluZGV4OyBqLS0pIHtcbiAgICAgIGN1cnJlbnRbaiArIDFdID0gY3VycmVudFtqXTtcbiAgICB9XG5cbiAgICBjdXJyZW50W2luZGV4XSA9IGtleTtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIHRpY2tcclxuICAgKi9cblxuXG4gIHRpY2soKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucHJldmlvdXM7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRtcDtcbiAgICB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBAbWV0aG9kIGdldERpZmZcclxuICAgKiBAcGFyYW0gIHthcnJheX0gYWRkaXRpb25zXHJcbiAgICogQHBhcmFtICB7YXJyYXl9IHJlbW92YWxzXHJcbiAgICovXG5cblxuICBnZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpIHtcbiAgICBjb25zdCBhID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGIgPSB0aGlzLnByZXZpb3VzO1xuICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsOyBpKyspIHtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgY29uc3Qga2V5QSA9IGFbaV07XG5cbiAgICAgIHdoaWxlIChrZXlBID4gYltqXSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG5cbiAgICAgIGZvdW5kID0ga2V5QSA9PT0gYltqXTtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB1bnBhY2tBbmRQdXNoKGFkZGl0aW9ucywga2V5QSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsOyBpKyspIHtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgY29uc3Qga2V5QiA9IGJbaV07XG5cbiAgICAgIHdoaWxlIChrZXlCID4gYVtqXSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG5cbiAgICAgIGZvdW5kID0gYVtqXSA9PT0ga2V5QjtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB1bnBhY2tBbmRQdXNoKHJlbW92YWxzLCBrZXlCKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiB1bnBhY2tBbmRQdXNoKGFycmF5LCBrZXkpIHtcbiAgYXJyYXkucHVzaCgoa2V5ICYgMHhmZmZmMDAwMCkgPj4gMTYsIGtleSAmIDB4MDAwMGZmZmYpO1xufVxuXG4vKipcclxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBUdXBsZURpY3Rpb25hcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBrZXlzOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBnZXRcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXG5cblxuICBnZXQoaSwgaikge1xuICAgIGlmIChpID4gaikge1xuICAgICAgLy8gc3dhcFxuICAgICAgY29uc3QgdGVtcCA9IGo7XG4gICAgICBqID0gaTtcbiAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbaSArIFwiLVwiICsgal07XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCBzZXRcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcclxuICAgKi9cblxuXG4gIHNldChpLCBqLCB2YWx1ZSkge1xuICAgIGlmIChpID4gaikge1xuICAgICAgY29uc3QgdGVtcCA9IGo7XG4gICAgICBqID0gaTtcbiAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGkgKyBcIi1cIiArIGo7IC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuXG4gICAgaWYgKCF0aGlzLmdldChpLCBqKSkge1xuICAgICAgdGhpcy5kYXRhLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQG1ldGhvZCByZXNldFxyXG4gICAqL1xuXG5cbiAgcmVzZXQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBrZXlzID0gZGF0YS5rZXlzO1xuXG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXHJcbiAqIFRoZSBwaHlzaWNzIHdvcmxkXHJcbiAqIEBjbGFzcyBXb3JsZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmdyYXZpdHldXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dTbGVlcF1cclxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXVxyXG4gKiBAcGFyYW0ge1NvbHZlcn0gW29wdGlvbnMuc29sdmVyXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0XVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXBdXHJcbiAqL1xuY2xhc3MgV29ybGQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8vIEN1cnJlbnRseSAvIGxhc3QgdXNlZCB0aW1lc3RlcC4gSXMgc2V0IHRvIC0xIGlmIG5vdCBhdmFpbGFibGUuIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCBiZWZvcmUgZWFjaCBpbnRlcm5hbCBzdGVwLCB3aGljaCBtZWFucyB0aGF0IGl0IGlzIFwiZnJlc2hcIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLlxuICAvLyBNYWtlcyBib2RpZXMgZ28gdG8gc2xlZXAgd2hlbiB0aGV5J3ZlIGJlZW4gaW5hY3RpdmUuXG4gIC8vIEFsbCB0aGUgY3VycmVudCBjb250YWN0cyAoaW5zdGFuY2VzIG9mIENvbnRhY3RFcXVhdGlvbikgaW4gdGhlIHdvcmxkLlxuICAvLyBIb3cgb2Z0ZW4gdG8gbm9ybWFsaXplIHF1YXRlcm5pb25zLiBTZXQgdG8gMCBmb3IgZXZlcnkgc3RlcCwgMSBmb3IgZXZlcnkgc2Vjb25kIGV0Yy4uIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyBwZXJmb3JtYW5jZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGEgc21hbGxlciB2YWx1ZSAoemVybyB0byBiZSBzdXJlIG5vdGhpbmcgY2FuIGdvIHdyb25nKS5cbiAgLy8gU2V0IHRvIHRydWUgdG8gdXNlIGZhc3QgcXVhdGVybmlvbiBub3JtYWxpemF0aW9uLiBJdCBpcyBvZnRlbiBlbm91Z2ggYWNjdXJhdGUgdG8gdXNlLiBJZiBib2RpZXMgdGVuZCB0byBleHBsb2RlLCBzZXQgdG8gZmFsc2UuXG4gIC8vIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydC5cbiAgLy8gTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydC5cbiAgLy8gRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplcy5cbiAgLy8gVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdCBpcyBOYWl2ZUJyb2FkcGhhc2UuXG4gIC8vIEFsbCBib2RpZXMgaW4gdGhpcyB3b3JsZFxuICAvLyBUcnVlIGlmIGFueSBib2RpZXMgYXJlIG5vdCBzbGVlcGluZywgZmFsc2UgaWYgZXZlcnkgYm9keSBpcyBzbGVlcGluZy5cbiAgLy8gVGhlIHNvbHZlciBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0IGlzIEdTU29sdmVyLlxuICAvLyBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC5cbiAgLy8gQWxsIGFkZGVkIG1hdGVyaWFscy5cbiAgLy8gVXNlZCB0byBsb29rIHVwIGEgQ29udGFjdE1hdGVyaWFsIGdpdmVuIHR3byBpbnN0YW5jZXMgb2YgTWF0ZXJpYWwuXG4gIC8vIFRoaXMgY29udGFjdCBtYXRlcmlhbCBpcyB1c2VkIGlmIG5vIHN1aXRhYmxlIGNvbnRhY3RtYXRlcmlhbCBpcyBmb3VuZCBmb3IgYSBjb250YWN0LlxuICAvLyBUaW1lIGFjY3VtdWxhdG9yIGZvciBpbnRlcnBvbGF0aW9uLiBTZWUgaHR0cDovL2dhZmZlcm9uZ2FtZXMuY29tL2dhbWUtcGh5c2ljcy9maXgteW91ci10aW1lc3RlcC9cbiAgLy8gRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHdvcmxkLlxuICAvLyBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZHQgPSAtMTtcbiAgICB0aGlzLmFsbG93U2xlZXAgPSAhIW9wdGlvbnMuYWxsb3dTbGVlcDtcbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuICAgIHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgPSBvcHRpb25zLnF1YXROb3JtYWxpemVTa2lwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YXROb3JtYWxpemVTa2lwIDogMDtcbiAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplRmFzdCA6IGZhbHNlO1xuICAgIHRoaXMudGltZSA9IDAuMDtcbiAgICB0aGlzLnN0ZXBudW1iZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEgLyA2MDtcbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IFZlYzMoKTtcblxuICAgIGlmIChvcHRpb25zLmdyYXZpdHkpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eS5jb3B5KG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJyb2FkcGhhc2UgOiBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcbiAgICB0aGlzLmhhc0FjdGl2ZUJvZGllcyA9IGZhbHNlO1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG4gICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlciA9IG5ldyBPdmVybGFwS2VlcGVyKCk7XG4gICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIgPSBuZXcgT3ZlcmxhcEtlZXBlcigpO1xuICAgIHRoaXMubWF0ZXJpYWxzID0gW107XG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzID0gW107XG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgnZGVmYXVsdCcpO1xuICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB7XG4gICAgICBmcmljdGlvbjogMC4zLFxuICAgICAgcmVzdGl0dXRpb246IDAuMFxuICAgIH0pO1xuICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnByb2ZpbGUgPSB7XG4gICAgICBzb2x2ZTogMCxcbiAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6IDAsXG4gICAgICBicm9hZHBoYXNlOiAwLFxuICAgICAgaW50ZWdyYXRlOiAwLFxuICAgICAgbmFycm93cGhhc2U6IDBcbiAgICB9O1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdO1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgdHlwZTogJ2FkZEJvZHknLFxuICAgICAgYm9keTogbnVsbFxuICAgIH07XG4gICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQgPSB7XG4gICAgICB0eXBlOiAncmVtb3ZlQm9keScsXG4gICAgICBib2R5OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmlkVG9Cb2R5TWFwID0ge307XG4gICAgdGhpcy5icm9hZHBoYXNlLnNldFdvcmxkKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29udGFjdCBtYXRlcmlhbCBiZXR3ZWVuIG1hdGVyaWFscyBtMSBhbmQgbTJcclxuICAgKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxyXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXHJcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gbTJcclxuICAgKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBjb250YWN0IG1hdGVyaWFsIGlmIGl0IHdhcyBmb3VuZC5cclxuICAgKi9cblxuXG4gIGdldENvbnRhY3RNYXRlcmlhbChtMSwgbTIpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsIG0yLmlkKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgbnVtYmVyIG9mIG9iamVjdHMgaW4gdGhlIHdvcmxkLlxyXG4gICAqIEBtZXRob2QgbnVtT2JqZWN0c1xyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xuXG5cbiAgbnVtT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5ib2RpZXMubGVuZ3RoO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3JlIG9sZCBjb2xsaXNpb24gc3RhdGUgaW5mb1xyXG4gICAqIEBtZXRob2QgY29sbGlzaW9uTWF0cml4VGlja1xyXG4gICAqL1xuXG5cbiAgY29sbGlzaW9uTWF0cml4VGljaygpIHtcbiAgICBjb25zdCB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gdGhpcy5jb2xsaXNpb25NYXRyaXg7XG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wO1xuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XG4gICAgdGhpcy5ib2R5T3ZlcmxhcEtlZXBlci50aWNrKCk7XG4gICAgdGhpcy5zaGFwZU92ZXJsYXBLZWVwZXIudGljaygpO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXHJcbiAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XHJcbiAgICogQHBhcmFtIHtDb25zdHJhaW50fSBjXHJcbiAgICovXG5cblxuICBhZGRDb25zdHJhaW50KGMpIHtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIGNvbnN0cmFpbnRcclxuICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcclxuICAgKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcclxuICAgKi9cblxuXG4gIHJlbW92ZUNvbnN0cmFpbnQoYykge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcblxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSYXljYXN0IHRlc3RcclxuICAgKiBAbWV0aG9kIHJheVRlc3RcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGZyb21cclxuICAgKiBAcGFyYW0ge1ZlYzN9IHRvXHJcbiAgICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgLnJheWNhc3RBbGwsIC5yYXljYXN0Q2xvc2VzdCBvciAucmF5Y2FzdEFueSBpbnN0ZWFkLlxyXG4gICAqL1xuXG5cbiAgcmF5VGVzdChmcm9tLCB0bywgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJheWNhc3RSZXN1bHQpIHtcbiAgICAgIC8vIERvIHJheWNhc3RDbG9zZXN0XG4gICAgICB0aGlzLnJheWNhc3RDbG9zZXN0KGZyb20sIHRvLCB7XG4gICAgICAgIHNraXBCYWNrZmFjZXM6IHRydWVcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvIHJheWNhc3RBbGxcbiAgICAgIHRoaXMucmF5Y2FzdEFsbChmcm9tLCB0bywge1xuICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICogQG1ldGhvZCByYXljYXN0QWxsXHJcbiAgICogQHBhcmFtICB7VmVjM30gZnJvbVxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IHRvXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxyXG4gICAqL1xuXG5cbiAgcmF5Y2FzdEFsbChmcm9tLCB0bywgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0bXBSYXkkMS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcclxuICAgKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxyXG4gICAqIEBtZXRob2QgcmF5Y2FzdEFueVxyXG4gICAqIEBwYXJhbSAge1ZlYzN9IGZyb21cclxuICAgKiBAcGFyYW0gIHtWZWMzfSB0b1xyXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxyXG4gICAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cclxuICAgKi9cblxuXG4gIHJheWNhc3RBbnkoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSwgcmVzdWx0KSB7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFOWTtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5JDEuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxyXG4gICAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcclxuICAgKiBAcGFyYW0gIHtWZWMzfSBmcm9tXHJcbiAgICogQHBhcmFtICB7VmVjM30gdG9cclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cclxuICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXHJcbiAgICovXG5cblxuICByYXljYXN0Q2xvc2VzdChmcm9tLCB0bywgb3B0aW9ucyA9IHt9LCByZXN1bHQpIHtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQ0xPU0VTVDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5JDEuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGEgcmlnaWQgYm9keSB0byB0aGUgc2ltdWxhdGlvbi5cclxuICAgKiBAbWV0aG9kIGFkZFxyXG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAqIEB0b2RvIElmIHRoZSBzaW11bGF0aW9uIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHdoeSByZWNyZXRlIGFuZCBjb3B5IGFycmF5cyBmb3IgZWFjaCBib2R5PyBBY2N1bXVsYXRlIGluIGR5bmFtaWMgYXJyYXlzIGluIHRoaXMgY2FzZS5cclxuICAgKiBAdG9kbyBBZGRpbmcgYW4gYXJyYXkgb2YgYm9kaWVzIHNob3VsZCBiZSBwb3NzaWJsZS4gVGhpcyB3b3VsZCBzYXZlIHNvbWUgbG9vcHMgdG9vXHJcbiAgICovXG5cblxuICBhZGRCb2R5KGJvZHkpIHtcbiAgICBpZiAodGhpcy5ib2RpZXMuaW5jbHVkZXMoYm9keSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBib2R5LmluZGV4ID0gdGhpcy5ib2RpZXMubGVuZ3RoO1xuICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgYm9keS53b3JsZCA9IHRoaXM7XG4gICAgYm9keS5pbml0UG9zaXRpb24uY29weShib2R5LnBvc2l0aW9uKTtcbiAgICBib2R5LmluaXRWZWxvY2l0eS5jb3B5KGJvZHkudmVsb2NpdHkpO1xuICAgIGJvZHkudGltZUxhc3RTbGVlcHkgPSB0aGlzLnRpbWU7XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEJvZHkpIHtcbiAgICAgIGJvZHkuaW5pdEFuZ3VsYXJWZWxvY2l0eS5jb3B5KGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pO1xuICAgIH1cblxuICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHModGhpcy5ib2RpZXMubGVuZ3RoKTtcbiAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmlkVG9Cb2R5TWFwW2JvZHkuaWRdID0gYm9keTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIHJpZ2lkIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi5cclxuICAgKiBAbWV0aG9kIHJlbW92ZVxyXG4gICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAqL1xuXG5cbiAgcmVtb3ZlQm9keShib2R5KSB7XG4gICAgYm9keS53b3JsZCA9IG51bGw7XG4gICAgY29uc3QgbiA9IHRoaXMuYm9kaWVzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgY29uc3QgaWR4ID0gYm9kaWVzLmluZGV4T2YoYm9keSk7XG5cbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZFxuICAgICAgLy8gUmVjb21wdXRlIGluZGV4XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm9kaWVzW2ldLmluZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTtcbiAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgZGVsZXRlIHRoaXMuaWRUb0JvZHlNYXBbYm9keS5pZF07XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldEJvZHlCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRUb0JvZHlNYXBbaWRdO1xuICB9IC8vIFRPRE8gTWFrZSBhIGZhc3RlciBtYXBcblxuXG4gIGdldFNoYXBlQnlJZChpZCkge1xuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJsID0gYm9kaWVzLmxlbmd0aDsgaSA8IGJsOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlcyA9IGJvZGllc1tpXS5zaGFwZXM7XG5cbiAgICAgIGZvciAobGV0IGogPSAwLCBzbCA9IHNoYXBlcy5sZW5ndGg7IGogPCBzbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2pdO1xuXG4gICAgICAgIGlmIChzaGFwZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkcyBhIG1hdGVyaWFsIHRvIHRoZSBXb3JsZC5cclxuICAgKiBAbWV0aG9kIGFkZE1hdGVyaWFsXHJcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gbVxyXG4gICAqIEB0b2RvIE5lY2Vzc2FyeT9cclxuICAgKi9cblxuXG4gIGFkZE1hdGVyaWFsKG0pIHtcbiAgICB0aGlzLm1hdGVyaWFscy5wdXNoKG0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZFxyXG4gICAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXHJcbiAgICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtYXRcclxuICAgKi9cblxuXG4gIGFkZENvbnRhY3RNYXRlcmlhbChjbWF0KSB7XG4gICAgLy8gQWRkIGNvbnRhY3QgbWF0ZXJpYWxcbiAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMucHVzaChjbWF0KTsgLy8gQWRkIGN1cnJlbnQgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgbWF0ZXJpYWwgdGFibGVcblxuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLCBjbWF0Lm1hdGVyaWFsc1sxXS5pZCwgY21hdCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXHJcbiAgICpcclxuICAgKiBUaGVyZSBhcmUgdHdvIG1vZGVzLiBUaGUgc2ltcGxlIG1vZGUgaXMgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvbi4gSW4gdGhpcyBjYXNlIHlvdSBvbmx5IHVzZSB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZSBzZWNvbmQgY2FzZSB1c2VzIGludGVycG9sYXRpb24uIEluIHRoYXQgeW91IGFsc28gcHJvdmlkZSB0aGUgdGltZSBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgdXNlZCwgYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBmaXhlZCB0aW1lc3RlcHMgdG8gdGFrZS5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgc3RlcFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZpeGVkIHRpbWUgc3RlcCBzaXplIHRvIHVzZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWRdICAgIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXHJcbiAgICogICAgIHdvcmxkLnN0ZXAoMS82MCk7XHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxyXG4gICAqL1xuXG5cbiAgc3RlcChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCA9IDAsIG1heFN1YlN0ZXBzID0gMTApIHtcbiAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCkge1xuICAgICAgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZ1xuICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpOyAvLyBJbmNyZW1lbnQgdGltZVxuXG4gICAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcbiAgICAgIGxldCBzdWJzdGVwcyA9IDA7XG5cbiAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHtcbiAgICAgICAgLy8gRG8gZml4ZWQgc3RlcHMgdG8gY2F0Y2ggdXBcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0O1xuICAgICAgICBzdWJzdGVwcysrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ID0gdGhpcy5hY2N1bXVsYXRvciAlIGR0IC8gZHQ7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSB0aGlzLmJvZGllcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBiID0gdGhpcy5ib2RpZXNbal07XG4gICAgICAgIGIucHJldmlvdXNQb3NpdGlvbi5sZXJwKGIucG9zaXRpb24sIHQsIGIuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuICAgICAgICBiLnByZXZpb3VzUXVhdGVybmlvbi5zbGVycChiLnF1YXRlcm5pb24sIHQsIGIuaW50ZXJwb2xhdGVkUXVhdGVybmlvbik7XG4gICAgICAgIGIucHJldmlvdXNRdWF0ZXJuaW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWUgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcbiAgICB9XG4gIH1cblxuICBpbnRlcm5hbFN0ZXAoZHQpIHtcbiAgICB0aGlzLmR0ID0gZHQ7XG4gICAgY29uc3QgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzO1xuICAgIGNvbnN0IHAxID0gV29ybGRfc3RlcF9wMTtcbiAgICBjb25zdCBwMiA9IFdvcmxkX3N0ZXBfcDI7XG4gICAgY29uc3QgTiA9IHRoaXMubnVtT2JqZWN0cygpO1xuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGNvbnN0IHNvbHZlciA9IHRoaXMuc29sdmVyO1xuICAgIGNvbnN0IGdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7XG4gICAgY29uc3QgZG9Qcm9maWxpbmcgPSB0aGlzLmRvUHJvZmlsaW5nO1xuICAgIGNvbnN0IHByb2ZpbGUgPSB0aGlzLnByb2ZpbGU7XG4gICAgY29uc3QgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQztcbiAgICBsZXQgcHJvZmlsaW5nU3RhcnQgPSAtSW5maW5pdHk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IGZyaWN0aW9uRXF1YXRpb25Qb29sID0gV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbDtcbiAgICBjb25zdCBnbm9ybSA9IGdyYXZpdHkubGVuZ3RoKCk7XG4gICAgY29uc3QgZ3ggPSBncmF2aXR5Lng7XG4gICAgY29uc3QgZ3kgPSBncmF2aXR5Lnk7XG4gICAgY29uc3QgZ3ogPSBncmF2aXR5Lno7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gLy8gQWRkIGdyYXZpdHkgdG8gYWxsIG9iamVjdHNcblxuXG4gICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgaWYgKGJpLnR5cGUgPT09IERZTkFNSUMpIHtcbiAgICAgICAgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgY29uc3QgZiA9IGJpLmZvcmNlO1xuICAgICAgICBjb25zdCBtID0gYmkubWFzcztcbiAgICAgICAgZi54ICs9IG0gKiBneDtcbiAgICAgICAgZi55ICs9IG0gKiBneTtcbiAgICAgICAgZi56ICs9IG0gKiBnejtcbiAgICAgIH1cbiAgICB9IC8vIFVwZGF0ZSBzdWJzeXN0ZW1zXG5cblxuICAgIGZvciAobGV0IGkgPSAwLCBOc3Vic3lzdGVtcyA9IHRoaXMuc3Vic3lzdGVtcy5sZW5ndGg7IGkgIT09IE5zdWJzeXN0ZW1zOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic3lzdGVtc1tpXS51cGRhdGUoKTtcbiAgICB9IC8vIENvbGxpc2lvbiBkZXRlY3Rpb25cblxuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXG5cbiAgICBwMi5sZW5ndGggPSAwO1xuICAgIHRoaXMuYnJvYWRwaGFzZS5jb2xsaXNpb25QYWlycyh0aGlzLCBwMSwgcDIpO1xuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH0gLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxuXG5cbiAgICBsZXQgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSAhPT0gTmNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBjb25zdHJhaW50c1tpXTtcblxuICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IHAxLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgaWYgKGMuYm9keUEgPT09IHAxW2pdICYmIGMuYm9keUIgPT09IHAyW2pdIHx8IGMuYm9keUIgPT09IHAxW2pdICYmIGMuYm9keUEgPT09IHAyW2pdKSB7XG4gICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBwMi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCk7IC8vIEdlbmVyYXRlIGNvbnRhY3RzXG5cbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcbiAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkY29udGFjdHMgPSBXb3JsZF9zdGVwX29sZENvbnRhY3RzO1xuICAgIGNvbnN0IE5vbGRDb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE5vbGRDb250YWN0czsgaSsrKSB7XG4gICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTtcbiAgICB9XG5cbiAgICBjb250YWN0cy5sZW5ndGggPSAwOyAvLyBUcmFuc2ZlciBGcmljdGlvbkVxdWF0aW9uIGZyb20gY3VycmVudCBsaXN0IHRvIHRoZSBwb29sIGZvciByZXVzZVxuXG4gICAgY29uc3QgTm9sZEZyaWN0aW9uRXF1YXRpb25zID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpICE9PSBOb2xkRnJpY3Rpb25FcXVhdGlvbnM7IGkrKykge1xuICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhwMSwgcDIsIHRoaXMsIGNvbnRhY3RzLCBvbGRjb250YWN0cywgLy8gVG8gYmUgcmV1c2VkXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucywgZnJpY3Rpb25FcXVhdGlvblBvb2wpO1xuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxlLm5hcnJvd3BoYXNlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9IC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xuXG5cbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcbiAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfSAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKHRoaXMuZnJpY3Rpb25FcXVhdGlvbnNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGsgPSAwOyBrICE9PSBuY29udGFjdHM7IGsrKykge1xuICAgICAgLy8gQ3VycmVudCBjb250YWN0XG4gICAgICBjb25zdCBjID0gY29udGFjdHNba107IC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBpbmRlY2VzXG5cbiAgICAgIGNvbnN0IGJpID0gYy5iaTtcbiAgICAgIGNvbnN0IGJqID0gYy5iajtcbiAgICAgIGNvbnN0IHNpID0gYy5zaTtcbiAgICAgIGNvbnN0IHNqID0gYy5zajsgLy8gR2V0IGNvbGxpc2lvbiBwcm9wZXJ0aWVzXG5cbiAgICAgIGxldCBjbTtcblxuICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7XG4gICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsIGJqLm1hdGVyaWFsKSB8fCB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbSA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgIH0gLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cblxuICAgICAgbGV0IG11ID0gY20uZnJpY3Rpb247IC8vIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcbiAgICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW1cblxuICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7XG4gICAgICAgIGlmIChiaS5tYXRlcmlhbC5mcmljdGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLmZyaWN0aW9uID49IDApIHtcbiAgICAgICAgICBtdSA9IGJpLm1hdGVyaWFsLmZyaWN0aW9uICogYmoubWF0ZXJpYWwuZnJpY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwKSB7XG4gICAgICAgICAgYy5yZXN0aXR1dGlvbiA9IGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uICogYmoubWF0ZXJpYWwucmVzdGl0dXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYy5zZXRTcG9va1BhcmFtcyhcbiAgICAgIC8vICAgICAgICAgICBjbS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsXG4gICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgIC8vICAgICAgICAgICBkdFxuICAgICAgLy8gICAgICAgKTtcblxuXG4gICAgICBzb2x2ZXIuYWRkRXF1YXRpb24oYyk7IC8vIC8vIEFkZCBmcmljdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uXG4gICAgICAvLyBpZihtdSA+IDApe1xuICAgICAgLy8gXHQvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuICAgICAgLy8gXHRjb25zdCBtdWcgPSBtdSAqIGdub3JtO1xuICAgICAgLy8gXHRjb25zdCByZWR1Y2VkTWFzcyA9IChiaS5pbnZNYXNzICsgYmouaW52TWFzcyk7XG4gICAgICAvLyBcdGlmKHJlZHVjZWRNYXNzID4gMCl7XG4gICAgICAvLyBcdFx0cmVkdWNlZE1hc3MgPSAxL3JlZHVjZWRNYXNzO1xuICAgICAgLy8gXHR9XG4gICAgICAvLyBcdGNvbnN0IHBvb2wgPSBmcmljdGlvbkVxdWF0aW9uUG9vbDtcbiAgICAgIC8vIFx0Y29uc3QgYzEgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpO1xuICAgICAgLy8gXHRjb25zdCBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG4gICAgICAvLyBcdHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaChjMSwgYzIpO1xuICAgICAgLy8gXHRjMS5iaSA9IGMyLmJpID0gYmk7XG4gICAgICAvLyBcdGMxLmJqID0gYzIuYmogPSBiajtcbiAgICAgIC8vIFx0YzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XG4gICAgICAvLyBcdGMxLm1heEZvcmNlID0gYzIubWF4Rm9yY2UgPSBtdWcqcmVkdWNlZE1hc3M7XG4gICAgICAvLyBcdC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xuICAgICAgLy8gXHRjMS5yaS5jb3B5KGMucmkpO1xuICAgICAgLy8gXHRjMS5yai5jb3B5KGMucmopO1xuICAgICAgLy8gXHRjMi5yaS5jb3B5KGMucmkpO1xuICAgICAgLy8gXHRjMi5yai5jb3B5KGMucmopO1xuICAgICAgLy8gXHQvLyBDb25zdHJ1Y3QgdGFuZ2VudHNcbiAgICAgIC8vIFx0Yy5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcbiAgICAgIC8vICAgICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXG4gICAgICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTtcbiAgICAgIC8vICAgICAgICAgICBjMi5zZXRTcG9va1BhcmFtcyhjbS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLCBjbS5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiwgZHQpO1xuICAgICAgLy8gICAgICAgICAgIGMxLmVuYWJsZWQgPSBjMi5lbmFibGVkID0gYy5lbmFibGVkO1xuICAgICAgLy8gXHQvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgLy8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzEpO1xuICAgICAgLy8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzIpO1xuICAgICAgLy8gfVxuXG4gICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJiBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBiai5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDKSB7XG4gICAgICAgIGNvbnN0IHNwZWVkU3F1YXJlZEIgPSBiai52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkgKyBiai5hbmd1bGFyVmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICBjb25zdCBzcGVlZExpbWl0U3F1YXJlZEIgPSBiai5zbGVlcFNwZWVkTGltaXQgKiogMjtcblxuICAgICAgICBpZiAoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIgKiAyKSB7XG4gICAgICAgICAgYmkud2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJqLmFsbG93U2xlZXAgJiYgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmIGJqLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJiBiaS50eXBlICE9PSBCb2R5LlNUQVRJQykge1xuICAgICAgICBjb25zdCBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubGVuZ3RoU3F1YXJlZCgpICsgYmkuYW5ndWxhclZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKTtcbiAgICAgICAgY29uc3Qgc3BlZWRMaW1pdFNxdWFyZWRBID0gYmkuc2xlZXBTcGVlZExpbWl0ICoqIDI7XG5cbiAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBICogMikge1xuICAgICAgICAgIGJqLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIE5vdyB3ZSBrbm93IHRoYXQgaSBhbmQgaiBhcmUgaW4gY29udGFjdC4gU2V0IGNvbGxpc2lvbiBtYXRyaXggc3RhdGVcblxuXG4gICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTtcblxuICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7XG4gICAgICAgIC8vIEZpcnN0IGNvbnRhY3QhXG4gICAgICAgIC8vIFdlIHJldXNlIHRoZSBjb2xsaWRlRXZlbnQgb2JqZWN0LCBvdGhlcndpc2Ugd2Ugd2lsbCBlbmQgdXAgY3JlYXRpbmcgbmV3IG9iamVjdHMgZm9yIGVhY2ggbmV3IGNvbnRhY3QsIGV2ZW4gaWYgdGhlcmUncyBubyBldmVudCBsaXN0ZW5lciBhdHRhY2hlZC5cbiAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqO1xuICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gYztcbiAgICAgICAgYmkuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XG4gICAgICAgIFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50LmJvZHkgPSBiaTtcbiAgICAgICAgYmouZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIuc2V0KGJpLmlkLCBiai5pZCk7XG4gICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5zZXQoc2kuaWQsIHNqLmlkKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXRDb250YWN0RXZlbnRzKCk7XG5cbiAgICBpZiAoZG9Qcm9maWxpbmcpIHtcbiAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gLy8gV2FrZSB1cCBib2RpZXNcblxuXG4gICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgaWYgKGJpLndha2VVcEFmdGVyTmFycm93cGhhc2UpIHtcbiAgICAgICAgYmkud2FrZVVwKCk7XG4gICAgICAgIGJpLndha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCB1c2VyLWFkZGVkIGNvbnN0cmFpbnRzXG5cblxuICAgIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE5jb25zdHJhaW50czsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gY29uc3RyYWludHNbaV07XG4gICAgICBjLnVwZGF0ZSgpO1xuXG4gICAgICBmb3IgKGxldCBqID0gMCwgTmVxID0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqICE9PSBOZXE7IGorKykge1xuICAgICAgICBjb25zdCBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24oZXEpO1xuICAgICAgfVxuICAgIH0gLy8gU29sdmUgdGhlIGNvbnN0cmFpbmVkIHN5c3RlbVxuXG5cbiAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpO1xuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9IC8vIFJlbW92ZSBhbGwgY29udGFjdHMgZnJvbSBzb2x2ZXJcblxuXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpOyAvLyBBcHBseSBkYW1waW5nLCBzZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2J1bGxldC9pc3N1ZXMvZGV0YWlsP2lkPTc0IGZvciBkZXRhaWxzXG5cbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdztcblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgIGlmIChiaS50eXBlICYgRFlOQU1JQykge1xuICAgICAgICAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllc1xuICAgICAgICBjb25zdCBsZCA9IHBvdygxLjAgLSBiaS5saW5lYXJEYW1waW5nLCBkdCk7XG4gICAgICAgIGNvbnN0IHYgPSBiaS52ZWxvY2l0eTtcbiAgICAgICAgdi5zY2FsZShsZCwgdik7XG4gICAgICAgIGNvbnN0IGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChhdikge1xuICAgICAgICAgIGNvbnN0IGFkID0gcG93KDEuMCAtIGJpLmFuZ3VsYXJEYW1waW5nLCBkdCk7XG4gICAgICAgICAgYXYuc2NhbGUoYWQsIGF2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCk7IC8vIEludm9rZSBwcmUtc3RlcCBjYWxsYmFja3NcblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgY29uc3QgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgIGlmIChiaS5wcmVTdGVwKSB7XG4gICAgICAgIGJpLnByZVN0ZXAuY2FsbChiaSk7XG4gICAgICB9XG4gICAgfSAvLyBMZWFwIGZyb2dcbiAgICAvLyB2bmV3ID0gdiArIGgqZi9tXG4gICAgLy8geG5ldyA9IHggKyBoKnZuZXdcblxuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXBudW1iZXIgPSB0aGlzLnN0ZXBudW1iZXI7XG4gICAgY29uc3QgcXVhdE5vcm1hbGl6ZSA9IHN0ZXBudW1iZXIgJSAodGhpcy5xdWF0Tm9ybWFsaXplU2tpcCArIDEpID09PSAwO1xuICAgIGNvbnN0IHF1YXROb3JtYWxpemVGYXN0ID0gdGhpcy5xdWF0Tm9ybWFsaXplRmFzdDtcblxuICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgYm9kaWVzW2ldLmludGVncmF0ZShkdCwgcXVhdE5vcm1hbGl6ZSwgcXVhdE5vcm1hbGl6ZUZhc3QpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJGb3JjZXMoKTtcbiAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICBwcm9maWxlLmludGVncmF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgfSAvLyBVcGRhdGUgd29ybGQgdGltZVxuXG5cbiAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgdGhpcy5zdGVwbnVtYmVyICs9IDE7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCk7IC8vIEludm9rZSBwb3N0LXN0ZXAgY2FsbGJhY2tzXG5cbiAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgIGNvbnN0IGJpID0gYm9kaWVzW2ldO1xuICAgICAgY29uc3QgcG9zdFN0ZXAgPSBiaS5wb3N0U3RlcDtcblxuICAgICAgaWYgKHBvc3RTdGVwKSB7XG4gICAgICAgIHBvc3RTdGVwLmNhbGwoYmkpO1xuICAgICAgfVxuICAgIH0gLy8gU2xlZXBpbmcgdXBkYXRlXG5cblxuICAgIGxldCBoYXNBY3RpdmVCb2RpZXMgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuYWxsb3dTbGVlcCkge1xuICAgICAgaGFzQWN0aXZlQm9kaWVzID0gZmFsc2U7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICBjb25zdCBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgYmkuc2xlZXBUaWNrKHRoaXMudGltZSk7XG5cbiAgICAgICAgaWYgKGJpLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcpIHtcbiAgICAgICAgICBoYXNBY3RpdmVCb2RpZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5oYXNBY3RpdmVCb2RpZXMgPSBoYXNBY3RpdmVCb2RpZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0cyBhbGwgYm9keSBmb3JjZXMgaW4gdGhlIHdvcmxkIHRvIHplcm8uXHJcbiAgICogQG1ldGhvZCBjbGVhckZvcmNlc1xyXG4gICAqL1xuXG5cbiAgY2xlYXJGb3JjZXMoKSB7XG4gICAgY29uc3QgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgY29uc3QgTiA9IGJvZGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICBjb25zdCBiID0gYm9kaWVzW2ldO1xuICAgICAgY29uc3QgZm9yY2UgPSBiLmZvcmNlO1xuICAgICAgY29uc3QgdGF1ID0gYi50b3JxdWU7XG4gICAgICBiLmZvcmNlLnNldCgwLCAwLCAwKTtcbiAgICAgIGIudG9ycXVlLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxufSAvLyBUZW1wIHN0dWZmXG5cbmNvbnN0IHRtcEFBQkIxID0gbmV3IEFBQkIoKTtcbmNvbnN0IHRtcFJheSQxID0gbmV3IFJheSgpOyAvLyBwZXJmb3JtYW5jZS5ub3coKVxuXG5pZiAodHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJykge1xuICBwZXJmb3JtYW5jZSA9IHt9O1xufVxuXG5pZiAoIXBlcmZvcm1hbmNlLm5vdykge1xuICBsZXQgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcblxuICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICB9XG5cbiAgcGVyZm9ybWFuY2Uubm93ID0gKCkgPT4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbn1cbi8vIFJldXNhYmxlIGV2ZW50IG9iamVjdHMgdG8gc2F2ZSBtZW1vcnkuXG5cbmNvbnN0IFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCA9IHtcbiAgdHlwZTogJ3Bvc3RTdGVwJ1xufTsgLy8gRGlzcGF0Y2hlZCBiZWZvcmUgdGhlIHdvcmxkIHN0ZXBzIGZvcndhcmQgaW4gdGltZS5cblxuY29uc3QgV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQgPSB7XG4gIHR5cGU6ICdwcmVTdGVwJ1xufTtcbmNvbnN0IFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50ID0ge1xuICB0eXBlOiBCb2R5LkNPTExJREVfRVZFTlRfTkFNRSxcbiAgYm9keTogbnVsbCxcbiAgY29udGFjdDogbnVsbFxufTsgLy8gUG9vbHMgZm9yIHVudXNlZCBvYmplY3RzXG5cbmNvbnN0IFdvcmxkX3N0ZXBfb2xkQ29udGFjdHMgPSBbXTtcbmNvbnN0IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTsgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnNcblxuY29uc3QgV29ybGRfc3RlcF9wMSA9IFtdO1xuY29uc3QgV29ybGRfc3RlcF9wMiA9IFtdO1xuXG5Xb3JsZC5wcm90b3R5cGUuZW1pdENvbnRhY3RFdmVudHMgPSAoKCkgPT4ge1xuICBjb25zdCBhZGRpdGlvbnMgPSBbXTtcbiAgY29uc3QgcmVtb3ZhbHMgPSBbXTtcbiAgY29uc3QgYmVnaW5Db250YWN0RXZlbnQgPSB7XG4gICAgdHlwZTogJ2JlZ2luQ29udGFjdCcsXG4gICAgYm9keUE6IG51bGwsXG4gICAgYm9keUI6IG51bGxcbiAgfTtcbiAgY29uc3QgZW5kQ29udGFjdEV2ZW50ID0ge1xuICAgIHR5cGU6ICdlbmRDb250YWN0JyxcbiAgICBib2R5QTogbnVsbCxcbiAgICBib2R5QjogbnVsbFxuICB9O1xuICBjb25zdCBiZWdpblNoYXBlQ29udGFjdEV2ZW50ID0ge1xuICAgIHR5cGU6ICdiZWdpblNoYXBlQ29udGFjdCcsXG4gICAgYm9keUE6IG51bGwsXG4gICAgYm9keUI6IG51bGwsXG4gICAgc2hhcGVBOiBudWxsLFxuICAgIHNoYXBlQjogbnVsbFxuICB9O1xuICBjb25zdCBlbmRTaGFwZUNvbnRhY3RFdmVudCA9IHtcbiAgICB0eXBlOiAnZW5kU2hhcGVDb250YWN0JyxcbiAgICBib2R5QTogbnVsbCxcbiAgICBib2R5QjogbnVsbCxcbiAgICBzaGFwZUE6IG51bGwsXG4gICAgc2hhcGVCOiBudWxsXG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaGFzQmVnaW5Db250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpbkNvbnRhY3QnKTtcbiAgICBjb25zdCBoYXNFbmRDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdlbmRDb250YWN0Jyk7XG5cbiAgICBpZiAoaGFzQmVnaW5Db250YWN0IHx8IGhhc0VuZENvbnRhY3QpIHtcbiAgICAgIHRoaXMuYm9keU92ZXJsYXBLZWVwZXIuZ2V0RGlmZihhZGRpdGlvbnMsIHJlbW92YWxzKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQmVnaW5Db250YWN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFkZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgYmVnaW5Db250YWN0RXZlbnQuYm9keUEgPSB0aGlzLmdldEJvZHlCeUlkKGFkZGl0aW9uc1tpXSk7XG4gICAgICAgIGJlZ2luQ29udGFjdEV2ZW50LmJvZHlCID0gdGhpcy5nZXRCb2R5QnlJZChhZGRpdGlvbnNbaSArIDFdKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGJlZ2luQ29udGFjdEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgYmVnaW5Db250YWN0RXZlbnQuYm9keUEgPSBiZWdpbkNvbnRhY3RFdmVudC5ib2R5QiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhhc0VuZENvbnRhY3QpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcmVtb3ZhbHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGVuZENvbnRhY3RFdmVudC5ib2R5QSA9IHRoaXMuZ2V0Qm9keUJ5SWQocmVtb3ZhbHNbaV0pO1xuICAgICAgICBlbmRDb250YWN0RXZlbnQuYm9keUIgPSB0aGlzLmdldEJvZHlCeUlkKHJlbW92YWxzW2kgKyAxXSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRDb250YWN0RXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBlbmRDb250YWN0RXZlbnQuYm9keUEgPSBlbmRDb250YWN0RXZlbnQuYm9keUIgPSBudWxsO1xuICAgIH1cblxuICAgIGFkZGl0aW9ucy5sZW5ndGggPSByZW1vdmFscy5sZW5ndGggPSAwO1xuICAgIGNvbnN0IGhhc0JlZ2luU2hhcGVDb250YWN0ID0gdGhpcy5oYXNBbnlFdmVudExpc3RlbmVyKCdiZWdpblNoYXBlQ29udGFjdCcpO1xuICAgIGNvbnN0IGhhc0VuZFNoYXBlQ29udGFjdCA9IHRoaXMuaGFzQW55RXZlbnRMaXN0ZW5lcignZW5kU2hhcGVDb250YWN0Jyk7XG5cbiAgICBpZiAoaGFzQmVnaW5TaGFwZUNvbnRhY3QgfHwgaGFzRW5kU2hhcGVDb250YWN0KSB7XG4gICAgICB0aGlzLnNoYXBlT3ZlcmxhcEtlZXBlci5nZXREaWZmKGFkZGl0aW9ucywgcmVtb3ZhbHMpO1xuICAgIH1cblxuICAgIGlmIChoYXNCZWdpblNoYXBlQ29udGFjdCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhZGRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlQSA9IHRoaXMuZ2V0U2hhcGVCeUlkKGFkZGl0aW9uc1tpXSk7XG4gICAgICAgIGNvbnN0IHNoYXBlQiA9IHRoaXMuZ2V0U2hhcGVCeUlkKGFkZGl0aW9uc1tpICsgMV0pO1xuICAgICAgICBiZWdpblNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQSA9IHNoYXBlQTtcbiAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUIgPSBzaGFwZUI7XG4gICAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuYm9keUEgPSBzaGFwZUEuYm9keTtcbiAgICAgICAgYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IHNoYXBlQi5ib2R5O1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoYmVnaW5TaGFwZUNvbnRhY3RFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIGJlZ2luU2hhcGVDb250YWN0RXZlbnQuYm9keUEgPSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LmJvZHlCID0gYmVnaW5TaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBiZWdpblNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhhc0VuZFNoYXBlQ29udGFjdCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZW1vdmFscy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qgc2hhcGVBID0gdGhpcy5nZXRTaGFwZUJ5SWQocmVtb3ZhbHNbaV0pO1xuICAgICAgICBjb25zdCBzaGFwZUIgPSB0aGlzLmdldFNoYXBlQnlJZChyZW1vdmFsc1tpICsgMV0pO1xuICAgICAgICBlbmRTaGFwZUNvbnRhY3RFdmVudC5zaGFwZUEgPSBzaGFwZUE7XG4gICAgICAgIGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IHNoYXBlQjtcbiAgICAgICAgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUEgPSBzaGFwZUEuYm9keTtcbiAgICAgICAgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUIgPSBzaGFwZUIuYm9keTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVuZFNoYXBlQ29udGFjdEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgZW5kU2hhcGVDb250YWN0RXZlbnQuYm9keUEgPSBlbmRTaGFwZUNvbnRhY3RFdmVudC5ib2R5QiA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQSA9IGVuZFNoYXBlQ29udGFjdEV2ZW50LnNoYXBlQiA9IG51bGw7XG4gICAgfVxuICB9O1xufSkoKTtcblxuZXhwb3J0IHsgQUFCQiwgQXJyYXlDb2xsaXNpb25NYXRyaXgsIEJPRFlfU0xFRVBfU1RBVEVTLCBCT0RZX1RZUEVTLCBCb2R5LCBCb3gsIEJyb2FkcGhhc2UsIENPTExJU0lPTl9UWVBFUywgQ29uZVR3aXN0Q29uc3RyYWludCwgQ29uc3RyYWludCwgQ29udGFjdEVxdWF0aW9uLCBDb250YWN0TWF0ZXJpYWwsIENvbnZleFBvbHloZWRyb24sIEN5bGluZGVyLCBEaXN0YW5jZUNvbnN0cmFpbnQsIEVxdWF0aW9uLCBFdmVudFRhcmdldCwgRnJpY3Rpb25FcXVhdGlvbiwgR1NTb2x2ZXIsIEdyaWRCcm9hZHBoYXNlLCBIZWlnaHRmaWVsZCwgSGluZ2VDb25zdHJhaW50LCBKYWNvYmlhbkVsZW1lbnQsIExvY2tDb25zdHJhaW50LCBNYXQzLCBNYXRlcmlhbCwgTmFpdmVCcm9hZHBoYXNlLCBOYXJyb3dwaGFzZSwgT2JqZWN0Q29sbGlzaW9uTWF0cml4LCBQYXJ0aWNsZSwgUGxhbmUsIFBvaW50VG9Qb2ludENvbnN0cmFpbnQsIFBvb2wsIFF1YXRlcm5pb24sIFJBWV9NT0RFUywgUmF5LCBSYXljYXN0UmVzdWx0LCBSYXljYXN0VmVoaWNsZSwgUmlnaWRWZWhpY2xlLCBSb3RhdGlvbmFsRXF1YXRpb24sIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLCBTQVBCcm9hZHBoYXNlLCBTSEFQRV9UWVBFUywgU1BIU3lzdGVtLCBTaGFwZSwgU29sdmVyLCBTcGhlcmUsIFNwbGl0U29sdmVyLCBTcHJpbmcsIFRyYW5zZm9ybSwgVHJpbWVzaCwgVmVjMywgVmVjM1Bvb2wsIFdvcmxkIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBBbW1vICovXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcblxuZXhwb3J0IGNvbnN0IFRZUEUgPSB7XG4gIEJPWDogXCJib3hcIixcbiAgQ1lMSU5ERVI6IFwiY3lsaW5kZXJcIixcbiAgU1BIRVJFOiBcInNwaGVyZVwiLFxuICBDQVBTVUxFOiBcImNhcHN1bGVcIixcbiAgQ09ORTogXCJjb25lXCIsXG4gIEhVTEw6IFwiaHVsbFwiLFxuICBIQUNEOiBcImhhY2RcIiwgLy9IaWVyYXJjaGljYWwgQXBwcm94aW1hdGUgQ29udmV4IERlY29tcG9zaXRpb25cbiAgVkhBQ0Q6IFwidmhhY2RcIiwgLy9Wb2x1bWV0cmljIEhpZXJhcmNoaWNhbCBBcHByb3hpbWF0ZSBDb252ZXggRGVjb21wb3NpdGlvblxuICBNRVNIOiBcIm1lc2hcIixcbiAgSEVJR0hURklFTEQ6IFwiaGVpZ2h0ZmllbGRcIlxufTtcblxuZXhwb3J0IGNvbnN0IEZJVCA9IHtcbiAgQUxMOiBcImFsbFwiLCAvL0Egc2luZ2xlIHNoYXBlIGlzIGF1dG9tYXRpY2FsbHkgc2l6ZWQgdG8gYm91bmQgYWxsIG1lc2hlcyB3aXRoaW4gdGhlIGVudGl0eS5cbiAgTUFOVUFMOiBcIm1hbnVhbFwiIC8vQSBzaW5nbGUgc2hhcGUgaXMgc2l6ZWQgbWFudWFsbHkuIFJlcXVpcmVzIGhhbGZFeHRlbnRzIG9yIHNwaGVyZVJhZGl1cy5cbn07XG5cbmV4cG9ydCBjb25zdCBIRUlHSFRGSUVMRF9EQVRBX1RZUEUgPSB7XG4gIHNob3J0OiBcInNob3J0XCIsXG4gIGZsb2F0OiBcImZsb2F0XCJcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb2xsaXNpb25TaGFwZXMgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIGluZGV4ZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlIFRZUEUuQk9YOlxuICAgICAgcmV0dXJuIFtjcmVhdGVCb3hTaGFwZSh2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zKV07XG4gICAgY2FzZSBUWVBFLkNZTElOREVSOlxuICAgICAgcmV0dXJuIFtjcmVhdGVDeWxpbmRlclNoYXBlKHZlcnRpY2VzLCBtYXRyaWNlcywgbWF0cml4V29ybGQsIG9wdGlvbnMpXTtcbiAgICBjYXNlIFRZUEUuQ0FQU1VMRTpcbiAgICAgIHJldHVybiBbY3JlYXRlQ2Fwc3VsZVNoYXBlKHZlcnRpY2VzLCBtYXRyaWNlcywgbWF0cml4V29ybGQsIG9wdGlvbnMpXTtcbiAgICBjYXNlIFRZUEUuQ09ORTpcbiAgICAgIHJldHVybiBbY3JlYXRlQ29uZVNoYXBlKHZlcnRpY2VzLCBtYXRyaWNlcywgbWF0cml4V29ybGQsIG9wdGlvbnMpXTtcbiAgICBjYXNlIFRZUEUuU1BIRVJFOlxuICAgICAgcmV0dXJuIFtjcmVhdGVTcGhlcmVTaGFwZSh2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zKV07XG4gICAgY2FzZSBUWVBFLkhVTEw6XG4gICAgICByZXR1cm4gW2NyZWF0ZUh1bGxTaGFwZSh2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zKV07XG4gICAgY2FzZSBUWVBFLkhBQ0Q6XG4gICAgICByZXR1cm4gY3JlYXRlSEFDRFNoYXBlcyh2ZXJ0aWNlcywgbWF0cmljZXMsIGluZGV4ZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zKTtcbiAgICBjYXNlIFRZUEUuVkhBQ0Q6XG4gICAgICByZXR1cm4gY3JlYXRlVkhBQ0RTaGFwZXModmVydGljZXMsIG1hdHJpY2VzLCBpbmRleGVzLCBtYXRyaXhXb3JsZCwgb3B0aW9ucyk7XG4gICAgY2FzZSBUWVBFLk1FU0g6XG4gICAgICByZXR1cm4gW2NyZWF0ZVRyaU1lc2hTaGFwZSh2ZXJ0aWNlcywgbWF0cmljZXMsIGluZGV4ZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zKV07XG4gICAgY2FzZSBUWVBFLkhFSUdIVEZJRUxEOlxuICAgICAgcmV0dXJuIFtjcmVhdGVIZWlnaHRmaWVsZFRlcnJhaW5TaGFwZShvcHRpb25zKV07XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybihvcHRpb25zLnR5cGUgKyBcIiBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLy9UT0RPOiBzdXBwb3J0IGdpbXBhY3QgKGR5bmFtaWMgdHJpbWVzaCkgYW5kIGhlaWdodG1hcFxuXG5leHBvcnQgY29uc3QgY3JlYXRlQm94U2hhcGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy50eXBlID0gVFlQRS5CT1g7XG4gIF9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmZpdCA9PT0gRklULkFMTCkge1xuICAgIG9wdGlvbnMuaGFsZkV4dGVudHMgPSBfY29tcHV0ZUhhbGZFeHRlbnRzKFxuICAgICAgX2NvbXB1dGVCb3VuZHModmVydGljZXMsIG1hdHJpY2VzKSxcbiAgICAgIG9wdGlvbnMubWluSGFsZkV4dGVudCxcbiAgICAgIG9wdGlvbnMubWF4SGFsZkV4dGVudFxuICAgICk7XG4gIH1cblxuICBjb25zdCBidEhhbGZFeHRlbnRzID0gbmV3IEFtbW8uYnRWZWN0b3IzKG9wdGlvbnMuaGFsZkV4dGVudHMueCwgb3B0aW9ucy5oYWxmRXh0ZW50cy55LCBvcHRpb25zLmhhbGZFeHRlbnRzLnopO1xuICBjb25zdCBjb2xsaXNpb25TaGFwZSA9IG5ldyBBbW1vLmJ0Qm94U2hhcGUoYnRIYWxmRXh0ZW50cyk7XG4gIEFtbW8uZGVzdHJveShidEhhbGZFeHRlbnRzKTtcblxuICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoY29sbGlzaW9uU2hhcGUsIG9wdGlvbnMsIF9jb21wdXRlU2NhbGUobWF0cml4V29ybGQsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIGNvbGxpc2lvblNoYXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUN5bGluZGVyU2hhcGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy50eXBlID0gVFlQRS5DWUxJTkRFUjtcbiAgX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMuZml0ID09PSBGSVQuQUxMKSB7XG4gICAgb3B0aW9ucy5oYWxmRXh0ZW50cyA9IF9jb21wdXRlSGFsZkV4dGVudHMoXG4gICAgICBfY29tcHV0ZUJvdW5kcyh2ZXJ0aWNlcywgbWF0cmljZXMpLFxuICAgICAgb3B0aW9ucy5taW5IYWxmRXh0ZW50LFxuICAgICAgb3B0aW9ucy5tYXhIYWxmRXh0ZW50XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGJ0SGFsZkV4dGVudHMgPSBuZXcgQW1tby5idFZlY3RvcjMob3B0aW9ucy5oYWxmRXh0ZW50cy54LCBvcHRpb25zLmhhbGZFeHRlbnRzLnksIG9wdGlvbnMuaGFsZkV4dGVudHMueik7XG4gIGNvbnN0IGNvbGxpc2lvblNoYXBlID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuY3lsaW5kZXJBeGlzKSB7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gbmV3IEFtbW8uYnRDeWxpbmRlclNoYXBlKGJ0SGFsZkV4dGVudHMpO1xuICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBBbW1vLmJ0Q3lsaW5kZXJTaGFwZVgoYnRIYWxmRXh0ZW50cyk7XG4gICAgICBjYXNlIFwielwiOlxuICAgICAgICByZXR1cm4gbmV3IEFtbW8uYnRDeWxpbmRlclNoYXBlWihidEhhbGZFeHRlbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pKCk7XG4gIEFtbW8uZGVzdHJveShidEhhbGZFeHRlbnRzKTtcblxuICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoY29sbGlzaW9uU2hhcGUsIG9wdGlvbnMsIF9jb21wdXRlU2NhbGUobWF0cml4V29ybGQsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIGNvbGxpc2lvblNoYXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNhcHN1bGVTaGFwZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXRyaWNlcywgbWF0cml4V29ybGQsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLnR5cGUgPSBUWVBFLkNBUFNVTEU7XG4gIF9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmZpdCA9PT0gRklULkFMTCkge1xuICAgIG9wdGlvbnMuaGFsZkV4dGVudHMgPSBfY29tcHV0ZUhhbGZFeHRlbnRzKFxuICAgICAgX2NvbXB1dGVCb3VuZHModmVydGljZXMsIG1hdHJpY2VzKSxcbiAgICAgIG9wdGlvbnMubWluSGFsZkV4dGVudCxcbiAgICAgIG9wdGlvbnMubWF4SGFsZkV4dGVudFxuICAgICk7XG4gIH1cblxuICBjb25zdCB7IHgsIHksIHogfSA9IG9wdGlvbnMuaGFsZkV4dGVudHM7XG4gIGNvbnN0IGNvbGxpc2lvblNoYXBlID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuY3lsaW5kZXJBeGlzKSB7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gbmV3IEFtbW8uYnRDYXBzdWxlU2hhcGUoTWF0aC5tYXgoeCwgeiksIHkgKiAyKTtcbiAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgQW1tby5idENhcHN1bGVTaGFwZVgoTWF0aC5tYXgoeSwgeiksIHggKiAyKTtcbiAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgIHJldHVybiBuZXcgQW1tby5idENhcHN1bGVTaGFwZVooTWF0aC5tYXgoeCwgeSksIHogKiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pKCk7XG5cbiAgX2ZpbmlzaENvbGxpc2lvblNoYXBlKGNvbGxpc2lvblNoYXBlLCBvcHRpb25zLCBfY29tcHV0ZVNjYWxlKG1hdHJpeFdvcmxkLCBvcHRpb25zKSk7XG4gIHJldHVybiBjb2xsaXNpb25TaGFwZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb25lU2hhcGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy50eXBlID0gVFlQRS5DT05FO1xuICBfc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5maXQgPT09IEZJVC5BTEwpIHtcbiAgICBvcHRpb25zLmhhbGZFeHRlbnRzID0gX2NvbXB1dGVIYWxmRXh0ZW50cyhcbiAgICAgIF9jb21wdXRlQm91bmRzKHZlcnRpY2VzLCBtYXRyaWNlcyksXG4gICAgICBvcHRpb25zLm1pbkhhbGZFeHRlbnQsXG4gICAgICBvcHRpb25zLm1heEhhbGZFeHRlbnRcbiAgICApO1xuICB9XG5cbiAgY29uc3QgeyB4LCB5LCB6IH0gPSBvcHRpb25zLmhhbGZFeHRlbnRzO1xuICBjb25zdCBjb2xsaXNpb25TaGFwZSA9ICgoKSA9PiB7XG4gICAgc3dpdGNoIChvcHRpb25zLmN5bGluZGVyQXhpcykge1xuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBBbW1vLmJ0Q29uZVNoYXBlKE1hdGgubWF4KHgsIHopLCB5ICogMik7XG4gICAgICBjYXNlIFwieFwiOlxuICAgICAgICByZXR1cm4gbmV3IEFtbW8uYnRDb25lU2hhcGVYKE1hdGgubWF4KHksIHopLCB4ICogMik7XG4gICAgICBjYXNlIFwielwiOlxuICAgICAgICByZXR1cm4gbmV3IEFtbW8uYnRDb25lU2hhcGVaKE1hdGgubWF4KHgsIHkpLCB6ICogMik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KSgpO1xuXG4gIF9maW5pc2hDb2xsaXNpb25TaGFwZShjb2xsaXNpb25TaGFwZSwgb3B0aW9ucywgX2NvbXB1dGVTY2FsZShtYXRyaXhXb3JsZCwgb3B0aW9ucykpO1xuICByZXR1cm4gY29sbGlzaW9uU2hhcGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3BoZXJlU2hhcGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy50eXBlID0gVFlQRS5TUEhFUkU7XG4gIF9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGxldCByYWRpdXM7XG4gIGlmIChvcHRpb25zLmZpdCA9PT0gRklULk1BTlVBTCAmJiAhaXNOYU4ob3B0aW9ucy5zcGhlcmVSYWRpdXMpKSB7XG4gICAgcmFkaXVzID0gb3B0aW9ucy5zcGhlcmVSYWRpdXM7XG4gIH0gZWxzZSB7XG4gICAgcmFkaXVzID0gX2NvbXB1dGVSYWRpdXModmVydGljZXMsIG1hdHJpY2VzLCBfY29tcHV0ZUJvdW5kcyh2ZXJ0aWNlcywgbWF0cmljZXMpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxpc2lvblNoYXBlID0gbmV3IEFtbW8uYnRTcGhlcmVTaGFwZShyYWRpdXMpO1xuICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoY29sbGlzaW9uU2hhcGUsIG9wdGlvbnMsIF9jb21wdXRlU2NhbGUobWF0cml4V29ybGQsIG9wdGlvbnMpKTtcblxuICByZXR1cm4gY29sbGlzaW9uU2hhcGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSHVsbFNoYXBlID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBjb25zdCBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBjb25zdCBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICByZXR1cm4gZnVuY3Rpb24odmVydGljZXMsIG1hdHJpY2VzLCBtYXRyaXhXb3JsZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy50eXBlID0gVFlQRS5IVUxMO1xuICAgIF9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuZml0ID09PSBGSVQuTUFOVUFMKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJjYW5ub3QgdXNlIGZpdDogbWFudWFsIHdpdGggdHlwZTogaHVsbFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGJvdW5kcyA9IF9jb21wdXRlQm91bmRzKHZlcnRpY2VzLCBtYXRyaWNlcyk7XG5cbiAgICBjb25zdCBidFZlcnRleCA9IG5ldyBBbW1vLmJ0VmVjdG9yMygpO1xuICAgIGNvbnN0IG9yaWdpbmFsSHVsbCA9IG5ldyBBbW1vLmJ0Q29udmV4SHVsbFNoYXBlKCk7XG4gICAgb3JpZ2luYWxIdWxsLnNldE1hcmdpbihvcHRpb25zLm1hcmdpbik7XG4gICAgY2VudGVyLmFkZFZlY3RvcnMoYm91bmRzLm1heCwgYm91bmRzLm1pbikubXVsdGlwbHlTY2FsYXIoMC41KTtcblxuICAgIGxldCB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmVydGV4Q291bnQgKz0gdmVydGljZXNbaV0ubGVuZ3RoIC8gMztcbiAgICB9XG5cbiAgICBjb25zdCBtYXhWZXJ0aWNlcyA9IG9wdGlvbnMuaHVsbE1heFZlcnRpY2VzIHx8IDEwMDAwMDtcbiAgICAvLyB0b2RvOiBtaWdodCB3YW50IHRvIGltcGxlbWVudCB0aGlzIGluIGEgZGV0ZXJtaW5pc3RpYyB3YXkgdGhhdCBkb2Vzbid0IGRvIE8odmVydHMpIGNhbGxzIHRvIE1hdGgucmFuZG9tXG4gICAgaWYgKHZlcnRleENvdW50ID4gbWF4VmVydGljZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihgdG9vIG1hbnkgdmVydGljZXMgZm9yIGh1bGwgc2hhcGU7IHNhbXBsaW5nIH4ke21heFZlcnRpY2VzfSBmcm9tIH4ke3ZlcnRleENvdW50fSB2ZXJ0aWNlc2ApO1xuICAgIH1cbiAgICBjb25zdCBwID0gTWF0aC5taW4oMSwgbWF4VmVydGljZXMgLyB2ZXJ0ZXhDb3VudCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gdmVydGljZXNbaV07XG4gICAgICBtYXRyaXguZnJvbUFycmF5KG1hdHJpY2VzW2ldKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICBjb25zdCBpc0xhc3RWZXJ0ZXggPSBpID09PSB2ZXJ0aWNlcy5sZW5ndGggLSAxICYmIGogPT09IGNvbXBvbmVudHMubGVuZ3RoIC0gMztcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPD0gcCB8fCBpc0xhc3RWZXJ0ZXgpIHtcbiAgICAgICAgICAvLyBhbHdheXMgaW5jbHVkZSB0aGUgbGFzdCB2ZXJ0ZXhcbiAgICAgICAgICB2ZXJ0ZXhcbiAgICAgICAgICAgIC5zZXQoY29tcG9uZW50c1tqXSwgY29tcG9uZW50c1tqICsgMV0sIGNvbXBvbmVudHNbaiArIDJdKVxuICAgICAgICAgICAgLmFwcGx5TWF0cml4NChtYXRyaXgpXG4gICAgICAgICAgICAuc3ViKGNlbnRlcik7XG4gICAgICAgICAgYnRWZXJ0ZXguc2V0VmFsdWUodmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7XG4gICAgICAgICAgb3JpZ2luYWxIdWxsLmFkZFBvaW50KGJ0VmVydGV4LCBpc0xhc3RWZXJ0ZXgpOyAvLyByZWNhbGMgQUFCQiBvbmx5IG9uIGxhc3QgZ2VvbWV0cnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb2xsaXNpb25TaGFwZSA9IG9yaWdpbmFsSHVsbDtcbiAgICBpZiAob3JpZ2luYWxIdWxsLmdldE51bVZlcnRpY2VzKCkgPj0gMTAwKSB7XG4gICAgICAvL0J1bGxldCBkb2N1bWVudGF0aW9uIHNheXMgZG9uJ3QgdXNlIGNvbnZleEh1bGxzIHdpdGggMTAwIHZlcnRzIG9yIG1vcmVcbiAgICAgIGNvbnN0IHNoYXBlSHVsbCA9IG5ldyBBbW1vLmJ0U2hhcGVIdWxsKG9yaWdpbmFsSHVsbCk7XG4gICAgICBzaGFwZUh1bGwuYnVpbGRIdWxsKG9wdGlvbnMubWFyZ2luKTtcbiAgICAgIEFtbW8uZGVzdHJveShvcmlnaW5hbEh1bGwpO1xuICAgICAgY29sbGlzaW9uU2hhcGUgPSBuZXcgQW1tby5idENvbnZleEh1bGxTaGFwZShcbiAgICAgICAgQW1tby5nZXRQb2ludGVyKHNoYXBlSHVsbC5nZXRWZXJ0ZXhQb2ludGVyKCkpLFxuICAgICAgICBzaGFwZUh1bGwubnVtVmVydGljZXMoKVxuICAgICAgKTtcbiAgICAgIEFtbW8uZGVzdHJveShzaGFwZUh1bGwpOyAvLyBidENvbnZleEh1bGxTaGFwZSBtYWtlcyBhIGNvcHlcbiAgICB9XG5cbiAgICBBbW1vLmRlc3Ryb3koYnRWZXJ0ZXgpO1xuXG4gICAgX2ZpbmlzaENvbGxpc2lvblNoYXBlKGNvbGxpc2lvblNoYXBlLCBvcHRpb25zLCBfY29tcHV0ZVNjYWxlKG1hdHJpeFdvcmxkLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIGNvbGxpc2lvblNoYXBlO1xuICB9O1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUhBQ0RTaGFwZXMgPSAoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGNvbnN0IGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGNvbnN0IG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gIHJldHVybiBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIGluZGV4ZXMsIG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLnR5cGUgPSBUWVBFLkhBQ0Q7XG4gICAgX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5maXQgPT09IEZJVC5NQU5VQUwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImNhbm5vdCB1c2UgZml0OiBtYW51YWwgd2l0aCB0eXBlOiBoYWNkXCIpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghQW1tby5oYXNPd25Qcm9wZXJ0eShcIkhBQ0RcIikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJIQUNEIHVuYXZhaWxhYmxlIGluIGluY2x1ZGVkIGJ1aWxkIG9mIEFtbW8uanMuIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhcmVhbGl0eS9hbW1vLmpzIGZvciB0aGUgbGF0ZXN0IHZlcnNpb24uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYm91bmRzID0gX2NvbXB1dGVCb3VuZHModmVydGljZXMsIG1hdHJpY2VzKTtcbiAgICBjb25zdCBzY2FsZSA9IF9jb21wdXRlU2NhbGUobWF0cml4V29ybGQsIG9wdGlvbnMpO1xuXG4gICAgbGV0IHZlcnRleENvdW50ID0gMDtcbiAgICBsZXQgdHJpQ291bnQgPSAwO1xuICAgIGNlbnRlci5hZGRWZWN0b3JzKGJvdW5kcy5tYXgsIGJvdW5kcy5taW4pLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2ZXJ0ZXhDb3VudCArPSB2ZXJ0aWNlc1tpXS5sZW5ndGggLyAzO1xuICAgICAgaWYgKGluZGV4ZXMgJiYgaW5kZXhlc1tpXSkge1xuICAgICAgICB0cmlDb3VudCArPSBpbmRleGVzW2ldLmxlbmd0aCAvIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlDb3VudCArPSB2ZXJ0aWNlc1tpXS5sZW5ndGggLyA5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhhY2QgPSBuZXcgQW1tby5IQUNEKCk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJjb21wYWNpdHlXZWlnaHRcIikpIGhhY2QuU2V0Q29tcGFjaXR5V2VpZ2h0KG9wdGlvbnMuY29tcGFjaXR5V2VpZ2h0KTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInZvbHVtZVdlaWdodFwiKSkgaGFjZC5TZXRWb2x1bWVXZWlnaHQob3B0aW9ucy52b2x1bWVXZWlnaHQpO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwibkNsdXN0ZXJzXCIpKSBoYWNkLlNldE5DbHVzdGVycyhvcHRpb25zLm5DbHVzdGVycyk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJuVmVydGljZXNQZXJDSFwiKSkgaGFjZC5TZXROVmVydGljZXNQZXJDSChvcHRpb25zLm5WZXJ0aWNlc1BlckNIKTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNvbmNhdml0eVwiKSkgaGFjZC5TZXRDb25jYXZpdHkob3B0aW9ucy5jb25jYXZpdHkpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gQW1tby5fbWFsbG9jKHZlcnRleENvdW50ICogMyAqIDgpO1xuICAgIGNvbnN0IHRyaWFuZ2xlcyA9IEFtbW8uX21hbGxvYyh0cmlDb3VudCAqIDMgKiA0KTtcbiAgICBoYWNkLlNldFBvaW50cyhwb2ludHMpO1xuICAgIGhhY2QuU2V0VHJpYW5nbGVzKHRyaWFuZ2xlcyk7XG4gICAgaGFjZC5TZXROUG9pbnRzKHZlcnRleENvdW50KTtcbiAgICBoYWNkLlNldE5UcmlhbmdsZXModHJpQ291bnQpO1xuXG4gICAgbGV0IHBwdHIgPSBwb2ludHMgLyA4LFxuICAgICAgdHB0ciA9IHRyaWFuZ2xlcyAvIDQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gdmVydGljZXNbaV07XG4gICAgICBtYXRyaXguZnJvbUFycmF5KG1hdHJpY2VzW2ldKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICB2ZWN0b3JcbiAgICAgICAgICAuc2V0KGNvbXBvbmVudHNbaiArIDBdLCBjb21wb25lbnRzW2ogKyAxXSwgY29tcG9uZW50c1tqICsgMl0pXG4gICAgICAgICAgLmFwcGx5TWF0cml4NChtYXRyaXgpXG4gICAgICAgICAgLnN1YihjZW50ZXIpO1xuICAgICAgICBBbW1vLkhFQVBGNjRbcHB0ciArIDBdID0gdmVjdG9yLng7XG4gICAgICAgIEFtbW8uSEVBUEY2NFtwcHRyICsgMV0gPSB2ZWN0b3IueTtcbiAgICAgICAgQW1tby5IRUFQRjY0W3BwdHIgKyAyXSA9IHZlY3Rvci56O1xuICAgICAgICBwcHRyICs9IDM7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhlc1tpXSkge1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gaW5kZXhlc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgQW1tby5IRUFQMzJbdHB0cl0gPSBpbmRpY2VzW2pdO1xuICAgICAgICAgIHRwdHIrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb21wb25lbnRzLmxlbmd0aCAvIDM7IGorKykge1xuICAgICAgICAgIEFtbW8uSEVBUDMyW3RwdHJdID0gajtcbiAgICAgICAgICB0cHRyKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYWNkLkNvbXB1dGUoKTtcbiAgICBBbW1vLl9mcmVlKHBvaW50cyk7XG4gICAgQW1tby5fZnJlZSh0cmlhbmdsZXMpO1xuICAgIGNvbnN0IG5DbHVzdGVycyA9IGhhY2QuR2V0TkNsdXN0ZXJzKCk7XG5cbiAgICBjb25zdCBzaGFwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5DbHVzdGVyczsgaSsrKSB7XG4gICAgICBjb25zdCBodWxsID0gbmV3IEFtbW8uYnRDb252ZXhIdWxsU2hhcGUoKTtcbiAgICAgIGh1bGwuc2V0TWFyZ2luKG9wdGlvbnMubWFyZ2luKTtcbiAgICAgIGNvbnN0IG5Qb2ludHMgPSBoYWNkLkdldE5Qb2ludHNDSChpKTtcbiAgICAgIGNvbnN0IG5UcmlhbmdsZXMgPSBoYWNkLkdldE5UcmlhbmdsZXNDSChpKTtcbiAgICAgIGNvbnN0IGh1bGxQb2ludHMgPSBBbW1vLl9tYWxsb2MoblBvaW50cyAqIDMgKiA4KTtcbiAgICAgIGNvbnN0IGh1bGxUcmlhbmdsZXMgPSBBbW1vLl9tYWxsb2MoblRyaWFuZ2xlcyAqIDMgKiA0KTtcbiAgICAgIGhhY2QuR2V0Q0goaSwgaHVsbFBvaW50cywgaHVsbFRyaWFuZ2xlcyk7XG5cbiAgICAgIGNvbnN0IHBwdHIgPSBodWxsUG9pbnRzIC8gODtcbiAgICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBuUG9pbnRzOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ0VmVydGV4ID0gbmV3IEFtbW8uYnRWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHB4ID0gQW1tby5IRUFQRjY0W3BwdHIgKyBwaSAqIDMgKyAwXTtcbiAgICAgICAgY29uc3QgcHkgPSBBbW1vLkhFQVBGNjRbcHB0ciArIHBpICogMyArIDFdO1xuICAgICAgICBjb25zdCBweiA9IEFtbW8uSEVBUEY2NFtwcHRyICsgcGkgKiAzICsgMl07XG4gICAgICAgIGJ0VmVydGV4LnNldFZhbHVlKHB4LCBweSwgcHopO1xuICAgICAgICBodWxsLmFkZFBvaW50KGJ0VmVydGV4LCBwaSA9PT0gblBvaW50cyAtIDEpO1xuICAgICAgICBBbW1vLmRlc3Ryb3koYnRWZXJ0ZXgpO1xuICAgICAgfVxuXG4gICAgICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoaHVsbCwgb3B0aW9ucywgc2NhbGUpO1xuICAgICAgc2hhcGVzLnB1c2goaHVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlcztcbiAgfTtcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVWSEFDRFNoYXBlcyA9IChmdW5jdGlvbigpIHtcbiAgY29uc3QgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgY29uc3QgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgY29uc3QgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXRyaWNlcywgaW5kZXhlcywgbWF0cml4V29ybGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMudHlwZSA9IFRZUEUuVkhBQ0Q7XG4gICAgX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5maXQgPT09IEZJVC5NQU5VQUwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImNhbm5vdCB1c2UgZml0OiBtYW51YWwgd2l0aCB0eXBlOiB2aGFjZFwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIUFtbW8uaGFzT3duUHJvcGVydHkoXCJWSEFDRFwiKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlZIQUNEIHVuYXZhaWxhYmxlIGluIGluY2x1ZGVkIGJ1aWxkIG9mIEFtbW8uanMuIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhcmVhbGl0eS9hbW1vLmpzIGZvciB0aGUgbGF0ZXN0IHZlcnNpb24uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYm91bmRzID0gX2NvbXB1dGVCb3VuZHModmVydGljZXMsIG1hdHJpY2VzKTtcbiAgICBjb25zdCBzY2FsZSA9IF9jb21wdXRlU2NhbGUobWF0cml4V29ybGQsIG9wdGlvbnMpO1xuXG4gICAgbGV0IHZlcnRleENvdW50ID0gMDtcbiAgICBsZXQgdHJpQ291bnQgPSAwO1xuICAgIGNlbnRlci5hZGRWZWN0b3JzKGJvdW5kcy5tYXgsIGJvdW5kcy5taW4pLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2ZXJ0ZXhDb3VudCArPSB2ZXJ0aWNlc1tpXS5sZW5ndGggLyAzO1xuICAgICAgaWYgKGluZGV4ZXMgJiYgaW5kZXhlc1tpXSkge1xuICAgICAgICB0cmlDb3VudCArPSBpbmRleGVzW2ldLmxlbmd0aCAvIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlDb3VudCArPSB2ZXJ0aWNlc1tpXS5sZW5ndGggLyA5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZoYWNkID0gbmV3IEFtbW8uVkhBQ0QoKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgQW1tby5QYXJhbWV0ZXJzKCk7XG4gICAgLy9odHRwczovL2ttYW1vdS5ibG9nc3BvdC5jb20vMjAxNC8xMi92LWhhY2QtMjAtcGFyYW1ldGVycy1kZXNjcmlwdGlvbi5odG1sXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJyZXNvbHV0aW9uXCIpKSBwYXJhbXMuc2V0X21fcmVzb2x1dGlvbihvcHRpb25zLnJlc29sdXRpb24pO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiZGVwdGhcIikpIHBhcmFtcy5zZXRfbV9kZXB0aChvcHRpb25zLmRlcHRoKTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNvbmNhdml0eVwiKSkgcGFyYW1zLnNldF9tX2NvbmNhdml0eShvcHRpb25zLmNvbmNhdml0eSk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJwbGFuZURvd25zYW1wbGluZ1wiKSkgcGFyYW1zLnNldF9tX3BsYW5lRG93bnNhbXBsaW5nKG9wdGlvbnMucGxhbmVEb3duc2FtcGxpbmcpO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiY29udmV4aHVsbERvd25zYW1wbGluZ1wiKSlcbiAgICAgIHBhcmFtcy5zZXRfbV9jb252ZXhodWxsRG93bnNhbXBsaW5nKG9wdGlvbnMuY29udmV4aHVsbERvd25zYW1wbGluZyk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJhbHBoYVwiKSkgcGFyYW1zLnNldF9tX2FscGhhKG9wdGlvbnMuYWxwaGEpO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiYmV0YVwiKSkgcGFyYW1zLnNldF9tX2JldGEob3B0aW9ucy5iZXRhKTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImdhbW1hXCIpKSBwYXJhbXMuc2V0X21fZ2FtbWEob3B0aW9ucy5nYW1tYSk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJwY2FcIikpIHBhcmFtcy5zZXRfbV9wY2Eob3B0aW9ucy5wY2EpO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwibW9kZVwiKSkgcGFyYW1zLnNldF9tX21vZGUob3B0aW9ucy5tb2RlKTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIm1heE51bVZlcnRpY2VzUGVyQ0hcIikpIHBhcmFtcy5zZXRfbV9tYXhOdW1WZXJ0aWNlc1BlckNIKG9wdGlvbnMubWF4TnVtVmVydGljZXNQZXJDSCk7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJtaW5Wb2x1bWVQZXJDSFwiKSkgcGFyYW1zLnNldF9tX21pblZvbHVtZVBlckNIKG9wdGlvbnMubWluVm9sdW1lUGVyQ0gpO1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwiY29udmV4aHVsbEFwcHJveGltYXRpb25cIikpXG4gICAgICBwYXJhbXMuc2V0X21fY29udmV4aHVsbEFwcHJveGltYXRpb24ob3B0aW9ucy5jb252ZXhodWxsQXBwcm94aW1hdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJvY2xBY2NlbGVyYXRpb25cIikpIHBhcmFtcy5zZXRfbV9vY2xBY2NlbGVyYXRpb24ob3B0aW9ucy5vY2xBY2NlbGVyYXRpb24pO1xuXG4gICAgY29uc3QgcG9pbnRzID0gQW1tby5fbWFsbG9jKHZlcnRleENvdW50ICogMyAqIDggKyAzKTtcbiAgICBjb25zdCB0cmlhbmdsZXMgPSBBbW1vLl9tYWxsb2ModHJpQ291bnQgKiAzICogNCk7XG5cbiAgICBsZXQgcHB0ciA9IHBvaW50cyAvIDgsXG4gICAgICB0cHRyID0gdHJpYW5nbGVzIC8gNDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgIG1hdHJpeC5mcm9tQXJyYXkobWF0cmljZXNbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb21wb25lbnRzLmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgIHZlY3RvclxuICAgICAgICAgIC5zZXQoY29tcG9uZW50c1tqICsgMF0sIGNvbXBvbmVudHNbaiArIDFdLCBjb21wb25lbnRzW2ogKyAyXSlcbiAgICAgICAgICAuYXBwbHlNYXRyaXg0KG1hdHJpeClcbiAgICAgICAgICAuc3ViKGNlbnRlcik7XG4gICAgICAgIEFtbW8uSEVBUEY2NFtwcHRyICsgMF0gPSB2ZWN0b3IueDtcbiAgICAgICAgQW1tby5IRUFQRjY0W3BwdHIgKyAxXSA9IHZlY3Rvci55O1xuICAgICAgICBBbW1vLkhFQVBGNjRbcHB0ciArIDJdID0gdmVjdG9yLno7XG4gICAgICAgIHBwdHIgKz0gMztcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleGVzW2ldKSB7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBpbmRleGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBBbW1vLkhFQVAzMlt0cHRyXSA9IGluZGljZXNbal07XG4gICAgICAgICAgdHB0cisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbXBvbmVudHMubGVuZ3RoIC8gMzsgaisrKSB7XG4gICAgICAgICAgQW1tby5IRUFQMzJbdHB0cl0gPSBqO1xuICAgICAgICAgIHRwdHIrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2aGFjZC5Db21wdXRlKHBvaW50cywgMywgdmVydGV4Q291bnQsIHRyaWFuZ2xlcywgMywgdHJpQ291bnQsIHBhcmFtcyk7XG4gICAgQW1tby5fZnJlZShwb2ludHMpO1xuICAgIEFtbW8uX2ZyZWUodHJpYW5nbGVzKTtcbiAgICBjb25zdCBuSHVsbHMgPSB2aGFjZC5HZXROQ29udmV4SHVsbHMoKTtcblxuICAgIGNvbnN0IHNoYXBlcyA9IFtdO1xuICAgIGNvbnN0IGNoID0gbmV3IEFtbW8uQ29udmV4SHVsbCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkh1bGxzOyBpKyspIHtcbiAgICAgIHZoYWNkLkdldENvbnZleEh1bGwoaSwgY2gpO1xuICAgICAgY29uc3QgblBvaW50cyA9IGNoLmdldF9tX25Qb2ludHMoKTtcbiAgICAgIGNvbnN0IGh1bGxQb2ludHMgPSBjaC5nZXRfbV9wb2ludHMoKTtcblxuICAgICAgY29uc3QgaHVsbCA9IG5ldyBBbW1vLmJ0Q29udmV4SHVsbFNoYXBlKCk7XG4gICAgICBodWxsLnNldE1hcmdpbihvcHRpb25zLm1hcmdpbik7XG5cbiAgICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBuUG9pbnRzOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ0VmVydGV4ID0gbmV3IEFtbW8uYnRWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHB4ID0gY2guZ2V0X21fcG9pbnRzKHBpICogMyArIDApO1xuICAgICAgICBjb25zdCBweSA9IGNoLmdldF9tX3BvaW50cyhwaSAqIDMgKyAxKTtcbiAgICAgICAgY29uc3QgcHogPSBjaC5nZXRfbV9wb2ludHMocGkgKiAzICsgMik7XG4gICAgICAgIGJ0VmVydGV4LnNldFZhbHVlKHB4LCBweSwgcHopO1xuICAgICAgICBodWxsLmFkZFBvaW50KGJ0VmVydGV4LCBwaSA9PT0gblBvaW50cyAtIDEpO1xuICAgICAgICBBbW1vLmRlc3Ryb3koYnRWZXJ0ZXgpO1xuICAgICAgfVxuXG4gICAgICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoaHVsbCwgb3B0aW9ucywgc2NhbGUpO1xuICAgICAgc2hhcGVzLnB1c2goaHVsbCk7XG4gICAgfVxuICAgIEFtbW8uZGVzdHJveShjaCk7XG4gICAgQW1tby5kZXN0cm95KHZoYWNkKTtcblxuICAgIHJldHVybiBzaGFwZXM7XG4gIH07XG59KSgpO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVHJpTWVzaFNoYXBlID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCB2YSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIGNvbnN0IHZiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgY29uc3QgdmMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBjb25zdCBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICByZXR1cm4gZnVuY3Rpb24odmVydGljZXMsIG1hdHJpY2VzLCBpbmRleGVzLCBtYXRyaXhXb3JsZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy50eXBlID0gVFlQRS5NRVNIO1xuICAgIF9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuZml0ID09PSBGSVQuTUFOVUFMKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJjYW5ub3QgdXNlIGZpdDogbWFudWFsIHdpdGggdHlwZTogbWVzaFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlID0gX2NvbXB1dGVTY2FsZShtYXRyaXhXb3JsZCwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBidGEgPSBuZXcgQW1tby5idFZlY3RvcjMoKTtcbiAgICBjb25zdCBidGIgPSBuZXcgQW1tby5idFZlY3RvcjMoKTtcbiAgICBjb25zdCBidGMgPSBuZXcgQW1tby5idFZlY3RvcjMoKTtcbiAgICBjb25zdCB0cmlNZXNoID0gbmV3IEFtbW8uYnRUcmlhbmdsZU1lc2godHJ1ZSwgZmFsc2UpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IHZlcnRpY2VzW2ldO1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleGVzW2ldID8gaW5kZXhlc1tpXSA6IG51bGw7XG4gICAgICBtYXRyaXguZnJvbUFycmF5KG1hdHJpY2VzW2ldKTtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4Lmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgICAgY29uc3QgYWkgPSBpbmRleFtqXSAqIDM7XG4gICAgICAgICAgY29uc3QgYmkgPSBpbmRleFtqICsgMV0gKiAzO1xuICAgICAgICAgIGNvbnN0IGNpID0gaW5kZXhbaiArIDJdICogMztcbiAgICAgICAgICB2YS5zZXQoY29tcG9uZW50c1thaV0sIGNvbXBvbmVudHNbYWkgKyAxXSwgY29tcG9uZW50c1thaSArIDJdKS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgICAgICB2Yi5zZXQoY29tcG9uZW50c1tiaV0sIGNvbXBvbmVudHNbYmkgKyAxXSwgY29tcG9uZW50c1tiaSArIDJdKS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgICAgICB2Yy5zZXQoY29tcG9uZW50c1tjaV0sIGNvbXBvbmVudHNbY2kgKyAxXSwgY29tcG9uZW50c1tjaSArIDJdKS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgICAgICBidGEuc2V0VmFsdWUodmEueCwgdmEueSwgdmEueik7XG4gICAgICAgICAgYnRiLnNldFZhbHVlKHZiLngsIHZiLnksIHZiLnopO1xuICAgICAgICAgIGJ0Yy5zZXRWYWx1ZSh2Yy54LCB2Yy55LCB2Yy56KTtcbiAgICAgICAgICB0cmlNZXNoLmFkZFRyaWFuZ2xlKGJ0YSwgYnRiLCBidGMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb21wb25lbnRzLmxlbmd0aDsgaiArPSA5KSB7XG4gICAgICAgICAgdmEuc2V0KGNvbXBvbmVudHNbaiArIDBdLCBjb21wb25lbnRzW2ogKyAxXSwgY29tcG9uZW50c1tqICsgMl0pLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgICAgIHZiLnNldChjb21wb25lbnRzW2ogKyAzXSwgY29tcG9uZW50c1tqICsgNF0sIGNvbXBvbmVudHNbaiArIDVdKS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgICAgICB2Yy5zZXQoY29tcG9uZW50c1tqICsgNl0sIGNvbXBvbmVudHNbaiArIDddLCBjb21wb25lbnRzW2ogKyA4XSkuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICAgICAgYnRhLnNldFZhbHVlKHZhLngsIHZhLnksIHZhLnopO1xuICAgICAgICAgIGJ0Yi5zZXRWYWx1ZSh2Yi54LCB2Yi55LCB2Yi56KTtcbiAgICAgICAgICBidGMuc2V0VmFsdWUodmMueCwgdmMueSwgdmMueik7XG4gICAgICAgICAgdHJpTWVzaC5hZGRUcmlhbmdsZShidGEsIGJ0YiwgYnRjLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbFNjYWxlID0gbmV3IEFtbW8uYnRWZWN0b3IzKHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnopO1xuICAgIHRyaU1lc2guc2V0U2NhbGluZyhsb2NhbFNjYWxlKTtcbiAgICBBbW1vLmRlc3Ryb3kobG9jYWxTY2FsZSk7XG5cbiAgICBjb25zdCBjb2xsaXNpb25TaGFwZSA9IG5ldyBBbW1vLmJ0QnZoVHJpYW5nbGVNZXNoU2hhcGUodHJpTWVzaCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgY29sbGlzaW9uU2hhcGUucmVzb3VyY2VzID0gW3RyaU1lc2hdO1xuXG4gICAgQW1tby5kZXN0cm95KGJ0YSk7XG4gICAgQW1tby5kZXN0cm95KGJ0Yik7XG4gICAgQW1tby5kZXN0cm95KGJ0Yyk7XG5cbiAgICBfZmluaXNoQ29sbGlzaW9uU2hhcGUoY29sbGlzaW9uU2hhcGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb2xsaXNpb25TaGFwZTtcbiAgfTtcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVIZWlnaHRmaWVsZFRlcnJhaW5TaGFwZSA9IGZ1bmN0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBfc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5maXQgPT09IEZJVC5BTEwpIHtcbiAgICBjb25zb2xlLndhcm4oXCJjYW5ub3QgdXNlIGZpdDogYWxsIHdpdGggdHlwZTogaGVpZ2h0ZmllbGRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGVpZ2h0ZmllbGREaXN0YW5jZSA9IG9wdGlvbnMuaGVpZ2h0ZmllbGREaXN0YW5jZSB8fCAxO1xuICBjb25zdCBoZWlnaHRmaWVsZERhdGEgPSBvcHRpb25zLmhlaWdodGZpZWxkRGF0YSB8fCBbXTtcbiAgY29uc3QgaGVpZ2h0U2NhbGUgPSBvcHRpb25zLmhlaWdodFNjYWxlIHx8IDA7XG4gIGNvbnN0IHVwQXhpcyA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ1cEF4aXNcIikgPyBvcHRpb25zLnVwQXhpcyA6IDE7IC8vIHggPSAwOyB5ID0gMTsgeiA9IDJcbiAgY29uc3QgaGR0ID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuaGVpZ2h0RGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgICByZXR1cm4gQW1tby5QSFlfU0hPUlQ7XG4gICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuIEFtbW8uUEhZX0ZMT0FUO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEFtbW8uUEhZX0ZMT0FUO1xuICAgIH1cbiAgfSkoKTtcbiAgY29uc3QgZmxpcFF1YWRFZGdlcyA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJmbGlwUXVhZEVkZ2VzXCIpID8gb3B0aW9ucy5mbGlwUXVhZEVkZ2VzIDogdHJ1ZTtcblxuICBjb25zdCBoZWlnaHRTdGlja0xlbmd0aCA9IGhlaWdodGZpZWxkRGF0YS5sZW5ndGg7XG4gIGNvbnN0IGhlaWdodFN0aWNrV2lkdGggPSBoZWlnaHRTdGlja0xlbmd0aCA+IDAgPyBoZWlnaHRmaWVsZERhdGFbMF0ubGVuZ3RoIDogMDtcblxuICBjb25zdCBkYXRhID0gQW1tby5fbWFsbG9jKGhlaWdodFN0aWNrTGVuZ3RoICogaGVpZ2h0U3RpY2tXaWR0aCAqIDQpO1xuICBjb25zdCBwdHIgPSBkYXRhIC8gNDtcblxuICBsZXQgbWluSGVpZ2h0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBsZXQgbWF4SGVpZ2h0ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgKGxldCBsID0gMDsgbCA8IGhlaWdodFN0aWNrTGVuZ3RoOyBsKyspIHtcbiAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGhlaWdodFN0aWNrV2lkdGg7IHcrKykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaGVpZ2h0ZmllbGREYXRhW2xdW3ddO1xuICAgICAgQW1tby5IRUFQRjMyW3B0ciArIGluZGV4XSA9IGhlaWdodDtcbiAgICAgIGluZGV4Kys7XG4gICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIGhlaWdodCk7XG4gICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29sbGlzaW9uU2hhcGUgPSBuZXcgQW1tby5idEhlaWdodGZpZWxkVGVycmFpblNoYXBlKFxuICAgIGhlaWdodFN0aWNrV2lkdGgsXG4gICAgaGVpZ2h0U3RpY2tMZW5ndGgsXG4gICAgZGF0YSxcbiAgICBoZWlnaHRTY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWF4SGVpZ2h0LFxuICAgIHVwQXhpcyxcbiAgICBoZHQsXG4gICAgZmxpcFF1YWRFZGdlc1xuICApO1xuXG4gIGNvbnN0IHNjYWxlID0gbmV3IEFtbW8uYnRWZWN0b3IzKGhlaWdodGZpZWxkRGlzdGFuY2UsIDEsIGhlaWdodGZpZWxkRGlzdGFuY2UpO1xuICBjb2xsaXNpb25TaGFwZS5zZXRMb2NhbFNjYWxpbmcoc2NhbGUpO1xuICBBbW1vLmRlc3Ryb3koc2NhbGUpO1xuXG4gIGNvbGxpc2lvblNoYXBlLmhlaWdodGZpZWxkRGF0YSA9IGRhdGE7XG5cbiAgX2ZpbmlzaENvbGxpc2lvblNoYXBlKGNvbGxpc2lvblNoYXBlLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbGxpc2lvblNoYXBlO1xufTtcblxuZnVuY3Rpb24gX3NldE9wdGlvbnMob3B0aW9ucykge1xuICBvcHRpb25zLmZpdCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJmaXRcIikgPyBvcHRpb25zLmZpdCA6IEZJVC5BTEw7XG4gIG9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCBUWVBFLkhVTEw7XG4gIG9wdGlvbnMubWluSGFsZkV4dGVudCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJtaW5IYWxmRXh0ZW50XCIpID8gb3B0aW9ucy5taW5IYWxmRXh0ZW50IDogMDtcbiAgb3B0aW9ucy5tYXhIYWxmRXh0ZW50ID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIm1heEhhbGZFeHRlbnRcIikgPyBvcHRpb25zLm1heEhhbGZFeHRlbnQgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIG9wdGlvbnMuY3lsaW5kZXJBeGlzID0gb3B0aW9ucy5jeWxpbmRlckF4aXMgfHwgXCJ5XCI7XG4gIG9wdGlvbnMubWFyZ2luID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIm1hcmdpblwiKSA/IG9wdGlvbnMubWFyZ2luIDogMC4wMTtcbiAgb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImluY2x1ZGVJbnZpc2libGVcIikgPyBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgOiBmYWxzZTtcblxuICBpZiAoIW9wdGlvbnMub2Zmc2V0KSB7XG4gICAgb3B0aW9ucy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgb3B0aW9ucy5vcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIH1cbn1cblxuY29uc3QgX2ZpbmlzaENvbGxpc2lvblNoYXBlID0gZnVuY3Rpb24oY29sbGlzaW9uU2hhcGUsIG9wdGlvbnMsIHNjYWxlKSB7XG4gIGNvbGxpc2lvblNoYXBlLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIGNvbGxpc2lvblNoYXBlLnNldE1hcmdpbihvcHRpb25zLm1hcmdpbik7XG4gIGNvbGxpc2lvblNoYXBlLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgZm9yIChsZXQgcmVzIG9mIGNvbGxpc2lvblNoYXBlLnJlc291cmNlcyB8fCBbXSkge1xuICAgICAgQW1tby5kZXN0cm95KHJlcyk7XG4gICAgfVxuICAgIGlmIChjb2xsaXNpb25TaGFwZS5oZWlnaHRmaWVsZERhdGEpIHtcbiAgICAgIEFtbW8uX2ZyZWUoY29sbGlzaW9uU2hhcGUuaGVpZ2h0ZmllbGREYXRhKTtcbiAgICB9XG4gICAgQW1tby5kZXN0cm95KGNvbGxpc2lvblNoYXBlKTtcbiAgfTtcblxuICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7XG4gIGNvbnN0IHJvdGF0aW9uID0gbmV3IEFtbW8uYnRRdWF0ZXJuaW9uKCk7XG4gIGxvY2FsVHJhbnNmb3JtLnNldElkZW50aXR5KCk7XG5cbiAgbG9jYWxUcmFuc2Zvcm0uZ2V0T3JpZ2luKCkuc2V0VmFsdWUob3B0aW9ucy5vZmZzZXQueCwgb3B0aW9ucy5vZmZzZXQueSwgb3B0aW9ucy5vZmZzZXQueik7XG4gIHJvdGF0aW9uLnNldFZhbHVlKG9wdGlvbnMub3JpZW50YXRpb24ueCwgb3B0aW9ucy5vcmllbnRhdGlvbi55LCBvcHRpb25zLm9yaWVudGF0aW9uLnosIG9wdGlvbnMub3JpZW50YXRpb24udyk7XG5cbiAgbG9jYWxUcmFuc2Zvcm0uc2V0Um90YXRpb24ocm90YXRpb24pO1xuICBBbW1vLmRlc3Ryb3kocm90YXRpb24pO1xuXG4gIGlmIChzY2FsZSkge1xuICAgIGNvbnN0IGxvY2FsU2NhbGUgPSBuZXcgQW1tby5idFZlY3RvcjMoc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueik7XG4gICAgY29sbGlzaW9uU2hhcGUuc2V0TG9jYWxTY2FsaW5nKGxvY2FsU2NhbGUpO1xuICAgIEFtbW8uZGVzdHJveShsb2NhbFNjYWxlKTtcbiAgfVxuXG4gIGNvbGxpc2lvblNoYXBlLmxvY2FsVHJhbnNmb3JtID0gbG9jYWxUcmFuc2Zvcm07XG59O1xuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUdlb21ldHJpZXMgPSAoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICByZXR1cm4gZnVuY3Rpb24ocm9vdCwgb3B0aW9ucywgY2IpIHtcbiAgICBpbnZlcnNlLmNvcHkocm9vdC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHNjYWxlLnNldEZyb21NYXRyaXhTY2FsZShyb290Lm1hdHJpeFdvcmxkKTtcbiAgICByb290LnRyYXZlcnNlKG1lc2ggPT4ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgbWVzaC5pc01lc2ggJiZcbiAgICAgICAgbWVzaC5uYW1lICE9PSBcIlNreVwiICYmXG4gICAgICAgIChvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgKG1lc2guZWwgJiYgbWVzaC5lbC5vYmplY3QzRC52aXNpYmxlKSB8fCBtZXNoLnZpc2libGUpXG4gICAgICApIHtcbiAgICAgICAgaWYgKG1lc2ggPT09IHJvb3QpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNoLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUpO1xuICAgICAgICAgIHRyYW5zZm9ybS5tdWx0aXBseU1hdHJpY2VzKGludmVyc2UsIG1lc2gubWF0cml4V29ybGQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IG1pZ2h0IHdhbnQgdG8gcmV0dXJuIG51bGwgeGZvcm0gaWYgdGhpcyBpcyB0aGUgcm9vdCBzbyB0aGF0IGNhbGxlcnMgY2FuIGF2b2lkIG11bHRpcGx5aW5nXG4gICAgICAgIC8vIHRoaW5ncyBieSB0aGUgaWRlbnRpdHkgbWF0cml4XG4gICAgICAgIGNiKFxuICAgICAgICAgIG1lc2guZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSA/IG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSA6IG1lc2guZ2VvbWV0cnkudmVydGljZXMsXG4gICAgICAgICAgdHJhbnNmb3JtLmVsZW1lbnRzLFxuICAgICAgICAgIG1lc2guZ2VvbWV0cnkuaW5kZXggPyBtZXNoLmdlb21ldHJ5LmluZGV4LmFycmF5IDogbnVsbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkoKTtcblxuY29uc3QgX2NvbXB1dGVTY2FsZSA9IChmdW5jdGlvbigpIHtcbiAgY29uc3QgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG1hdHJpeFdvcmxkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpO1xuICAgIGlmIChvcHRpb25zLmZpdCA9PT0gRklULkFMTCkge1xuICAgICAgbWF0cml4LmZyb21BcnJheShtYXRyaXhXb3JsZCk7XG4gICAgICBzY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUobWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufSkoKTtcblxuY29uc3QgX2NvbXB1dGVSYWRpdXMgPSAoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHJldHVybiBmdW5jdGlvbih2ZXJ0aWNlcywgbWF0cmljZXMsIGJvdW5kcykge1xuICAgIGxldCBtYXhSYWRpdXNTcSA9IDA7XG4gICAgbGV0IHsgeDogY3gsIHk6IGN5LCB6OiBjeiB9ID0gYm91bmRzLmdldENlbnRlcihjZW50ZXIpO1xuXG4gICAgX2l0ZXJhdGVWZXJ0aWNlcyh2ZXJ0aWNlcywgbWF0cmljZXMsIHYgPT4ge1xuICAgICAgY29uc3QgZHggPSBjeCAtIHYueDtcbiAgICAgIGNvbnN0IGR5ID0gY3kgLSB2Lnk7XG4gICAgICBjb25zdCBkeiA9IGN6IC0gdi56O1xuICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICB9KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KG1heFJhZGl1c1NxKTtcbiAgfTtcbn0pKCk7XG5cbmNvbnN0IF9jb21wdXRlSGFsZkV4dGVudHMgPSBmdW5jdGlvbihib3VuZHMsIG1pbkhhbGZFeHRlbnQsIG1heEhhbGZFeHRlbnQpIHtcbiAgY29uc3QgaGFsZkV4dGVudHMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICByZXR1cm4gaGFsZkV4dGVudHNcbiAgICAuc3ViVmVjdG9ycyhib3VuZHMubWF4LCBib3VuZHMubWluKVxuICAgIC5tdWx0aXBseVNjYWxhcigwLjUpXG4gICAgLmNsYW1wU2NhbGFyKG1pbkhhbGZFeHRlbnQsIG1heEhhbGZFeHRlbnQpO1xufTtcblxuY29uc3QgX2NvbXB1dGVMb2NhbE9mZnNldCA9IGZ1bmN0aW9uKG1hdHJpeCwgYm91bmRzLCB0YXJnZXQpIHtcbiAgdGFyZ2V0XG4gICAgLmFkZFZlY3RvcnMoYm91bmRzLm1heCwgYm91bmRzLm1pbilcbiAgICAubXVsdGlwbHlTY2FsYXIoMC41KVxuICAgIC5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8vIHJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhlIGdlb21ldHJpZXMgdW5kZXJuZWF0aCBgcm9vdGAuXG5jb25zdCBfY29tcHV0ZUJvdW5kcyA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXRyaWNlcykge1xuICBjb25zdCBib3VuZHMgPSBuZXcgVEhSRUUuQm94MygpO1xuICBsZXQgbWluWCA9ICtJbmZpbml0eTtcbiAgbGV0IG1pblkgPSArSW5maW5pdHk7XG4gIGxldCBtaW5aID0gK0luZmluaXR5O1xuICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG4gIGxldCBtYXhaID0gLUluZmluaXR5O1xuICBib3VuZHMubWluLnNldCgwLCAwLCAwKTtcbiAgYm91bmRzLm1heC5zZXQoMCwgMCwgMCk7XG5cbiAgX2l0ZXJhdGVWZXJ0aWNlcyh2ZXJ0aWNlcywgbWF0cmljZXMsIHYgPT4ge1xuICAgIGlmICh2LnggPCBtaW5YKSBtaW5YID0gdi54O1xuICAgIGlmICh2LnkgPCBtaW5ZKSBtaW5ZID0gdi55O1xuICAgIGlmICh2LnogPCBtaW5aKSBtaW5aID0gdi56O1xuICAgIGlmICh2LnggPiBtYXhYKSBtYXhYID0gdi54O1xuICAgIGlmICh2LnkgPiBtYXhZKSBtYXhZID0gdi55O1xuICAgIGlmICh2LnogPiBtYXhaKSBtYXhaID0gdi56O1xuICB9KTtcblxuICBib3VuZHMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcbiAgYm91bmRzLm1heC5zZXQobWF4WCwgbWF4WSwgbWF4Wik7XG4gIHJldHVybiBib3VuZHM7XG59O1xuXG5jb25zdCBfaXRlcmF0ZVZlcnRpY2VzID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBjb25zdCBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICByZXR1cm4gZnVuY3Rpb24odmVydGljZXMsIG1hdHJpY2VzLCBjYikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hdHJpeC5mcm9tQXJyYXkobWF0cmljZXNbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2ZXJ0aWNlc1tpXS5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICB2ZXJ0ZXguc2V0KHZlcnRpY2VzW2ldW2pdLCB2ZXJ0aWNlc1tpXVtqICsgMV0sIHZlcnRpY2VzW2ldW2ogKyAyXSkuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICAgIGNiKHZlcnRleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcbiIsImZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jIChtb2R1bGVzKSB7XG4vKioqKioqLyAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyAgICBpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyAgICAgIGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsOiBmYWxzZSxcbi8qKioqKiovICAgICAgZXhwb3J0czoge31cbi8qKioqKiovICAgIH07XG5cbi8qKioqKiovICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovICAgIG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyAgICBpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gICAgICAgIGdldDogZ2V0dGVyXG4vKioqKioqLyAgICAgIH0pO1xuLyoqKioqKi8gICAgfVxuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gICAgcmV0dXJuIGdldHRlcjtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuLyoqKioqKi8gIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuICB2YXIgZiA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gRU5UUllfTU9EVUxFKVxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGYgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG59XG5cbnZhciBtb2R1bGVOYW1lUmVxRXhwID0gJ1tcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3xcXC98QF0rJ1xudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXChcXFxccyooXFwvXFxcXCouKj9cXFxcKlxcLyk/XFxcXHMqLio/KCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykuKj9cXFxcKScgLy8gYWRkaXRpb25hbCBjaGFycyB3aGVuIG91dHB1dC5wYXRoaW5mbyBpcyB0cnVlXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI1OTM2NjEvMTMwNDQyXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cCAoc3RyKSB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiAhaXNOYU4oMSAqIG4pOyAvLyAxICogbiBjb252ZXJ0cyBpbnRlZ2VycywgaW50ZWdlcnMgYXMgc3RyaW5nIChcIjEyM1wiKSwgMWUzIGFuZCBcIjFlM1wiIHRvIGludGVnZXJzIGFuZCBzdHJpbmdzIHRvIE5hTlxufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGVEZXBlbmRlbmNpZXMgKHNvdXJjZXMsIG1vZHVsZSwgcXVldWVOYW1lKSB7XG4gIHZhciByZXR2YWwgPSB7fVxuICByZXR2YWxbcXVldWVOYW1lXSA9IFtdXG5cbiAgdmFyIGZuU3RyaW5nID0gbW9kdWxlLnRvU3RyaW5nKClcbiAgdmFyIHdyYXBwZXJTaWduYXR1cmUgPSBmblN0cmluZy5tYXRjaCgvXmZ1bmN0aW9uXFxzP1xcdypcXChcXHcrLFxccypcXHcrLFxccyooXFx3KylcXCkvKVxuICBpZiAoIXdyYXBwZXJTaWduYXR1cmUpIHJldHVybiByZXR2YWxcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV1cblxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcXFxcXG58XFxcXFcpJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHZhciBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoWzNdID09PSAnZGxsLXJlZmVyZW5jZScpIGNvbnRpbnVlXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSlcbiAgfVxuXG4gIC8vIGRsbCBkZXBzXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpKVwiXFxcXClcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XG4gICAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzFdKVxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tXG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKVxuICB9XG5cbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyAocXVldWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKVxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwXG4gIH0sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMgKHNvdXJjZXMsIG1vZHVsZUlkKSB7XG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XG4gICAgbWFpbjogW21vZHVsZUlkXVxuICB9XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfVxuICB2YXIgc2Vlbk1vZHVsZXMgPSB7XG4gICAgbWFpbjoge31cbiAgfVxuXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlTmFtZSA9IHF1ZXVlc1tpXVxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV1cbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKClcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gPSBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdIHx8IHt9XG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWVcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdID0gcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gfHwgW11cbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjaylcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKVxuICAgICAgdmFyIG5ld01vZHVsZXNLZXlzID0gT2JqZWN0LmtleXMobmV3TW9kdWxlcylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gfHwgW11cbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHNvdXJjZXMgPSB7XG4gICAgbWFpbjogX193ZWJwYWNrX21vZHVsZXNfX1xuICB9XG5cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpXG5cbiAgdmFyIHNyYyA9ICcnXG5cbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09ICdtYWluJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwXG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrK1xuICAgIH1cbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKVxuICAgIHNvdXJjZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0gPSAnKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pJ1xuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KTtcXG4nXG4gIH0pXG5cbiAgc3JjID0gc3JjICsgJ25ldyAoKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KG1vZHVsZUlkKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlcy5tYWluLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXMubWFpbltpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOydcblxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICBpZiAob3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iIH1cblxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMXG5cbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybClcbiAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybFxuXG4gIHJldHVybiB3b3JrZXJcbn1cbiIsIi8qIGdsb2JhbCBBbW1vICovXG5jb25zdCBDT05TVFJBSU5UID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKS5DT05TVFJBSU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudChcImFtbW8tY29uc3RyYWludFwiLCB7XG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIHNjaGVtYToge1xuICAgIC8vIFR5cGUgb2YgY29uc3RyYWludC5cbiAgICB0eXBlOiB7XG4gICAgICBkZWZhdWx0OiBDT05TVFJBSU5ULkxPQ0ssXG4gICAgICBvbmVPZjogW1xuICAgICAgICBDT05TVFJBSU5ULkxPQ0ssXG4gICAgICAgIENPTlNUUkFJTlQuRklYRUQsXG4gICAgICAgIENPTlNUUkFJTlQuU1BSSU5HLFxuICAgICAgICBDT05TVFJBSU5ULlNMSURFUixcbiAgICAgICAgQ09OU1RSQUlOVC5ISU5HRSxcbiAgICAgICAgQ09OU1RSQUlOVC5DT05FX1RXSVNULFxuICAgICAgICBDT05TVFJBSU5ULlBPSU5UX1RPX1BPSU5UXG4gICAgICBdXG4gICAgfSxcblxuICAgIC8vIFRhcmdldCAob3RoZXIpIGJvZHkgZm9yIHRoZSBjb25zdHJhaW50LlxuICAgIHRhcmdldDogeyB0eXBlOiBcInNlbGVjdG9yXCIgfSxcblxuICAgIC8vIE9mZnNldCBvZiB0aGUgaGluZ2Ugb3IgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5LiBVc2VkIGZvciBoaW5nZSwgY29uZVR3aXN0IHBvaW50VG9Qb2ludCBjb25zdHJhaW50cy5cbiAgICBwaXZvdDogeyB0eXBlOiBcInZlYzNcIiB9LFxuICAgIHRhcmdldFBpdm90OiB7IHR5cGU6IFwidmVjM1wiIH0sXG5cbiAgICAvLyBBbiBheGlzIHRoYXQgZWFjaCBib2R5IGNhbiByb3RhdGUgYXJvdW5kLCBkZWZpbmVkIGxvY2FsbHkgdG8gdGhhdCBib2R5LiBVc2VkIGZvciBoaW5nZSBjb25zdHJhaW50cy5cbiAgICBheGlzOiB7IHR5cGU6IFwidmVjM1wiLCBkZWZhdWx0OiB7IHg6IDAsIHk6IDAsIHo6IDEgfSB9LFxuICAgIHRhcmdldEF4aXM6IHsgdHlwZTogXCJ2ZWMzXCIsIGRlZmF1bHQ6IHsgeDogMCwgeTogMCwgejogMSB9IH0sXG5cbiAgICAvLyBkYW1waW5nICYgc3R1ZmZuZXNzIC0gdXNlZCBmb3Igc3ByaW5nIGNvbnRyYWludHMgb25seVxuICAgIGRhbXBpbmc6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogMSB9LFxuICAgIHN0aWZmbmVzczogeyB0eXBlOiBcIm51bWJlclwiLCBkZWZhdWx0OiAxMDAgfSxcbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN5c3RlbSA9IHRoaXMuZWwuc2NlbmVFbC5zeXN0ZW1zLnBoeXNpY3M7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gbnVsbDtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJhaW50KSByZXR1cm47XG5cbiAgICB0aGlzLnN5c3RlbS5yZW1vdmVDb25zdHJhaW50KHRoaXMuY29uc3RyYWludCk7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gbnVsbDtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbCxcbiAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgaWYgKCFlbC5ib2R5IHx8ICFkYXRhLnRhcmdldC5ib2R5KSB7XG4gICAgICAoZWwuYm9keSA/IGRhdGEudGFyZ2V0IDogZWwpLmFkZEV2ZW50TGlzdGVuZXIoXCJib2R5LWxvYWRlZFwiLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMsIHt9KSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3RyYWludCA9IHRoaXMuY3JlYXRlQ29uc3RyYWludCgpO1xuICAgIHRoaXMuc3lzdGVtLmFkZENvbnN0cmFpbnQodGhpcy5jb25zdHJhaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QW1tby5idFR5cGVkQ29uc3RyYWludH1cbiAgICovXG4gIGNyZWF0ZUNvbnN0cmFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb25zdHJhaW50O1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICBib2R5ID0gdGhpcy5lbC5ib2R5LFxuICAgICAgdGFyZ2V0Qm9keSA9IGRhdGEudGFyZ2V0LmJvZHk7XG5cbiAgICBjb25zdCBib2R5VHJhbnNmb3JtID0gYm9keVxuICAgICAgLmdldENlbnRlck9mTWFzc1RyYW5zZm9ybSgpXG4gICAgICAuaW52ZXJzZSgpXG4gICAgICAub3BfbXVsKHRhcmdldEJvZHkuZ2V0V29ybGRUcmFuc2Zvcm0oKSk7XG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gbmV3IEFtbW8uYnRUcmFuc2Zvcm0oKTtcbiAgICB0YXJnZXRUcmFuc2Zvcm0uc2V0SWRlbnRpdHkoKTtcblxuICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICBjYXNlIENPTlNUUkFJTlQuTE9DSzoge1xuICAgICAgICBjb25zdHJhaW50ID0gbmV3IEFtbW8uYnRHZW5lcmljNkRvZkNvbnN0cmFpbnQoYm9keSwgdGFyZ2V0Qm9keSwgYm9keVRyYW5zZm9ybSwgdGFyZ2V0VHJhbnNmb3JtLCB0cnVlKTtcbiAgICAgICAgY29uc3QgemVybyA9IG5ldyBBbW1vLmJ0VmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgLy9UT0RPOiBhbGxvdyB0aGVzZSB0byBiZSBjb25maWd1cmFibGVcbiAgICAgICAgY29uc3RyYWludC5zZXRMaW5lYXJMb3dlckxpbWl0KHplcm8pO1xuICAgICAgICBjb25zdHJhaW50LnNldExpbmVhclVwcGVyTGltaXQoemVybyk7XG4gICAgICAgIGNvbnN0cmFpbnQuc2V0QW5ndWxhckxvd2VyTGltaXQoemVybyk7XG4gICAgICAgIGNvbnN0cmFpbnQuc2V0QW5ndWxhclVwcGVyTGltaXQoemVybyk7XG4gICAgICAgIEFtbW8uZGVzdHJveSh6ZXJvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RPRE86IHRlc3QgYW5kIHZlcmlmeSBhbGwgb3RoZXIgY29uc3RyYWludCB0eXBlc1xuICAgICAgY2FzZSBDT05TVFJBSU5ULkZJWEVEOiB7XG4gICAgICAgIC8vYnRGaXhlZENvbnN0cmFpbnQgZG9lcyBub3Qgc2VlbSB0byBkZWJ1ZyByZW5kZXJcbiAgICAgICAgYm9keVRyYW5zZm9ybS5zZXRSb3RhdGlvbihib2R5LmdldFdvcmxkVHJhbnNmb3JtKCkuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHRhcmdldFRyYW5zZm9ybS5zZXRSb3RhdGlvbih0YXJnZXRCb2R5LmdldFdvcmxkVHJhbnNmb3JtKCkuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQW1tby5idEZpeGVkQ29uc3RyYWludChib2R5LCB0YXJnZXRCb2R5LCBib2R5VHJhbnNmb3JtLCB0YXJnZXRUcmFuc2Zvcm0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQ09OU1RSQUlOVC5TUFJJTkc6IHtcbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBBbW1vLmJ0R2VuZXJpYzZEb2ZTcHJpbmdDb25zdHJhaW50KGJvZHksIHRhcmdldEJvZHksIGJvZHlUcmFuc2Zvcm0sIHRhcmdldFRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVmVyeSBsaW1pdGVkIGluaXRpYWwgaW1wbGVtZW50YXRpb24gb2Ygc3ByaW5nIGNvbnN0cmFpbnQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL241cm8vYWZyYW1lLXBoeXNpY3Mtc3lzdGVtL2lzc3Vlcy8xNzFcbiAgICAgICAgZm9yICh2YXIgaSBpbiBbMCwxLDIsMyw0LDVdKSB7XG4gICAgICAgICAgY29uc3RyYWludC5lbmFibGVTcHJpbmcoMSwgdHJ1ZSlcbiAgICAgICAgICBjb25zdHJhaW50LnNldFN0aWZmbmVzcygxLCB0aGlzLmRhdGEuc3RpZmZuZXNzKVxuICAgICAgICAgIGNvbnN0cmFpbnQuc2V0RGFtcGluZygxLCB0aGlzLmRhdGEuZGFtcGluZylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cHBlciA9IG5ldyBBbW1vLmJ0VmVjdG9yMygtMSwgLTEsIC0xKTtcbiAgICAgICAgY29uc3QgbG93ZXIgPSBuZXcgQW1tby5idFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgICAgIGNvbnN0cmFpbnQuc2V0TGluZWFyVXBwZXJMaW1pdCh1cHBlcik7XG4gICAgICAgIGNvbnN0cmFpbnQuc2V0TGluZWFyTG93ZXJMaW1pdChsb3dlcilcbiAgICAgICAgQW1tby5kZXN0cm95KHVwcGVyKTtcbiAgICAgICAgQW1tby5kZXN0cm95KGxvd2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIENPTlNUUkFJTlQuU0xJREVSOiB7XG4gICAgICAgIC8vVE9ETzogc3VwcG9ydCBzZXR0aW5nIGxpbmVhciBhbmQgYW5ndWxhciBsaW1pdHNcbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBBbW1vLmJ0U2xpZGVyQ29uc3RyYWludChib2R5LCB0YXJnZXRCb2R5LCBib2R5VHJhbnNmb3JtLCB0YXJnZXRUcmFuc2Zvcm0sIHRydWUpO1xuICAgICAgICBjb25zdHJhaW50LnNldExvd2VyTGluTGltaXQoLTEpO1xuICAgICAgICBjb25zdHJhaW50LnNldFVwcGVyTGluTGltaXQoMSk7XG4gICAgICAgIC8vIGNvbnN0cmFpbnQuc2V0TG93ZXJBbmdMaW1pdCgpO1xuICAgICAgICAvLyBjb25zdHJhaW50LnNldFVwcGVyQW5nTGltaXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIENPTlNUUkFJTlQuSElOR0U6IHtcbiAgICAgICAgY29uc3QgcGl2b3QgPSBuZXcgQW1tby5idFZlY3RvcjMoZGF0YS5waXZvdC54LCBkYXRhLnBpdm90LnksIGRhdGEucGl2b3Queik7XG4gICAgICAgIGNvbnN0IHRhcmdldFBpdm90ID0gbmV3IEFtbW8uYnRWZWN0b3IzKGRhdGEudGFyZ2V0UGl2b3QueCwgZGF0YS50YXJnZXRQaXZvdC55LCBkYXRhLnRhcmdldFBpdm90LnopO1xuXG4gICAgICAgIGNvbnN0IGF4aXMgPSBuZXcgQW1tby5idFZlY3RvcjMoZGF0YS5heGlzLngsIGRhdGEuYXhpcy55LCBkYXRhLmF4aXMueik7XG4gICAgICAgIGNvbnN0IHRhcmdldEF4aXMgPSBuZXcgQW1tby5idFZlY3RvcjMoZGF0YS50YXJnZXRBeGlzLngsIGRhdGEudGFyZ2V0QXhpcy55LCBkYXRhLnRhcmdldEF4aXMueik7XG5cbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBBbW1vLmJ0SGluZ2VDb25zdHJhaW50KGJvZHksIHRhcmdldEJvZHksIHBpdm90LCB0YXJnZXRQaXZvdCwgYXhpcywgdGFyZ2V0QXhpcywgdHJ1ZSk7XG5cbiAgICAgICAgQW1tby5kZXN0cm95KHBpdm90KTtcbiAgICAgICAgQW1tby5kZXN0cm95KHRhcmdldFBpdm90KTtcbiAgICAgICAgQW1tby5kZXN0cm95KGF4aXMpO1xuICAgICAgICBBbW1vLmRlc3Ryb3kodGFyZ2V0QXhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBDT05TVFJBSU5ULkNPTkVfVFdJU1Q6IHtcbiAgICAgICAgY29uc3QgcGl2b3RUcmFuc2Zvcm0gPSBuZXcgQW1tby5idFRyYW5zZm9ybSgpO1xuICAgICAgICBwaXZvdFRyYW5zZm9ybS5zZXRJZGVudGl0eSgpO1xuICAgICAgICBwaXZvdFRyYW5zZm9ybS5nZXRPcmlnaW4oKS5zZXRWYWx1ZShkYXRhLnBpdm90LngsIGRhdGEucGl2b3QueSwgZGF0YS5waXZvdC56KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGl2b3RUcmFuc2Zvcm0gPSBuZXcgQW1tby5idFRyYW5zZm9ybSgpO1xuICAgICAgICB0YXJnZXRQaXZvdFRyYW5zZm9ybS5zZXRJZGVudGl0eSgpO1xuICAgICAgICB0YXJnZXRQaXZvdFRyYW5zZm9ybS5nZXRPcmlnaW4oKS5zZXRWYWx1ZShkYXRhLnRhcmdldFBpdm90LngsIGRhdGEudGFyZ2V0UGl2b3QueSwgZGF0YS50YXJnZXRQaXZvdC56KTtcbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBBbW1vLmJ0Q29uZVR3aXN0Q29uc3RyYWludChib2R5LCB0YXJnZXRCb2R5LCBwaXZvdFRyYW5zZm9ybSwgdGFyZ2V0UGl2b3RUcmFuc2Zvcm0pO1xuICAgICAgICBBbW1vLmRlc3Ryb3kocGl2b3RUcmFuc2Zvcm0pO1xuICAgICAgICBBbW1vLmRlc3Ryb3kodGFyZ2V0UGl2b3RUcmFuc2Zvcm0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQ09OU1RSQUlOVC5QT0lOVF9UT19QT0lOVDoge1xuICAgICAgICBjb25zdCBwaXZvdCA9IG5ldyBBbW1vLmJ0VmVjdG9yMyhkYXRhLnBpdm90LngsIGRhdGEucGl2b3QueSwgZGF0YS5waXZvdC56KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGl2b3QgPSBuZXcgQW1tby5idFZlY3RvcjMoZGF0YS50YXJnZXRQaXZvdC54LCBkYXRhLnRhcmdldFBpdm90LnksIGRhdGEudGFyZ2V0UGl2b3Queik7XG5cbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBBbW1vLmJ0UG9pbnQyUG9pbnRDb25zdHJhaW50KGJvZHksIHRhcmdldEJvZHksIHBpdm90LCB0YXJnZXRQaXZvdCk7XG5cbiAgICAgICAgQW1tby5kZXN0cm95KHBpdm90KTtcbiAgICAgICAgQW1tby5kZXN0cm95KHRhcmdldFBpdm90KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbY29uc3RyYWludF0gVW5leHBlY3RlZCB0eXBlOiBcIiArIGRhdGEudHlwZSk7XG4gICAgfVxuXG4gICAgQW1tby5kZXN0cm95KGJvZHlUcmFuc2Zvcm0pO1xuICAgIEFtbW8uZGVzdHJveSh0YXJnZXRUcmFuc2Zvcm0pO1xuXG4gICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gIH1cbn0pO1xuIiwiLyogZ2xvYmFsIEFtbW8sVEhSRUUgKi9cbmNvbnN0IEFtbW9EZWJ1Z0RyYXdlciA9IHJlcXVpcmUoXCJhbW1vLWRlYnVnLWRyYXdlclwiKTtcbmNvbnN0IHRocmVlVG9BbW1vID0gcmVxdWlyZShcInRocmVlLXRvLWFtbW9cIik7XG5jb25zdCBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpLFxuICBBQ1RJVkFUSU9OX1NUQVRFID0gQ09OU1RBTlRTLkFDVElWQVRJT05fU1RBVEUsXG4gIENPTExJU0lPTl9GTEFHID0gQ09OU1RBTlRTLkNPTExJU0lPTl9GTEFHLFxuICBTSEFQRSA9IENPTlNUQU5UUy5TSEFQRSxcbiAgVFlQRSA9IENPTlNUQU5UUy5UWVBFLFxuICBGSVQgPSBDT05TVEFOVFMuRklUO1xuXG5jb25zdCBBQ1RJVkFUSU9OX1NUQVRFUyA9IFtcbiAgQUNUSVZBVElPTl9TVEFURS5BQ1RJVkVfVEFHLFxuICBBQ1RJVkFUSU9OX1NUQVRFLklTTEFORF9TTEVFUElORyxcbiAgQUNUSVZBVElPTl9TVEFURS5XQU5UU19ERUFDVElWQVRJT04sXG4gIEFDVElWQVRJT05fU1RBVEUuRElTQUJMRV9ERUFDVElWQVRJT04sXG4gIEFDVElWQVRJT05fU1RBVEUuRElTQUJMRV9TSU1VTEFUSU9OXG5dO1xuXG5jb25zdCBSSUdJRF9CT0RZX0ZMQUdTID0ge1xuICBOT05FOiAwLFxuICBESVNBQkxFX1dPUkxEX0dSQVZJVFk6IDFcbn07XG5cbmZ1bmN0aW9uIGFsbW9zdEVxdWFsc1ZlY3RvcjMoZXBzaWxvbiwgdSwgdikge1xuICByZXR1cm4gTWF0aC5hYnModS54IC0gdi54KSA8IGVwc2lsb24gJiYgTWF0aC5hYnModS55IC0gdi55KSA8IGVwc2lsb24gJiYgTWF0aC5hYnModS56IC0gdi56KSA8IGVwc2lsb247XG59XG5cbmZ1bmN0aW9uIGFsbW9zdEVxdWFsc0J0VmVjdG9yMyhlcHNpbG9uLCB1LCB2KSB7XG4gIHJldHVybiBNYXRoLmFicyh1LngoKSAtIHYueCgpKSA8IGVwc2lsb24gJiYgTWF0aC5hYnModS55KCkgLSB2LnkoKSkgPCBlcHNpbG9uICYmIE1hdGguYWJzKHUueigpIC0gdi56KCkpIDwgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzUXVhdGVybmlvbihlcHNpbG9uLCB1LCB2KSB7XG4gIHJldHVybiAoXG4gICAgKE1hdGguYWJzKHUueCAtIHYueCkgPCBlcHNpbG9uICYmXG4gICAgICBNYXRoLmFicyh1LnkgLSB2LnkpIDwgZXBzaWxvbiAmJlxuICAgICAgTWF0aC5hYnModS56IC0gdi56KSA8IGVwc2lsb24gJiZcbiAgICAgIE1hdGguYWJzKHUudyAtIHYudykgPCBlcHNpbG9uKSB8fFxuICAgIChNYXRoLmFicyh1LnggKyB2LngpIDwgZXBzaWxvbiAmJlxuICAgICAgTWF0aC5hYnModS55ICsgdi55KSA8IGVwc2lsb24gJiZcbiAgICAgIE1hdGguYWJzKHUueiArIHYueikgPCBlcHNpbG9uICYmXG4gICAgICBNYXRoLmFicyh1LncgKyB2LncpIDwgZXBzaWxvbilcbiAgKTtcbn1cblxubGV0IEFtbW9Cb2R5ID0ge1xuICBzY2hlbWE6IHtcbiAgICBsb2FkZWRFdmVudDogeyBkZWZhdWx0OiBcIlwiIH0sXG4gICAgbWFzczogeyBkZWZhdWx0OiAxIH0sXG4gICAgZ3Jhdml0eTogeyB0eXBlOiBcInZlYzNcIiwgZGVmYXVsdDogeyB4OiB1bmRlZmluZWQsIHk6IHVuZGVmaW5lZCwgejogdW5kZWZpbmVkIH0gfSxcbiAgICBsaW5lYXJEYW1waW5nOiB7IGRlZmF1bHQ6IDAuMDEgfSxcbiAgICBhbmd1bGFyRGFtcGluZzogeyBkZWZhdWx0OiAwLjAxIH0sXG4gICAgbGluZWFyU2xlZXBpbmdUaHJlc2hvbGQ6IHsgZGVmYXVsdDogMS42IH0sXG4gICAgYW5ndWxhclNsZWVwaW5nVGhyZXNob2xkOiB7IGRlZmF1bHQ6IDIuNSB9LFxuICAgIGFuZ3VsYXJGYWN0b3I6IHsgdHlwZTogXCJ2ZWMzXCIsIGRlZmF1bHQ6IHsgeDogMSwgeTogMSwgejogMSB9IH0sXG4gICAgYWN0aXZhdGlvblN0YXRlOiB7XG4gICAgICBkZWZhdWx0OiBBQ1RJVkFUSU9OX1NUQVRFLkFDVElWRV9UQUcsXG4gICAgICBvbmVPZjogQUNUSVZBVElPTl9TVEFURVNcbiAgICB9LFxuICAgIHR5cGU6IHsgZGVmYXVsdDogXCJkeW5hbWljXCIsIG9uZU9mOiBbVFlQRS5TVEFUSUMsIFRZUEUuRFlOQU1JQywgVFlQRS5LSU5FTUFUSUNdIH0sXG4gICAgZW1pdENvbGxpc2lvbkV2ZW50czogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGRpc2FibGVDb2xsaXNpb246IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICBjb2xsaXNpb25GaWx0ZXJHcm91cDogeyBkZWZhdWx0OiAxIH0sIC8vMzItYml0IG1hc2ssXG4gICAgY29sbGlzaW9uRmlsdGVyTWFzazogeyBkZWZhdWx0OiAxIH0sIC8vMzItYml0IG1hc2tcbiAgICBzY2FsZUF1dG9VcGRhdGU6IHsgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIHJlc3RpdHV0aW9uOiB7ZGVmYXVsdDogMH0gLy8gZG9lcyBub3Qgc3VwcG9ydCB1cGRhdGVzXG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgYm9keSBjb21wb25lbnQsIGFzc2lnbmluZyBpdCB0byB0aGUgcGh5c2ljcyBzeXN0ZW0gYW5kIGJpbmRpbmcgbGlzdGVuZXJzIGZvclxuICAgKiBwYXJzaW5nIHRoZSBlbGVtZW50cyBnZW9tZXRyeS5cbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3lzdGVtID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcztcbiAgICB0aGlzLnNoYXBlQ29tcG9uZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5sb2FkZWRFdmVudCA9PT0gXCJcIikge1xuICAgICAgdGhpcy5sb2FkZWRFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICB0aGlzLmRhdGEubG9hZGVkRXZlbnQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWRlZEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zeXN0ZW0uaW5pdGlhbGl6ZWQgJiYgdGhpcy5sb2FkZWRFdmVudEZpcmVkKSB7XG4gICAgICB0aGlzLmluaXRCb2R5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZWxlbWVudCdzIGdlb21ldHJ5IGFuZCBjb21wb25lbnQgbWV0YWRhdGEgdG8gY3JlYXRlIGFuIEFtbW8gYm9keSBpbnN0YW5jZSBmb3IgdGhlXG4gICAqIGNvbXBvbmVudC5cbiAgICovXG4gIGluaXRCb2R5OiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuZWwsXG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBjb25zdCBjbGFtcCA9IChudW0sIG1pbiwgbWF4KSA9PiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heClcblxuICAgICAgdGhpcy5sb2NhbFNjYWxpbmcgPSBuZXcgQW1tby5idFZlY3RvcjMoKTtcblxuICAgICAgY29uc3Qgb2JqID0gdGhpcy5lbC5vYmplY3QzRDtcbiAgICAgIG9iai5nZXRXb3JsZFBvc2l0aW9uKHBvcyk7XG4gICAgICBvYmouZ2V0V29ybGRRdWF0ZXJuaW9uKHF1YXQpO1xuXG4gICAgICB0aGlzLnByZXZTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgdGhpcy5wcmV2TnVtQ2hpbGRTaGFwZXMgPSAwO1xuXG4gICAgICB0aGlzLm1zVHJhbnNmb3JtID0gbmV3IEFtbW8uYnRUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMubXNUcmFuc2Zvcm0uc2V0SWRlbnRpdHkoKTtcbiAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQW1tby5idFF1YXRlcm5pb24ocXVhdC54LCBxdWF0LnksIHF1YXQueiwgcXVhdC53KTtcblxuICAgICAgdGhpcy5tc1RyYW5zZm9ybS5nZXRPcmlnaW4oKS5zZXRWYWx1ZShwb3MueCwgcG9zLnksIHBvcy56KTtcbiAgICAgIHRoaXMubXNUcmFuc2Zvcm0uc2V0Um90YXRpb24odGhpcy5yb3RhdGlvbik7XG5cbiAgICAgIHRoaXMubW90aW9uU3RhdGUgPSBuZXcgQW1tby5idERlZmF1bHRNb3Rpb25TdGF0ZSh0aGlzLm1zVHJhbnNmb3JtKTtcblxuICAgICAgdGhpcy5sb2NhbEluZXJ0aWEgPSBuZXcgQW1tby5idFZlY3RvcjMoMCwgMCwgMCk7XG5cbiAgICAgIHRoaXMuY29tcG91bmRTaGFwZSA9IG5ldyBBbW1vLmJ0Q29tcG91bmRTaGFwZSh0cnVlKTtcblxuICAgICAgdGhpcy5yYkluZm8gPSBuZXcgQW1tby5idFJpZ2lkQm9keUNvbnN0cnVjdGlvbkluZm8oXG4gICAgICAgIGRhdGEubWFzcyxcbiAgICAgICAgdGhpcy5tb3Rpb25TdGF0ZSxcbiAgICAgICAgdGhpcy5jb21wb3VuZFNoYXBlLFxuICAgICAgICB0aGlzLmxvY2FsSW5lcnRpYVxuICAgICAgKTtcbiAgICAgIHRoaXMucmJJbmZvLm1fcmVzdGl0dXRpb24gPSBjbGFtcCh0aGlzLmRhdGEucmVzdGl0dXRpb24sIDAsIDEpO1xuICAgICAgdGhpcy5ib2R5ID0gbmV3IEFtbW8uYnRSaWdpZEJvZHkodGhpcy5yYkluZm8pO1xuICAgICAgdGhpcy5ib2R5LnNldEFjdGl2YXRpb25TdGF0ZShBQ1RJVkFUSU9OX1NUQVRFUy5pbmRleE9mKGRhdGEuYWN0aXZhdGlvblN0YXRlKSArIDEpO1xuICAgICAgdGhpcy5ib2R5LnNldFNsZWVwaW5nVGhyZXNob2xkcyhkYXRhLmxpbmVhclNsZWVwaW5nVGhyZXNob2xkLCBkYXRhLmFuZ3VsYXJTbGVlcGluZ1RocmVzaG9sZCk7XG5cbiAgICAgIHRoaXMuYm9keS5zZXREYW1waW5nKGRhdGEubGluZWFyRGFtcGluZywgZGF0YS5hbmd1bGFyRGFtcGluZyk7XG5cbiAgICAgIGNvbnN0IGFuZ3VsYXJGYWN0b3IgPSBuZXcgQW1tby5idFZlY3RvcjMoZGF0YS5hbmd1bGFyRmFjdG9yLngsIGRhdGEuYW5ndWxhckZhY3Rvci55LCBkYXRhLmFuZ3VsYXJGYWN0b3Iueik7XG4gICAgICB0aGlzLmJvZHkuc2V0QW5ndWxhckZhY3Rvcihhbmd1bGFyRmFjdG9yKTtcbiAgICAgIEFtbW8uZGVzdHJveShhbmd1bGFyRmFjdG9yKTtcblxuICAgICAgdGhpcy5fdXBkYXRlQm9keUdyYXZpdHkoZGF0YS5ncmF2aXR5KVxuXG4gICAgICB0aGlzLnVwZGF0ZUNvbGxpc2lvbkZsYWdzKCk7XG5cbiAgICAgIHRoaXMuZWwuYm9keSA9IHRoaXMuYm9keTtcbiAgICAgIHRoaXMuYm9keS5lbCA9IGVsO1xuXG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5lbC5lbWl0KFwiYm9keS1sb2FkZWRcIiwgeyBib2R5OiB0aGlzLmVsLmJvZHkgfSk7XG5cbiAgICAgIHRoaXMuX2FkZFRvU3lzdGVtKCk7XG4gICAgfTtcbiAgfSkoKSxcblxuICB0aWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW0uaW5pdGlhbGl6ZWQgJiYgIXRoaXMuaXNMb2FkZWQgJiYgdGhpcy5sb2FkZWRFdmVudEZpcmVkKSB7XG4gICAgICB0aGlzLmluaXRCb2R5KCk7XG4gICAgfVxuICB9LFxuXG4gIF91cGRhdGVCb2R5R3Jhdml0eShncmF2aXR5KSB7XG5cbiAgICBpZiAoZ3Jhdml0eS54ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZ3Jhdml0eS55ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZ3Jhdml0eS56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGdyYXZpdHlCdFZlYyA9IG5ldyBBbW1vLmJ0VmVjdG9yMyhncmF2aXR5LngsIGdyYXZpdHkueSwgZ3Jhdml0eS56KTtcbiAgICAgIGlmICghYWxtb3N0RXF1YWxzQnRWZWN0b3IzKDAuMDAxLCBncmF2aXR5QnRWZWMsIHRoaXMuc3lzdGVtLmRyaXZlci5waHlzaWNzV29ybGQuZ2V0R3Jhdml0eSgpKSkge1xuICAgICAgICB0aGlzLmJvZHkuc2V0RmxhZ3MoUklHSURfQk9EWV9GTEFHUy5ESVNBQkxFX1dPUkxEX0dSQVZJVFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LnNldEZsYWdzKFJJR0lEX0JPRFlfRkxBR1MuTk9ORSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuc2V0R3Jhdml0eShncmF2aXR5QnRWZWMpO1xuICAgICAgQW1tby5kZXN0cm95KGdyYXZpdHlCdFZlYyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbm8gcGVyLWJvZHkgZ3Jhdml0eSBzcGVjaWZpZWQgLSBqdXN0IHVzZSB3b3JsZCBncmF2aXR5XG4gICAgICB0aGlzLmJvZHkuc2V0RmxhZ3MoUklHSURfQk9EWV9GTEFHUy5OT05FKTtcbiAgICB9XG4gIH0sXG5cbiAgX3VwZGF0ZVNoYXBlczogKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG5lZWRzUG9seWhlZHJhbEluaXRpYWxpemF0aW9uID0gW1NIQVBFLkhVTEwsIFNIQVBFLkhBQ0QsIFNIQVBFLlZIQUNEXTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCBvYmogPSB0aGlzLmVsLm9iamVjdDNEO1xuICAgICAgaWYgKHRoaXMuZGF0YS5zY2FsZUF1dG9VcGRhdGUgJiYgdGhpcy5wcmV2U2NhbGUgJiYgIWFsbW9zdEVxdWFsc1ZlY3RvcjMoMC4wMDEsIG9iai5zY2FsZSwgdGhpcy5wcmV2U2NhbGUpKSB7XG4gICAgICAgIHRoaXMucHJldlNjYWxlLmNvcHkob2JqLnNjYWxlKTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5sb2NhbFNjYWxpbmcuc2V0VmFsdWUodGhpcy5wcmV2U2NhbGUueCwgdGhpcy5wcmV2U2NhbGUueSwgdGhpcy5wcmV2U2NhbGUueik7XG4gICAgICAgIHRoaXMuY29tcG91bmRTaGFwZS5zZXRMb2NhbFNjYWxpbmcodGhpcy5sb2NhbFNjYWxpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFwZUNvbXBvbmVudHNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuc2hhcGVDb21wb25lbnRzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNoYXBlQ29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNoYXBlQ29tcG9uZW50ID0gdGhpcy5zaGFwZUNvbXBvbmVudHNbaV07XG4gICAgICAgICAgaWYgKHNoYXBlQ29tcG9uZW50LmdldFNoYXBlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29sbGlzaW9uU2hhcGUoc2hhcGVDb21wb25lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb2xsaXNpb25TaGFwZXMgPSBzaGFwZUNvbXBvbmVudC5nZXRTaGFwZXMoKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbGxpc2lvblNoYXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uU2hhcGUgPSBjb2xsaXNpb25TaGFwZXNbal07XG4gICAgICAgICAgICBpZiAoIWNvbGxpc2lvblNoYXBlLmFkZGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG91bmRTaGFwZS5hZGRDaGlsZFNoYXBlKGNvbGxpc2lvblNoYXBlLmxvY2FsVHJhbnNmb3JtLCBjb2xsaXNpb25TaGFwZSk7XG4gICAgICAgICAgICAgIGNvbGxpc2lvblNoYXBlLmFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09IFRZUEUuRFlOQU1JQykge1xuICAgICAgICAgIHRoaXMudXBkYXRlTWFzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zeXN0ZW0uZHJpdmVyLnVwZGF0ZUJvZHkodGhpcy5ib2R5KTtcbiAgICAgIH1cblxuICAgICAgLy9jYWxsIGluaXRpYWxpemVQb2x5aGVkcmFsRmVhdHVyZXMgZm9yIGh1bGwgc2hhcGVzIGlmIGRlYnVnIGlzIHR1cm5lZCBvbiBhbmQvb3Igc2NhbGUgY2hhbmdlc1xuICAgICAgaWYgKHRoaXMuc3lzdGVtLmRlYnVnICYmICh1cGRhdGVkIHx8ICF0aGlzLnBvbHlIZWRyYWxGZWF0dXJlc0luaXRpYWxpemVkKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcGVDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY29sbGlzaW9uU2hhcGVzID0gdGhpcy5zaGFwZUNvbXBvbmVudHNbaV0uZ2V0U2hhcGVzKCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xsaXNpb25TaGFwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGVzW2pdO1xuICAgICAgICAgICAgaWYgKG5lZWRzUG9seWhlZHJhbEluaXRpYWxpemF0aW9uLmluZGV4T2YoY29sbGlzaW9uU2hhcGUudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbGxpc2lvblNoYXBlLmluaXRpYWxpemVQb2x5aGVkcmFsRmVhdHVyZXMoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9seUhlZHJhbEZlYXR1cmVzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCksXG5cbiAgX2NyZWF0ZUNvbGxpc2lvblNoYXBlOiBmdW5jdGlvbihzaGFwZUNvbXBvbmVudCkge1xuICAgIGNvbnN0IGRhdGEgPSBzaGFwZUNvbXBvbmVudC5kYXRhO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgbWF0cmljZXMgPSBbXTtcbiAgICBjb25zdCBpbmRleGVzID0gW107XG5cbiAgICBjb25zdCByb290ID0gc2hhcGVDb21wb25lbnQuZWwub2JqZWN0M0Q7XG4gICAgY29uc3QgbWF0cml4V29ybGQgPSByb290Lm1hdHJpeFdvcmxkO1xuXG4gICAgdGhyZWVUb0FtbW8uaXRlcmF0ZUdlb21ldHJpZXMocm9vdCwgZGF0YSwgKHZlcnRleEFycmF5LCBtYXRyaXhBcnJheSwgaW5kZXhBcnJheSkgPT4ge1xuICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXhBcnJheSk7XG4gICAgICBtYXRyaWNlcy5wdXNoKG1hdHJpeEFycmF5KTtcbiAgICAgIGluZGV4ZXMucHVzaChpbmRleEFycmF5KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbGxpc2lvblNoYXBlcyA9IHRocmVlVG9BbW1vLmNyZWF0ZUNvbGxpc2lvblNoYXBlcyh2ZXJ0aWNlcywgbWF0cmljZXMsIGluZGV4ZXMsIG1hdHJpeFdvcmxkLmVsZW1lbnRzLCBkYXRhKTtcbiAgICBzaGFwZUNvbXBvbmVudC5hZGRTaGFwZXMoY29sbGlzaW9uU2hhcGVzKTtcbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgY29tcG9uZW50IHdpdGggdGhlIHBoeXNpY3Mgc3lzdGVtLlxuICAgKi9cbiAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQpIHtcbiAgICAgIHRoaXMuX2FkZFRvU3lzdGVtKCk7XG4gICAgfVxuICB9LFxuXG4gIF9hZGRUb1N5c3RlbTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFkZGVkVG9TeXN0ZW0pIHtcbiAgICAgIHRoaXMuc3lzdGVtLmFkZEJvZHkodGhpcy5ib2R5LCB0aGlzLmRhdGEuY29sbGlzaW9uRmlsdGVyR3JvdXAsIHRoaXMuZGF0YS5jb2xsaXNpb25GaWx0ZXJNYXNrKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5lbWl0Q29sbGlzaW9uRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc3lzdGVtLmRyaXZlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuYm9keSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3lzdGVtLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkZWRUb1N5c3RlbSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyB0aGUgY29tcG9uZW50IHdpdGggdGhlIHBoeXNpY3Mgc3lzdGVtLlxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFkZGVkVG9TeXN0ZW0pIHtcbiAgICAgIHRoaXMuc3lzdGVtLnJlbW92ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgIHRoaXMuc3lzdGVtLnJlbW92ZUJvZHkodGhpcy5ib2R5KTtcbiAgICAgIHRoaXMuYWRkZWRUb1N5c3RlbSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmlnaWQgYm9keSBpbnN0YW5jZSwgd2hlcmUgcG9zc2libGUuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHByZXZEYXRhKSB7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQpIHtcbiAgICAgIGlmICghdGhpcy5oYXNVcGRhdGVkKSB7XG4gICAgICAgIC8vc2tpcCB0aGUgZmlyc3QgdXBkYXRlXG4gICAgICAgIHRoaXMuaGFzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICAgaWYgKHByZXZEYXRhLnR5cGUgIT09IGRhdGEudHlwZSB8fCBwcmV2RGF0YS5kaXNhYmxlQ29sbGlzaW9uICE9PSBkYXRhLmRpc2FibGVDb2xsaXNpb24pIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xsaXNpb25GbGFncygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkRhdGEuYWN0aXZhdGlvblN0YXRlICE9PSBkYXRhLmFjdGl2YXRpb25TdGF0ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZm9yY2VBY3RpdmF0aW9uU3RhdGUoQUNUSVZBVElPTl9TVEFURVMuaW5kZXhPZihkYXRhLmFjdGl2YXRpb25TdGF0ZSkgKyAxKTtcbiAgICAgICAgaWYgKGRhdGEuYWN0aXZhdGlvblN0YXRlID09PSBBQ1RJVkFUSU9OX1NUQVRFLkFDVElWRV9UQUcpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuYWN0aXZhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwcmV2RGF0YS5jb2xsaXNpb25GaWx0ZXJHcm91cCAhPT0gZGF0YS5jb2xsaXNpb25GaWx0ZXJHcm91cCB8fFxuICAgICAgICBwcmV2RGF0YS5jb2xsaXNpb25GaWx0ZXJNYXNrICE9PSBkYXRhLmNvbGxpc2lvbkZpbHRlck1hc2tcbiAgICAgICkge1xuICAgICAgICBjb25zdCBicm9hZHBoYXNlUHJveHkgPSB0aGlzLmJvZHkuZ2V0QnJvYWRwaGFzZVByb3h5KCk7XG4gICAgICAgIGJyb2FkcGhhc2VQcm94eS5zZXRfbV9jb2xsaXNpb25GaWx0ZXJHcm91cChkYXRhLmNvbGxpc2lvbkZpbHRlckdyb3VwKTtcbiAgICAgICAgYnJvYWRwaGFzZVByb3h5LnNldF9tX2NvbGxpc2lvbkZpbHRlck1hc2soZGF0YS5jb2xsaXNpb25GaWx0ZXJNYXNrKTtcbiAgICAgICAgdGhpcy5zeXN0ZW0uZHJpdmVyLmJyb2FkcGhhc2VcbiAgICAgICAgICAuZ2V0T3ZlcmxhcHBpbmdQYWlyQ2FjaGUoKVxuICAgICAgICAgIC5yZW1vdmVPdmVybGFwcGluZ1BhaXJzQ29udGFpbmluZ1Byb3h5KGJyb2FkcGhhc2VQcm94eSwgdGhpcy5zeXN0ZW0uZHJpdmVyLmRpc3BhdGNoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkRhdGEubGluZWFyRGFtcGluZyAhPSBkYXRhLmxpbmVhckRhbXBpbmcgfHwgcHJldkRhdGEuYW5ndWxhckRhbXBpbmcgIT0gZGF0YS5hbmd1bGFyRGFtcGluZykge1xuICAgICAgICB0aGlzLmJvZHkuc2V0RGFtcGluZyhkYXRhLmxpbmVhckRhbXBpbmcsIGRhdGEuYW5ndWxhckRhbXBpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFsbW9zdEVxdWFsc1ZlY3RvcjMoMC4wMDEsIHByZXZEYXRhLmdyYXZpdHksIGRhdGEuZ3Jhdml0eSkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm9keUdyYXZpdHkoZGF0YS5ncmF2aXR5KVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByZXZEYXRhLmxpbmVhclNsZWVwaW5nVGhyZXNob2xkICE9IGRhdGEubGluZWFyU2xlZXBpbmdUaHJlc2hvbGQgfHxcbiAgICAgICAgcHJldkRhdGEuYW5ndWxhclNsZWVwaW5nVGhyZXNob2xkICE9IGRhdGEuYW5ndWxhclNsZWVwaW5nVGhyZXNob2xkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5ib2R5LnNldFNsZWVwaW5nVGhyZXNob2xkcyhkYXRhLmxpbmVhclNsZWVwaW5nVGhyZXNob2xkLCBkYXRhLmFuZ3VsYXJTbGVlcGluZ1RocmVzaG9sZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWxtb3N0RXF1YWxzVmVjdG9yMygwLjAwMSwgcHJldkRhdGEuYW5ndWxhckZhY3RvciwgZGF0YS5hbmd1bGFyRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhbmd1bGFyRmFjdG9yID0gbmV3IEFtbW8uYnRWZWN0b3IzKGRhdGEuYW5ndWxhckZhY3Rvci54LCBkYXRhLmFuZ3VsYXJGYWN0b3IueSwgZGF0YS5hbmd1bGFyRmFjdG9yLnopO1xuICAgICAgICB0aGlzLmJvZHkuc2V0QW5ndWxhckZhY3Rvcihhbmd1bGFyRmFjdG9yKTtcbiAgICAgICAgQW1tby5kZXN0cm95KGFuZ3VsYXJGYWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkRhdGEucmVzdGl0dXRpb24gIT0gZGF0YS5yZXN0aXR1dGlvbiApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiYW1tby1ib2R5IHJlc3RpdHV0aW9uIGNhbm5vdCBiZSB1cGRhdGVkIGZyb20gaXRzIGluaXRpYWwgdmFsdWUuXCIpXG4gICAgICB9XG5cbiAgICAgIC8vVE9ETzogc3VwcG9ydCBkeW5hbWljIHVwZGF0ZSBmb3Igb3RoZXIgcHJvcGVydGllc1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY29tcG9uZW50IGFuZCBhbGwgcGh5c2ljcyBhbmQgc2NlbmUgc2lkZSBlZmZlY3RzLlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmlNZXNoKSBBbW1vLmRlc3Ryb3kodGhpcy50cmlNZXNoKTtcbiAgICBpZiAodGhpcy5sb2NhbFNjYWxpbmcpIEFtbW8uZGVzdHJveSh0aGlzLmxvY2FsU2NhbGluZyk7XG4gICAgaWYgKHRoaXMuY29tcG91bmRTaGFwZSkgQW1tby5kZXN0cm95KHRoaXMuY29tcG91bmRTaGFwZSk7XG4gICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgQW1tby5kZXN0cm95KHRoaXMuYm9keSk7XG4gICAgICBkZWxldGUgdGhpcy5ib2R5O1xuICAgIH1cbiAgICBBbW1vLmRlc3Ryb3kodGhpcy5yYkluZm8pO1xuICAgIEFtbW8uZGVzdHJveSh0aGlzLm1zVHJhbnNmb3JtKTtcbiAgICBBbW1vLmRlc3Ryb3kodGhpcy5tb3Rpb25TdGF0ZSk7XG4gICAgQW1tby5kZXN0cm95KHRoaXMubG9jYWxJbmVydGlhKTtcbiAgICBBbW1vLmRlc3Ryb3kodGhpcy5yb3RhdGlvbik7XG4gIH0sXG5cbiAgYmVmb3JlU3RlcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlU2hhcGVzKCk7XG4gICAgLy8gTm90ZSB0aGF0IHNpbmNlIHN0YXRpYyBvYmplY3RzIGRvbid0IG1vdmUsXG4gICAgLy8gd2UgZG9uJ3Qgc3luYyB0aGVtIHRvIHBoeXNpY3Mgb24gYSByb3V0aW5lIGJhc2lzLlxuICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gVFlQRS5LSU5FTUFUSUMpIHtcbiAgICAgIHRoaXMuc3luY1RvUGh5c2ljcygpO1xuICAgIH1cbiAgfSxcblxuICBzdGVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09IFRZUEUuRFlOQU1JQykge1xuICAgICAgdGhpcy5zeW5jRnJvbVBoeXNpY3MoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJpZ2lkIGJvZHkncyBwb3NpdGlvbiwgdmVsb2NpdHksIGFuZCByb3RhdGlvbiwgYmFzZWQgb24gdGhlIHNjZW5lLlxuICAgKi9cbiAgc3luY1RvUGh5c2ljczogKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIGNvbnN0IHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHEyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmVsLFxuICAgICAgICBwYXJlbnRFbCA9IGVsLnBhcmVudEVsLFxuICAgICAgICBib2R5ID0gdGhpcy5ib2R5O1xuXG4gICAgICBpZiAoIWJvZHkpIHJldHVybjtcblxuICAgICAgdGhpcy5tb3Rpb25TdGF0ZS5nZXRXb3JsZFRyYW5zZm9ybSh0aGlzLm1zVHJhbnNmb3JtKTtcblxuICAgICAgaWYgKHBhcmVudEVsLmlzU2NlbmUpIHtcbiAgICAgICAgdi5jb3B5KGVsLm9iamVjdDNELnBvc2l0aW9uKTtcbiAgICAgICAgcS5jb3B5KGVsLm9iamVjdDNELnF1YXRlcm5pb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwub2JqZWN0M0QuZ2V0V29ybGRQb3NpdGlvbih2KTtcbiAgICAgICAgZWwub2JqZWN0M0QuZ2V0V29ybGRRdWF0ZXJuaW9uKHEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMubXNUcmFuc2Zvcm0uZ2V0T3JpZ2luKCk7XG4gICAgICB2Mi5zZXQocG9zaXRpb24ueCgpLCBwb3NpdGlvbi55KCksIHBvc2l0aW9uLnooKSk7XG5cbiAgICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLm1zVHJhbnNmb3JtLmdldFJvdGF0aW9uKCk7XG4gICAgICBxMi5zZXQocXVhdGVybmlvbi54KCksIHF1YXRlcm5pb24ueSgpLCBxdWF0ZXJuaW9uLnooKSwgcXVhdGVybmlvbi53KCkpO1xuXG4gICAgICBpZiAoIWFsbW9zdEVxdWFsc1ZlY3RvcjMoMC4wMDEsIHYsIHYyKSB8fCAhYWxtb3N0RXF1YWxzUXVhdGVybmlvbigwLjAwMSwgcSwgcTIpKSB7XG4gICAgICAgIGlmICghdGhpcy5ib2R5LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuYWN0aXZhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tc1RyYW5zZm9ybS5nZXRPcmlnaW4oKS5zZXRWYWx1ZSh2LngsIHYueSwgdi56KTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbi5zZXRWYWx1ZShxLngsIHEueSwgcS56LCBxLncpO1xuICAgICAgICB0aGlzLm1zVHJhbnNmb3JtLnNldFJvdGF0aW9uKHRoaXMucm90YXRpb24pO1xuICAgICAgICB0aGlzLm1vdGlvblN0YXRlLnNldFdvcmxkVHJhbnNmb3JtKHRoaXMubXNUcmFuc2Zvcm0pO1xuXG4gICAgICAgIGlmICh0aGlzLmRhdGEudHlwZSA9PT0gVFlQRS5TVEFUSUMpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuc2V0Q2VudGVyT2ZNYXNzVHJhbnNmb3JtKHRoaXMubXNUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2NlbmUgb2JqZWN0J3MgcG9zaXRpb24gYW5kIHJvdGF0aW9uLCBiYXNlZCBvbiB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLlxuICAgKi9cbiAgc3luY0Zyb21QaHlzaWNzOiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksXG4gICAgICBxMiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5tb3Rpb25TdGF0ZS5nZXRXb3JsZFRyYW5zZm9ybSh0aGlzLm1zVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5tc1RyYW5zZm9ybS5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLm1zVHJhbnNmb3JtLmdldFJvdGF0aW9uKCk7XG5cbiAgICAgIGNvbnN0IGVsID0gdGhpcy5lbCxcbiAgICAgICAgYm9keSA9IHRoaXMuYm9keTtcblxuICAgICAgLy8gRm9yIHRoZSBwYXJlbnQsIHByZWZlciB0byB1c2UgdGhlIFRISFJFRS5qcyBzY2VuZSBncmFwaCBwYXJlbnQgKGlmIGl0IGNhbiBiZSBkZXRlcm1pbmVkKVxuICAgICAgLy8gYW5kIG9ubHkgdXNlIHRoZSBIVE1MIHNjZW5lIGdyYXBoIHBhcmVudCBhcyBhIGZhbGxiYWNrLlxuICAgICAgLy8gVXN1YWxseSB0aGVzZSBhcmUgdGhlIHNhbWUsIGJ1dCB0aGVyZSBhcmUgdmFyaW91cyBjYXNlcyB3aGVyZSBpdCdzIHVzZWZ1bCB0byBtb2RpZnkgdGhlIFRIUkVFLmpzXG4gICAgICAvLyBzY2VuZSBncmFwaCBzbyB0aGF0IGl0IGRldmlhdGVzIGZyb20gdGhlIEhUTUwuXG4gICAgICAvLyBJbiB0aGVzZSBjYXNlcyB0aGUgVEhSRUUuanMgc2NlbmUgZ3JhcGggc2hvdWxkIGJlIGNvbnNpZGVyZWQgdGhlIGRlZmluaXRpdmUgcmVmZXJlbmNlIGluIHRlcm1zXG4gICAgICAvLyBvZiBvYmplY3QgcG9zaXRpb25pbmcgZXRjLlxuICAgICAgLy8gRm9yIHNwZWNpZmljIGV4YW1wbGVzLCBhbmQgbW9yZSBkaXNjdXNzaW9uLCBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYy1mcmFtZS9hZnJhbWUtcGh5c2ljcy1zeXN0ZW0vcHVsbC8xI2lzc3VlY29tbWVudC0xMjY0Njg2NDMzXG4gICAgICBjb25zdCBwYXJlbnRFbCA9IGVsLm9iamVjdDNELnBhcmVudC5lbCA/IGVsLm9iamVjdDNELnBhcmVudC5lbCA6IGVsLnBhcmVudEVsO1xuXG4gICAgICBpZiAoIWJvZHkpIHJldHVybjtcbiAgICAgIGlmICghcGFyZW50RWwpIHJldHVybjtcblxuICAgICAgaWYgKHBhcmVudEVsLmlzU2NlbmUpIHtcbiAgICAgICAgZWwub2JqZWN0M0QucG9zaXRpb24uc2V0KHBvc2l0aW9uLngoKSwgcG9zaXRpb24ueSgpLCBwb3NpdGlvbi56KCkpO1xuICAgICAgICBlbC5vYmplY3QzRC5xdWF0ZXJuaW9uLnNldChxdWF0ZXJuaW9uLngoKSwgcXVhdGVybmlvbi55KCksIHF1YXRlcm5pb24ueigpLCBxdWF0ZXJuaW9uLncoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxMS5zZXQocXVhdGVybmlvbi54KCksIHF1YXRlcm5pb24ueSgpLCBxdWF0ZXJuaW9uLnooKSwgcXVhdGVybmlvbi53KCkpO1xuICAgICAgICBwYXJlbnRFbC5vYmplY3QzRC5nZXRXb3JsZFF1YXRlcm5pb24ocTIpO1xuICAgICAgICBxMS5tdWx0aXBseShxMi5pbnZlcnQoKSk7XG4gICAgICAgIGVsLm9iamVjdDNELnF1YXRlcm5pb24uY29weShxMSk7XG5cbiAgICAgICAgdi5zZXQocG9zaXRpb24ueCgpLCBwb3NpdGlvbi55KCksIHBvc2l0aW9uLnooKSk7XG4gICAgICAgIHBhcmVudEVsLm9iamVjdDNELndvcmxkVG9Mb2NhbCh2KTtcbiAgICAgICAgZWwub2JqZWN0M0QucG9zaXRpb24uY29weSh2KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpLFxuXG4gIGFkZFNoYXBlQ29tcG9uZW50OiBmdW5jdGlvbihzaGFwZUNvbXBvbmVudCkge1xuICAgIGlmIChzaGFwZUNvbXBvbmVudC5kYXRhLnR5cGUgPT09IFNIQVBFLk1FU0ggJiYgdGhpcy5kYXRhLnR5cGUgIT09IFRZUEUuU1RBVElDKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJub24tc3RhdGljIG1lc2ggY29sbGlkZXJzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZUNvbXBvbmVudHMucHVzaChzaGFwZUNvbXBvbmVudCk7XG4gICAgdGhpcy5zaGFwZUNvbXBvbmVudHNDaGFuZ2VkID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVTaGFwZUNvbXBvbmVudDogZnVuY3Rpb24oc2hhcGVDb21wb25lbnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2hhcGVDb21wb25lbnRzLmluZGV4T2Yoc2hhcGVDb21wb25lbnQpO1xuICAgIGlmICh0aGlzLmNvbXBvdW5kU2hhcGUgJiYgaW5kZXggIT09IC0xICYmIHRoaXMuYm9keSkge1xuICAgICAgY29uc3Qgc2hhcGVzID0gc2hhcGVDb21wb25lbnQuZ2V0U2hhcGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmNvbXBvdW5kU2hhcGUucmVtb3ZlQ2hpbGRTaGFwZShzaGFwZXNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zaGFwZUNvbXBvbmVudHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2hhcGVDb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZU1hc3M6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5ib2R5LmdldENvbGxpc2lvblNoYXBlKCk7XG4gICAgY29uc3QgbWFzcyA9IHRoaXMuZGF0YS50eXBlID09PSBUWVBFLkRZTkFNSUMgPyB0aGlzLmRhdGEubWFzcyA6IDA7XG4gICAgc2hhcGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIHRoaXMubG9jYWxJbmVydGlhKTtcbiAgICB0aGlzLmJvZHkuc2V0TWFzc1Byb3BzKG1hc3MsIHRoaXMubG9jYWxJbmVydGlhKTtcbiAgICB0aGlzLmJvZHkudXBkYXRlSW5lcnRpYVRlbnNvcigpO1xuICB9LFxuXG4gIHVwZGF0ZUNvbGxpc2lvbkZsYWdzOiBmdW5jdGlvbigpIHtcbiAgICBsZXQgZmxhZ3MgPSB0aGlzLmRhdGEuZGlzYWJsZUNvbGxpc2lvbiA/IDQgOiAwO1xuICAgIHN3aXRjaCAodGhpcy5kYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgVFlQRS5TVEFUSUM6XG4gICAgICAgIGZsYWdzIHw9IENPTExJU0lPTl9GTEFHLlNUQVRJQ19PQkpFQ1Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUWVBFLktJTkVNQVRJQzpcbiAgICAgICAgZmxhZ3MgfD0gQ09MTElTSU9OX0ZMQUcuS0lORU1BVElDX09CSkVDVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmJvZHkuYXBwbHlHcmF2aXR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmJvZHkuc2V0Q29sbGlzaW9uRmxhZ3MoZmxhZ3MpO1xuXG4gICAgdGhpcy51cGRhdGVNYXNzKCk7XG5cbiAgICAvLyBUT0RPOiBlbmFibGUgQ0NEIGlmIGR5bmFtaWM/XG4gICAgLy8gdGhpcy5ib2R5LnNldENjZE1vdGlvblRocmVzaG9sZCgwLjAwMSk7XG4gICAgLy8gdGhpcy5ib2R5LnNldENjZFN3ZXB0U3BoZXJlUmFkaXVzKDAuMDAxKTtcblxuICAgIHRoaXMuc3lzdGVtLmRyaXZlci51cGRhdGVCb2R5KHRoaXMuYm9keSk7XG4gIH0sXG5cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJvZHkuZ2V0TGluZWFyVmVsb2NpdHkoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZGVmaW5pdGlvbiA9IEFtbW9Cb2R5O1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KFwiYW1tby1ib2R5XCIsIEFtbW9Cb2R5KTtcbiIsInZhciBDQU5OT04gPSByZXF1aXJlKCdjYW5ub24tZXMnKTtcbmNvbnN0IHsgdGhyZWVUb0Nhbm5vbiwgU2hhcGVUeXBlIH0gPSByZXF1aXJlKCd0aHJlZS10by1jYW5ub24nKTtcbmNvbnN0IGlkZW50aXR5UXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKClcblxuZnVuY3Rpb24gbWVzaDJzaGFwZSAob2JqZWN0LCBvcHRpb25zKSB7XG5cbiAgY29uc3QgcmVzdWx0ID0gdGhyZWVUb0Nhbm5vbihvYmplY3QsIG9wdGlvbnMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5yZXF1aXJlKCcuLi8uLi8uLi9saWIvQ0FOTk9OLXNoYXBlMm1lc2gnKTtcblxudmFyIEJvZHkgPSB7XG4gIGRlcGVuZGVuY2llczogWyd2ZWxvY2l0eSddLFxuXG4gIHNjaGVtYToge1xuICAgIG1hc3M6IHtkZWZhdWx0OiA1LCBpZjoge3R5cGU6ICdkeW5hbWljJ319LFxuICAgIGxpbmVhckRhbXBpbmc6ICB7IGRlZmF1bHQ6IDAuMDEsIGlmOiB7dHlwZTogJ2R5bmFtaWMnfX0sXG4gICAgYW5ndWxhckRhbXBpbmc6IHsgZGVmYXVsdDogMC4wMSwgIGlmOiB7dHlwZTogJ2R5bmFtaWMnfX0sXG4gICAgc2hhcGU6IHtkZWZhdWx0OiAnYXV0bycsIG9uZU9mOiBbJ2F1dG8nLCAnYm94JywgJ2N5bGluZGVyJywgJ3NwaGVyZScsICdodWxsJywgJ21lc2gnLCAnbm9uZSddfSxcbiAgICBjeWxpbmRlckF4aXM6IHtkZWZhdWx0OiAneScsIG9uZU9mOiBbJ3gnLCAneScsICd6J119LFxuICAgIHNwaGVyZVJhZGl1czoge2RlZmF1bHQ6IE5hTn0sXG4gICAgdHlwZToge2RlZmF1bHQ6ICdkeW5hbWljJywgb25lT2Y6IFsnc3RhdGljJywgJ2R5bmFtaWMnXX1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBib2R5IGNvbXBvbmVudCwgYXNzaWduaW5nIGl0IHRvIHRoZSBwaHlzaWNzIHN5c3RlbSBhbmQgYmluZGluZyBsaXN0ZW5lcnMgZm9yXG4gICAqIHBhcnNpbmcgdGhlIGVsZW1lbnRzIGdlb21ldHJ5LlxuICAgKi9cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3lzdGVtID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcztcblxuICAgIGlmICh0aGlzLmVsLnNjZW5lRWwuaGFzTG9hZGVkKSB7XG4gICAgICB0aGlzLmluaXRCb2R5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCB0aGlzLmluaXRCb2R5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGFyc2VzIGFuIGVsZW1lbnQncyBnZW9tZXRyeSBhbmQgY29tcG9uZW50IG1ldGFkYXRhIHRvIGNyZWF0ZSBhIENBTk5PTi5Cb2R5IGluc3RhbmNlIGZvciB0aGVcbiAgICogY29tcG9uZW50LlxuICAgKi9cbiAgaW5pdEJvZHk6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgdmFyIG9iaiA9IHRoaXMuZWwub2JqZWN0M0Q7XG4gICAgdmFyIHBvcyA9IG9iai5wb3NpdGlvbjtcbiAgICB2YXIgcXVhdCA9IG9iai5xdWF0ZXJuaW9uO1xuXG4gICAgdGhpcy5ib2R5ID0gbmV3IENBTk5PTi5Cb2R5KHtcbiAgICAgIG1hc3M6IGRhdGEudHlwZSA9PT0gJ3N0YXRpYycgPyAwIDogZGF0YS5tYXNzIHx8IDAsXG4gICAgICBtYXRlcmlhbDogdGhpcy5zeXN0ZW0uZ2V0TWF0ZXJpYWwoJ2RlZmF1bHRNYXRlcmlhbCcpLFxuICAgICAgcG9zaXRpb246IG5ldyBDQU5OT04uVmVjMyhwb3MueCwgcG9zLnksIHBvcy56KSxcbiAgICAgIHF1YXRlcm5pb246IG5ldyBDQU5OT04uUXVhdGVybmlvbihxdWF0LngsIHF1YXQueSwgcXVhdC56LCBxdWF0LncpLFxuICAgICAgbGluZWFyRGFtcGluZzogZGF0YS5saW5lYXJEYW1waW5nLFxuICAgICAgYW5ndWxhckRhbXBpbmc6IGRhdGEuYW5ndWxhckRhbXBpbmcsXG4gICAgICB0eXBlOiBkYXRhLnR5cGUgPT09ICdkeW5hbWljJyA/IENBTk5PTi5Cb2R5LkRZTkFNSUMgOiBDQU5OT04uQm9keS5TVEFUSUMsXG4gICAgfSk7XG5cbiAgICAvLyBNYXRyaXggV29ybGQgbXVzdCBiZSB1cGRhdGVkIGF0IHJvb3QgbGV2ZWwsIGlmIHNjYWxlIGlzIHRvIGJlIGFwcGxpZWQg4oCTIHVwZGF0ZU1hdHJpeFdvcmxkKClcbiAgICAvLyBvbmx5IGNoZWNrcyBhbiBvYmplY3QncyBwYXJlbnQsIG5vdCB0aGUgcmVzdCBvZiB0aGUgYW5jZXN0b3JzLiBIZW5jZSwgYSB3cmFwcGluZyBlbnRpdHkgd2l0aFxuICAgIC8vIHNjYWxlPVwiMC41IDAuNSAwLjVcIiB3aWxsIGJlIGlnbm9yZWQuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvbWFzdGVyL3NyYy9jb3JlL09iamVjdDNELmpzI0w1MTEtTDU0MVxuICAgIC8vIFBvdGVudGlhbCBmaXg6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC83MDE5XG4gICAgdGhpcy5lbC5vYmplY3QzRC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcblxuICAgIGlmKGRhdGEuc2hhcGUgIT09ICdub25lJykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBkYXRhLnNoYXBlID09PSAnYXV0bycgPyB1bmRlZmluZWQgOiBBRlJBTUUudXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmRhdGEsIHtcbiAgICAgICAgdHlwZTogU2hhcGVUeXBlW2RhdGEuc2hhcGUudG9VcHBlckNhc2UoKV1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaGFwZUluZm8gPSBtZXNoMnNoYXBlKHRoaXMuZWwub2JqZWN0M0QsIG9wdGlvbnMpO1xuICAgICAgbGV0IHNoYXBlLCBvZmZzZXQsIG9yaWVudGF0aW9uO1xuICAgICAgaWYgKHNoYXBlSW5mbykge1xuICAgICAgICAoeyBzaGFwZSwgb2Zmc2V0LCBvcmllbnRhdGlvbiB9ID0gc2hhcGVJbmZvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGFwZSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdvYmplY3QzZHNldCcsIHRoaXMuaW5pdEJvZHkuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmFkZFNoYXBlKHNoYXBlLCBvZmZzZXQsIG9yaWVudGF0aW9uKTtcblxuICAgICAgLy8gU2hvdyB3aXJlZnJhbWVcbiAgICAgIGlmICh0aGlzLnN5c3RlbS5kZWJ1Zykge1xuICAgICAgICB0aGlzLnNob3VsZFVwZGF0ZVdpcmVmcmFtZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFzU2hhcGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZWwuYm9keSA9IHRoaXMuYm9keTtcbiAgICB0aGlzLmJvZHkuZWwgPSBlbDtcblxuICAgIC8vIElmIGNvbXBvbmVudCB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2hlbiBwbGF5KCkgd2FzIGNhbGxlZCwgZmluaXNoIHVwLlxuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5fcGxheSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1NoYXBlKSB7XG4gICAgICB0aGlzLmVsLmVtaXQoJ2JvZHktbG9hZGVkJywge2JvZHk6IHRoaXMuZWwuYm9keX0pO1xuICAgIH1cbiAgfSxcblxuICBhZGRTaGFwZTogZnVuY3Rpb24oc2hhcGUsIG9mZnNldCwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAodGhpcy5kYXRhLnNoYXBlICE9PSAnbm9uZScpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2hhcGUgY2FuIG9ubHkgYmUgYWRkZWQgaWYgc2hhcGUgcHJvcGVydHkgaXMgbm9uZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc2hhcGUpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2hhcGUgY2Fubm90IGJlIG51bGwnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYm9keSkge1xuICAgICAgY29uc29sZS53YXJuKCdzaGFwZSBjYW5ub3QgYmUgYWRkZWQgYmVmb3JlIGJvZHkgaXMgbG9hZGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYm9keS5hZGRTaGFwZShzaGFwZSwgb2Zmc2V0LCBvcmllbnRhdGlvbik7XG5cbiAgICBpZiAodGhpcy5zeXN0ZW0uZGVidWcpIHtcbiAgICAgIHRoaXMuc2hvdWxkVXBkYXRlV2lyZWZyYW1lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNob3VsZFVwZGF0ZUJvZHkgPSB0cnVlO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGVCb2R5KSB7XG4gICAgICBcbiAgICAgIC8vIENhbGxpbmcgcGxheSB3aWxsIHJlc3VsdCBpbiB0aGUgb2JqZWN0IGJlaW5nIHJlLWFkZGVkIHRvIHRoZVxuICAgICAgLy8gcGh5c2ljcyBzeXN0ZW0gd2l0aCB0aGUgdXBkYXRlZCBib2R5IC8gc2hhcGUgZGF0YS5cbiAgICAgIC8vIEJ1dCB3ZSBtdXN0bid0IGFkZCBpdCB0d2ljZSwgc28gYW55IHByZXZpb3VzbHkgbG9hZGVkIGJvZHkgc2hvdWxkIGJlIHBhdXNlZCBmaXJzdC5cbiAgICAgIHRoaXMuX3BhdXNlKCk7XG4gICAgICB0aGlzLmhhc1NoYXBlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BsYXkoKVxuXG4gICAgICB0aGlzLmVsLmVtaXQoJ2JvZHktbG9hZGVkJywge2JvZHk6IHRoaXMuZWwuYm9keX0pO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGVCb2R5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlV2lyZWZyYW1lKSB7XG4gICAgICB0aGlzLmNyZWF0ZVdpcmVmcmFtZSh0aGlzLmJvZHkpO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGVXaXJlZnJhbWUgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgY29tcG9uZW50IHdpdGggdGhlIHBoeXNpY3Mgc3lzdGVtLCBpZiByZWFkeS5cbiAgICovXG4gIHBsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wbGF5KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciB0byByZWdpc3RlciBjb21wb25lbnQgd2l0aCBwaHlzaWNzIHN5c3RlbS5cbiAgICovXG4gIF9wbGF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIXRoaXMuaGFzU2hhcGUpIHJldHVybjtcblxuICAgIHRoaXMuc3luY1RvUGh5c2ljcygpO1xuICAgIHRoaXMuc3lzdGVtLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbS5hZGRCb2R5KHRoaXMuYm9keSk7XG4gICAgaWYgKHRoaXMud2lyZWZyYW1lKSB0aGlzLmVsLnNjZW5lRWwub2JqZWN0M0QuYWRkKHRoaXMud2lyZWZyYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgdGhlIGNvbXBvbmVudCB3aXRoIHRoZSBwaHlzaWNzIHN5c3RlbS5cbiAgICovXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2UoKTtcbiAgfSxcblxuICBfcGF1c2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5oYXNTaGFwZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5zeXN0ZW0ucmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xuICAgIGlmICh0aGlzLmJvZHkpIHRoaXMuc3lzdGVtLnJlbW92ZUJvZHkodGhpcy5ib2R5KTtcbiAgICBpZiAodGhpcy53aXJlZnJhbWUpIHRoaXMuZWwuc2NlbmVFbC5vYmplY3QzRC5yZW1vdmUodGhpcy53aXJlZnJhbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBDQU5OT04uQm9keSBpbnN0YW5jZSwgd2hlcmUgcG9zc2libGUuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIChwcmV2RGF0YSkge1xuICAgIGlmICghdGhpcy5ib2R5KSByZXR1cm47XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChwcmV2RGF0YS50eXBlICE9IHVuZGVmaW5lZCAmJiBkYXRhLnR5cGUgIT0gcHJldkRhdGEudHlwZSkge1xuICAgICAgdGhpcy5ib2R5LnR5cGUgPSBkYXRhLnR5cGUgPT09ICdkeW5hbWljJyA/IENBTk5PTi5Cb2R5LkRZTkFNSUMgOiBDQU5OT04uQm9keS5TVEFUSUM7XG4gICAgfVxuXG4gICAgdGhpcy5ib2R5Lm1hc3MgPSBkYXRhLm1hc3MgfHwgMDtcbiAgICBpZiAoZGF0YS50eXBlID09PSAnZHluYW1pYycpIHtcbiAgICAgIHRoaXMuYm9keS5saW5lYXJEYW1waW5nID0gZGF0YS5saW5lYXJEYW1waW5nO1xuICAgICAgdGhpcy5ib2R5LmFuZ3VsYXJEYW1waW5nID0gZGF0YS5hbmd1bGFyRGFtcGluZztcbiAgICB9XG4gICAgaWYgKGRhdGEubWFzcyAhPT0gcHJldkRhdGEubWFzcykge1xuICAgICAgdGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvZHkudXBkYXRlUHJvcGVydGllcykgdGhpcy5ib2R5LnVwZGF0ZVByb3BlcnRpZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY29tcG9uZW50IGFuZCBhbGwgcGh5c2ljcyBhbmQgc2NlbmUgc2lkZSBlZmZlY3RzLlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgZGVsZXRlIHRoaXMuYm9keS5lbDtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmVsLmJvZHk7XG4gICAgZGVsZXRlIHRoaXMud2lyZWZyYW1lO1xuICB9LFxuXG4gIGJlZm9yZVN0ZXA6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5ib2R5Lm1hc3MgPT09IDApIHtcbiAgICAgIHRoaXMuc3luY1RvUGh5c2ljcygpO1xuICAgIH1cbiAgfSxcblxuICBzdGVwOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYm9keS5tYXNzICE9PSAwKSB7XG4gICAgICB0aGlzLnN5bmNGcm9tUGh5c2ljcygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdpcmVmcmFtZSBmb3IgdGhlIGJvZHksIGZvciBkZWJ1Z2dpbmcuXG4gICAqIFRPRE8oZG9ubWNjdXJkeSkg4oCTIFJlZmFjdG9yIHRoaXMgaW50byBhIHN0YW5kYWxvbmUgdXRpbGl0eSBvciBjb21wb25lbnQuXG4gICAqIEBwYXJhbSAge0NBTk5PTi5Cb2R5fSBib2R5XG4gICAqIEBwYXJhbSAge0NBTk5PTi5TaGFwZX0gc2hhcGVcbiAgICovXG4gIGNyZWF0ZVdpcmVmcmFtZTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICBpZiAodGhpcy53aXJlZnJhbWUpIHtcbiAgICAgIHRoaXMuZWwuc2NlbmVFbC5vYmplY3QzRC5yZW1vdmUodGhpcy53aXJlZnJhbWUpO1xuICAgICAgZGVsZXRlIHRoaXMud2lyZWZyYW1lO1xuICAgIH1cbiAgICB0aGlzLndpcmVmcmFtZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIHRoaXMuZWwuc2NlbmVFbC5vYmplY3QzRC5hZGQodGhpcy53aXJlZnJhbWUpO1xuXG4gICAgdmFyIG9mZnNldCwgbWVzaDtcbiAgICB2YXIgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LnNoYXBlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmJvZHkuc2hhcGVPZmZzZXRzW2ldLFxuICAgICAgb3JpZW50YXRpb24uY29weSh0aGlzLmJvZHkuc2hhcGVPcmllbnRhdGlvbnNbaV0pLFxuICAgICAgbWVzaCA9IENBTk5PTi5zaGFwZTJtZXNoKHRoaXMuYm9keSkuY2hpbGRyZW5baV07XG5cbiAgICAgIHZhciB3aXJlZnJhbWUgPSBuZXcgVEhSRUUuTGluZVNlZ21lbnRzKFxuICAgICAgICBuZXcgVEhSRUUuRWRnZXNHZW9tZXRyeShtZXNoLmdlb21ldHJ5KSxcbiAgICAgICAgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjogMHhmZjAwMDB9KVxuICAgICAgKTtcblxuICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICB3aXJlZnJhbWUucG9zaXRpb24uY29weShvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24pIHtcbiAgICAgICAgd2lyZWZyYW1lLnF1YXRlcm5pb24uY29weShvcmllbnRhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lyZWZyYW1lLmFkZCh3aXJlZnJhbWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3luY1dpcmVmcmFtZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkZWJ1Z2dpbmcgd2lyZWZyYW1lJ3MgcG9zaXRpb24gYW5kIHJvdGF0aW9uLlxuICAgKi9cbiAgc3luY1dpcmVmcmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBvZmZzZXQsXG4gICAgICAgIHdpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXG4gICAgaWYgKCF0aGlzLndpcmVmcmFtZSkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgcm90YXRpb24uIElmIHRoZSBzaGFwZSByZXF1aXJlZCBjdXN0b20gb3JpZW50YXRpb24sIGFsc28gYXBwbHlcbiAgICAvLyB0aGF0IG9uIHRoZSB3aXJlZnJhbWUuXG4gICAgd2lyZWZyYW1lLnF1YXRlcm5pb24uY29weSh0aGlzLmJvZHkucXVhdGVybmlvbik7XG4gICAgaWYgKHdpcmVmcmFtZS5vcmllbnRhdGlvbikge1xuICAgICAgd2lyZWZyYW1lLnF1YXRlcm5pb24ubXVsdGlwbHkod2lyZWZyYW1lLm9yaWVudGF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBwb3NpdGlvbi4gSWYgdGhlIHNoYXBlIHJlcXVpcmVkIGN1c3RvbSBvZmZzZXQsIGFsc28gYXBwbHkgdGhhdCBvblxuICAgIC8vIHRoZSB3aXJlZnJhbWUuXG4gICAgd2lyZWZyYW1lLnBvc2l0aW9uLmNvcHkodGhpcy5ib2R5LnBvc2l0aW9uKTtcbiAgICBpZiAod2lyZWZyYW1lLm9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gd2lyZWZyYW1lLm9mZnNldC5jbG9uZSgpLmFwcGx5UXVhdGVybmlvbih3aXJlZnJhbWUucXVhdGVybmlvbik7XG4gICAgICB3aXJlZnJhbWUucG9zaXRpb24uYWRkKG9mZnNldCk7XG4gICAgfVxuXG4gICAgd2lyZWZyYW1lLnVwZGF0ZU1hdHJpeCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBDQU5OT04uQm9keSBpbnN0YW5jZSdzIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYW5kIHJvdGF0aW9uLCBiYXNlZCBvbiB0aGUgc2NlbmUuXG4gICAqL1xuICBzeW5jVG9QaHlzaWNzOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBxID0gIG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksXG4gICAgICAgIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgIHBhcmVudEVsID0gZWwucGFyZW50RWwsXG4gICAgICAgICAgYm9keSA9IHRoaXMuYm9keTtcblxuICAgICAgaWYgKCFib2R5KSByZXR1cm47XG5cbiAgICAgIGlmIChlbC5jb21wb25lbnRzLnZlbG9jaXR5KSBib2R5LnZlbG9jaXR5LmNvcHkoZWwuZ2V0QXR0cmlidXRlKCd2ZWxvY2l0eScpKTtcblxuICAgICAgaWYgKHBhcmVudEVsLmlzU2NlbmUpIHtcbiAgICAgICAgYm9keS5xdWF0ZXJuaW9uLmNvcHkoZWwub2JqZWN0M0QucXVhdGVybmlvbik7XG4gICAgICAgIGJvZHkucG9zaXRpb24uY29weShlbC5vYmplY3QzRC5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5vYmplY3QzRC5nZXRXb3JsZFF1YXRlcm5pb24ocSk7XG4gICAgICAgIGJvZHkucXVhdGVybmlvbi5jb3B5KHEpO1xuICAgICAgICBlbC5vYmplY3QzRC5nZXRXb3JsZFBvc2l0aW9uKHYpO1xuICAgICAgICBib2R5LnBvc2l0aW9uLmNvcHkodik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJvZHkudXBkYXRlUHJvcGVydGllcykgdGhpcy5ib2R5LnVwZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIGlmICh0aGlzLndpcmVmcmFtZSkgdGhpcy5zeW5jV2lyZWZyYW1lKCk7XG4gICAgfTtcbiAgfSgpKSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2NlbmUgb2JqZWN0J3MgcG9zaXRpb24gYW5kIHJvdGF0aW9uLCBiYXNlZCBvbiB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLlxuICAgKi9cbiAgc3luY0Zyb21QaHlzaWNzOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLFxuICAgICAgICBxMiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgcGFyZW50RWwgPSBlbC5wYXJlbnRFbCxcbiAgICAgICAgICBib2R5ID0gdGhpcy5ib2R5O1xuXG4gICAgICBpZiAoIWJvZHkpIHJldHVybjtcbiAgICAgIGlmICghcGFyZW50RWwpIHJldHVybjtcblxuICAgICAgaWYgKHBhcmVudEVsLmlzU2NlbmUpIHtcbiAgICAgICAgZWwub2JqZWN0M0QucXVhdGVybmlvbi5jb3B5KGJvZHkucXVhdGVybmlvbik7XG4gICAgICAgIGVsLm9iamVjdDNELnBvc2l0aW9uLmNvcHkoYm9keS5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxMS5jb3B5KGJvZHkucXVhdGVybmlvbik7XG4gICAgICAgIHBhcmVudEVsLm9iamVjdDNELmdldFdvcmxkUXVhdGVybmlvbihxMik7XG4gICAgICAgIHExLnByZW11bHRpcGx5KHEyLmludmVydCgpKTtcbiAgICAgICAgZWwub2JqZWN0M0QucXVhdGVybmlvbi5jb3B5KHExKTtcblxuICAgICAgICB2LmNvcHkoYm9keS5wb3NpdGlvbik7XG4gICAgICAgIHBhcmVudEVsLm9iamVjdDNELndvcmxkVG9Mb2NhbCh2KTtcbiAgICAgICAgZWwub2JqZWN0M0QucG9zaXRpb24uY29weSh2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2lyZWZyYW1lKSB0aGlzLnN5bmNXaXJlZnJhbWUoKTtcbiAgICB9O1xuICB9KCkpXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWZpbml0aW9uID0gQm9keTtcbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnYm9keScsIEJvZHkpO1xuIiwidmFyIEJvZHkgPSByZXF1aXJlKCcuL2JvZHknKTtcblxuLyoqXG4gKiBEeW5hbWljIGJvZHkuXG4gKlxuICogTW92ZXMgYWNjb3JkaW5nIHRvIHBoeXNpY3Mgc2ltdWxhdGlvbiwgYW5kIG1heSBjb2xsaWRlIHdpdGggb3RoZXIgb2JqZWN0cy5cbiAqL1xudmFyIER5bmFtaWNCb2R5ID0gQUZSQU1FLnV0aWxzLmV4dGVuZCh7fSwgQm9keS5kZWZpbml0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2R5bmFtaWMtYm9keScsIER5bmFtaWNCb2R5KTtcbiIsInZhciBCb2R5ID0gcmVxdWlyZSgnLi9ib2R5Jyk7XG5cbi8qKlxuICogU3RhdGljIGJvZHkuXG4gKlxuICogU29saWQgYm9keSB3aXRoIGEgZml4ZWQgcG9zaXRpb24uIFVuYWZmZWN0ZWQgYnkgZ3Jhdml0eSBhbmQgY29sbGlzaW9ucywgYnV0XG4gKiBvdGhlciBvYmplY3RzIG1heSBjb2xsaWRlIHdpdGggaXQuXG4gKi9cbnZhciBTdGF0aWNCb2R5ID0gQUZSQU1FLnV0aWxzLmV4dGVuZCh7fSwgQm9keS5kZWZpbml0aW9uKTtcblxuU3RhdGljQm9keS5zY2hlbWEgPSBBRlJBTUUudXRpbHMuZXh0ZW5kKHt9LCBCb2R5LmRlZmluaXRpb24uc2NoZW1hLCB7XG4gIHR5cGU6IHtkZWZhdWx0OiAnc3RhdGljJywgb25lT2Y6IFsnc3RhdGljJywgJ2R5bmFtaWMnXX0sXG4gIG1hc3M6IHtkZWZhdWx0OiAwfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzdGF0aWMtYm9keScsIFN0YXRpY0JvZHkpO1xuIiwidmFyIENBTk5PTiA9IHJlcXVpcmUoXCJjYW5ub24tZXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KFwiY29uc3RyYWludFwiLCB7XG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIHNjaGVtYToge1xuICAgIC8vIFR5cGUgb2YgY29uc3RyYWludC5cbiAgICB0eXBlOiB7IGRlZmF1bHQ6IFwibG9ja1wiLCBvbmVPZjogW1wiY29uZVR3aXN0XCIsIFwiZGlzdGFuY2VcIiwgXCJoaW5nZVwiLCBcImxvY2tcIiwgXCJwb2ludFRvUG9pbnRcIl0gfSxcblxuICAgIC8vIFRhcmdldCAob3RoZXIpIGJvZHkgZm9yIHRoZSBjb25zdHJhaW50LlxuICAgIHRhcmdldDogeyB0eXBlOiBcInNlbGVjdG9yXCIgfSxcblxuICAgIC8vIE1heGltdW0gZm9yY2UgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBjb25zdHJhaW50IHRoZSBib2RpZXMuXG4gICAgbWF4Rm9yY2U6IHsgZGVmYXVsdDogMWU2LCBtaW46IDAgfSxcblxuICAgIC8vIElmIHRydWUsIGJvZGllcyBjYW4gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC5cbiAgICBjb2xsaWRlQ29ubmVjdGVkOiB7IGRlZmF1bHQ6IHRydWUgfSxcblxuICAgIC8vIFdha2UgdXAgYm9kaWVzIHdoZW4gY29ubmVjdGVkLlxuICAgIHdha2VVcEJvZGllczogeyBkZWZhdWx0OiB0cnVlIH0sXG5cbiAgICAvLyBUaGUgZGlzdGFuY2UgdG8gYmUga2VwdCBiZXR3ZWVuIHRoZSBib2RpZXMuIElmIDAsIHdpbGwgYmUgc2V0IHRvIGN1cnJlbnQgZGlzdGFuY2UuXG4gICAgZGlzdGFuY2U6IHsgZGVmYXVsdDogMCwgbWluOiAwIH0sXG5cbiAgICAvLyBPZmZzZXQgb2YgdGhlIGhpbmdlIG9yIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQsIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keS5cbiAgICBwaXZvdDogeyB0eXBlOiBcInZlYzNcIiB9LFxuICAgIHRhcmdldFBpdm90OiB7IHR5cGU6IFwidmVjM1wiIH0sXG5cbiAgICAvLyBBbiBheGlzIHRoYXQgZWFjaCBib2R5IGNhbiByb3RhdGUgYXJvdW5kLCBkZWZpbmVkIGxvY2FsbHkgdG8gdGhhdCBib2R5LlxuICAgIGF4aXM6IHsgdHlwZTogXCJ2ZWMzXCIsIGRlZmF1bHQ6IHsgeDogMCwgeTogMCwgejogMSB9IH0sXG4gICAgdGFyZ2V0QXhpczogeyB0eXBlOiBcInZlYzNcIiwgZGVmYXVsdDogeyB4OiAwLCB5OiAwLCB6OiAxIH0gfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3lzdGVtID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcztcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSAvKiB7Q0FOTk9OLkNvbnN0cmFpbnR9ICovIG51bGw7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RyYWludCkgcmV0dXJuO1xuXG4gICAgdGhpcy5zeXN0ZW0ucmVtb3ZlQ29uc3RyYWludCh0aGlzLmNvbnN0cmFpbnQpO1xuICAgIHRoaXMuY29uc3RyYWludCA9IG51bGw7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIHRoaXMucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWVsLmJvZHkgfHwgIWRhdGEudGFyZ2V0LmJvZHkpIHtcbiAgICAgIChlbC5ib2R5ID8gZGF0YS50YXJnZXQgOiBlbCkuYWRkRXZlbnRMaXN0ZW5lcihcImJvZHktbG9hZGVkXCIsIHRoaXMudXBkYXRlLmJpbmQodGhpcywge30pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnN0cmFpbnQgPSB0aGlzLmNyZWF0ZUNvbnN0cmFpbnQoKTtcbiAgICB0aGlzLnN5c3RlbS5hZGRDb25zdHJhaW50KHRoaXMuY29uc3RyYWludCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uc3RyYWludCwgZ2l2ZW4gY3VycmVudCBjb21wb25lbnQgZGF0YS4gVGhlIENBTk5PTi5qcyBjb25zdHJ1Y3RvcnMgYXJlIGEgYml0XG4gICAqIGRpZmZlcmVudCBmb3IgZWFjaCBjb25zdHJhaW50IHR5cGUuIEEgYC50eXBlYCBwcm9wZXJ0eSBpcyBhZGRlZCB0byBlYWNoIGNvbnN0cmFpbnQsIGJlY2F1c2VcbiAgICogYGluc3RhbmNlb2ZgIGNoZWNrcyBhcmUgbm90IHJlbGlhYmxlIGZvciBzb21lIHR5cGVzLiBUaGVzZSB0eXBlcyBhcmUgbmVlZGVkIGZvciBzZXJpYWxpemF0aW9uLlxuICAgKiBAcmV0dXJuIHtDQU5OT04uQ29uc3RyYWludH1cbiAgICovXG4gIGNyZWF0ZUNvbnN0cmFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25zdHJhaW50LFxuICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgIHBpdm90ID0gbmV3IENBTk5PTi5WZWMzKGRhdGEucGl2b3QueCwgZGF0YS5waXZvdC55LCBkYXRhLnBpdm90LnopLFxuICAgICAgdGFyZ2V0UGl2b3QgPSBuZXcgQ0FOTk9OLlZlYzMoZGF0YS50YXJnZXRQaXZvdC54LCBkYXRhLnRhcmdldFBpdm90LnksIGRhdGEudGFyZ2V0UGl2b3QueiksXG4gICAgICBheGlzID0gbmV3IENBTk5PTi5WZWMzKGRhdGEuYXhpcy54LCBkYXRhLmF4aXMueSwgZGF0YS5heGlzLnopLFxuICAgICAgdGFyZ2V0QXhpcyA9IG5ldyBDQU5OT04uVmVjMyhkYXRhLnRhcmdldEF4aXMueCwgZGF0YS50YXJnZXRBeGlzLnksIGRhdGEudGFyZ2V0QXhpcy56KTtcblxuICAgIHZhciBjb25zdHJhaW50O1xuXG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJsb2NrXCI6XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ0FOTk9OLkxvY2tDb25zdHJhaW50KHRoaXMuZWwuYm9keSwgZGF0YS50YXJnZXQuYm9keSwgeyBtYXhGb3JjZTogZGF0YS5tYXhGb3JjZSB9KTtcbiAgICAgICAgY29uc3RyYWludC50eXBlID0gXCJMb2NrQ29uc3RyYWludFwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImRpc3RhbmNlXCI6XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ0FOTk9OLkRpc3RhbmNlQ29uc3RyYWludCh0aGlzLmVsLmJvZHksIGRhdGEudGFyZ2V0LmJvZHksIGRhdGEuZGlzdGFuY2UsIGRhdGEubWF4Rm9yY2UpO1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBcIkRpc3RhbmNlQ29uc3RyYWludFwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImhpbmdlXCI6XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ0FOTk9OLkhpbmdlQ29uc3RyYWludCh0aGlzLmVsLmJvZHksIGRhdGEudGFyZ2V0LmJvZHksIHtcbiAgICAgICAgICBwaXZvdEE6IHBpdm90LFxuICAgICAgICAgIHBpdm90QjogdGFyZ2V0UGl2b3QsXG4gICAgICAgICAgYXhpc0E6IGF4aXMsXG4gICAgICAgICAgYXhpc0I6IHRhcmdldEF4aXMsXG4gICAgICAgICAgbWF4Rm9yY2U6IGRhdGEubWF4Rm9yY2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0cmFpbnQudHlwZSA9IFwiSGluZ2VDb25zdHJhaW50XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiY29uZVR3aXN0XCI6XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ0FOTk9OLkNvbmVUd2lzdENvbnN0cmFpbnQodGhpcy5lbC5ib2R5LCBkYXRhLnRhcmdldC5ib2R5LCB7XG4gICAgICAgICAgcGl2b3RBOiBwaXZvdCxcbiAgICAgICAgICBwaXZvdEI6IHRhcmdldFBpdm90LFxuICAgICAgICAgIGF4aXNBOiBheGlzLFxuICAgICAgICAgIGF4aXNCOiB0YXJnZXRBeGlzLFxuICAgICAgICAgIG1heEZvcmNlOiBkYXRhLm1heEZvcmNlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBcIkNvbmVUd2lzdENvbnN0cmFpbnRcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJwb2ludFRvUG9pbnRcIjpcbiAgICAgICAgY29uc3RyYWludCA9IG5ldyBDQU5OT04uUG9pbnRUb1BvaW50Q29uc3RyYWludChcbiAgICAgICAgICB0aGlzLmVsLmJvZHksXG4gICAgICAgICAgcGl2b3QsXG4gICAgICAgICAgZGF0YS50YXJnZXQuYm9keSxcbiAgICAgICAgICB0YXJnZXRQaXZvdCxcbiAgICAgICAgICBkYXRhLm1heEZvcmNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0cmFpbnQudHlwZSA9IFwiUG9pbnRUb1BvaW50Q29uc3RyYWludFwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW2NvbnN0cmFpbnRdIFVuZXhwZWN0ZWQgdHlwZTogXCIgKyBkYXRhLnR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0cmFpbnQuY29sbGlkZUNvbm5lY3RlZCA9IGRhdGEuY29sbGlkZUNvbm5lY3RlZDtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ3ZlbG9jaXR5JzogICByZXF1aXJlKCcuL3ZlbG9jaXR5JyksXG5cbiAgcmVnaXN0ZXJBbGw6IGZ1bmN0aW9uIChBRlJBTUUpIHtcbiAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZCkgcmV0dXJuO1xuXG4gICAgQUZSQU1FID0gQUZSQU1FIHx8IHdpbmRvdy5BRlJBTUU7XG5cbiAgICBpZiAoIUFGUkFNRS5jb21wb25lbnRzWyd2ZWxvY2l0eSddKSAgICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3ZlbG9jaXR5JywgICB0aGlzLnZlbG9jaXR5KTtcblxuICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSB0cnVlO1xuICB9XG59O1xuIiwiLyoqXG4gKiBWZWxvY2l0eSwgaW4gbS9zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgndmVsb2NpdHknLCB7XG4gIHNjaGVtYToge3R5cGU6ICd2ZWMzJ30sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3lzdGVtID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcztcblxuICAgIGlmICh0aGlzLnN5c3RlbSkge1xuICAgICAgdGhpcy5zeXN0ZW0uYWRkQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW0pIHtcbiAgICAgIHRoaXMuc3lzdGVtLnJlbW92ZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgdGljazogZnVuY3Rpb24gKHQsIGR0KSB7XG4gICAgaWYgKCFkdCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnN5c3RlbSkgcmV0dXJuO1xuICAgIHRoaXMuYWZ0ZXJTdGVwKHQsIGR0KTtcbiAgfSxcblxuICBhZnRlclN0ZXA6IGZ1bmN0aW9uICh0LCBkdCkge1xuICAgIGlmICghZHQpIHJldHVybjtcblxuICAgIHZhciBwaHlzaWNzID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcyB8fCB7ZGF0YToge21heEludGVydmFsOiAxIC8gNjB9fSxcblxuICAgIC8vIFRPRE8gLSBUaGVyZSdzIGRlZmluaXRlbHkgYSBidWcgd2l0aCBnZXRDb21wdXRlZEF0dHJpYnV0ZSBhbmQgZWwuZGF0YS5cbiAgICB2ZWxvY2l0eSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCd2ZWxvY2l0eScpIHx8IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICBwb3NpdGlvbiA9IHRoaXMuZWwub2JqZWN0M0QucG9zaXRpb24gfHwge3g6IDAsIHk6IDAsIHo6IDB9O1xuXG4gICAgZHQgPSBNYXRoLm1pbihkdCwgcGh5c2ljcy5kYXRhLm1heEludGVydmFsICogMTAwMCk7XG5cbiAgICB0aGlzLmVsLm9iamVjdDNELnBvc2l0aW9uLnNldChcbiAgICAgIHBvc2l0aW9uLnggKyB2ZWxvY2l0eS54ICogZHQgLyAxMDAwLFxuICAgICAgcG9zaXRpb24ueSArIHZlbG9jaXR5LnkgKiBkdCAvIDEwMDAsXG4gICAgICBwb3NpdGlvbi56ICsgdmVsb2NpdHkueiAqIGR0IC8gMTAwMFxuICAgICk7XG4gIH1cbn0pO1xuIiwiLyogZ2xvYmFsIEFtbW8sVEhSRUUgKi9cbmNvbnN0IHRocmVlVG9BbW1vID0gcmVxdWlyZShcInRocmVlLXRvLWFtbW9cIik7XG5jb25zdCBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpLFxuICBTSEFQRSA9IENPTlNUQU5UUy5TSEFQRSxcbiAgRklUID0gQ09OU1RBTlRTLkZJVDtcblxudmFyIEFtbW9TaGFwZSA9IHtcbiAgc2NoZW1hOiB7XG4gICAgdHlwZToge1xuICAgICAgZGVmYXVsdDogU0hBUEUuSFVMTCxcbiAgICAgIG9uZU9mOiBbXG4gICAgICAgIFNIQVBFLkJPWCxcbiAgICAgICAgU0hBUEUuQ1lMSU5ERVIsXG4gICAgICAgIFNIQVBFLlNQSEVSRSxcbiAgICAgICAgU0hBUEUuQ0FQU1VMRSxcbiAgICAgICAgU0hBUEUuQ09ORSxcbiAgICAgICAgU0hBUEUuSFVMTCxcbiAgICAgICAgU0hBUEUuSEFDRCxcbiAgICAgICAgU0hBUEUuVkhBQ0QsXG4gICAgICAgIFNIQVBFLk1FU0gsXG4gICAgICAgIFNIQVBFLkhFSUdIVEZJRUxEXG4gICAgICBdXG4gICAgfSxcbiAgICBmaXQ6IHsgZGVmYXVsdDogRklULkFMTCwgb25lT2Y6IFtGSVQuQUxMLCBGSVQuTUFOVUFMXSB9LFxuICAgIGhhbGZFeHRlbnRzOiB7IHR5cGU6IFwidmVjM1wiLCBkZWZhdWx0OiB7IHg6IDEsIHk6IDEsIHo6IDEgfSB9LFxuICAgIG1pbkhhbGZFeHRlbnQ6IHsgZGVmYXVsdDogMCB9LFxuICAgIG1heEhhbGZFeHRlbnQ6IHsgZGVmYXVsdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH0sXG4gICAgc3BoZXJlUmFkaXVzOiB7IGRlZmF1bHQ6IE5hTiB9LFxuICAgIGN5bGluZGVyQXhpczogeyBkZWZhdWx0OiBcInlcIiwgb25lT2Y6IFtcInhcIiwgXCJ5XCIsIFwielwiXSB9LFxuICAgIG1hcmdpbjogeyBkZWZhdWx0OiAwLjAxIH0sXG4gICAgb2Zmc2V0OiB7IHR5cGU6IFwidmVjM1wiLCBkZWZhdWx0OiB7IHg6IDAsIHk6IDAsIHo6IDAgfSB9LFxuICAgIG9yaWVudGF0aW9uOiB7IHR5cGU6IFwidmVjNFwiLCBkZWZhdWx0OiB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDEgfSB9LFxuICAgIGhlaWdodGZpZWxkRGF0YTogeyBkZWZhdWx0OiBbXSB9LFxuICAgIGhlaWdodGZpZWxkRGlzdGFuY2U6IHsgZGVmYXVsdDogMSB9LFxuICAgIGluY2x1ZGVJbnZpc2libGU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuXG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRhdGEuZml0ICE9PSBGSVQuTUFOVUFMKSB7XG4gICAgICBpZiAodGhpcy5lbC5vYmplY3QzRE1hcC5tZXNoKSB7XG5cdHRoaXMubWVzaCA9IHRoaXMuZWwub2JqZWN0M0RNYXAubWVzaDtcbiAgICAgIH0gZWxzZSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJvYmplY3QzZHNldFwiLCBmdW5jdGlvbiAoZSkge1xuXHQgIGlmIChlLmRldGFpbC50eXBlID09PSBcIm1lc2hcIikge1xuXHQgICAgc2VsZi5pbml0KCk7XG5cdCAgfVxuXHR9KTtcblx0Y29uc29sZS5sb2coXCJDYW5ub3QgdXNlIEZJVC5BTEwgd2l0aG91dCBvYmplY3QzRE1hcC5tZXNoLiBXYWl0aW5nIGZvciBpdCB0byBiZSBzZXQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zeXN0ZW0gPSB0aGlzLmVsLnNjZW5lRWwuc3lzdGVtcy5waHlzaWNzO1xuICAgIHRoaXMuY29sbGlzaW9uU2hhcGVzID0gW107XG5cbiAgICBsZXQgYm9keUVsID0gdGhpcy5lbDtcbiAgICB0aGlzLmJvZHkgPSBib2R5RWwuY29tcG9uZW50c1tcImFtbW8tYm9keVwiXSB8fCBudWxsO1xuICAgIHdoaWxlICghdGhpcy5ib2R5ICYmIGJvZHlFbC5wYXJlbnROb2RlICE9IHRoaXMuZWwuc2NlbmVFbCkge1xuICAgICAgYm9keUVsID0gYm9keUVsLnBhcmVudE5vZGU7XG4gICAgICBpZiAoYm9keUVsLmNvbXBvbmVudHNbXCJhbW1vLWJvZHlcIl0pIHtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keUVsLmNvbXBvbmVudHNbXCJhbW1vLWJvZHlcIl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5ib2R5KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJib2R5IG5vdCBmb3VuZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ib2R5LmFkZFNoYXBlQ29tcG9uZW50KHRoaXMpO1xuICB9LFxuXG4gIGdldE1lc2g6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc2ggfHwgbnVsbDtcbiAgfSxcblxuICBhZGRTaGFwZXM6IGZ1bmN0aW9uKGNvbGxpc2lvblNoYXBlcykge1xuICAgIHRoaXMuY29sbGlzaW9uU2hhcGVzID0gY29sbGlzaW9uU2hhcGVzO1xuICB9LFxuXG4gIGdldFNoYXBlczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uU2hhcGVzO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmJvZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJvZHkucmVtb3ZlU2hhcGVDb21wb25lbnQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5jb2xsaXNpb25TaGFwZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY29sbGlzaW9uU2hhcGUgPSB0aGlzLmNvbGxpc2lvblNoYXBlcy5wb3AoKTtcbiAgICAgIGNvbGxpc2lvblNoYXBlLmRlc3Ryb3koKTtcbiAgICAgIEFtbW8uZGVzdHJveShjb2xsaXNpb25TaGFwZS5sb2NhbFRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWZpbml0aW9uID0gQW1tb1NoYXBlO1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KFwiYW1tby1zaGFwZVwiLCBBbW1vU2hhcGUpO1xuIiwidmFyIENBTk5PTiA9IHJlcXVpcmUoJ2Nhbm5vbi1lcycpO1xuXG52YXIgU2hhcGUgPSB7XG4gIHNjaGVtYToge1xuICAgIHNoYXBlOiB7ZGVmYXVsdDogJ2JveCcsIG9uZU9mOiBbJ2JveCcsICdzcGhlcmUnLCAnY3lsaW5kZXInXX0sXG4gICAgb2Zmc2V0OiB7dHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiB7eDogMCwgeTogMCwgejogMH19LFxuICAgIG9yaWVudGF0aW9uOiB7dHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiB7eDogMCwgeTogMCwgejogMCwgdzogMX19LFxuXG4gICAgLy8gc3BoZXJlXG4gICAgcmFkaXVzOiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEsIGlmOiB7c2hhcGU6IFsnc3BoZXJlJ119fSxcblxuICAgIC8vIGJveFxuICAgIGhhbGZFeHRlbnRzOiB7dHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiB7eDogMC41LCB5OiAwLjUsIHo6IDAuNX0sIGlmOiB7c2hhcGU6IFsnYm94J119fSxcbiAgICBcbiAgICAvLyBjeWxpbmRlclxuICAgIHJhZGl1c1RvcDoge3R5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxLCBpZjoge3NoYXBlOiBbJ2N5bGluZGVyJ119fSxcbiAgICByYWRpdXNCb3R0b206IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMSwgaWY6IHtzaGFwZTogWydjeWxpbmRlciddfX0sXG4gICAgaGVpZ2h0OiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEsIGlmOiB7c2hhcGU6IFsnY3lsaW5kZXInXX19LFxuICAgIG51bVNlZ21lbnRzOiB7dHlwZTogJ2ludCcsIGRlZmF1bHQ6IDgsIGlmOiB7c2hhcGU6IFsnY3lsaW5kZXInXX19XG4gIH0sXG5cbiAgbXVsdGlwbGU6IHRydWUsXG5cbiAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZWwuc2NlbmVFbC5oYXNMb2FkZWQpIHtcbiAgICAgIHRoaXMuaW5pdFNoYXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCB0aGlzLmluaXRTaGFwZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdFNoYXBlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJvZHlFbCA9IHRoaXMuZWw7XG4gICAgdmFyIGJvZHlUeXBlID0gdGhpcy5fZmluZFR5cGUodGhpcy5ib2R5RWwpO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgd2hpbGUgKCFib2R5VHlwZSAmJiB0aGlzLmJvZHlFbC5wYXJlbnROb2RlICE9IHRoaXMuZWwuc2NlbmVFbCkge1xuICAgICAgdGhpcy5ib2R5RWwgPSB0aGlzLmJvZHlFbC5wYXJlbnROb2RlO1xuICAgICAgYm9keVR5cGUgPSB0aGlzLl9maW5kVHlwZSh0aGlzLmJvZHlFbCk7XG4gICAgfVxuXG4gICAgaWYgKCFib2R5VHlwZSkge1xuICAgICAgY29uc29sZS53YXJuKCdib2R5IG5vdCBmb3VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5ib2R5RWwub2JqZWN0M0QuZ2V0V29ybGRTY2FsZShzY2FsZSk7XG4gICAgdmFyIHNoYXBlLCBvZmZzZXQsIG9yaWVudGF0aW9uO1xuXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICBvZmZzZXQgPSBuZXcgQ0FOTk9OLlZlYzMoXG4gICAgICAgIGRhdGEub2Zmc2V0LnggKiBzY2FsZS54LCBcbiAgICAgICAgZGF0YS5vZmZzZXQueSAqIHNjYWxlLnksIFxuICAgICAgICBkYXRhLm9mZnNldC56ICogc2NhbGUuelxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnb3JpZW50YXRpb24nKSkge1xuICAgICAgb3JpZW50YXRpb24gPSBuZXcgQ0FOTk9OLlF1YXRlcm5pb24oKTtcbiAgICAgIG9yaWVudGF0aW9uLmNvcHkoZGF0YS5vcmllbnRhdGlvbik7XG4gICAgfVxuXG4gICAgc3dpdGNoKGRhdGEuc2hhcGUpIHtcbiAgICAgIGNhc2UgJ3NwaGVyZSc6XG4gICAgICAgIHNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUoZGF0YS5yYWRpdXMgKiBzY2FsZS54KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3gnOlxuICAgICAgICB2YXIgaGFsZkV4dGVudHMgPSBuZXcgQ0FOTk9OLlZlYzMoXG4gICAgICAgICAgZGF0YS5oYWxmRXh0ZW50cy54ICogc2NhbGUueCwgXG4gICAgICAgICAgZGF0YS5oYWxmRXh0ZW50cy55ICogc2NhbGUueSwgXG4gICAgICAgICAgZGF0YS5oYWxmRXh0ZW50cy56ICogc2NhbGUuelxuICAgICAgICApO1xuICAgICAgICBzaGFwZSA9IG5ldyBDQU5OT04uQm94KGhhbGZFeHRlbnRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjeWxpbmRlcic6XG4gICAgICAgIHNoYXBlID0gbmV3IENBTk5PTi5DeWxpbmRlcihcbiAgICAgICAgICBkYXRhLnJhZGl1c1RvcCAqIHNjYWxlLngsIFxuICAgICAgICAgIGRhdGEucmFkaXVzQm90dG9tICogc2NhbGUueCwgXG4gICAgICAgICAgZGF0YS5oZWlnaHQgKiBzY2FsZS55LCBcbiAgICAgICAgICBkYXRhLm51bVNlZ21lbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9yb3RhdGUgYnkgOTAgZGVncmVlcyBzaW1pbGFyIHRvIG1lc2gyc2hhcGU6Y3JlYXRlQ3lsaW5kZXJTaGFwZVxuICAgICAgICB2YXIgcXVhdCA9IG5ldyBDQU5OT04uUXVhdGVybmlvbigpO1xuICAgICAgICBxdWF0LnNldEZyb21FdWxlcig5MCAqIFRIUkVFLk1hdGhVdGlscy5ERUcyUkFELCAwLCAwLCAnWFlaJykubm9ybWFsaXplKCk7XG4gICAgICAgIG9yaWVudGF0aW9uLm11bHQocXVhdCwgb3JpZW50YXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKGRhdGEuc2hhcGUgKyAnIHNoYXBlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJvZHlFbC5ib2R5KSB7XG4gICAgICB0aGlzLmJvZHlFbC5jb21wb25lbnRzW2JvZHlUeXBlXS5hZGRTaGFwZShzaGFwZSwgb2Zmc2V0LCBvcmllbnRhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYm9keUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JvZHktbG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYm9keUVsLmNvbXBvbmVudHNbYm9keVR5cGVdLmFkZFNoYXBlKHNoYXBlLCBvZmZzZXQsIG9yaWVudGF0aW9uKTtcbiAgICAgIH0sIHtvbmNlOiB0cnVlfSk7XG4gICAgfVxuICB9LFxuXG4gIF9maW5kVHlwZTogZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdib2R5JykpIHtcbiAgICAgIHJldHVybiAnYm9keSc7XG4gICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2R5bmFtaWMtYm9keScpKSB7XG4gICAgICByZXR1cm4gJ2R5bmFtaWMtYm9keSc7XG4gICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3N0YXRpYy1ib2R5JykpIHtcbiAgICAgIHJldHVybidzdGF0aWMtYm9keSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYm9keUVsLnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybigncmVtb3Zpbmcgc2hhcGUgY29tcG9uZW50IG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWZpbml0aW9uID0gU2hhcGU7XG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3NoYXBlJywgU2hhcGUpO1xuIiwidmFyIENBTk5PTiA9IHJlcXVpcmUoJ2Nhbm5vbi1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc3ByaW5nJywge1xuXG4gIG11bHRpcGxlOiB0cnVlLFxuXG4gIHNjaGVtYToge1xuICAgIC8vIFRhcmdldCAob3RoZXIpIGJvZHkgZm9yIHRoZSBjb25zdHJhaW50LlxuICAgIHRhcmdldDoge3R5cGU6ICdzZWxlY3Rvcid9LFxuXG4gICAgLy8gTGVuZ3RoIG9mIHRoZSBzcHJpbmcsIHdoZW4gbm8gZm9yY2UgYWN0cyB1cG9uIGl0LlxuICAgIHJlc3RMZW5ndGg6IHtkZWZhdWx0OiAxLCBtaW46IDB9LFxuXG4gICAgLy8gSG93IG11Y2ggd2lsbCB0aGUgc3ByaW5nIHN1cHByZXNzIHRoZSBmb3JjZS5cbiAgICBzdGlmZm5lc3M6IHtkZWZhdWx0OiAxMDAsIG1pbjogMH0sXG5cbiAgICAvLyBTdHJldGNoIGZhY3RvciBvZiB0aGUgc3ByaW5nLlxuICAgIGRhbXBpbmc6IHtkZWZhdWx0OiAxLCBtaW46IDB9LFxuXG4gICAgLy8gT2Zmc2V0cy5cbiAgICBsb2NhbEFuY2hvckE6IHt0eXBlOiAndmVjMycsIGRlZmF1bHQ6IHt4OiAwLCB5OiAwLCB6OiAwfX0sXG4gICAgbG9jYWxBbmNob3JCOiB7dHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiB7eDogMCwgeTogMCwgejogMH19LFxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3lzdGVtID0gdGhpcy5lbC5zY2VuZUVsLnN5c3RlbXMucGh5c2ljcztcbiAgICB0aGlzLnN5c3RlbS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zcHJpbmcgPSAvKiB7Q0FOTk9OLlNwcmluZ30gKi8gbnVsbDtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKG9sZERhdGEpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKCFkYXRhLnRhcmdldCkge1xuICAgICAgY29uc29sZS53YXJuKCdTcHJpbmc6IGludmFsaWQgdGFyZ2V0IHNwZWNpZmllZC4nKTtcbiAgICAgIHJldHVybjsgXG4gICAgfVxuICAgIFxuICAgIC8vIHdhaXQgdW50aWwgdGhlIENBTk5PTiBib2RpZXMgaXMgY3JlYXRlZCBhbmQgYXR0YWNoZWRcbiAgICBpZiAoIWVsLmJvZHkgfHwgIWRhdGEudGFyZ2V0LmJvZHkpIHtcbiAgICAgIChlbC5ib2R5ID8gZGF0YS50YXJnZXQgOiBlbCkuYWRkRXZlbnRMaXN0ZW5lcignYm9keS1sb2FkZWQnLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMsIHt9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSBzcHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgdGhpcy5jcmVhdGVTcHJpbmcoKTtcbiAgICAvLyBhcHBseSBuZXcgZGF0YSB0byB0aGUgc3ByaW5nXG4gICAgdGhpcy51cGRhdGVTcHJpbmcob2xkRGF0YSk7XG4gIH0sXG5cbiAgdXBkYXRlU3ByaW5nOiBmdW5jdGlvbihvbGREYXRhKSB7XG4gICAgaWYgKCF0aGlzLnNwcmluZykge1xuICAgICAgY29uc29sZS53YXJuKCdTcHJpbmc6IENvbXBvbmVudCBhdHRlbXB0ZWQgdG8gY2hhbmdlIHNwcmluZyBiZWZvcmUgaXRzIGNyZWF0ZWQuIE5vIGNoYW5nZXMgbWFkZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9IFxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBzcHJpbmcgPSB0aGlzLnNwcmluZztcblxuICAgIC8vIEN5Y2xlIHRocm91Z2ggdGhlIHNjaGVtYSBhbmQgY2hlY2sgaWYgYW4gYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIC8vIGlmIHNvLCBhcHBseSBpdCB0byB0aGUgc3ByaW5nXG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoZGF0YVthdHRyXSAhPT0gb2xkRGF0YVthdHRyXSkge1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHRoZSB0YXJnZXQgc2VsZWN0b3JcbiAgICAgICAgICBzcHJpbmcuYm9keUIgPSBkYXRhLnRhcmdldC5ib2R5O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzcHJpbmdbYXR0cl0gPSBkYXRhW2F0dHJdO1xuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgY3JlYXRlU3ByaW5nOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zcHJpbmcpIHJldHVybjsgLy8gbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgc3ByaW5nXG4gICAgdGhpcy5zcHJpbmcgPSBuZXcgQ0FOTk9OLlNwcmluZyh0aGlzLmVsLmJvZHkpO1xuICB9LFxuXG4gIC8vIElmIHRoZSBzcHJpbmcgaXMgdmFsaWQsIHVwZGF0ZSB0aGUgZm9yY2UgZWFjaCB0aWNrIHRoZSBwaHlzaWNzIGFyZSBjYWxjdWxhdGVkXG4gIHN0ZXA6IGZ1bmN0aW9uKHQsIGR0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3ByaW5nICYmIHRoaXMuaXNBY3RpdmUgPyB0aGlzLnNwcmluZy5hcHBseUZvcmNlKCkgOiB2b2lkIDA7XG4gIH0sXG5cbiAgLy8gcmVzdW1lIHVwZGF0aW5nIHRoZSBmb3JjZSB3aGVuIGNvbXBvbmVudCB1cG9uIGNhbGxpbmcgcGxheSgpXG4gIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICB9LFxuXG4gIC8vIHN0b3AgdXBkYXRpbmcgdGhlIGZvcmNlIHdoZW4gY29tcG9uZW50IHVwb24gY2FsbGluZyBzdG9wKClcbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgfSxcblxuICAvL3JlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgKyBkZWxldGUgdGhlIHNwcmluZ1xuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNwcmluZylcbiAgICAgIGRlbGV0ZSB0aGlzLnNwcmluZztcbiAgICAgIHRoaXMuc3ByaW5nID0gbnVsbDtcbiAgfVxufSlcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBHUkFWSVRZOiAtOS44LFxuICBNQVhfSU5URVJWQUw6IDQgLyA2MCxcbiAgSVRFUkFUSU9OUzogMTAsXG4gIENPTlRBQ1RfTUFURVJJQUw6IHtcbiAgICBmcmljdGlvbjogMC4wMSxcbiAgICByZXN0aXR1dGlvbjogMC4zLFxuICAgIGNvbnRhY3RFcXVhdGlvblN0aWZmbmVzczogMWU4LFxuICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczogMWU4LFxuICAgIGZyaWN0aW9uRXF1YXRpb25SZWd1bGFyaXphdGlvbjogM1xuICB9LFxuICBBQ1RJVkFUSU9OX1NUQVRFOiB7XG4gICAgQUNUSVZFX1RBRzogXCJhY3RpdmVcIixcbiAgICBJU0xBTkRfU0xFRVBJTkc6IFwiaXNsYW5kU2xlZXBpbmdcIixcbiAgICBXQU5UU19ERUFDVElWQVRJT046IFwid2FudHNEZWFjdGl2YXRpb25cIixcbiAgICBESVNBQkxFX0RFQUNUSVZBVElPTjogXCJkaXNhYmxlRGVhY3RpdmF0aW9uXCIsXG4gICAgRElTQUJMRV9TSU1VTEFUSU9OOiBcImRpc2FibGVTaW11bGF0aW9uXCJcbiAgfSxcbiAgQ09MTElTSU9OX0ZMQUc6IHtcbiAgICBTVEFUSUNfT0JKRUNUOiAxLFxuICAgIEtJTkVNQVRJQ19PQkpFQ1Q6IDIsXG4gICAgTk9fQ09OVEFDVF9SRVNQT05TRTogNCxcbiAgICBDVVNUT01fTUFURVJJQUxfQ0FMTEJBQ0s6IDgsIC8vdGhpcyBhbGxvd3MgcGVyLXRyaWFuZ2xlIG1hdGVyaWFsIChmcmljdGlvbi9yZXN0aXR1dGlvbilcbiAgICBDSEFSQUNURVJfT0JKRUNUOiAxNixcbiAgICBESVNBQkxFX1ZJU1VBTElaRV9PQkpFQ1Q6IDMyLCAvL2Rpc2FibGUgZGVidWcgZHJhd2luZ1xuICAgIERJU0FCTEVfU1BVX0NPTExJU0lPTl9QUk9DRVNTSU5HOiA2NCAvL2Rpc2FibGUgcGFyYWxsZWwvU1BVIHByb2Nlc3NpbmdcbiAgfSxcbiAgVFlQRToge1xuICAgIFNUQVRJQzogXCJzdGF0aWNcIixcbiAgICBEWU5BTUlDOiBcImR5bmFtaWNcIixcbiAgICBLSU5FTUFUSUM6IFwia2luZW1hdGljXCJcbiAgfSxcbiAgU0hBUEU6IHtcbiAgICBCT1g6IFwiYm94XCIsXG4gICAgQ1lMSU5ERVI6IFwiY3lsaW5kZXJcIixcbiAgICBTUEhFUkU6IFwic3BoZXJlXCIsXG4gICAgQ0FQU1VMRTogXCJjYXBzdWxlXCIsXG4gICAgQ09ORTogXCJjb25lXCIsXG4gICAgSFVMTDogXCJodWxsXCIsXG4gICAgSEFDRDogXCJoYWNkXCIsXG4gICAgVkhBQ0Q6IFwidmhhY2RcIixcbiAgICBNRVNIOiBcIm1lc2hcIixcbiAgICBIRUlHSFRGSUVMRDogXCJoZWlnaHRmaWVsZFwiXG4gIH0sXG4gIEZJVDoge1xuICAgIEFMTDogXCJhbGxcIixcbiAgICBNQU5VQUw6IFwibWFudWFsXCJcbiAgfSxcbiAgQ09OU1RSQUlOVDoge1xuICAgIExPQ0s6IFwibG9ja1wiLFxuICAgIEZJWEVEOiBcImZpeGVkXCIsXG4gICAgU1BSSU5HOiBcInNwcmluZ1wiLFxuICAgIFNMSURFUjogXCJzbGlkZXJcIixcbiAgICBISU5HRTogXCJoaW5nZVwiLFxuICAgIENPTkVfVFdJU1Q6IFwiY29uZVR3aXN0XCIsXG4gICAgUE9JTlRfVE9fUE9JTlQ6IFwicG9pbnRUb1BvaW50XCJcbiAgfVxufTtcbiIsIi8qIGdsb2JhbCBUSFJFRSAqL1xuY29uc3QgRHJpdmVyID0gcmVxdWlyZShcIi4vZHJpdmVyXCIpO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LkFtbW9Nb2R1bGUgPSB3aW5kb3cuQW1tbztcbiAgd2luZG93LkFtbW8gPSBudWxsO1xufVxuXG5jb25zdCBFUFMgPSAxMGUtNjtcblxuZnVuY3Rpb24gQW1tb0RyaXZlcigpIHtcbiAgdGhpcy5jb2xsaXNpb25Db25maWd1cmF0aW9uID0gbnVsbDtcbiAgdGhpcy5kaXNwYXRjaGVyID0gbnVsbDtcbiAgdGhpcy5icm9hZHBoYXNlID0gbnVsbDtcbiAgdGhpcy5zb2x2ZXIgPSBudWxsO1xuICB0aGlzLnBoeXNpY3NXb3JsZCA9IG51bGw7XG4gIHRoaXMuZGVidWdEcmF3ZXIgPSBudWxsO1xuXG4gIHRoaXMuZWxzID0gbmV3IE1hcCgpO1xuICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gIHRoaXMuY29sbGlzaW9ucyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5jb2xsaXNpb25LZXlzID0gW107XG4gIHRoaXMuY3VycmVudENvbGxpc2lvbnMgPSBuZXcgTWFwKCk7XG59XG5cbkFtbW9Ecml2ZXIucHJvdG90eXBlID0gbmV3IERyaXZlcigpO1xuQW1tb0RyaXZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbW1vRHJpdmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFtbW9Ecml2ZXI7XG5cbi8qIEBwYXJhbSB7b2JqZWN0fSB3b3JsZENvbmZpZyAqL1xuQW1tb0RyaXZlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdvcmxkQ29uZmlnKSB7XG4gIC8vRW1zY3JpcHRlbiBkb2Vzbid0IHVzZSByZWFsIHByb21pc2VzLCBqdXN0IGEgLnRoZW4oKSBjYWxsYmFjaywgc28gaXQgbmVjZXNzYXJ5IHRvIHdyYXAgaW4gYSByZWFsIHByb21pc2UuXG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBBbW1vTW9kdWxlKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgQW1tbyA9IHJlc3VsdDtcbiAgICAgIHRoaXMuZXBzaWxvbiA9IHdvcmxkQ29uZmlnLmVwc2lsb24gfHwgRVBTO1xuICAgICAgdGhpcy5kZWJ1Z0RyYXdNb2RlID0gd29ybGRDb25maWcuZGVidWdEcmF3TW9kZSB8fCBUSFJFRS5BbW1vRGVidWdDb25zdGFudHMuTm9EZWJ1ZztcbiAgICAgIHRoaXMubWF4U3ViU3RlcHMgPSB3b3JsZENvbmZpZy5tYXhTdWJTdGVwcyB8fCA0O1xuICAgICAgdGhpcy5maXhlZFRpbWVTdGVwID0gd29ybGRDb25maWcuZml4ZWRUaW1lU3RlcCB8fCAxIC8gNjA7XG4gICAgICB0aGlzLmNvbGxpc2lvbkNvbmZpZ3VyYXRpb24gPSBuZXcgQW1tby5idERlZmF1bHRDb2xsaXNpb25Db25maWd1cmF0aW9uKCk7XG4gICAgICB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgQW1tby5idENvbGxpc2lvbkRpc3BhdGNoZXIodGhpcy5jb2xsaXNpb25Db25maWd1cmF0aW9uKTtcbiAgICAgIHRoaXMuYnJvYWRwaGFzZSA9IG5ldyBBbW1vLmJ0RGJ2dEJyb2FkcGhhc2UoKTtcbiAgICAgIHRoaXMuc29sdmVyID0gbmV3IEFtbW8uYnRTZXF1ZW50aWFsSW1wdWxzZUNvbnN0cmFpbnRTb2x2ZXIoKTtcbiAgICAgIHRoaXMucGh5c2ljc1dvcmxkID0gbmV3IEFtbW8uYnREaXNjcmV0ZUR5bmFtaWNzV29ybGQoXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlcixcbiAgICAgICAgdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICB0aGlzLnNvbHZlcixcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Db25maWd1cmF0aW9uXG4gICAgICApO1xuICAgICAgdGhpcy5waHlzaWNzV29ybGQuc2V0Rm9yY2VVcGRhdGVBbGxBYWJicyhmYWxzZSk7XG4gICAgICB0aGlzLnBoeXNpY3NXb3JsZC5zZXRHcmF2aXR5KFxuICAgICAgICBuZXcgQW1tby5idFZlY3RvcjMoMCwgd29ybGRDb25maWcuaGFzT3duUHJvcGVydHkoXCJncmF2aXR5XCIpID8gd29ybGRDb25maWcuZ3Jhdml0eSA6IC05LjgsIDApXG4gICAgICApO1xuICAgICAgdGhpcy5waHlzaWNzV29ybGQuZ2V0U29sdmVySW5mbygpLnNldF9tX251bUl0ZXJhdGlvbnMod29ybGRDb25maWcuc29sdmVySXRlcmF0aW9ucyk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyogQHBhcmFtIHtBbW1vLmJ0Q29sbGlzaW9uT2JqZWN0fSBib2R5ICovXG5BbW1vRHJpdmVyLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24oYm9keSwgZ3JvdXAsIG1hc2spIHtcbiAgdGhpcy5waHlzaWNzV29ybGQuYWRkUmlnaWRCb2R5KGJvZHksIGdyb3VwLCBtYXNrKTtcbiAgdGhpcy5lbHMuc2V0KEFtbW8uZ2V0UG9pbnRlcihib2R5KSwgYm9keS5lbCk7XG59O1xuXG4vKiBAcGFyYW0ge0FtbW8uYnRDb2xsaXNpb25PYmplY3R9IGJvZHkgKi9cbkFtbW9Ecml2ZXIucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gIHRoaXMucGh5c2ljc1dvcmxkLnJlbW92ZVJpZ2lkQm9keShib2R5KTtcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGJvZHkpO1xuICBjb25zdCBib2R5cHRyID0gQW1tby5nZXRQb2ludGVyKGJvZHkpO1xuICB0aGlzLmVscy5kZWxldGUoYm9keXB0cik7XG4gIHRoaXMuY29sbGlzaW9ucy5kZWxldGUoYm9keXB0cik7XG4gIHRoaXMuY29sbGlzaW9uS2V5cy5zcGxpY2UodGhpcy5jb2xsaXNpb25LZXlzLmluZGV4T2YoYm9keXB0ciksIDEpO1xuICB0aGlzLmN1cnJlbnRDb2xsaXNpb25zLmRlbGV0ZShib2R5cHRyKTtcbn07XG5cbkFtbW9Ecml2ZXIucHJvdG90eXBlLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gIGlmICh0aGlzLmVscy5oYXMoQW1tby5nZXRQb2ludGVyKGJvZHkpKSkge1xuICAgIHRoaXMucGh5c2ljc1dvcmxkLnVwZGF0ZVNpbmdsZUFhYmIoYm9keSk7XG4gIH1cbn07XG5cbi8qIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgKi9cbkFtbW9Ecml2ZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihkZWx0YVRpbWUpIHtcbiAgdGhpcy5waHlzaWNzV29ybGQuc3RlcFNpbXVsYXRpb24oZGVsdGFUaW1lLCB0aGlzLm1heFN1YlN0ZXBzLCB0aGlzLmZpeGVkVGltZVN0ZXApO1xuXG4gIGNvbnN0IG51bU1hbmlmb2xkcyA9IHRoaXMuZGlzcGF0Y2hlci5nZXROdW1NYW5pZm9sZHMoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NYW5pZm9sZHM7IGkrKykge1xuICAgIGNvbnN0IHBlcnNpc3RlbnRNYW5pZm9sZCA9IHRoaXMuZGlzcGF0Y2hlci5nZXRNYW5pZm9sZEJ5SW5kZXhJbnRlcm5hbChpKTtcbiAgICBjb25zdCBudW1Db250YWN0cyA9IHBlcnNpc3RlbnRNYW5pZm9sZC5nZXROdW1Db250YWN0cygpO1xuICAgIGNvbnN0IGJvZHkwcHRyID0gQW1tby5nZXRQb2ludGVyKHBlcnNpc3RlbnRNYW5pZm9sZC5nZXRCb2R5MCgpKTtcbiAgICBjb25zdCBib2R5MXB0ciA9IEFtbW8uZ2V0UG9pbnRlcihwZXJzaXN0ZW50TWFuaWZvbGQuZ2V0Qm9keTEoKSk7XG4gICAgbGV0IGNvbGxpZGVkID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNvbnRhY3RzOyBqKyspIHtcbiAgICAgIGNvbnN0IG1hbmlmb2xkUG9pbnQgPSBwZXJzaXN0ZW50TWFuaWZvbGQuZ2V0Q29udGFjdFBvaW50KGopO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBtYW5pZm9sZFBvaW50LmdldERpc3RhbmNlKCk7XG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdGhpcy5lcHNpbG9uKSB7XG4gICAgICAgIGNvbGxpZGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbGxpZGVkKSB7XG4gICAgICBpZiAoIXRoaXMuY29sbGlzaW9ucy5oYXMoYm9keTBwdHIpKSB7XG4gICAgICAgIHRoaXMuY29sbGlzaW9ucy5zZXQoYm9keTBwdHIsIFtdKTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25LZXlzLnB1c2goYm9keTBwdHIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29sbGlzaW9ucy5nZXQoYm9keTBwdHIpLmluZGV4T2YoYm9keTFwdHIpID09PSAtMSkge1xuICAgICAgICB0aGlzLmNvbGxpc2lvbnMuZ2V0KGJvZHkwcHRyKS5wdXNoKGJvZHkxcHRyKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihib2R5MHB0cikgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5lbHMuZ2V0KGJvZHkwcHRyKS5lbWl0KFwiY29sbGlkZXN0YXJ0XCIsIHsgdGFyZ2V0RWw6IHRoaXMuZWxzLmdldChib2R5MXB0cikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihib2R5MXB0cikgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5lbHMuZ2V0KGJvZHkxcHRyKS5lbWl0KFwiY29sbGlkZXN0YXJ0XCIsIHsgdGFyZ2V0RWw6IHRoaXMuZWxzLmdldChib2R5MHB0cikgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jdXJyZW50Q29sbGlzaW9ucy5oYXMoYm9keTBwdHIpKSB7XG4gICAgICAgIHRoaXMuY3VycmVudENvbGxpc2lvbnMuc2V0KGJvZHkwcHRyLCBuZXcgU2V0KCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Q29sbGlzaW9ucy5nZXQoYm9keTBwdHIpLmFkZChib2R5MXB0cik7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxpc2lvbktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBib2R5MHB0ciA9IHRoaXMuY29sbGlzaW9uS2V5c1tpXTtcbiAgICBjb25zdCBib2R5MXB0cnMgPSB0aGlzLmNvbGxpc2lvbnMuZ2V0KGJvZHkwcHRyKTtcbiAgICBmb3IgKGxldCBqID0gYm9keTFwdHJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBjb25zdCBib2R5MXB0ciA9IGJvZHkxcHRyc1tqXTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRDb2xsaXNpb25zLmdldChib2R5MHB0cikuaGFzKGJvZHkxcHRyKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmluZGV4T2YoYm9keTBwdHIpICE9PSAtMSkge1xuICAgICAgICB0aGlzLmVscy5nZXQoYm9keTBwdHIpLmVtaXQoXCJjb2xsaWRlZW5kXCIsIHsgdGFyZ2V0RWw6IHRoaXMuZWxzLmdldChib2R5MXB0cikgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ldmVudExpc3RlbmVycy5pbmRleE9mKGJvZHkxcHRyKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbHMuZ2V0KGJvZHkxcHRyKS5lbWl0KFwiY29sbGlkZWVuZFwiLCB7IHRhcmdldEVsOiB0aGlzLmVscy5nZXQoYm9keTBwdHIpIH0pO1xuICAgICAgfVxuICAgICAgYm9keTFwdHJzLnNwbGljZShqLCAxKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50Q29sbGlzaW9ucy5nZXQoYm9keTBwdHIpLmNsZWFyKCk7XG4gIH1cblxuICBpZiAodGhpcy5kZWJ1Z0RyYXdlcikge1xuICAgIHRoaXMuZGVidWdEcmF3ZXIudXBkYXRlKCk7XG4gIH1cbn07XG5cbi8qIEBwYXJhbSB7P30gY29uc3RyYWludCAqL1xuQW1tb0RyaXZlci5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpIHtcbiAgdGhpcy5waHlzaWNzV29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50LCBmYWxzZSk7XG59O1xuXG4vKiBAcGFyYW0gez99IGNvbnN0cmFpbnQgKi9cbkFtbW9Ecml2ZXIucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb25zdHJhaW50KSB7XG4gIHRoaXMucGh5c2ljc1dvcmxkLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludCk7XG59O1xuXG4vKiBAcGFyYW0ge0FtbW8uYnRDb2xsaXNpb25PYmplY3R9IGJvZHkgKi9cbkFtbW9Ecml2ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihib2R5KSB7XG4gIHRoaXMuZXZlbnRMaXN0ZW5lcnMucHVzaChBbW1vLmdldFBvaW50ZXIoYm9keSkpO1xufTtcblxuLyogQHBhcmFtIHtBbW1vLmJ0Q29sbGlzaW9uT2JqZWN0fSBib2R5ICovXG5BbW1vRHJpdmVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oYm9keSkge1xuICBjb25zdCBwdHIgPSBBbW1vLmdldFBvaW50ZXIoYm9keSk7XG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmluZGV4T2YocHRyKSAhPT0gLTEpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNwbGljZSh0aGlzLmV2ZW50TGlzdGVuZXJzLmluZGV4T2YocHRyKSwgMSk7XG4gIH1cbn07XG5cbkFtbW9Ecml2ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgQW1tby5kZXN0cm95KHRoaXMuY29sbGlzaW9uQ29uZmlndXJhdGlvbik7XG4gIEFtbW8uZGVzdHJveSh0aGlzLmRpc3BhdGNoZXIpO1xuICBBbW1vLmRlc3Ryb3kodGhpcy5icm9hZHBoYXNlKTtcbiAgQW1tby5kZXN0cm95KHRoaXMuc29sdmVyKTtcbiAgQW1tby5kZXN0cm95KHRoaXMucGh5c2ljc1dvcmxkKTtcbiAgQW1tby5kZXN0cm95KHRoaXMuZGVidWdEcmF3ZXIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RIUkVFLlNjZW5lfSBzY2VuZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuQW1tb0RyaXZlci5wcm90b3R5cGUuZ2V0RGVidWdEcmF3ZXIgPSBmdW5jdGlvbihzY2VuZSwgb3B0aW9ucykge1xuICBpZiAoIXRoaXMuZGVidWdEcmF3ZXIpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRlYnVnRHJhd01vZGUgPSBvcHRpb25zLmRlYnVnRHJhd01vZGUgfHwgdGhpcy5kZWJ1Z0RyYXdNb2RlO1xuICAgIHRoaXMuZGVidWdEcmF3ZXIgPSBuZXcgVEhSRUUuQW1tb0RlYnVnRHJhd2VyKHNjZW5lLCB0aGlzLnBoeXNpY3NXb3JsZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGVidWdEcmF3ZXI7XG59O1xuIiwiLyoqXG4gKiBEcml2ZXIgLSBkZWZpbmVzIGxpbWl0ZWQgQVBJIHRvIGxvY2FsIGFuZCByZW1vdGUgcGh5c2ljcyBjb250cm9sbGVycy5cbiAqL1xuXG5mdW5jdGlvbiBEcml2ZXIgKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBEcml2ZXI7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIExpZmVjeWNsZVxuICovXG5cbi8qIEBwYXJhbSB7b2JqZWN0fSB3b3JsZENvbmZpZyAqL1xuRHJpdmVyLnByb3RvdHlwZS5pbml0ID0gYWJzdHJhY3RNZXRob2Q7XG5cbi8qIEBwYXJhbSB7bnVtYmVyfSBkZWx0YU1TICovXG5Ecml2ZXIucHJvdG90eXBlLnN0ZXAgPSBhYnN0cmFjdE1ldGhvZDtcblxuRHJpdmVyLnByb3RvdHlwZS5kZXN0cm95ID0gYWJzdHJhY3RNZXRob2Q7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEJvZGllc1xuICovXG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkJvZHl9IGJvZHkgKi9cbkRyaXZlci5wcm90b3R5cGUuYWRkQm9keSA9IGFic3RyYWN0TWV0aG9kO1xuXG4vKiBAcGFyYW0ge0NBTk5PTi5Cb2R5fSBib2R5ICovXG5Ecml2ZXIucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBhYnN0cmFjdE1ldGhvZDtcblxuLyoqXG4gKiBAcGFyYW0ge0NBTk5PTi5Cb2R5fSBib2R5XG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICovXG5Ecml2ZXIucHJvdG90eXBlLmFwcGx5Qm9keU1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuXG4vKiogQHBhcmFtIHtDQU5OT04uQm9keX0gYm9keSAqL1xuRHJpdmVyLnByb3RvdHlwZS51cGRhdGVCb2R5UHJvcGVydGllcyA9IGFic3RyYWN0TWV0aG9kO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNYXRlcmlhbHNcbiAqL1xuXG4vKiogQHBhcmFtIHtvYmplY3R9IG1hdGVyaWFsQ29uZmlnICovXG5Ecml2ZXIucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gYWJzdHJhY3RNZXRob2Q7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hdGVyaWFsTmFtZTFcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRlcmlhbE5hbWUyXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGFjdE1hdGVyaWFsQ29uZmlnXG4gKi9cbkRyaXZlci5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gYWJzdHJhY3RNZXRob2Q7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvbnN0cmFpbnRzXG4gKi9cblxuLyogQHBhcmFtIHtDQU5OT04uQ29uc3RyYWludH0gY29uc3RyYWludCAqL1xuRHJpdmVyLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gYWJzdHJhY3RNZXRob2Q7XG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkNvbnN0cmFpbnR9IGNvbnN0cmFpbnQgKi9cbkRyaXZlci5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGFic3RyYWN0TWV0aG9kO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb250YWN0c1xuICovXG5cbi8qKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSAqL1xuRHJpdmVyLnByb3RvdHlwZS5nZXRDb250YWN0cyA9IGFic3RyYWN0TWV0aG9kO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIElOSVQ6ICdpbml0JyxcbiAgU1RFUDogJ3N0ZXAnLFxuXG4gIC8vIEJvZGllcy5cbiAgQUREX0JPRFk6ICdhZGQtYm9keScsXG4gIFJFTU9WRV9CT0RZOiAncmVtb3ZlLWJvZHknLFxuICBBUFBMWV9CT0RZX01FVEhPRDogJ2FwcGx5LWJvZHktbWV0aG9kJyxcbiAgVVBEQVRFX0JPRFlfUFJPUEVSVElFUzogJ3VwZGF0ZS1ib2R5LXByb3BlcnRpZXMnLFxuXG4gIC8vIE1hdGVyaWFscy5cbiAgQUREX01BVEVSSUFMOiAnYWRkLW1hdGVyaWFsJyxcbiAgQUREX0NPTlRBQ1RfTUFURVJJQUw6ICdhZGQtY29udGFjdC1tYXRlcmlhbCcsXG5cbiAgLy8gQ29uc3RyYWludHMuXG4gIEFERF9DT05TVFJBSU5UOiAnYWRkLWNvbnN0cmFpbnQnLFxuICBSRU1PVkVfQ09OU1RSQUlOVDogJ3JlbW92ZS1jb25zdHJhaW50JyxcblxuICAvLyBFdmVudHMuXG4gIENPTExJREU6ICdjb2xsaWRlJ1xufTtcbiIsInZhciBDQU5OT04gPSByZXF1aXJlKCdjYW5ub24tZXMnKSxcbiAgICBEcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpO1xuXG5mdW5jdGlvbiBMb2NhbERyaXZlciAoKSB7XG4gIHRoaXMud29ybGQgPSBudWxsO1xuICB0aGlzLm1hdGVyaWFscyA9IHt9O1xuICB0aGlzLmNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XG59XG5cbkxvY2FsRHJpdmVyLnByb3RvdHlwZSA9IG5ldyBEcml2ZXIoKTtcbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvY2FsRHJpdmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRHJpdmVyO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBMaWZlY3ljbGVcbiAqL1xuXG4vKiBAcGFyYW0ge29iamVjdH0gd29ybGRDb25maWcgKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHdvcmxkQ29uZmlnKSB7XG4gIHZhciB3b3JsZCA9IG5ldyBDQU5OT04uV29ybGQoKTtcbiAgd29ybGQucXVhdE5vcm1hbGl6ZVNraXAgPSB3b3JsZENvbmZpZy5xdWF0Tm9ybWFsaXplU2tpcDtcbiAgd29ybGQucXVhdE5vcm1hbGl6ZUZhc3QgPSB3b3JsZENvbmZpZy5xdWF0Tm9ybWFsaXplRmFzdDtcbiAgd29ybGQuc29sdmVyLml0ZXJhdGlvbnMgPSB3b3JsZENvbmZpZy5zb2x2ZXJJdGVyYXRpb25zO1xuICB3b3JsZC5ncmF2aXR5LnNldCgwLCB3b3JsZENvbmZpZy5ncmF2aXR5LCAwKTtcbiAgd29ybGQuYnJvYWRwaGFzZSA9IG5ldyBDQU5OT04uTmFpdmVCcm9hZHBoYXNlKCk7XG5cbiAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyogQHBhcmFtIHtudW1iZXJ9IGRlbHRhTVMgKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGRlbHRhTVMpIHtcbiAgdGhpcy53b3JsZC5zdGVwKGRlbHRhTVMpO1xufTtcblxuTG9jYWxEcml2ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGRlbGV0ZSB0aGlzLndvcmxkO1xuICBkZWxldGUgdGhpcy5jb250YWN0TWF0ZXJpYWw7XG4gIHRoaXMubWF0ZXJpYWxzID0ge307XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBCb2RpZXNcbiAqL1xuXG4vKiBAcGFyYW0ge0NBTk5PTi5Cb2R5fSBib2R5ICovXG5Mb2NhbERyaXZlci5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHRoaXMud29ybGQuYWRkQm9keShib2R5KTtcbn07XG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkJvZHl9IGJvZHkgKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgdGhpcy53b3JsZC5yZW1vdmVCb2R5KGJvZHkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0NBTk5PTi5Cb2R5fSBib2R5XG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICovXG5Mb2NhbERyaXZlci5wcm90b3R5cGUuYXBwbHlCb2R5TWV0aG9kID0gZnVuY3Rpb24gKGJvZHksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgYm9keVsnX18nICsgbWV0aG9kTmFtZV0uYXBwbHkoYm9keSwgYXJncyk7XG59O1xuXG4vKiogQHBhcmFtIHtDQU5OT04uQm9keX0gYm9keSAqL1xuTG9jYWxEcml2ZXIucHJvdG90eXBlLnVwZGF0ZUJvZHlQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge307XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1hdGVyaWFsc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NBTk5PTi5NYXRlcmlhbH1cbiAqL1xuTG9jYWxEcml2ZXIucHJvdG90eXBlLmdldE1hdGVyaWFsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWF0ZXJpYWxzW25hbWVdO1xufTtcblxuLyoqIEBwYXJhbSB7b2JqZWN0fSBtYXRlcmlhbENvbmZpZyAqL1xuTG9jYWxEcml2ZXIucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24gKG1hdGVyaWFsQ29uZmlnKSB7XG4gIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsQ29uZmlnLm5hbWVdID0gbmV3IENBTk5PTi5NYXRlcmlhbChtYXRlcmlhbENvbmZpZyk7XG4gIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsQ29uZmlnLm5hbWVdLm5hbWUgPSBtYXRlcmlhbENvbmZpZy5uYW1lO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF0TmFtZTFcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXROYW1lMlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRhY3RNYXRlcmlhbENvbmZpZ1xuICovXG5Mb2NhbERyaXZlci5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKG1hdE5hbWUxLCBtYXROYW1lMiwgY29udGFjdE1hdGVyaWFsQ29uZmlnKSB7XG4gIHZhciBtYXQxID0gdGhpcy5tYXRlcmlhbHNbbWF0TmFtZTFdLFxuICAgICAgbWF0MiA9IHRoaXMubWF0ZXJpYWxzW21hdE5hbWUyXTtcbiAgdGhpcy5jb250YWN0TWF0ZXJpYWwgPSBuZXcgQ0FOTk9OLkNvbnRhY3RNYXRlcmlhbChtYXQxLCBtYXQyLCBjb250YWN0TWF0ZXJpYWxDb25maWcpO1xuICB0aGlzLndvcmxkLmFkZENvbnRhY3RNYXRlcmlhbCh0aGlzLmNvbnRhY3RNYXRlcmlhbCk7XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb25zdHJhaW50c1xuICovXG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkNvbnN0cmFpbnR9IGNvbnN0cmFpbnQgKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgaWYgKCFjb25zdHJhaW50LnR5cGUpIHtcbiAgICBpZiAoY29uc3RyYWludCBpbnN0YW5jZW9mIENBTk5PTi5Mb2NrQ29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWludC50eXBlID0gJ0xvY2tDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uRGlzdGFuY2VDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnRGlzdGFuY2VDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uSGluZ2VDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnSGluZ2VDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uQ29uZVR3aXN0Q29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWludC50eXBlID0gJ0NvbmVUd2lzdENvbnN0cmFpbnQnO1xuICAgIH0gZWxzZSBpZiAoY29uc3RyYWludCBpbnN0YW5jZW9mIENBTk5PTi5Qb2ludFRvUG9pbnRDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnUG9pbnRUb1BvaW50Q29uc3RyYWludCc7XG4gICAgfVxuICB9XG4gIHRoaXMud29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbn07XG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkNvbnN0cmFpbnR9IGNvbnN0cmFpbnQgKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgdGhpcy53b3JsZC5yZW1vdmVDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29udGFjdHNcbiAqL1xuXG4vKiogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn0gKi9cbkxvY2FsRHJpdmVyLnByb3RvdHlwZS5nZXRDb250YWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud29ybGQuY29udGFjdHM7XG59O1xuIiwidmFyIERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyJyk7XG5cbmZ1bmN0aW9uIE5ldHdvcmtEcml2ZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1tOZXR3b3JrRHJpdmVyXSBEcml2ZXIgbm90IGltcGxlbWVudGVkLicpO1xufVxuXG5OZXR3b3JrRHJpdmVyLnByb3RvdHlwZSA9IG5ldyBEcml2ZXIoKTtcbk5ldHdvcmtEcml2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmV0d29ya0RyaXZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrRHJpdmVyO1xuIiwiLyoqXG4gKiBTdHViIHZlcnNpb24gb2Ygd2Vid29ya2lmeSwgZm9yIGRlYnVnZ2luZyBjb2RlIG91dHNpZGUgb2YgYSB3ZWJ3b3JrZXIuXG4gKi9cbmZ1bmN0aW9uIHdlYndvcmtpZnlEZWJ1ZyAod29ya2VyKSB7XG4gIHZhciB0YXJnZXRBID0gbmV3IEV2ZW50VGFyZ2V0KCksXG4gICAgICB0YXJnZXRCID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG5cbiAgdGFyZ2V0QS5zZXRUYXJnZXQodGFyZ2V0Qik7XG4gIHRhcmdldEIuc2V0VGFyZ2V0KHRhcmdldEEpO1xuXG4gIHdvcmtlcih0YXJnZXRBKTtcbiAgcmV0dXJuIHRhcmdldEI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2Vid29ya2lmeURlYnVnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFdmVudFRhcmdldFxuICovXG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0ICgpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKGZuKTtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmxpc3RlbmVyc1tpXShldmVudCk7XG4gIH1cbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudCgnbWVzc2FnZScsIHtkYXRhOiBtc2d9KTtcbn07XG4iLCIvKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cblxudmFyIHdlYndvcmtpZnkgPSByZXF1aXJlKCd3ZWJ3b3JraWZ5LXdlYnBhY2snKSxcbiAgICB3ZWJ3b3JraWZ5RGVidWcgPSByZXF1aXJlKCcuL3dlYndvcmtpZnktZGVidWcnKSxcbiAgICBEcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpLFxuICAgIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpLFxuICAgIHdvcmtlciA9IHJlcXVpcmUoJy4vd29ya2VyJyksXG4gICAgcHJvdG9jb2wgPSByZXF1aXJlKCcuLi91dGlscy9wcm90b2NvbCcpO1xuXG52YXIgSUQgPSBwcm90b2NvbC5JRDtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBXb3JrZXJEcml2ZXIgKG9wdGlvbnMpIHtcbiAgdGhpcy5mcHMgPSBvcHRpb25zLmZwcztcbiAgdGhpcy5lbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcbiAgdGhpcy5pbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGU7XG4gIC8vIEFwcHJveGltYXRlIG51bWJlciBvZiBwaHlzaWNzIHN0ZXBzIHRvICdwYWQnIHJlbmRlcmluZy5cbiAgdGhpcy5pbnRlcnBCdWZmZXJTaXplID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uQnVmZmVyU2l6ZTtcbiAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgdGhpcy5ib2RpZXMgPSB7fTtcbiAgdGhpcy5jb250YWN0cyA9IFtdO1xuXG4gIC8vIGh0dHBzOi8vZ2FmZmVyb25nYW1lcy5jb20vcG9zdC9zbmFwc2hvdF9pbnRlcnBvbGF0aW9uL1xuICB0aGlzLmZyYW1lRGVsYXkgPSB0aGlzLmludGVycEJ1ZmZlclNpemUgKiAxMDAwIC8gdGhpcy5mcHM7XG4gIHRoaXMuZnJhbWVCdWZmZXIgPSBbXTtcblxuICB0aGlzLndvcmtlciA9IHRoaXMuZGVidWdcbiAgICA/IHdlYndvcmtpZnlEZWJ1Zyh3b3JrZXIpXG4gICAgOiB3ZWJ3b3JraWZ5KHdvcmtlcik7XG4gIHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG59XG5cbldvcmtlckRyaXZlci5wcm90b3R5cGUgPSBuZXcgRHJpdmVyKCk7XG5Xb3JrZXJEcml2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV29ya2VyRHJpdmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlckRyaXZlcjtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTGlmZWN5Y2xlXG4gKi9cblxuLyogQHBhcmFtIHtvYmplY3R9IHdvcmxkQ29uZmlnICovXG5Xb3JrZXJEcml2ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAod29ybGRDb25maWcpIHtcbiAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IEV2ZW50LklOSVQsXG4gICAgd29ybGRDb25maWc6IHdvcmxkQ29uZmlnLFxuICAgIGZwczogdGhpcy5mcHMsXG4gICAgZW5naW5lOiB0aGlzLmVuZ2luZVxuICB9KTtcbn07XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIG9uZSBzdGVwLCBpZiBpbnRlcnBvbGF0aW9uIGlzIGVuYWJsZWQuXG4gKiBJZiBkaXNhYmxlZCwgaW5jcmVtZW50cyBhcmUgcGVyZm9ybWVkIGFzIG1lc3NhZ2VzIGFycml2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YU1TXG4gKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmludGVycG9sYXRlKSByZXR1cm47XG5cbiAgLy8gR2V0IHRoZSB0d28gb2xkZXN0IGZyYW1lcyB0aGF0IGhhdmVuJ3QgZXhwaXJlZC4gSWRlYWxseSB3ZSB3b3VsZCB1c2UgYWxsXG4gIC8vIGF2YWlsYWJsZSBmcmFtZXMgdG8ga2VlcCB0aGluZ3Mgc21vb3RoLCBidXQgbGVycGluZyBpcyBlYXNpZXIgYW5kIGZhc3Rlci5cbiAgdmFyIHByZXZGcmFtZSA9IHRoaXMuZnJhbWVCdWZmZXJbMF07XG4gIHZhciBuZXh0RnJhbWUgPSB0aGlzLmZyYW1lQnVmZmVyWzFdO1xuICB2YXIgdGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIHdoaWxlIChwcmV2RnJhbWUgJiYgbmV4dEZyYW1lICYmIHRpbWVzdGFtcCAtIHByZXZGcmFtZS50aW1lc3RhbXAgPiB0aGlzLmZyYW1lRGVsYXkpIHtcbiAgICB0aGlzLmZyYW1lQnVmZmVyLnNoaWZ0KCk7XG4gICAgcHJldkZyYW1lID0gdGhpcy5mcmFtZUJ1ZmZlclswXTtcbiAgICBuZXh0RnJhbWUgPSB0aGlzLmZyYW1lQnVmZmVyWzFdO1xuICB9XG5cbiAgaWYgKCFwcmV2RnJhbWUgfHwgIW5leHRGcmFtZSkgcmV0dXJuO1xuXG4gIHZhciBtaXggPSAodGltZXN0YW1wIC0gcHJldkZyYW1lLnRpbWVzdGFtcCkgLyB0aGlzLmZyYW1lRGVsYXk7XG4gIG1peCA9IChtaXggLSAoMSAtIDEgLyB0aGlzLmludGVycEJ1ZmZlclNpemUpKSAqIHRoaXMuaW50ZXJwQnVmZmVyU2l6ZTtcblxuICBmb3IgKHZhciBpZCBpbiBwcmV2RnJhbWUuYm9kaWVzKSB7XG4gICAgaWYgKHByZXZGcmFtZS5ib2RpZXMuaGFzT3duUHJvcGVydHkoaWQpICYmIG5leHRGcmFtZS5ib2RpZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBwcm90b2NvbC5kZXNlcmlhbGl6ZUludGVycEJvZHlVcGRhdGUoXG4gICAgICAgIHByZXZGcmFtZS5ib2RpZXNbaWRdLFxuICAgICAgICBuZXh0RnJhbWUuYm9kaWVzW2lkXSxcbiAgICAgICAgdGhpcy5ib2RpZXNbaWRdLFxuICAgICAgICBtaXhcbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5Xb3JrZXJEcml2ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICBkZWxldGUgdGhpcy53b3JrZXI7XG59O1xuXG4vKioge0V2ZW50fSBldmVudCAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChldmVudC5kYXRhLnR5cGUgPT09IEV2ZW50LlNURVApIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGEsXG4gICAgICAgIGJvZGllcyA9IGRhdGEuYm9kaWVzO1xuXG4gICAgdGhpcy5jb250YWN0cyA9IGV2ZW50LmRhdGEuY29udGFjdHM7XG5cbiAgICAvLyBJZiBpbnRlcnBvbGF0aW9uIGlzIGVuYWJsZWQsIHN0b3JlIHRoZSBmcmFtZS4gSWYgbm90LCB1cGRhdGUgYWxsIGJvZGllc1xuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLmludGVycG9sYXRlKSB7XG4gICAgICB0aGlzLmZyYW1lQnVmZmVyLnB1c2goe3RpbWVzdGFtcDogcGVyZm9ybWFuY2Uubm93KCksIGJvZGllczogYm9kaWVzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGlkIGluIGJvZGllcykge1xuICAgICAgICBpZiAoYm9kaWVzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHByb3RvY29sLmRlc2VyaWFsaXplQm9keVVwZGF0ZShib2RpZXNbaWRdLCB0aGlzLmJvZGllc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudC5DT0xMSURFKSB7XG4gICAgdmFyIGJvZHkgPSB0aGlzLmJvZGllc1tldmVudC5kYXRhLmJvZHlJRF07XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuYm9kaWVzW2V2ZW50LmRhdGEudGFyZ2V0SURdO1xuICAgIHZhciBjb250YWN0ID0gcHJvdG9jb2wuZGVzZXJpYWxpemVDb250YWN0KGV2ZW50LmRhdGEuY29udGFjdCwgdGhpcy5ib2RpZXMpO1xuICAgIGlmICghYm9keS5fbGlzdGVuZXJzIHx8ICFib2R5Ll9saXN0ZW5lcnMuY29sbGlkZSkgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5fbGlzdGVuZXJzLmNvbGxpZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvZHkuX2xpc3RlbmVycy5jb2xsaWRlW2ldKHt0YXJnZXQ6IHRhcmdldCwgYm9keTogYm9keSwgY29udGFjdDogY29udGFjdH0pO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignW1dvcmtlckRyaXZlcl0gVW5leHBlY3RlZCBtZXNzYWdlIHR5cGUuJyk7XG4gIH1cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEJvZGllc1xuICovXG5cbi8qIEBwYXJhbSB7Q0FOTk9OLkJvZHl9IGJvZHkgKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHByb3RvY29sLmFzc2lnbklEKCdib2R5JywgYm9keSk7XG4gIHRoaXMuYm9kaWVzW2JvZHlbSURdXSA9IGJvZHk7XG4gIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOiBFdmVudC5BRERfQk9EWSwgYm9keTogcHJvdG9jb2wuc2VyaWFsaXplQm9keShib2R5KX0pO1xufTtcblxuLyogQHBhcmFtIHtDQU5OT04uQm9keX0gYm9keSAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6IEV2ZW50LlJFTU9WRV9CT0RZLCBib2R5SUQ6IGJvZHlbSURdfSk7XG4gIGRlbGV0ZSB0aGlzLmJvZGllc1tib2R5W0lEXV07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Q0FOTk9OLkJvZHl9IGJvZHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUuYXBwbHlCb2R5TWV0aG9kID0gZnVuY3Rpb24gKGJvZHksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG4gICAgY2FzZSAnYXBwbHlGb3JjZSc6XG4gICAgY2FzZSAnYXBwbHlJbXB1bHNlJzpcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogRXZlbnQuQVBQTFlfQk9EWV9NRVRIT0QsXG4gICAgICAgIGJvZHlJRDogYm9keVtJRF0sXG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3M6IFthcmdzWzBdLnRvQXJyYXkoKSwgYXJnc1sxXS50b0FycmF5KCldXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbWV0aG9kTmFtZTogJXMnLCBtZXRob2ROYW1lKTtcbiAgfVxufTtcblxuLyoqIEBwYXJhbSB7Q0FOTk9OLkJvZHl9IGJvZHkgKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUudXBkYXRlQm9keVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYm9keSkge1xuICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgdHlwZTogRXZlbnQuVVBEQVRFX0JPRFlfUFJPUEVSVElFUyxcbiAgICBib2R5OiBwcm90b2NvbC5zZXJpYWxpemVCb2R5KGJvZHkpXG4gIH0pO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTWF0ZXJpYWxzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NBTk5PTi5NYXRlcmlhbH1cbiAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5nZXRNYXRlcmlhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vIE5vIGFjY2VzcyB0byBtYXRlcmlhbHMgaGVyZS4gRXZlbnR1YWxseSB3ZSBtaWdodCByZXR1cm4gdGhlIG5hbWUgb3IgSUQsIGlmXG4gIC8vIG11bHRpcGxlIG1hdGVyaWFscyB3ZXJlIHNlbGVjdGVkLCBidXQgZm9yIG5vdyB0aGVyZSdzIG9ubHkgb25lIGFuZCBpdCdzIHNhZmVcbiAgLy8gdG8gYXNzdW1lIHRoZSB3b3JrZXIgaXMgYWxyZWFkeSB1c2luZyBpdC5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWxDb25maWcgKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUuYWRkTWF0ZXJpYWwgPSBmdW5jdGlvbiAobWF0ZXJpYWxDb25maWcpIHtcbiAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6IEV2ZW50LkFERF9NQVRFUklBTCwgbWF0ZXJpYWxDb25maWc6IG1hdGVyaWFsQ29uZmlnfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXROYW1lMVxuICogQHBhcmFtIHtzdHJpbmd9IG1hdE5hbWUyXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGFjdE1hdGVyaWFsQ29uZmlnXG4gKi9cbldvcmtlckRyaXZlci5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKG1hdE5hbWUxLCBtYXROYW1lMiwgY29udGFjdE1hdGVyaWFsQ29uZmlnKSB7XG4gIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICB0eXBlOiBFdmVudC5BRERfQ09OVEFDVF9NQVRFUklBTCxcbiAgICBtYXRlcmlhbE5hbWUxOiBtYXROYW1lMSxcbiAgICBtYXRlcmlhbE5hbWUyOiBtYXROYW1lMixcbiAgICBjb250YWN0TWF0ZXJpYWxDb25maWc6IGNvbnRhY3RNYXRlcmlhbENvbmZpZ1xuICB9KTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvbnN0cmFpbnRzXG4gKi9cblxuLyogQHBhcmFtIHtDQU5OT04uQ29uc3RyYWludH0gY29uc3RyYWludCAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgaWYgKCFjb25zdHJhaW50LnR5cGUpIHtcbiAgICBpZiAoY29uc3RyYWludCBpbnN0YW5jZW9mIENBTk5PTi5Mb2NrQ29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWludC50eXBlID0gJ0xvY2tDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uRGlzdGFuY2VDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnRGlzdGFuY2VDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uSGluZ2VDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnSGluZ2VDb25zdHJhaW50JztcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnQgaW5zdGFuY2VvZiBDQU5OT04uQ29uZVR3aXN0Q29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWludC50eXBlID0gJ0NvbmVUd2lzdENvbnN0cmFpbnQnO1xuICAgIH0gZWxzZSBpZiAoY29uc3RyYWludCBpbnN0YW5jZW9mIENBTk5PTi5Qb2ludFRvUG9pbnRDb25zdHJhaW50KSB7XG4gICAgICBjb25zdHJhaW50LnR5cGUgPSAnUG9pbnRUb1BvaW50Q29uc3RyYWludCc7XG4gICAgfVxuICB9XG4gIHByb3RvY29sLmFzc2lnbklEKCdjb25zdHJhaW50JywgY29uc3RyYWludCk7XG4gIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICB0eXBlOiBFdmVudC5BRERfQ09OU1RSQUlOVCxcbiAgICBjb25zdHJhaW50OiBwcm90b2NvbC5zZXJpYWxpemVDb25zdHJhaW50KGNvbnN0cmFpbnQpXG4gIH0pO1xufTtcblxuLyogQHBhcmFtIHtDQU5OT04uQ29uc3RyYWludH0gY29uc3RyYWludCAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IEV2ZW50LlJFTU9WRV9DT05TVFJBSU5ULFxuICAgIGNvbnN0cmFpbnRJRDogY29uc3RyYWludFtJRF1cbiAgfSk7XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb250YWN0c1xuICovXG5cbi8qKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSAqL1xuV29ya2VyRHJpdmVyLnByb3RvdHlwZS5nZXRDb250YWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETyhkb25tY2N1cmR5KTogVGhlcmUncyBzb21lIHdhc3RlZCBtZW1vcnkgYWxsb2NhdGlvbiBoZXJlLlxuICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gIHJldHVybiB0aGlzLmNvbnRhY3RzLm1hcChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHJldHVybiBwcm90b2NvbC5kZXNlcmlhbGl6ZUNvbnRhY3QobWVzc2FnZSwgYm9kaWVzKTtcbiAgfSk7XG59O1xuIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpLFxuICAgIExvY2FsRHJpdmVyID0gcmVxdWlyZSgnLi9sb2NhbC1kcml2ZXInKSxcbiAgICBBbW1vRHJpdmVyID0gcmVxdWlyZSgnLi9hbW1vLWRyaXZlcicpLFxuICAgIHByb3RvY29sID0gcmVxdWlyZSgnLi4vdXRpbHMvcHJvdG9jb2wnKTtcblxudmFyIElEID0gcHJvdG9jb2wuSUQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgdmFyIGRyaXZlciA9IG51bGw7XG4gIHZhciBib2RpZXMgPSB7fTtcbiAgdmFyIGNvbnN0cmFpbnRzID0ge307XG4gIHZhciBzdGVwU2l6ZTtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgLy8gTGlmZWN5Y2xlLlxuICAgICAgY2FzZSBFdmVudC5JTklUOlxuICAgICAgICBkcml2ZXIgPSBkYXRhLmVuZ2luZSA9PT0gJ2Nhbm5vbidcbiAgICAgICAgICA/IG5ldyBMb2NhbERyaXZlcigpXG4gICAgICAgICAgOiBuZXcgQW1tb0RyaXZlcigpO1xuICAgICAgICBkcml2ZXIuaW5pdChkYXRhLndvcmxkQ29uZmlnKTtcbiAgICAgICAgc3RlcFNpemUgPSAxIC8gZGF0YS5mcHM7XG4gICAgICAgIHNldEludGVydmFsKHN0ZXAsIDEwMDAgLyBkYXRhLmZwcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBCb2RpZXMuXG4gICAgICBjYXNlIEV2ZW50LkFERF9CT0RZOlxuICAgICAgICB2YXIgYm9keSA9IHByb3RvY29sLmRlc2VyaWFsaXplQm9keShkYXRhLmJvZHkpO1xuICAgICAgICBib2R5Lm1hdGVyaWFsID0gZHJpdmVyLmdldE1hdGVyaWFsKCAnZGVmYXVsdE1hdGVyaWFsJyApO1xuICAgICAgICBib2RpZXNbYm9keVtJRF1dID0gYm9keTtcblxuICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbGxpZGUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBFdmVudC5DT0xMSURFLFxuICAgICAgICAgICAgYm9keUlEOiBldnQudGFyZ2V0W0lEXSwgLy8gc2V0IHRoZSB0YXJnZXQgYXMgdGhlIGJvZHkgdG8gYmUgaWRlbnRpY2FsIHRvIHRoZSBsb2NhbCBkcml2ZXJcbiAgICAgICAgICAgIHRhcmdldElEOiBldnQuYm9keVtJRF0sIC8vIHNldCB0aGUgYm9keSBhcyB0aGUgdGFyZ2V0IHRvIGJlIGlkZW50aWNhbCB0byB0aGUgbG9jYWwgZHJpdmVyXG4gICAgICAgICAgICBjb250YWN0OiBwcm90b2NvbC5zZXJpYWxpemVDb250YWN0KGV2dC5jb250YWN0KVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgZHJpdmVyLmFkZEJvZHkoYm9keSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFdmVudC5SRU1PVkVfQk9EWTpcbiAgICAgICAgZHJpdmVyLnJlbW92ZUJvZHkoYm9kaWVzW2RhdGEuYm9keUlEXSk7XG4gICAgICAgIGRlbGV0ZSBib2RpZXNbZGF0YS5ib2R5SURdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXZlbnQuQVBQTFlfQk9EWV9NRVRIT0Q6XG4gICAgICAgIGJvZGllc1tkYXRhLmJvZHlJRF1bZGF0YS5tZXRob2ROYW1lXShcbiAgICAgICAgICBwcm90b2NvbC5kZXNlcmlhbGl6ZVZlYzMoZGF0YS5hcmdzWzBdKSxcbiAgICAgICAgICBwcm90b2NvbC5kZXNlcmlhbGl6ZVZlYzMoZGF0YS5hcmdzWzFdKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXZlbnQuVVBEQVRFX0JPRFlfUFJPUEVSVElFUzpcbiAgICAgICAgcHJvdG9jb2wuZGVzZXJpYWxpemVCb2R5VXBkYXRlKGRhdGEuYm9keSwgYm9kaWVzW2RhdGEuYm9keS5pZF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gTWF0ZXJpYWxzLlxuICAgICAgY2FzZSBFdmVudC5BRERfTUFURVJJQUw6XG4gICAgICAgIGRyaXZlci5hZGRNYXRlcmlhbChkYXRhLm1hdGVyaWFsQ29uZmlnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEV2ZW50LkFERF9DT05UQUNUX01BVEVSSUFMOlxuICAgICAgICBkcml2ZXIuYWRkQ29udGFjdE1hdGVyaWFsKFxuICAgICAgICAgIGRhdGEubWF0ZXJpYWxOYW1lMSxcbiAgICAgICAgICBkYXRhLm1hdGVyaWFsTmFtZTIsXG4gICAgICAgICAgZGF0YS5jb250YWN0TWF0ZXJpYWxDb25maWdcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIENvbnN0cmFpbnRzLlxuICAgICAgY2FzZSBFdmVudC5BRERfQ09OU1RSQUlOVDpcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBwcm90b2NvbC5kZXNlcmlhbGl6ZUNvbnN0cmFpbnQoZGF0YS5jb25zdHJhaW50LCBib2RpZXMpO1xuICAgICAgICBjb25zdHJhaW50c1tjb25zdHJhaW50W0lEXV0gPSBjb25zdHJhaW50O1xuICAgICAgICBkcml2ZXIuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEV2ZW50LlJFTU9WRV9DT05TVFJBSU5UOlxuICAgICAgICBkcml2ZXIucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50c1tkYXRhLmNvbnN0cmFpbnRJRF0pO1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHNbZGF0YS5jb25zdHJhaW50SURdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbV29ya2VyXSBVbmV4cGVjdGVkIGV2ZW50IHR5cGU6ICVzJywgZGF0YS50eXBlKTtcblxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc3RlcCAoKSB7XG4gICAgZHJpdmVyLnN0ZXAoc3RlcFNpemUpO1xuXG4gICAgdmFyIGJvZHlNZXNzYWdlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGJvZGllcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGJvZHlNZXNzYWdlc1tpZF0gPSBwcm90b2NvbC5zZXJpYWxpemVCb2R5KGJvZGllc1tpZF0pO1xuICAgIH0pO1xuXG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBFdmVudC5TVEVQLFxuICAgICAgYm9kaWVzOiBib2R5TWVzc2FnZXMsXG4gICAgICBjb250YWN0czogZHJpdmVyLmdldENvbnRhY3RzKCkubWFwKHByb3RvY29sLnNlcmlhbGl6ZUNvbnRhY3QpXG4gICAgfSk7XG4gIH1cbn07XG4iLCIvKiBnbG9iYWwgVEhSRUUgKi9cbnZhciBDQU5OT04gPSByZXF1aXJlKCdjYW5ub24tZXMnKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgIENfR1JBViA9IENPTlNUQU5UUy5HUkFWSVRZLFxuICAgIENfTUFUID0gQ09OU1RBTlRTLkNPTlRBQ1RfTUFURVJJQUw7XG5cbmNvbnN0IHsgVFlQRSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBMb2NhbERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVycy9sb2NhbC1kcml2ZXInKSxcbiAgICBXb3JrZXJEcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcnMvd29ya2VyLWRyaXZlcicpLFxuICAgIE5ldHdvcmtEcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcnMvbmV0d29yay1kcml2ZXInKSxcbiAgICBBbW1vRHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXJzL2FtbW8tZHJpdmVyJyk7XG5yZXF1aXJlKCdhZnJhbWUtc3RhdHMtcGFuZWwnKVxuXG4vKipcbiAqIFBoeXNpY3Mgc3lzdGVtLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFGUkFNRS5yZWdpc3RlclN5c3RlbSgncGh5c2ljcycsIHtcbiAgc2NoZW1hOiB7XG4gICAgLy8gQ0FOTk9OLmpzIGRyaXZlciB0eXBlXG4gICAgZHJpdmVyOiAgICAgICAgICAgICAgICAgICAgICAgICB7IGRlZmF1bHQ6ICdsb2NhbCcsIG9uZU9mOiBbJ2xvY2FsJywgJ3dvcmtlcicsICduZXR3b3JrJywgJ2FtbW8nXSB9LFxuICAgIG5ldHdvcmtVcmw6ICAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiAnJywgaWY6IHtkcml2ZXI6ICduZXR3b3JrJ30gfSxcbiAgICB3b3JrZXJGcHM6ICAgICAgICAgICAgICAgICAgICAgIHsgZGVmYXVsdDogNjAsIGlmOiB7ZHJpdmVyOiAnd29ya2VyJ30gfSxcbiAgICB3b3JrZXJJbnRlcnBvbGF0ZTogICAgICAgICAgICAgIHsgZGVmYXVsdDogdHJ1ZSwgaWY6IHtkcml2ZXI6ICd3b3JrZXInfSB9LFxuICAgIHdvcmtlckludGVycEJ1ZmZlclNpemU6ICAgICAgICAgeyBkZWZhdWx0OiAyLCBpZjoge2RyaXZlcjogJ3dvcmtlcid9IH0sXG4gICAgd29ya2VyRW5naW5lOiAgICAgICAgICAgICAgICAgICB7IGRlZmF1bHQ6ICdjYW5ub24nLCBpZjoge2RyaXZlcjogJ3dvcmtlcid9LCBvbmVPZjogWydjYW5ub24nXSB9LFxuICAgIHdvcmtlckRlYnVnOiAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiBmYWxzZSwgaWY6IHtkcml2ZXI6ICd3b3JrZXInfSB9LFxuXG4gICAgZ3Jhdml0eTogICAgICAgICAgICAgICAgICAgICAgICB7IGRlZmF1bHQ6IENfR1JBViB9LFxuICAgIGl0ZXJhdGlvbnM6ICAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiBDT05TVEFOVFMuSVRFUkFUSU9OUyB9LFxuICAgIGZyaWN0aW9uOiAgICAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiBDX01BVC5mcmljdGlvbiB9LFxuICAgIHJlc3RpdHV0aW9uOiAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiBDX01BVC5yZXN0aXR1dGlvbiB9LFxuICAgIGNvbnRhY3RFcXVhdGlvblN0aWZmbmVzczogICAgICAgeyBkZWZhdWx0OiBDX01BVC5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MgfSxcbiAgICBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uOiAgICAgIHsgZGVmYXVsdDogQ19NQVQuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiB9LFxuICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6ICAgICAgeyBkZWZhdWx0OiBDX01BVC5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzIH0sXG4gICAgZnJpY3Rpb25FcXVhdGlvblJlZ3VsYXJpemF0aW9uOiB7IGRlZmF1bHQ6IENfTUFULmZyaWN0aW9uRXF1YXRpb25SZWd1bGFyaXphdGlvbiB9LFxuXG4gICAgLy8gTmV2ZXIgc3RlcCBtb3JlIHRoYW4gZm91ciBmcmFtZXMgYXQgb25jZS4gRWZmZWN0aXZlbHkgcGF1c2VzIHRoZSBzY2VuZVxuICAgIC8vIHdoZW4gb3V0IG9mIGZvY3VzLCBhbmQgcHJldmVudHMgd2VpcmQgXCJqdW1wc1wiIHdoZW4gZm9jdXMgcmV0dXJucy5cbiAgICBtYXhJbnRlcnZhbDogICAgICAgICAgICAgICAgICAgIHsgZGVmYXVsdDogNCAvIDYwIH0sXG5cbiAgICAvLyBJZiB0cnVlLCBzaG93IHdpcmVmcmFtZXMgYXJvdW5kIHBoeXNpY3MgYm9kaWVzLlxuICAgIGRlYnVnOiAgICAgICAgICAgICAgICAgICAgICAgICAgeyBkZWZhdWx0OiBmYWxzZSB9LFxuXG4gICAgLy8gSWYgdXNpbmcgYW1tbywgc2V0IHRoZSBkZWZhdWx0IHJlbmRlcmluZyBtb2RlIGZvciBkZWJ1Z1xuICAgIGRlYnVnRHJhd01vZGU6IHsgZGVmYXVsdDogVEhSRUUuQW1tb0RlYnVnQ29uc3RhbnRzLk5vRGVidWcgfSxcbiAgICAvLyBJZiB1c2luZyBhbW1vLCBzZXQgdGhlIG1heCBudW1iZXIgb2Ygc3RlcHMgcGVyIGZyYW1lIFxuICAgIG1heFN1YlN0ZXBzOiB7IGRlZmF1bHQ6IDQgfSxcbiAgICAvLyBJZiB1c2luZyBhbW1vLCBzZXQgdGhlIGZyYW1lcmF0ZSBvZiB0aGUgc2ltdWxhdGlvblxuICAgIGZpeGVkVGltZVN0ZXA6IHsgZGVmYXVsdDogMSAvIDYwIH0sXG4gICAgLy8gV2hldGhlciB0byBvdXRwdXQgc3RhdHMsIGFuZCBob3cgdG8gb3V0cHV0IHRoZW0uICBPbmUgb3IgbW9yZSBvZiBcImNvbnNvbGVcIiwgXCJldmVudHNcIiwgXCJwYW5lbFwiXG4gICAgc3RhdHM6IHt0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXX1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHBoeXNpY3Mgc3lzdGVtLlxuICAgKi9cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIC8vIElmIHRydWUsIHNob3cgd2lyZWZyYW1lcyBhcm91bmQgcGh5c2ljcyBib2RpZXMuXG4gICAgdGhpcy5kZWJ1ZyA9IGRhdGEuZGVidWc7XG4gICAgdGhpcy5pbml0U3RhdHMoKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0ge2JlZm9yZVN0ZXA6IFtdLCBzdGVwOiBbXSwgYWZ0ZXJTdGVwOiBbXX07XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIFxuXG4gICAgdGhpcy5kcml2ZXIgPSBudWxsO1xuICAgIHN3aXRjaCAoZGF0YS5kcml2ZXIpIHtcbiAgICAgIGNhc2UgJ2xvY2FsJzpcbiAgICAgICAgdGhpcy5kcml2ZXIgPSBuZXcgTG9jYWxEcml2ZXIoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FtbW8nOlxuICAgICAgICB0aGlzLmRyaXZlciA9IG5ldyBBbW1vRHJpdmVyKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICduZXR3b3JrJzpcbiAgICAgICAgdGhpcy5kcml2ZXIgPSBuZXcgTmV0d29ya0RyaXZlcihkYXRhLm5ldHdvcmtVcmwpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnd29ya2VyJzpcbiAgICAgICAgdGhpcy5kcml2ZXIgPSBuZXcgV29ya2VyRHJpdmVyKHtcbiAgICAgICAgICBmcHM6IGRhdGEud29ya2VyRnBzLFxuICAgICAgICAgIGVuZ2luZTogZGF0YS53b3JrZXJFbmdpbmUsXG4gICAgICAgICAgaW50ZXJwb2xhdGU6IGRhdGEud29ya2VySW50ZXJwb2xhdGUsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbkJ1ZmZlclNpemU6IGRhdGEud29ya2VySW50ZXJwQnVmZmVyU2l6ZSxcbiAgICAgICAgICBkZWJ1ZzogZGF0YS53b3JrZXJEZWJ1Z1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3BoeXNpY3NdIERyaXZlciBub3QgcmVjb2duaXplZDogXCIlc1wiLicsIGRhdGEuZHJpdmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5kcml2ZXIgIT09ICdhbW1vJykge1xuICAgICAgYXdhaXQgdGhpcy5kcml2ZXIuaW5pdCh7XG4gICAgICAgIHF1YXROb3JtYWxpemVTa2lwOiAwLFxuICAgICAgICBxdWF0Tm9ybWFsaXplRmFzdDogZmFsc2UsXG4gICAgICAgIHNvbHZlckl0ZXJhdGlvbnM6IGRhdGEuaXRlcmF0aW9ucyxcbiAgICAgICAgZ3Jhdml0eTogZGF0YS5ncmF2aXR5LFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRyaXZlci5hZGRNYXRlcmlhbCh7bmFtZTogJ2RlZmF1bHRNYXRlcmlhbCd9KTtcbiAgICAgIHRoaXMuZHJpdmVyLmFkZE1hdGVyaWFsKHtuYW1lOiAnc3RhdGljTWF0ZXJpYWwnfSk7XG4gICAgICB0aGlzLmRyaXZlci5hZGRDb250YWN0TWF0ZXJpYWwoJ2RlZmF1bHRNYXRlcmlhbCcsICdkZWZhdWx0TWF0ZXJpYWwnLCB7XG4gICAgICAgIGZyaWN0aW9uOiBkYXRhLmZyaWN0aW9uLFxuICAgICAgICByZXN0aXR1dGlvbjogZGF0YS5yZXN0aXR1dGlvbixcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiBkYXRhLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjogZGF0YS5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzOiBkYXRhLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25SZWd1bGFyaXphdGlvbjogZGF0YS5mcmljdGlvbkVxdWF0aW9uUmVndWxhcml6YXRpb25cbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcml2ZXIuYWRkQ29udGFjdE1hdGVyaWFsKCdzdGF0aWNNYXRlcmlhbCcsICdkZWZhdWx0TWF0ZXJpYWwnLCB7XG4gICAgICAgIGZyaWN0aW9uOiAxLjAsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAwLjAsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvblN0aWZmbmVzczogZGF0YS5jb250YWN0RXF1YXRpb25TdGlmZm5lc3MsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IGRhdGEuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczogZGF0YS5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUmVndWxhcml6YXRpb246IGRhdGEuZnJpY3Rpb25FcXVhdGlvblJlZ3VsYXJpemF0aW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5kcml2ZXIuaW5pdCh7XG4gICAgICBncmF2aXR5OiBkYXRhLmdyYXZpdHksXG4gICAgICBkZWJ1Z0RyYXdNb2RlOiBkYXRhLmRlYnVnRHJhd01vZGUsXG4gICAgICBzb2x2ZXJJdGVyYXRpb25zOiBkYXRhLml0ZXJhdGlvbnMsXG4gICAgICBtYXhTdWJTdGVwczogZGF0YS5tYXhTdWJTdGVwcyxcbiAgICAgIGZpeGVkVGltZVN0ZXA6IGRhdGEuZml4ZWRUaW1lU3RlcFxuICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIHRoaXMuc2V0RGVidWcodHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRTdGF0cygpIHtcbiAgICAvLyBEYXRhIHVzZWQgZm9yIHBlcmZvcm1hbmNlIG1vbml0b3JpbmcuXG4gICAgdGhpcy5zdGF0c1RvQ29uc29sZSA9IHRoaXMuZGF0YS5zdGF0cy5pbmNsdWRlcyhcImNvbnNvbGVcIilcbiAgICB0aGlzLnN0YXRzVG9FdmVudHMgPSB0aGlzLmRhdGEuc3RhdHMuaW5jbHVkZXMoXCJldmVudHNcIilcbiAgICB0aGlzLnN0YXRzVG9QYW5lbCA9IHRoaXMuZGF0YS5zdGF0cy5pbmNsdWRlcyhcInBhbmVsXCIpXG5cbiAgICBpZiAodGhpcy5zdGF0c1RvQ29uc29sZSB8fCB0aGlzLnN0YXRzVG9FdmVudHMgfHwgdGhpcy5zdGF0c1RvUGFuZWwpIHtcbiAgICAgIHRoaXMudHJhY2tQZXJmID0gdHJ1ZTtcbiAgICAgIHRoaXMudGlja0NvdW50ZXIgPSAwO1xuICAgICAgXG4gICAgICB0aGlzLnN0YXRzVGlja0RhdGEgPSB7fTtcbiAgICAgIHRoaXMuc3RhdHNCb2R5RGF0YSA9IHt9O1xuXG4gICAgICB0aGlzLmNvdW50Qm9kaWVzID0ge1xuICAgICAgICBcImFtbW9cIjogKCkgPT4gdGhpcy5jb3VudEJvZGllc0FtbW8oKSxcbiAgICAgICAgXCJsb2NhbFwiOiAoKSA9PiB0aGlzLmNvdW50Qm9kaWVzQ2Fubm9uKGZhbHNlKSxcbiAgICAgICAgXCJ3b3JrZXJcIjogKCkgPT4gdGhpcy5jb3VudEJvZGllc0Nhbm5vbih0cnVlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHlUeXBlVG9TdGF0c1Byb3BlcnR5TWFwID0ge1xuICAgICAgICBcImFtbW9cIjoge1xuICAgICAgICAgIFtUWVBFLlNUQVRJQ10gOiBcInN0YXRpY0JvZGllc1wiLFxuICAgICAgICAgIFtUWVBFLktJTkVNQVRJQ10gOiBcImtpbmVtYXRpY0JvZGllc1wiLFxuICAgICAgICAgIFtUWVBFLkRZTkFNSUNdIDogXCJkeW5hbWljQm9kaWVzXCIsXG4gICAgICAgIH0sIFxuICAgICAgICBcImNhbm5vblwiOiB7XG4gICAgICAgICAgW0NBTk5PTi5Cb2R5LlNUQVRJQ10gOiBcInN0YXRpY0JvZGllc1wiLFxuICAgICAgICAgIFtDQU5OT04uQm9keS5EWU5BTUlDXSA6IFwiZHluYW1pY0JvZGllc1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLmVsLnNjZW5lRWw7XG4gICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1jb2xsZWN0b3JcIiwgYGluRXZlbnQ6IHBoeXNpY3MtdGljay1kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogYmVmb3JlLCBhZnRlciwgZW5naW5lLCB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZyZXF1ZW5jeTogMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0RXZlbnQ6IHBoeXNpY3MtdGljay1zdW1tYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcGVyY2VudGlsZV9fNTAsIHBlcmNlbnRpbGVfXzkwLCBtYXhgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0c1RvUGFuZWwpIHtcbiAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5lbC5zY2VuZUVsO1xuICAgICAgY29uc3Qgc3BhY2UgPSBcIiZuYnNwJm5ic3AmbmJzcFwiXG4gICAgXG4gICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1wYW5lbFwiLCBcIlwiKVxuICAgICAgc2NlbmUuc2V0QXR0cmlidXRlKFwic3RhdHMtZ3JvdXBfX2JvZGllc1wiLCBgbGFiZWw6IFBoeXNpY3MgQm9kaWVzYClcbiAgICAgIHNjZW5lLnNldEF0dHJpYnV0ZShcInN0YXRzLXJvd19fYjFcIiwgYGdyb3VwOiBib2RpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6cGh5c2ljcy1ib2R5LWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogc3RhdGljQm9kaWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBTdGF0aWNgKVxuICAgICAgc2NlbmUuc2V0QXR0cmlidXRlKFwic3RhdHMtcm93X19iMlwiLCBgZ3JvdXA6IGJvZGllcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDpwaHlzaWNzLWJvZHktZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBkeW5hbWljQm9kaWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBEeW5hbWljYClcbiAgICAgIGlmICh0aGlzLmRhdGEuZHJpdmVyID09PSAnbG9jYWwnIHx8IHRoaXMuZGF0YS5kcml2ZXIgPT09ICd3b3JrZXInKSB7XG4gICAgICAgIHNjZW5lLnNldEF0dHJpYnV0ZShcInN0YXRzLXJvd19fYjNcIiwgYGdyb3VwOiBib2RpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDpwaHlzaWNzLWJvZHktZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGNvbnRhY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IENvbnRhY3RzYClcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YS5kcml2ZXIgPT09ICdhbW1vJykge1xuICAgICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1yb3dfX2IzXCIsIGBncm91cDogYm9kaWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6cGh5c2ljcy1ib2R5LWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBraW5lbWF0aWNCb2RpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogS2luZW1hdGljYClcbiAgICAgICAgc2NlbmUuc2V0QXR0cmlidXRlKFwic3RhdHMtcm93X19iNFwiLCBgZ3JvdXA6IGJvZGllcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBwaHlzaWNzLWJvZHktZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG1hbmlmb2xkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBNYW5pZm9sZHNgKVxuICAgICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1yb3dfX2I1XCIsIGBncm91cDogYm9kaWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHBoeXNpY3MtYm9keS1kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogbWFuaWZvbGRDb250YWN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBDb250YWN0c2ApXG4gICAgICAgIHNjZW5lLnNldEF0dHJpYnV0ZShcInN0YXRzLXJvd19fYjZcIiwgYGdyb3VwOiBib2RpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogcGh5c2ljcy1ib2R5LWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBjb2xsaXNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IENvbGxpc2lvbnNgKVxuICAgICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1yb3dfX2I3XCIsIGBncm91cDogYm9kaWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHBoeXNpY3MtYm9keS1kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogY29sbGlzaW9uS2V5cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBDb2xsIEtleXNgKVxuICAgICAgfVxuXG4gICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1ncm91cF9fdGlja1wiLCBgbGFiZWw6IFBoeXNpY3MgVGlja3M6IE1lZGlhbiR7c3BhY2V9OTB0aCUke3NwYWNlfTk5dGglYClcbiAgICAgIHNjZW5lLnNldEF0dHJpYnV0ZShcInN0YXRzLXJvd19fMVwiLCBgZ3JvdXA6IHRpY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDpwaHlzaWNzLXRpY2stc3VtbWFyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGJlZm9yZS5wZXJjZW50aWxlX181MCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUucGVyY2VudGlsZV9fOTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlLm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBCZWZvcmVgKVxuICAgICAgc2NlbmUuc2V0QXR0cmlidXRlKFwic3RhdHMtcm93X18yXCIsIGBncm91cDogdGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OnBoeXNpY3MtdGljay1zdW1tYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogYWZ0ZXIucGVyY2VudGlsZV9fNTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIucGVyY2VudGlsZV9fOTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWF4OyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBBZnRlcmApXG4gICAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoXCJzdGF0cy1yb3dfXzNcIiwgYGdyb3VwOiB0aWNrOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OnBoeXNpY3MtdGljay1zdW1tYXJ5OyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGVuZ2luZS5wZXJjZW50aWxlX181MCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUucGVyY2VudGlsZV9fOTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lLm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBFbmdpbmVgKVxuICAgICAgc2NlbmUuc2V0QXR0cmlidXRlKFwic3RhdHMtcm93X180XCIsIGBncm91cDogdGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OnBoeXNpY3MtdGljay1zdW1tYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogdG90YWwucGVyY2VudGlsZV9fNTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwucGVyY2VudGlsZV9fOTAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwubWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFRvdGFsYClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBoeXNpY3Mgd29ybGQgb24gZWFjaCB0aWNrIG9mIHRoZSBBLUZyYW1lIHNjZW5lLiBJdCB3b3VsZCBiZVxuICAgKiBlbnRpcmVseSBwb3NzaWJsZSB0byBzZXBhcmF0ZSB0aGUgdHdvIOKAkyB1cGRhdGluZyBwaHlzaWNzIG1vcmUgb3IgbGVzc1xuICAgKiBmcmVxdWVudGx5IHRoYW4gdGhlIHNjZW5lIOKAkyBpZiBncmVhdGVyIHByZWNpc2lvbiBvciBwZXJmb3JtYW5jZSB3ZXJlXG4gICAqIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEBwYXJhbSAge251bWJlcn0gZHRcbiAgICovXG4gIHRpY2s6IGZ1bmN0aW9uICh0LCBkdCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCAhZHQpIHJldHVybjtcblxuICAgIGNvbnN0IGJlZm9yZVN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2FsbGJhY2tzLmJlZm9yZVN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLmJlZm9yZVN0ZXBbaV0uYmVmb3JlU3RlcCh0LCBkdCk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5naW5lU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICB0aGlzLmRyaXZlci5zdGVwKE1hdGgubWluKGR0IC8gMTAwMCwgdGhpcy5kYXRhLm1heEludGVydmFsKSk7XG5cbiAgICBjb25zdCBlbmdpbmVFbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLnN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrcy5zdGVwW2ldLnN0ZXAodCwgZHQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MuYWZ0ZXJTdGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFja3MuYWZ0ZXJTdGVwW2ldLmFmdGVyU3RlcCh0LCBkdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhY2tQZXJmKSB7XG4gICAgICBjb25zdCBhZnRlckVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgdGhpcy5zdGF0c1RpY2tEYXRhLmJlZm9yZSA9IGVuZ2luZVN0YXJ0VGltZSAtIGJlZm9yZVN0YXJ0VGltZVxuICAgICAgdGhpcy5zdGF0c1RpY2tEYXRhLmVuZ2luZSA9IGVuZ2luZUVuZFRpbWUgLSBlbmdpbmVTdGFydFRpbWVcbiAgICAgIHRoaXMuc3RhdHNUaWNrRGF0YS5hZnRlciA9IGFmdGVyRW5kVGltZSAtIGVuZ2luZUVuZFRpbWVcbiAgICAgIHRoaXMuc3RhdHNUaWNrRGF0YS50b3RhbCA9IGFmdGVyRW5kVGltZSAtIGJlZm9yZVN0YXJ0VGltZVxuXG4gICAgICB0aGlzLmVsLmVtaXQoXCJwaHlzaWNzLXRpY2stZGF0YVwiLCB0aGlzLnN0YXRzVGlja0RhdGEpXG5cbiAgICAgIHRoaXMudGlja0NvdW50ZXIrKztcblxuICAgICAgaWYgKHRoaXMudGlja0NvdW50ZXIgPT09IDEwMCkge1xuXG4gICAgICAgIHRoaXMuY291bnRCb2RpZXNbdGhpcy5kYXRhLmRyaXZlcl0oKVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRzVG9Db25zb2xlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJQaHlzaWNzIGJvZHkgc3RhdHM6XCIsIHRoaXMuc3RhdHNCb2R5RGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRzVG9FdmVudHMgIHx8IHRoaXMuc3RhdHNUb1BhbmVsKSB7XG4gICAgICAgICAgdGhpcy5lbC5lbWl0KFwicGh5c2ljcy1ib2R5LWRhdGFcIiwgdGhpcy5zdGF0c0JvZHlEYXRhKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlja0NvdW50ZXIgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb3VudEJvZGllc0FtbW8oKSB7XG5cbiAgICBjb25zdCBzdGF0c0RhdGEgPSB0aGlzLnN0YXRzQm9keURhdGFcbiAgICBzdGF0c0RhdGEubWFuaWZvbGRzID0gdGhpcy5kcml2ZXIuZGlzcGF0Y2hlci5nZXROdW1NYW5pZm9sZHMoKTtcbiAgICBzdGF0c0RhdGEubWFuaWZvbGRDb250YWN0cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0c0RhdGEubWFuaWZvbGRzOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hbmlmb2xkID0gdGhpcy5kcml2ZXIuZGlzcGF0Y2hlci5nZXRNYW5pZm9sZEJ5SW5kZXhJbnRlcm5hbChpKTtcbiAgICAgIHN0YXRzRGF0YS5tYW5pZm9sZENvbnRhY3RzICs9IG1hbmlmb2xkLmdldE51bUNvbnRhY3RzKCk7XG4gICAgfVxuICAgIHN0YXRzRGF0YS5jb2xsaXNpb25zID0gdGhpcy5kcml2ZXIuY29sbGlzaW9ucy5zaXplO1xuICAgIHN0YXRzRGF0YS5jb2xsaXNpb25LZXlzID0gdGhpcy5kcml2ZXIuY29sbGlzaW9uS2V5cy5sZW5ndGg7XG4gICAgc3RhdHNEYXRhLnN0YXRpY0JvZGllcyA9IDBcbiAgICBzdGF0c0RhdGEua2luZW1hdGljQm9kaWVzID0gMFxuICAgIHN0YXRzRGF0YS5keW5hbWljQm9kaWVzID0gMFxuICAgIFxuICAgIGZ1bmN0aW9uIHR5cGUoZWwpIHtcbiAgICAgIHJldHVybiBlbC5jb21wb25lbnRzWydhbW1vLWJvZHknXS5kYXRhLnR5cGVcbiAgICB9XG5cbiAgICB0aGlzLmRyaXZlci5lbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5ib2R5VHlwZVRvU3RhdHNQcm9wZXJ0eU1hcFtcImFtbW9cIl1bdHlwZShlbCldXG4gICAgICBzdGF0c0RhdGFbcHJvcGVydHldKytcbiAgICB9KVxuICB9LFxuXG4gIGNvdW50Qm9kaWVzQ2Fubm9uKHdvcmtlcikge1xuXG4gICAgY29uc3Qgc3RhdHNEYXRhID0gdGhpcy5zdGF0c0JvZHlEYXRhXG4gICAgc3RhdHNEYXRhLmNvbnRhY3RzID0gd29ya2VyID8gdGhpcy5kcml2ZXIuY29udGFjdHMubGVuZ3RoIDogdGhpcy5kcml2ZXIud29ybGQuY29udGFjdHMubGVuZ3RoO1xuICAgIHN0YXRzRGF0YS5zdGF0aWNCb2RpZXMgPSAwXG4gICAgc3RhdHNEYXRhLmR5bmFtaWNCb2RpZXMgPSAwXG5cbiAgICBjb25zdCBib2RpZXMgPSB3b3JrZXIgPyBPYmplY3QudmFsdWVzKHRoaXMuZHJpdmVyLmJvZGllcykgIDogdGhpcy5kcml2ZXIud29ybGQuYm9kaWVzXG5cbiAgICBib2RpZXMuZm9yRWFjaCgoYm9keSkgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmJvZHlUeXBlVG9TdGF0c1Byb3BlcnR5TWFwW1wiY2Fubm9uXCJdW2JvZHkudHlwZV1cbiAgICAgIHN0YXRzRGF0YVtwcm9wZXJ0eV0rK1xuICAgIH0pXG4gIH0sXG5cbiAgc2V0RGVidWc6IGZ1bmN0aW9uKGRlYnVnKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIGlmICh0aGlzLmRhdGEuZHJpdmVyID09PSAnYW1tbycgJiYgdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgaWYgKGRlYnVnICYmICF0aGlzLmRlYnVnRHJhd2VyKSB7XG4gICAgICAgIHRoaXMuZGVidWdEcmF3ZXIgPSB0aGlzLmRyaXZlci5nZXREZWJ1Z0RyYXdlcih0aGlzLmVsLm9iamVjdDNEKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0RyYXdlci5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWJ1Z0RyYXdlcikge1xuICAgICAgICB0aGlzLmRlYnVnRHJhd2VyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0RyYXdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgYm9keSB0byB0aGUgc2NlbmUsIGFuZCBiaW5kcyBwcm94aWVkIG1ldGhvZHMgdG8gdGhlIGRyaXZlci5cbiAgICogQHBhcmFtIHtDQU5OT04uQm9keX0gYm9keVxuICAgKi9cbiAgYWRkQm9keTogZnVuY3Rpb24gKGJvZHksIGdyb3VwLCBtYXNrKSB7XG4gICAgdmFyIGRyaXZlciA9IHRoaXMuZHJpdmVyO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5kcml2ZXIgPT09ICdsb2NhbCcpIHtcbiAgICAgIGJvZHkuX19hcHBseUltcHVsc2UgPSBib2R5LmFwcGx5SW1wdWxzZTtcbiAgICAgIGJvZHkuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkcml2ZXIuYXBwbHlCb2R5TWV0aG9kKGJvZHksICdhcHBseUltcHVsc2UnLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgYm9keS5fX2FwcGx5Rm9yY2UgPSBib2R5LmFwcGx5Rm9yY2U7XG4gICAgICBib2R5LmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRyaXZlci5hcHBseUJvZHlNZXRob2QoYm9keSwgJ2FwcGx5Rm9yY2UnLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgYm9keS51cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkcml2ZXIudXBkYXRlQm9keVByb3BlcnRpZXMoYm9keSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmxpc3RlbmVyc1tib2R5LmlkXSA9IGZ1bmN0aW9uIChlKSB7IGJvZHkuZWwuZW1pdCgnY29sbGlkZScsIGUpOyB9O1xuICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjb2xsaWRlJywgdGhpcy5saXN0ZW5lcnNbYm9keS5pZF0pO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyLmFkZEJvZHkoYm9keSwgZ3JvdXAsIG1hc2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgYm9keSBhbmQgaXRzIHByb3hpZWQgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtDQU5OT04uQm9keX0gYm9keVxuICAgKi9cbiAgcmVtb3ZlQm9keTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICB0aGlzLmRyaXZlci5yZW1vdmVCb2R5KGJvZHkpO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5kcml2ZXIgPT09ICdsb2NhbCcgfHwgdGhpcy5kYXRhLmRyaXZlciA9PT0gJ3dvcmtlcicpIHtcbiAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29sbGlkZScsIHRoaXMubGlzdGVuZXJzW2JvZHkuaWRdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tib2R5LmlkXTtcblxuICAgICAgYm9keS5hcHBseUltcHVsc2UgPSBib2R5Ll9fYXBwbHlJbXB1bHNlO1xuICAgICAgZGVsZXRlIGJvZHkuX19hcHBseUltcHVsc2U7XG5cbiAgICAgIGJvZHkuYXBwbHlGb3JjZSA9IGJvZHkuX19hcHBseUZvcmNlO1xuICAgICAgZGVsZXRlIGJvZHkuX19hcHBseUZvcmNlO1xuXG4gICAgICBkZWxldGUgYm9keS51cGRhdGVQcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSxcblxuICAvKiogQHBhcmFtIHtDQU5OT04uQ29uc3RyYWludCBvciBBbW1vLmJ0VHlwZWRDb25zdHJhaW50fSBjb25zdHJhaW50ICovXG4gIGFkZENvbnN0cmFpbnQ6IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgdGhpcy5kcml2ZXIuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAgfSxcblxuICAvKiogQHBhcmFtIHtDQU5OT04uQ29uc3RyYWludCBvciBBbW1vLmJ0VHlwZWRDb25zdHJhaW50fSBjb25zdHJhaW50ICovXG4gIHJlbW92ZUNvbnN0cmFpbnQ6IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgdGhpcy5kcml2ZXIucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBpbnN0YW5jZSB0byB0aGUgc3lzdGVtIGFuZCBzY2hlZHVsZXMgaXRzIHVwZGF0ZSBtZXRob2RzIHRvIGJlIGNhbGxlZFxuICAgKiB0aGUgZ2l2ZW4gcGhhc2UuXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBoYXNlXG4gICAqL1xuICBhZGRDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgaWYgKGNvbXBvbmVudC5iZWZvcmVTdGVwKSBjYWxsYmFja3MuYmVmb3JlU3RlcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgaWYgKGNvbXBvbmVudC5zdGVwKSAgICAgICBjYWxsYmFja3Muc3RlcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgaWYgKGNvbXBvbmVudC5hZnRlclN0ZXApICBjYWxsYmFja3MuYWZ0ZXJTdGVwLnB1c2goY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBpbnN0YW5jZSBmcm9tIHRoZSBzeXN0ZW0uXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBoYXNlXG4gICAqL1xuICByZW1vdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgaWYgKGNvbXBvbmVudC5iZWZvcmVTdGVwKSB7XG4gICAgICBjYWxsYmFja3MuYmVmb3JlU3RlcC5zcGxpY2UoY2FsbGJhY2tzLmJlZm9yZVN0ZXAuaW5kZXhPZihjb21wb25lbnQpLCAxKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudC5zdGVwKSB7XG4gICAgICBjYWxsYmFja3Muc3RlcC5zcGxpY2UoY2FsbGJhY2tzLnN0ZXAuaW5kZXhPZihjb21wb25lbnQpLCAxKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudC5hZnRlclN0ZXApIHtcbiAgICAgIGNhbGxiYWNrcy5hZnRlclN0ZXAuc3BsaWNlKGNhbGxiYWNrcy5hZnRlclN0ZXAuaW5kZXhPZihjb21wb25lbnQpLCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqIEByZXR1cm4ge0FycmF5PG9iamVjdD59ICovXG4gIGdldENvbnRhY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyLmdldENvbnRhY3RzKCk7XG4gIH0sXG5cbiAgZ2V0TWF0ZXJpYWw6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyLmdldE1hdGVyaWFsKG5hbWUpO1xuICB9XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzLnNsZXJwID0gZnVuY3Rpb24gKCBhLCBiLCB0ICkge1xuICBpZiAoIHQgPD0gMCApIHJldHVybiBhO1xuICBpZiAoIHQgPj0gMSApIHJldHVybiBiO1xuXG4gIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcblxuICAvLyBodHRwczovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIGJbM10gKyB4ICogYlswXSArIHkgKiBiWzFdICsgeiAqIGJbMl07XG5cbiAgaWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG4gICAgYSA9IGEuc2xpY2UoKTtcblxuICAgIGFbM10gPSAtIGJbM107XG4gICAgYVswXSA9IC0gYlswXTtcbiAgICBhWzFdID0gLSBiWzFdO1xuICAgIGFbMl0gPSAtIGJbMl07XG5cbiAgICBjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuICB9IGVsc2Uge1xuXG4gICAgcmV0dXJuIGI7XG5cbiAgfVxuXG4gIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuICAgIGFbM10gPSB3O1xuICAgIGFbMF0gPSB4O1xuICAgIGFbMV0gPSB5O1xuICAgIGFbMl0gPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG4gIHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG4gIGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cbiAgICBhWzNdID0gMC41ICogKCB3ICsgYVszXSApO1xuICAgIGFbMF0gPSAwLjUgKiAoIHggKyBhWzBdICk7XG4gICAgYVsxXSA9IDAuNSAqICggeSArIGFbMV0gKTtcbiAgICBhWzJdID0gMC41ICogKCB6ICsgYVsyXSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG4gIHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuICB2YXIgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICBhWzNdID0gKCB3ICogcmF0aW9BICsgYVszXSAqIHJhdGlvQiApO1xuICBhWzBdID0gKCB4ICogcmF0aW9BICsgYVswXSAqIHJhdGlvQiApO1xuICBhWzFdID0gKCB5ICogcmF0aW9BICsgYVsxXSAqIHJhdGlvQiApO1xuICBhWzJdID0gKCB6ICogcmF0aW9BICsgYVsyXSAqIHJhdGlvQiApO1xuXG4gIHJldHVybiBhO1xuXG59O1xuIiwidmFyIENBTk5PTiA9IHJlcXVpcmUoJ2Nhbm5vbi1lcycpO1xudmFyIG1hdGhVdGlscyA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBJRHNcbiAqL1xuXG52YXIgSUQgPSAnX19pZCc7XG5tb2R1bGUuZXhwb3J0cy5JRCA9IElEO1xuXG52YXIgbmV4dElEID0ge307XG5tb2R1bGUuZXhwb3J0cy5hc3NpZ25JRCA9IGZ1bmN0aW9uIChwcmVmaXgsIG9iamVjdCkge1xuICBpZiAob2JqZWN0W0lEXSkgcmV0dXJuO1xuICBuZXh0SURbcHJlZml4XSA9IG5leHRJRFtwcmVmaXhdIHx8IDE7XG4gIG9iamVjdFtJRF0gPSBwcmVmaXggKyAnXycgKyBuZXh0SURbcHJlZml4XSsrO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQm9kaWVzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuc2VyaWFsaXplQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHZhciBtZXNzYWdlID0ge1xuICAgIC8vIFNoYXBlcy5cbiAgICBzaGFwZXM6IGJvZHkuc2hhcGVzLm1hcChzZXJpYWxpemVTaGFwZSksXG4gICAgc2hhcGVPZmZzZXRzOiBib2R5LnNoYXBlT2Zmc2V0cy5tYXAoc2VyaWFsaXplVmVjMyksXG4gICAgc2hhcGVPcmllbnRhdGlvbnM6IGJvZHkuc2hhcGVPcmllbnRhdGlvbnMubWFwKHNlcmlhbGl6ZVF1YXRlcm5pb24pLFxuXG4gICAgLy8gVmVjdG9ycy5cbiAgICBwb3NpdGlvbjogc2VyaWFsaXplVmVjMyhib2R5LnBvc2l0aW9uKSxcbiAgICBxdWF0ZXJuaW9uOiBib2R5LnF1YXRlcm5pb24udG9BcnJheSgpLFxuICAgIHZlbG9jaXR5OiBzZXJpYWxpemVWZWMzKGJvZHkudmVsb2NpdHkpLFxuICAgIGFuZ3VsYXJWZWxvY2l0eTogc2VyaWFsaXplVmVjMyhib2R5LmFuZ3VsYXJWZWxvY2l0eSksXG5cbiAgICAvLyBQcm9wZXJ0aWVzLlxuICAgIGlkOiBib2R5W0lEXSxcbiAgICBtYXNzOiBib2R5Lm1hc3MsXG4gICAgbGluZWFyRGFtcGluZzogYm9keS5saW5lYXJEYW1waW5nLFxuICAgIGFuZ3VsYXJEYW1waW5nOiBib2R5LmFuZ3VsYXJEYW1waW5nLFxuICAgIGZpeGVkUm90YXRpb246IGJvZHkuZml4ZWRSb3RhdGlvbixcbiAgICBhbGxvd1NsZWVwOiBib2R5LmFsbG93U2xlZXAsXG4gICAgc2xlZXBTcGVlZExpbWl0OiBib2R5LnNsZWVwU3BlZWRMaW1pdCxcbiAgICBzbGVlcFRpbWVMaW1pdDogYm9keS5zbGVlcFRpbWVMaW1pdFxuICB9O1xuXG4gIHJldHVybiBtZXNzYWdlO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVCb2R5VXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGJvZHkpIHtcbiAgYm9keS5wb3NpdGlvbi5zZXQobWVzc2FnZS5wb3NpdGlvblswXSwgbWVzc2FnZS5wb3NpdGlvblsxXSwgbWVzc2FnZS5wb3NpdGlvblsyXSk7XG4gIGJvZHkucXVhdGVybmlvbi5zZXQobWVzc2FnZS5xdWF0ZXJuaW9uWzBdLCBtZXNzYWdlLnF1YXRlcm5pb25bMV0sIG1lc3NhZ2UucXVhdGVybmlvblsyXSwgbWVzc2FnZS5xdWF0ZXJuaW9uWzNdKTtcbiAgYm9keS52ZWxvY2l0eS5zZXQobWVzc2FnZS52ZWxvY2l0eVswXSwgbWVzc2FnZS52ZWxvY2l0eVsxXSwgbWVzc2FnZS52ZWxvY2l0eVsyXSk7XG4gIGJvZHkuYW5ndWxhclZlbG9jaXR5LnNldChtZXNzYWdlLmFuZ3VsYXJWZWxvY2l0eVswXSwgbWVzc2FnZS5hbmd1bGFyVmVsb2NpdHlbMV0sIG1lc3NhZ2UuYW5ndWxhclZlbG9jaXR5WzJdKTtcblxuICBib2R5LmxpbmVhckRhbXBpbmcgPSBtZXNzYWdlLmxpbmVhckRhbXBpbmc7XG4gIGJvZHkuYW5ndWxhckRhbXBpbmcgPSBtZXNzYWdlLmFuZ3VsYXJEYW1waW5nO1xuICBib2R5LmZpeGVkUm90YXRpb24gPSBtZXNzYWdlLmZpeGVkUm90YXRpb247XG4gIGJvZHkuYWxsb3dTbGVlcCA9IG1lc3NhZ2UuYWxsb3dTbGVlcDtcbiAgYm9keS5zbGVlcFNwZWVkTGltaXQgPSBtZXNzYWdlLnNsZWVwU3BlZWRMaW1pdDtcbiAgYm9keS5zbGVlcFRpbWVMaW1pdCA9IG1lc3NhZ2Uuc2xlZXBUaW1lTGltaXQ7XG5cbiAgaWYgKGJvZHkubWFzcyAhPT0gbWVzc2FnZS5tYXNzKSB7XG4gICAgYm9keS5tYXNzID0gbWVzc2FnZS5tYXNzO1xuICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgfVxuXG4gIHJldHVybiBib2R5O1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVJbnRlcnBCb2R5VXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UxLCBtZXNzYWdlMiwgYm9keSwgbWl4KSB7XG4gIHZhciB3ZWlnaHQxID0gMSAtIG1peDtcbiAgdmFyIHdlaWdodDIgPSBtaXg7XG5cbiAgYm9keS5wb3NpdGlvbi5zZXQoXG4gICAgbWVzc2FnZTEucG9zaXRpb25bMF0gKiB3ZWlnaHQxICsgbWVzc2FnZTIucG9zaXRpb25bMF0gKiB3ZWlnaHQyLFxuICAgIG1lc3NhZ2UxLnBvc2l0aW9uWzFdICogd2VpZ2h0MSArIG1lc3NhZ2UyLnBvc2l0aW9uWzFdICogd2VpZ2h0MixcbiAgICBtZXNzYWdlMS5wb3NpdGlvblsyXSAqIHdlaWdodDEgKyBtZXNzYWdlMi5wb3NpdGlvblsyXSAqIHdlaWdodDJcbiAgKTtcbiAgdmFyIHF1YXRlcm5pb24gPSBtYXRoVXRpbHMuc2xlcnAobWVzc2FnZTEucXVhdGVybmlvbiwgbWVzc2FnZTIucXVhdGVybmlvbiwgbWl4KTtcbiAgYm9keS5xdWF0ZXJuaW9uLnNldChxdWF0ZXJuaW9uWzBdLCBxdWF0ZXJuaW9uWzFdLCBxdWF0ZXJuaW9uWzJdLCBxdWF0ZXJuaW9uWzNdKTtcbiAgYm9keS52ZWxvY2l0eS5zZXQoXG4gICAgbWVzc2FnZTEudmVsb2NpdHlbMF0gKiB3ZWlnaHQxICsgbWVzc2FnZTIudmVsb2NpdHlbMF0gKiB3ZWlnaHQyLFxuICAgIG1lc3NhZ2UxLnZlbG9jaXR5WzFdICogd2VpZ2h0MSArIG1lc3NhZ2UyLnZlbG9jaXR5WzFdICogd2VpZ2h0MixcbiAgICBtZXNzYWdlMS52ZWxvY2l0eVsyXSAqIHdlaWdodDEgKyBtZXNzYWdlMi52ZWxvY2l0eVsyXSAqIHdlaWdodDJcbiAgKTtcbiAgYm9keS5hbmd1bGFyVmVsb2NpdHkuc2V0KFxuICAgIG1lc3NhZ2UxLmFuZ3VsYXJWZWxvY2l0eVswXSAqIHdlaWdodDEgKyBtZXNzYWdlMi5hbmd1bGFyVmVsb2NpdHlbMF0gKiB3ZWlnaHQyLFxuICAgIG1lc3NhZ2UxLmFuZ3VsYXJWZWxvY2l0eVsxXSAqIHdlaWdodDEgKyBtZXNzYWdlMi5hbmd1bGFyVmVsb2NpdHlbMV0gKiB3ZWlnaHQyLFxuICAgIG1lc3NhZ2UxLmFuZ3VsYXJWZWxvY2l0eVsyXSAqIHdlaWdodDEgKyBtZXNzYWdlMi5hbmd1bGFyVmVsb2NpdHlbMl0gKiB3ZWlnaHQyXG4gICk7XG5cbiAgYm9keS5saW5lYXJEYW1waW5nID0gbWVzc2FnZTIubGluZWFyRGFtcGluZztcbiAgYm9keS5hbmd1bGFyRGFtcGluZyA9IG1lc3NhZ2UyLmFuZ3VsYXJEYW1waW5nO1xuICBib2R5LmZpeGVkUm90YXRpb24gPSBtZXNzYWdlMi5maXhlZFJvdGF0aW9uO1xuICBib2R5LmFsbG93U2xlZXAgPSBtZXNzYWdlMi5hbGxvd1NsZWVwO1xuICBib2R5LnNsZWVwU3BlZWRMaW1pdCA9IG1lc3NhZ2UyLnNsZWVwU3BlZWRMaW1pdDtcbiAgYm9keS5zbGVlcFRpbWVMaW1pdCA9IG1lc3NhZ2UyLnNsZWVwVGltZUxpbWl0O1xuXG4gIGlmIChib2R5Lm1hc3MgIT09IG1lc3NhZ2UyLm1hc3MpIHtcbiAgICBib2R5Lm1hc3MgPSBtZXNzYWdlMi5tYXNzO1xuICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgfVxuXG4gIHJldHVybiBib2R5O1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVCb2R5ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIGJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoe1xuICAgIG1hc3M6IG1lc3NhZ2UubWFzcyxcblxuICAgIHBvc2l0aW9uOiBkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5wb3NpdGlvbiksXG4gICAgcXVhdGVybmlvbjogZGVzZXJpYWxpemVRdWF0ZXJuaW9uKG1lc3NhZ2UucXVhdGVybmlvbiksXG4gICAgdmVsb2NpdHk6IGRlc2VyaWFsaXplVmVjMyhtZXNzYWdlLnZlbG9jaXR5KSxcbiAgICBhbmd1bGFyVmVsb2NpdHk6IGRlc2VyaWFsaXplVmVjMyhtZXNzYWdlLmFuZ3VsYXJWZWxvY2l0eSksXG5cbiAgICBsaW5lYXJEYW1waW5nOiBtZXNzYWdlLmxpbmVhckRhbXBpbmcsXG4gICAgYW5ndWxhckRhbXBpbmc6IG1lc3NhZ2UuYW5ndWxhckRhbXBpbmcsXG4gICAgZml4ZWRSb3RhdGlvbjogbWVzc2FnZS5maXhlZFJvdGF0aW9uLFxuICAgIGFsbG93U2xlZXA6IG1lc3NhZ2UuYWxsb3dTbGVlcCxcbiAgICBzbGVlcFNwZWVkTGltaXQ6IG1lc3NhZ2Uuc2xlZXBTcGVlZExpbWl0LFxuICAgIHNsZWVwVGltZUxpbWl0OiBtZXNzYWdlLnNsZWVwVGltZUxpbWl0XG4gIH0pO1xuXG4gIGZvciAodmFyIHNoYXBlTXNnLCBpID0gMDsgKHNoYXBlTXNnID0gbWVzc2FnZS5zaGFwZXNbaV0pOyBpKyspIHtcbiAgICBib2R5LmFkZFNoYXBlKFxuICAgICAgZGVzZXJpYWxpemVTaGFwZShzaGFwZU1zZyksXG4gICAgICBkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5zaGFwZU9mZnNldHNbaV0pLFxuICAgICAgZGVzZXJpYWxpemVRdWF0ZXJuaW9uKG1lc3NhZ2Uuc2hhcGVPcmllbnRhdGlvbnNbaV0pXG4gICAgKTtcbiAgfVxuXG4gIGJvZHlbSURdID0gbWVzc2FnZS5pZDtcblxuICByZXR1cm4gYm9keTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNoYXBlc1xuICovXG5cbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZVNoYXBlID0gc2VyaWFsaXplU2hhcGU7XG5mdW5jdGlvbiBzZXJpYWxpemVTaGFwZSAoc2hhcGUpIHtcbiAgdmFyIHNoYXBlTXNnID0ge3R5cGU6IHNoYXBlLnR5cGV9O1xuICBpZiAoc2hhcGUudHlwZSA9PT0gQ0FOTk9OLlNoYXBlLnR5cGVzLkJPWCkge1xuICAgIHNoYXBlTXNnLmhhbGZFeHRlbnRzID0gc2VyaWFsaXplVmVjMyhzaGFwZS5oYWxmRXh0ZW50cyk7XG5cbiAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09PSBDQU5OT04uU2hhcGUudHlwZXMuU1BIRVJFKSB7XG4gICAgc2hhcGVNc2cucmFkaXVzID0gc2hhcGUucmFkaXVzO1xuXG4gIC8vIFBhdGNoIHNjaHRlcHBlL2Nhbm5vbi5qcyMzMjkuXG4gIH0gZWxzZSBpZiAoc2hhcGUuX3R5cGUgPT09IENBTk5PTi5TaGFwZS50eXBlcy5DWUxJTkRFUikge1xuICAgIHNoYXBlTXNnLnR5cGUgPSBDQU5OT04uU2hhcGUudHlwZXMuQ1lMSU5ERVI7XG4gICAgc2hhcGVNc2cucmFkaXVzVG9wID0gc2hhcGUucmFkaXVzVG9wO1xuICAgIHNoYXBlTXNnLnJhZGl1c0JvdHRvbSA9IHNoYXBlLnJhZGl1c0JvdHRvbTtcbiAgICBzaGFwZU1zZy5oZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgc2hhcGVNc2cubnVtU2VnbWVudHMgPSBzaGFwZS5udW1TZWdtZW50cztcblxuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZG9ubWNjdXJkeSk6IFN1cHBvcnQgZm9yIG90aGVyIHNoYXBlIHR5cGVzLlxuICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBzaGFwZSB0eXBlOiAlcycsIHNoYXBlLnR5cGUpO1xuICB9XG4gIHJldHVybiBzaGFwZU1zZztcbn1cblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVTaGFwZSA9IGRlc2VyaWFsaXplU2hhcGU7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVNoYXBlIChtZXNzYWdlKSB7XG4gIHZhciBzaGFwZTtcblxuICBpZiAobWVzc2FnZS50eXBlID09PSBDQU5OT04uU2hhcGUudHlwZXMuQk9YKSB7XG4gICAgc2hhcGUgPSBuZXcgQ0FOTk9OLkJveChkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5oYWxmRXh0ZW50cykpO1xuXG4gIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBDQU5OT04uU2hhcGUudHlwZXMuU1BIRVJFKSB7XG4gICAgc2hhcGUgPSBuZXcgQ0FOTk9OLlNwaGVyZShtZXNzYWdlLnJhZGl1cyk7XG5cbiAgLy8gUGF0Y2ggc2NodGVwcGUvY2Fubm9uLmpzIzMyOS5cbiAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IENBTk5PTi5TaGFwZS50eXBlcy5DWUxJTkRFUikge1xuICAgIHNoYXBlID0gbmV3IENBTk5PTi5DeWxpbmRlcihtZXNzYWdlLnJhZGl1c1RvcCwgbWVzc2FnZS5yYWRpdXNCb3R0b20sIG1lc3NhZ2UuaGVpZ2h0LCBtZXNzYWdlLm51bVNlZ21lbnRzKTtcbiAgICBzaGFwZS5fdHlwZSA9IENBTk5PTi5TaGFwZS50eXBlcy5DWUxJTkRFUjtcblxuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZG9ubWNjdXJkeSk6IFN1cHBvcnQgZm9yIG90aGVyIHNoYXBlIHR5cGVzLlxuICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBzaGFwZSB0eXBlOiAlcycsIG1lc3NhZ2UudHlwZSk7XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvbnN0cmFpbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuc2VyaWFsaXplQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG5cbiAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgaWQ6IGNvbnN0cmFpbnRbSURdLFxuICAgIHR5cGU6IGNvbnN0cmFpbnQudHlwZSxcbiAgICBtYXhGb3JjZTogY29uc3RyYWludC5tYXhGb3JjZSxcbiAgICBib2R5QTogY29uc3RyYWludC5ib2R5QVtJRF0sXG4gICAgYm9keUI6IGNvbnN0cmFpbnQuYm9keUJbSURdXG4gIH07XG5cbiAgc3dpdGNoIChjb25zdHJhaW50LnR5cGUpIHtcbiAgICBjYXNlICdMb2NrQ29uc3RyYWludCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEaXN0YW5jZUNvbnN0cmFpbnQnOlxuICAgICAgbWVzc2FnZS5kaXN0YW5jZSA9IGNvbnN0cmFpbnQuZGlzdGFuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdIaW5nZUNvbnN0cmFpbnQnOlxuICAgIGNhc2UgJ0NvbmVUd2lzdENvbnN0cmFpbnQnOlxuICAgICAgbWVzc2FnZS5heGlzQSA9IHNlcmlhbGl6ZVZlYzMoY29uc3RyYWludC5heGlzQSk7XG4gICAgICBtZXNzYWdlLmF4aXNCID0gc2VyaWFsaXplVmVjMyhjb25zdHJhaW50LmF4aXNCKTtcbiAgICAgIG1lc3NhZ2UucGl2b3RBID0gc2VyaWFsaXplVmVjMyhjb25zdHJhaW50LnBpdm90QSk7XG4gICAgICBtZXNzYWdlLnBpdm90QiA9IHNlcmlhbGl6ZVZlYzMoY29uc3RyYWludC5waXZvdEIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9pbnRUb1BvaW50Q29uc3RyYWludCc6XG4gICAgICBtZXNzYWdlLnBpdm90QSA9IHNlcmlhbGl6ZVZlYzMoY29uc3RyYWludC5waXZvdEEpO1xuICAgICAgbWVzc2FnZS5waXZvdEIgPSBzZXJpYWxpemVWZWMzKGNvbnN0cmFpbnQucGl2b3RCKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJydcbiAgICAgICAgKyAnVW5leHBlY3RlZCBjb25zdHJhaW50IHR5cGU6ICcgKyBjb25zdHJhaW50LnR5cGUgKyAnLiAnXG4gICAgICAgICsgJ1lvdSBtYXkgbmVlZCB0byBtYW51YWxseSBzZXQgYGNvbnN0cmFpbnQudHlwZSA9IFwiRm9vQ29uc3RyYWludFwiO2AuJ1xuICAgICAgKTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVDb25zdHJhaW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGJvZGllcykge1xuICB2YXIgVHlwZWRDb25zdHJhaW50ID0gQ0FOTk9OW21lc3NhZ2UudHlwZV07XG4gIHZhciBib2R5QSA9IGJvZGllc1ttZXNzYWdlLmJvZHlBXTtcbiAgdmFyIGJvZHlCID0gYm9kaWVzW21lc3NhZ2UuYm9keUJdO1xuXG4gIHZhciBjb25zdHJhaW50O1xuXG4gIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgY2FzZSAnTG9ja0NvbnN0cmFpbnQnOlxuICAgICAgY29uc3RyYWludCA9IG5ldyBDQU5OT04uTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRGlzdGFuY2VDb25zdHJhaW50JzpcbiAgICAgIGNvbnN0cmFpbnQgPSBuZXcgQ0FOTk9OLkRpc3RhbmNlQ29uc3RyYWludChcbiAgICAgICAgYm9keUEsXG4gICAgICAgIGJvZHlCLFxuICAgICAgICBtZXNzYWdlLmRpc3RhbmNlLFxuICAgICAgICBtZXNzYWdlLm1heEZvcmNlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdIaW5nZUNvbnN0cmFpbnQnOlxuICAgIGNhc2UgJ0NvbmVUd2lzdENvbnN0cmFpbnQnOlxuICAgICAgY29uc3RyYWludCA9IG5ldyBUeXBlZENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gICAgICAgIHBpdm90QTogZGVzZXJpYWxpemVWZWMzKG1lc3NhZ2UucGl2b3RBKSxcbiAgICAgICAgcGl2b3RCOiBkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5waXZvdEIpLFxuICAgICAgICBheGlzQTogZGVzZXJpYWxpemVWZWMzKG1lc3NhZ2UuYXhpc0EpLFxuICAgICAgICBheGlzQjogZGVzZXJpYWxpemVWZWMzKG1lc3NhZ2UuYXhpc0IpLFxuICAgICAgICBtYXhGb3JjZTogbWVzc2FnZS5tYXhGb3JjZVxuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BvaW50VG9Qb2ludENvbnN0cmFpbnQnOlxuICAgICAgY29uc3RyYWludCA9IG5ldyBDQU5OT04uUG9pbnRUb1BvaW50Q29uc3RyYWludChcbiAgICAgICAgYm9keUEsXG4gICAgICAgIGRlc2VyaWFsaXplVmVjMyhtZXNzYWdlLnBpdm90QSksXG4gICAgICAgIGJvZHlCLFxuICAgICAgICBkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5waXZvdEIpLFxuICAgICAgICBtZXNzYWdlLm1heEZvcmNlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnN0cmFpbnQgdHlwZTogJyArIG1lc3NhZ2UudHlwZSk7XG4gIH1cblxuICBjb25zdHJhaW50W0lEXSA9IG1lc3NhZ2UuaWQ7XG4gIHJldHVybiBjb25zdHJhaW50O1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29udGFjdHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVDb250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgcmV0dXJuIHtcbiAgICBiaTogY29udGFjdC5iaVtJRF0sXG4gICAgYmo6IGNvbnRhY3QuYmpbSURdLFxuICAgIG5pOiBzZXJpYWxpemVWZWMzKGNvbnRhY3QubmkpLFxuICAgIHJpOiBzZXJpYWxpemVWZWMzKGNvbnRhY3QucmkpLFxuICAgIHJqOiBzZXJpYWxpemVWZWMzKGNvbnRhY3QucmopXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZXNlcmlhbGl6ZUNvbnRhY3QgPSBmdW5jdGlvbiAobWVzc2FnZSwgYm9kaWVzKSB7XG4gIHJldHVybiB7XG4gICAgYmk6IGJvZGllc1ttZXNzYWdlLmJpXSxcbiAgICBiajogYm9kaWVzW21lc3NhZ2UuYmpdLFxuICAgIG5pOiBkZXNlcmlhbGl6ZVZlYzMobWVzc2FnZS5uaSksXG4gICAgcmk6IGRlc2VyaWFsaXplVmVjMyhtZXNzYWdlLnJpKSxcbiAgICByajogZGVzZXJpYWxpemVWZWMzKG1lc3NhZ2UucmopXG4gIH07XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNYXRoXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuc2VyaWFsaXplVmVjMyA9IHNlcmlhbGl6ZVZlYzM7XG5mdW5jdGlvbiBzZXJpYWxpemVWZWMzICh2ZWMzKSB7XG4gIHJldHVybiB2ZWMzLnRvQXJyYXkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZGVzZXJpYWxpemVWZWMzID0gZGVzZXJpYWxpemVWZWMzO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVWZWMzIChtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgQ0FOTk9OLlZlYzMobWVzc2FnZVswXSwgbWVzc2FnZVsxXSwgbWVzc2FnZVsyXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZVF1YXRlcm5pb24gPSBzZXJpYWxpemVRdWF0ZXJuaW9uO1xuZnVuY3Rpb24gc2VyaWFsaXplUXVhdGVybmlvbiAocXVhdCkge1xuICByZXR1cm4gcXVhdC50b0FycmF5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmRlc2VyaWFsaXplUXVhdGVybmlvbiA9IGRlc2VyaWFsaXplUXVhdGVybmlvbjtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplUXVhdGVybmlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IENBTk5PTi5RdWF0ZXJuaW9uKG1lc3NhZ2VbMF0sIG1lc3NhZ2VbMV0sIG1lc3NhZ2VbMl0sIG1lc3NhZ2VbM10pO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBUSFJFRTsiLCJ2YXIgY2Fubm9uRXMgPSByZXF1aXJlKCdjYW5ub24tZXMnKTtcbnZhciB0aHJlZSA9IHJlcXVpcmUoJ3RocmVlJyk7XG5cbi8qKlxuICogUG9ydGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXVyaXp6emlvL3F1aWNraHVsbDNkLyBieSBNYXVyaWNpbyBQb3BwZSAoaHR0cHM6Ly9naXRodWIuY29tL21hdXJpenp6aW8pXG4gKi9cblxudmFyIENvbnZleEh1bGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaXNpYmxlID0gMDtcbiAgdmFyIERlbGV0ZWQgPSAxO1xuICB2YXIgdjEgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXG4gIGZ1bmN0aW9uIENvbnZleEh1bGwoKSB7XG4gICAgdGhpcy50b2xlcmFuY2UgPSAtMTtcbiAgICB0aGlzLmZhY2VzID0gW107IC8vIHRoZSBnZW5lcmF0ZWQgZmFjZXMgb2YgdGhlIGNvbnZleCBodWxsXG5cbiAgICB0aGlzLm5ld0ZhY2VzID0gW107IC8vIHRoaXMgYXJyYXkgaG9sZHMgdGhlIGZhY2VzIHRoYXQgYXJlIGdlbmVyYXRlZCB3aXRoaW4gYSBzaW5nbGUgaXRlcmF0aW9uXG4gICAgLy8gdGhlIHZlcnRleCBsaXN0cyB3b3JrIGFzIGZvbGxvd3M6XG4gICAgLy9cbiAgICAvLyBsZXQgJ2EnIGFuZCAnYicgYmUgJ0ZhY2UnIGluc3RhbmNlc1xuICAgIC8vIGxldCAndicgYmUgcG9pbnRzIHdyYXBwZWQgYXMgaW5zdGFuY2Ugb2YgJ1ZlcnRleCdcbiAgICAvL1xuICAgIC8vICAgICBbdiwgdiwgLi4uLCB2LCB2LCB2LCAuLi5dXG4gICAgLy8gICAgICBeICAgICAgICAgICAgIF5cbiAgICAvLyAgICAgIHwgICAgICAgICAgICAgfFxuICAgIC8vICBhLm91dHNpZGUgICAgIGIub3V0c2lkZVxuICAgIC8vXG5cbiAgICB0aGlzLmFzc2lnbmVkID0gbmV3IFZlcnRleExpc3QoKTtcbiAgICB0aGlzLnVuYXNzaWduZWQgPSBuZXcgVmVydGV4TGlzdCgpO1xuICAgIHRoaXMudmVydGljZXMgPSBbXTsgLy8gdmVydGljZXMgb2YgdGhlIGh1bGwgKGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGdpdmVuIGdlb21ldHJ5IGRhdGEpXG4gIH1cblxuICBPYmplY3QuYXNzaWduKENvbnZleEh1bGwucHJvdG90eXBlLCB7XG4gICAgc2V0RnJvbVBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzKSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5Db252ZXhIdWxsOiBQb2ludHMgcGFyYW1ldGVyIGlzIG5vdCBhbiBhcnJheS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkNvbnZleEh1bGw6IFRoZSBhbGdvcml0aG0gbmVlZHMgYXQgbGVhc3QgZm91ciBwb2ludHMuJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFZlcnRleE5vZGUocG9pbnRzW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBvYmplY3QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICBvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGwsIHBvaW50O1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuICAgICAgICBpZiAoZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeS5pc0dlb21ldHJ5KSB7XG4gICAgICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS50b0J1ZmZlckdlb21ldHJ5ID8gZ2VvbWV0cnkudG9CdWZmZXJHZW9tZXRyeSgpIDogbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICBwb2ludC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaSkuYXBwbHlNYXRyaXg0KG5vZGUubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnNldEZyb21Qb2ludHMocG9pbnRzKTtcbiAgICB9LFxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tpXTsgLy8gY29tcHV0ZSBzaWduZWQgZGlzdGFuY2UgYW5kIGNoZWNrIG9uIHdoYXQgaGFsZiBzcGFjZSB0aGUgcG9pbnQgbGllc1xuXG4gICAgICAgIGlmIChmYWNlLmRpc3RhbmNlVG9Qb2ludChwb2ludCkgPiB0aGlzLnRvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGludGVyc2VjdFJheTogZnVuY3Rpb24gKHJheSwgdGFyZ2V0KSB7XG4gICAgICAvLyBiYXNlZCBvbiBcIkZhc3QgUmF5LUNvbnZleCBQb2x5aGVkcm9uIEludGVyc2VjdGlvblwiICBieSBFcmljIEhhaW5lcywgR1JBUEhJQ1MgR0VNUyBJSVxuICAgICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgICAgIHZhciB0TmVhciA9IC1JbmZpbml0eTtcbiAgICAgIHZhciB0RmFyID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07IC8vIGludGVycHJldCBmYWNlcyBhcyBwbGFuZXMgZm9yIHRoZSBmdXJ0aGVyIGNvbXB1dGF0aW9uXG5cbiAgICAgICAgdmFyIHZOID0gZmFjZS5kaXN0YW5jZVRvUG9pbnQocmF5Lm9yaWdpbik7XG4gICAgICAgIHZhciB2RCA9IGZhY2Uubm9ybWFsLmRvdChyYXkuZGlyZWN0aW9uKTsgLy8gaWYgdGhlIG9yaWdpbiBpcyBvbiB0aGUgcG9zaXRpdmUgc2lkZSBvZiBhIHBsYW5lIChzbyB0aGUgcGxhbmUgY2FuIFwic2VlXCIgdGhlIG9yaWdpbikgYW5kXG4gICAgICAgIC8vIHRoZSByYXkgaXMgdHVybmVkIGF3YXkgb3IgcGFyYWxsZWwgdG8gdGhlIHBsYW5lLCB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cblxuICAgICAgICBpZiAodk4gPiAwICYmIHZEID49IDApIHJldHVybiBudWxsOyAvLyBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByYXnigJlzIG9yaWdpbiB0byB0aGUgaW50ZXJzZWN0aW9uIHdpdGggdGhlIHBsYW5lXG5cbiAgICAgICAgdmFyIHQgPSB2RCAhPT0gMCA/IC12TiAvIHZEIDogMDsgLy8gb25seSBwcm9jZWVkIGlmIHRoZSBkaXN0YW5jZSBpcyBwb3NpdGl2ZS4gYSBuZWdhdGl2ZSBkaXN0YW5jZSBtZWFucyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIC8vIGxpZXMgXCJiZWhpbmRcIiB0aGUgb3JpZ2luXG5cbiAgICAgICAgaWYgKHQgPD0gMCkgY29udGludWU7IC8vIG5vdyBjYXRlZ29yaXplZCBwbGFuZSBhcyBmcm9udC1mYWNpbmcgb3IgYmFjay1mYWNpbmdcblxuICAgICAgICBpZiAodkQgPiAwKSB7XG4gICAgICAgICAgLy8gIHBsYW5lIGZhY2VzIGF3YXkgZnJvbSB0aGUgcmF5LCBzbyB0aGlzIHBsYW5lIGlzIGEgYmFjay1mYWNlXG4gICAgICAgICAgdEZhciA9IE1hdGgubWluKHQsIHRGYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb250LWZhY2VcbiAgICAgICAgICB0TmVhciA9IE1hdGgubWF4KHQsIHROZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0TmVhciA+IHRGYXIpIHtcbiAgICAgICAgICAvLyBpZiB0TmVhciBldmVyIGlzIGdyZWF0ZXIgdGhhbiB0RmFyLCB0aGUgcmF5IG11c3QgbWlzcyB0aGUgY29udmV4IGh1bGxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBldmFsdWF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgIC8vIGFsd2F5cyB0cnkgdE5lYXIgZmlyc3Qgc2luY2UgaXRzIHRoZSBjbG9zZXIgaW50ZXJzZWN0aW9uIHBvaW50XG5cblxuICAgICAgaWYgKHROZWFyICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmF5LmF0KHROZWFyLCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmF5LmF0KHRGYXIsIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RzUmF5OiBmdW5jdGlvbiAocmF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RSYXkocmF5LCB2MSkgIT09IG51bGw7XG4gICAgfSxcbiAgICBtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZmFjZXMgPSBbXTtcbiAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQWRkcyBhIHZlcnRleCB0byB0aGUgJ2Fzc2lnbmVkJyBsaXN0IG9mIHZlcnRpY2VzIGFuZCBhc3NpZ25zIGl0IHRvIHRoZSBnaXZlbiBmYWNlXG4gICAgYWRkVmVydGV4VG9GYWNlOiBmdW5jdGlvbiAodmVydGV4LCBmYWNlKSB7XG4gICAgICB2ZXJ0ZXguZmFjZSA9IGZhY2U7XG5cbiAgICAgIGlmIChmYWNlLm91dHNpZGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NpZ25lZC5hcHBlbmQodmVydGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXNzaWduZWQuaW5zZXJ0QmVmb3JlKGZhY2Uub3V0c2lkZSwgdmVydGV4KTtcbiAgICAgIH1cblxuICAgICAgZmFjZS5vdXRzaWRlID0gdmVydGV4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBSZW1vdmVzIGEgdmVydGV4IGZyb20gdGhlICdhc3NpZ25lZCcgbGlzdCBvZiB2ZXJ0aWNlcyBhbmQgZnJvbSB0aGUgZ2l2ZW4gZmFjZVxuICAgIHJlbW92ZVZlcnRleEZyb21GYWNlOiBmdW5jdGlvbiAodmVydGV4LCBmYWNlKSB7XG4gICAgICBpZiAodmVydGV4ID09PSBmYWNlLm91dHNpZGUpIHtcbiAgICAgICAgLy8gZml4IGZhY2Uub3V0c2lkZSBsaW5rXG4gICAgICAgIGlmICh2ZXJ0ZXgubmV4dCAhPT0gbnVsbCAmJiB2ZXJ0ZXgubmV4dC5mYWNlID09PSBmYWNlKSB7XG4gICAgICAgICAgLy8gZmFjZSBoYXMgYXQgbGVhc3QgMiBvdXRzaWRlIHZlcnRpY2VzLCBtb3ZlIHRoZSAnb3V0c2lkZScgcmVmZXJlbmNlXG4gICAgICAgICAgZmFjZS5vdXRzaWRlID0gdmVydGV4Lm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmVydGV4IHdhcyB0aGUgb25seSBvdXRzaWRlIHZlcnRleCB0aGF0IGZhY2UgaGFkXG4gICAgICAgICAgZmFjZS5vdXRzaWRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFzc2lnbmVkLnJlbW92ZSh2ZXJ0ZXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBSZW1vdmVzIGFsbCB0aGUgdmlzaWJsZSB2ZXJ0aWNlcyB0aGF0IGEgZ2l2ZW4gZmFjZSBpcyBhYmxlIHRvIHNlZSB3aGljaCBhcmUgc3RvcmVkIGluIHRoZSAnYXNzaWduZWQnIHZlcnRleHQgbGlzdFxuICAgIHJlbW92ZUFsbFZlcnRpY2VzRnJvbUZhY2U6IGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICBpZiAoZmFjZS5vdXRzaWRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgZmlyc3QgYW5kIGxhc3QgdmVydGV4IG9mIHRoaXMgZmFjZVxuICAgICAgICB2YXIgc3RhcnQgPSBmYWNlLm91dHNpZGU7XG4gICAgICAgIHZhciBlbmQgPSBmYWNlLm91dHNpZGU7XG5cbiAgICAgICAgd2hpbGUgKGVuZC5uZXh0ICE9PSBudWxsICYmIGVuZC5uZXh0LmZhY2UgPT09IGZhY2UpIHtcbiAgICAgICAgICBlbmQgPSBlbmQubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXNzaWduZWQucmVtb3ZlU3ViTGlzdChzdGFydCwgZW5kKTsgLy8gZml4IHJlZmVyZW5jZXNcblxuICAgICAgICBzdGFydC5wcmV2ID0gZW5kLm5leHQgPSBudWxsO1xuICAgICAgICBmYWNlLm91dHNpZGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBSZW1vdmVzIGFsbCB0aGUgdmlzaWJsZSB2ZXJ0aWNlcyB0aGF0ICdmYWNlJyBpcyBhYmxlIHRvIHNlZVxuICAgIGRlbGV0ZUZhY2VWZXJ0aWNlczogZnVuY3Rpb24gKGZhY2UsIGFic29yYmluZ0ZhY2UpIHtcbiAgICAgIHZhciBmYWNlVmVydGljZXMgPSB0aGlzLnJlbW92ZUFsbFZlcnRpY2VzRnJvbUZhY2UoZmFjZSk7XG5cbiAgICAgIGlmIChmYWNlVmVydGljZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWJzb3JiaW5nRmFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gbWFyayB0aGUgdmVydGljZXMgdG8gYmUgcmVhc3NpZ25lZCB0byBzb21lIG90aGVyIGZhY2VcbiAgICAgICAgICB0aGlzLnVuYXNzaWduZWQuYXBwZW5kQ2hhaW4oZmFjZVZlcnRpY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIGFuIGFic29yYmluZyBmYWNlIHRyeSB0byBhc3NpZ24gYXMgbWFueSB2ZXJ0aWNlcyBhcyBwb3NzaWJsZSB0byBpdFxuICAgICAgICAgIHZhciB2ZXJ0ZXggPSBmYWNlVmVydGljZXM7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciB0aGUgc3Vic2VxdWVudCB2ZXJ0ZXggYXQgdGhpcyBwb2ludCBiZWNhdXNlIHRoZSAndmVydGV4Lm5leHQnIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gd2lsbCBiZSBjaGFuZ2VkIGJ5IHVwY29taW5nIG1ldGhvZCBjYWxsc1xuICAgICAgICAgICAgdmFyIG5leHRWZXJ0ZXggPSB2ZXJ0ZXgubmV4dDtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGFic29yYmluZ0ZhY2UuZGlzdGFuY2VUb1BvaW50KHZlcnRleC5wb2ludCk7IC8vIGNoZWNrIGlmICd2ZXJ0ZXgnIGlzIGFibGUgdG8gc2VlICdhYnNvcmJpbmdGYWNlJ1xuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLnRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleFRvRmFjZSh2ZXJ0ZXgsIGFic29yYmluZ0ZhY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy51bmFzc2lnbmVkLmFwcGVuZCh2ZXJ0ZXgpO1xuICAgICAgICAgICAgfSAvLyBub3cgYXNzaWduIG5leHQgdmVydGV4XG5cblxuICAgICAgICAgICAgdmVydGV4ID0gbmV4dFZlcnRleDtcbiAgICAgICAgICB9IHdoaWxlICh2ZXJ0ZXggIT09IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVhc3NpZ25zIGFzIG1hbnkgdmVydGljZXMgYXMgcG9zc2libGUgZnJvbSB0aGUgdW5hc3NpZ25lZCBsaXN0IHRvIHRoZSBuZXcgZmFjZXNcbiAgICByZXNvbHZlVW5hc3NpZ25lZFBvaW50czogZnVuY3Rpb24gKG5ld0ZhY2VzKSB7XG4gICAgICBpZiAodGhpcy51bmFzc2lnbmVkLmlzRW1wdHkoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudW5hc3NpZ25lZC5maXJzdCgpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBidWZmZXIgJ25leHQnIHJlZmVyZW5jZSwgc2VlIC5kZWxldGVGYWNlVmVydGljZXMoKVxuICAgICAgICAgIHZhciBuZXh0VmVydGV4ID0gdmVydGV4Lm5leHQ7XG4gICAgICAgICAgdmFyIG1heERpc3RhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgICAgICAgdmFyIG1heEZhY2UgPSBudWxsO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdGYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXdGYWNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGZhY2UubWFyayA9PT0gVmlzaWJsZSkge1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBmYWNlLmRpc3RhbmNlVG9Qb2ludCh2ZXJ0ZXgucG9pbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBtYXhGYWNlID0gZmFjZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtYXhEaXN0YW5jZSA+IDEwMDAgKiB0aGlzLnRvbGVyYW5jZSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyAnbWF4RmFjZScgY2FuIGJlIG51bGwgZS5nLiBpZiB0aGVyZSBhcmUgaWRlbnRpY2FsIHZlcnRpY2VzXG5cblxuICAgICAgICAgIGlmIChtYXhGYWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFZlcnRleFRvRmFjZSh2ZXJ0ZXgsIG1heEZhY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZlcnRleCA9IG5leHRWZXJ0ZXg7XG4gICAgICAgIH0gd2hpbGUgKHZlcnRleCAhPT0gbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGV4dHJlbWVzIG9mIGEgc2ltcGxleCB3aGljaCB3aWxsIGJlIHRoZSBpbml0aWFsIGh1bGxcbiAgICBjb21wdXRlRXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtaW4gPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdmFyIG1heCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB2YXIgbWluVmVydGljZXMgPSBbXTtcbiAgICAgIHZhciBtYXhWZXJ0aWNlcyA9IFtdO1xuICAgICAgdmFyIGksIGwsIGo7IC8vIGluaXRpYWxseSBhc3N1bWUgdGhhdCB0aGUgZmlyc3QgdmVydGV4IGlzIHRoZSBtaW4vbWF4XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbWluVmVydGljZXNbaV0gPSBtYXhWZXJ0aWNlc1tpXSA9IHRoaXMudmVydGljZXNbMF07XG4gICAgICB9XG5cbiAgICAgIG1pbi5jb3B5KHRoaXMudmVydGljZXNbMF0ucG9pbnQpO1xuICAgICAgbWF4LmNvcHkodGhpcy52ZXJ0aWNlc1swXS5wb2ludCk7IC8vIGNvbXB1dGUgdGhlIG1pbi9tYXggdmVydGV4IG9uIGFsbCBzaXggZGlyZWN0aW9uc1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHZhciBwb2ludCA9IHZlcnRleC5wb2ludDsgLy8gdXBkYXRlIHRoZSBtaW4gY29vcmRpbmF0ZXNcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgaWYgKHBvaW50LmdldENvbXBvbmVudChqKSA8IG1pbi5nZXRDb21wb25lbnQoaikpIHtcbiAgICAgICAgICAgIG1pbi5zZXRDb21wb25lbnQoaiwgcG9pbnQuZ2V0Q29tcG9uZW50KGopKTtcbiAgICAgICAgICAgIG1pblZlcnRpY2VzW2pdID0gdmVydGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB1cGRhdGUgdGhlIG1heCBjb29yZGluYXRlc1xuXG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgIGlmIChwb2ludC5nZXRDb21wb25lbnQoaikgPiBtYXguZ2V0Q29tcG9uZW50KGopKSB7XG4gICAgICAgICAgICBtYXguc2V0Q29tcG9uZW50KGosIHBvaW50LmdldENvbXBvbmVudChqKSk7XG4gICAgICAgICAgICBtYXhWZXJ0aWNlc1tqXSA9IHZlcnRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXNlIG1pbi9tYXggdmVjdG9ycyB0byBjb21wdXRlIGFuIG9wdGltYWwgZXBzaWxvblxuXG5cbiAgICAgIHRoaXMudG9sZXJhbmNlID0gMyAqIE51bWJlci5FUFNJTE9OICogKE1hdGgubWF4KE1hdGguYWJzKG1pbi54KSwgTWF0aC5hYnMobWF4LngpKSArIE1hdGgubWF4KE1hdGguYWJzKG1pbi55KSwgTWF0aC5hYnMobWF4LnkpKSArIE1hdGgubWF4KE1hdGguYWJzKG1pbi56KSwgTWF0aC5hYnMobWF4LnopKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IG1pblZlcnRpY2VzLFxuICAgICAgICBtYXg6IG1heFZlcnRpY2VzXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGluaXRpYWwgc2ltcGxleCBhc3NpZ25pbmcgdG8gaXRzIGZhY2VzIGFsbCB0aGUgcG9pbnRzXG4gICAgLy8gdGhhdCBhcmUgY2FuZGlkYXRlcyB0byBmb3JtIHBhcnQgb2YgdGhlIGh1bGxcbiAgICBjb21wdXRlSW5pdGlhbEh1bGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsaW5lMywgcGxhbmUsIGNsb3Nlc3RQb2ludDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlSW5pdGlhbEh1bGwoKSB7XG4gICAgICAgIGlmIChsaW5lMyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGluZTMgPSBuZXcgdGhyZWUuTGluZTMoKTtcbiAgICAgICAgICBwbGFuZSA9IG5ldyB0aHJlZS5QbGFuZSgpO1xuICAgICAgICAgIGNsb3Nlc3RQb2ludCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4LFxuICAgICAgICAgICAgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgZXh0cmVtZXMgPSB0aGlzLmNvbXB1dGVFeHRyZW1lcygpO1xuICAgICAgICB2YXIgbWluID0gZXh0cmVtZXMubWluO1xuICAgICAgICB2YXIgbWF4ID0gZXh0cmVtZXMubWF4O1xuICAgICAgICB2YXIgdjAsIHYxLCB2MiwgdjM7XG4gICAgICAgIHZhciBpLCBsLCBqOyAvLyAxLiBGaW5kIHRoZSB0d28gdmVydGljZXMgJ3YwJyBhbmQgJ3YxJyB3aXRoIHRoZSBncmVhdGVzdCAxZCBzZXBhcmF0aW9uXG4gICAgICAgIC8vIChtYXgueCAtIG1pbi54KVxuICAgICAgICAvLyAobWF4LnkgLSBtaW4ueSlcbiAgICAgICAgLy8gKG1heC56IC0gbWluLnopXG5cbiAgICAgICAgdmFyIGRpc3RhbmNlLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSAwO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IG1heFtpXS5wb2ludC5nZXRDb21wb25lbnQoaSkgLSBtaW5baV0ucG9pbnQuZ2V0Q29tcG9uZW50KGkpO1xuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdjAgPSBtaW5baW5kZXhdO1xuICAgICAgICB2MSA9IG1heFtpbmRleF07IC8vIDIuIFRoZSBuZXh0IHZlcnRleCAndjInIGlzIHRoZSBvbmUgZmFydGhlc3QgdG8gdGhlIGxpbmUgZm9ybWVkIGJ5ICd2MCcgYW5kICd2MSdcblxuICAgICAgICBtYXhEaXN0YW5jZSA9IDA7XG4gICAgICAgIGxpbmUzLnNldCh2MC5wb2ludCwgdjEucG9pbnQpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHZlcnRleCAhPT0gdjAgJiYgdmVydGV4ICE9PSB2MSkge1xuICAgICAgICAgICAgbGluZTMuY2xvc2VzdFBvaW50VG9Qb2ludCh2ZXJ0ZXgucG9pbnQsIHRydWUsIGNsb3Nlc3RQb2ludCk7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCh2ZXJ0ZXgucG9pbnQpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICB2MiA9IHZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gMy4gVGhlIG5leHQgdmVydGV4ICd2MycgaXMgdGhlIG9uZSBmYXJ0aGVzdCB0byB0aGUgcGxhbmUgJ3YwJywgJ3YxJywgJ3YyJ1xuXG5cbiAgICAgICAgbWF4RGlzdGFuY2UgPSAtMTtcbiAgICAgICAgcGxhbmUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHYwLnBvaW50LCB2MS5wb2ludCwgdjIucG9pbnQpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHZlcnRleCAhPT0gdjAgJiYgdmVydGV4ICE9PSB2MSAmJiB2ZXJ0ZXggIT09IHYyKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh2ZXJ0ZXgucG9pbnQpKTtcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgdjMgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhY2VzID0gW107XG5cbiAgICAgICAgaWYgKHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh2My5wb2ludCkgPCAwKSB7XG4gICAgICAgICAgLy8gdGhlIGZhY2UgaXMgbm90IGFibGUgdG8gc2VlIHRoZSBwb2ludCBzbyAncGxhbmUubm9ybWFsJyBpcyBwb2ludGluZyBvdXRzaWRlIHRoZSB0ZXRyYWhlZHJvblxuICAgICAgICAgIGZhY2VzLnB1c2goRmFjZS5jcmVhdGUodjAsIHYxLCB2MiksIEZhY2UuY3JlYXRlKHYzLCB2MSwgdjApLCBGYWNlLmNyZWF0ZSh2MywgdjIsIHYxKSwgRmFjZS5jcmVhdGUodjMsIHYwLCB2MikpOyAvLyBzZXQgdGhlIHR3aW4gZWRnZVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgaiA9IChpICsgMSkgJSAzOyAvLyBqb2luIGZhY2VbIGkgXSBpID4gMCwgd2l0aCB0aGUgZmlyc3QgZmFjZVxuXG4gICAgICAgICAgICBmYWNlc1tpICsgMV0uZ2V0RWRnZSgyKS5zZXRUd2luKGZhY2VzWzBdLmdldEVkZ2UoaikpOyAvLyBqb2luIGZhY2VbIGkgXSB3aXRoIGZhY2VbIGkgKyAxIF0sIDEgPD0gaSA8PSAzXG5cbiAgICAgICAgICAgIGZhY2VzW2kgKyAxXS5nZXRFZGdlKDEpLnNldFR3aW4oZmFjZXNbaiArIDFdLmdldEVkZ2UoMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGUgZmFjZSBpcyBhYmxlIHRvIHNlZSB0aGUgcG9pbnQgc28gJ3BsYW5lLm5vcm1hbCcgaXMgcG9pbnRpbmcgaW5zaWRlIHRoZSB0ZXRyYWhlZHJvblxuICAgICAgICAgIGZhY2VzLnB1c2goRmFjZS5jcmVhdGUodjAsIHYyLCB2MSksIEZhY2UuY3JlYXRlKHYzLCB2MCwgdjEpLCBGYWNlLmNyZWF0ZSh2MywgdjEsIHYyKSwgRmFjZS5jcmVhdGUodjMsIHYyLCB2MCkpOyAvLyBzZXQgdGhlIHR3aW4gZWRnZVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgaiA9IChpICsgMSkgJSAzOyAvLyBqb2luIGZhY2VbIGkgXSBpID4gMCwgd2l0aCB0aGUgZmlyc3QgZmFjZVxuXG4gICAgICAgICAgICBmYWNlc1tpICsgMV0uZ2V0RWRnZSgyKS5zZXRUd2luKGZhY2VzWzBdLmdldEVkZ2UoKDMgLSBpKSAlIDMpKTsgLy8gam9pbiBmYWNlWyBpIF0gd2l0aCBmYWNlWyBpICsgMSBdXG5cbiAgICAgICAgICAgIGZhY2VzW2kgKyAxXS5nZXRFZGdlKDApLnNldFR3aW4oZmFjZXNbaiArIDFdLmdldEVkZ2UoMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0aGUgaW5pdGlhbCBodWxsIGlzIHRoZSB0ZXRyYWhlZHJvblxuXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChmYWNlc1tpXSk7XG4gICAgICAgIH0gLy8gaW5pdGlhbCBhc3NpZ25tZW50IG9mIHZlcnRpY2VzIHRvIHRoZSBmYWNlcyBvZiB0aGUgdGV0cmFoZWRyb25cblxuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IHYwICYmIHZlcnRleCAhPT0gdjEgJiYgdmVydGV4ICE9PSB2MiAmJiB2ZXJ0ZXggIT09IHYzKSB7XG4gICAgICAgICAgICBtYXhEaXN0YW5jZSA9IHRoaXMudG9sZXJhbmNlO1xuICAgICAgICAgICAgdmFyIG1heEZhY2UgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5mYWNlc1tqXS5kaXN0YW5jZVRvUG9pbnQodmVydGV4LnBvaW50KTtcblxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgbWF4RmFjZSA9IHRoaXMuZmFjZXNbal07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1heEZhY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXhUb0ZhY2UodmVydGV4LCBtYXhGYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSgpLFxuICAgIC8vIFJlbW92ZXMgaW5hY3RpdmUgZmFjZXNcbiAgICByZWluZGV4RmFjZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhY3RpdmVGYWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzW2ldO1xuXG4gICAgICAgIGlmIChmYWNlLm1hcmsgPT09IFZpc2libGUpIHtcbiAgICAgICAgICBhY3RpdmVGYWNlcy5wdXNoKGZhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmFjZXMgPSBhY3RpdmVGYWNlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gRmluZHMgdGhlIG5leHQgdmVydGV4IHRvIGNyZWF0ZSBmYWNlcyB3aXRoIHRoZSBjdXJyZW50IGh1bGxcbiAgICBuZXh0VmVydGV4VG9BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmIHRoZSAnYXNzaWduZWQnIGxpc3Qgb2YgdmVydGljZXMgaXMgZW1wdHksIG5vIHZlcnRpY2VzIGFyZSBsZWZ0LiByZXR1cm4gd2l0aCAndW5kZWZpbmVkJ1xuICAgICAgaWYgKHRoaXMuYXNzaWduZWQuaXNFbXB0eSgpID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgZXllVmVydGV4LFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSAwOyAvLyBncmFwIHRoZSBmaXJzdCBhdmFpbGFibGUgZmFjZSBhbmQgc3RhcnQgd2l0aCB0aGUgZmlyc3QgdmlzaWJsZSB2ZXJ0ZXggb2YgdGhhdCBmYWNlXG5cbiAgICAgICAgdmFyIGV5ZUZhY2UgPSB0aGlzLmFzc2lnbmVkLmZpcnN0KCkuZmFjZTtcbiAgICAgICAgdmFyIHZlcnRleCA9IGV5ZUZhY2Uub3V0c2lkZTsgLy8gbm93IGNhbGN1bGF0ZSB0aGUgZmFydGhlc3QgdmVydGV4IHRoYXQgZmFjZSBjYW4gc2VlXG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGV5ZUZhY2UuZGlzdGFuY2VUb1BvaW50KHZlcnRleC5wb2ludCk7XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIGV5ZVZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0ZXgubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodmVydGV4ICE9PSBudWxsICYmIHZlcnRleC5mYWNlID09PSBleWVGYWNlKTtcblxuICAgICAgICByZXR1cm4gZXllVmVydGV4O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQ29tcHV0ZXMgYSBjaGFpbiBvZiBoYWxmIGVkZ2VzIGluIENDVyBvcmRlciBjYWxsZWQgdGhlICdob3Jpem9uJy5cbiAgICAvLyBGb3IgYW4gZWRnZSB0byBiZSBwYXJ0IG9mIHRoZSBob3Jpem9uIGl0IG11c3Qgam9pbiBhIGZhY2UgdGhhdCBjYW4gc2VlXG4gICAgLy8gJ2V5ZVBvaW50JyBhbmQgYSBmYWNlIHRoYXQgY2Fubm90IHNlZSAnZXllUG9pbnQnLlxuICAgIGNvbXB1dGVIb3Jpem9uOiBmdW5jdGlvbiAoZXllUG9pbnQsIGNyb3NzRWRnZSwgZmFjZSwgaG9yaXpvbikge1xuICAgICAgLy8gbW92ZXMgZmFjZSdzIHZlcnRpY2VzIHRvIHRoZSAndW5hc3NpZ25lZCcgdmVydGV4IGxpc3RcbiAgICAgIHRoaXMuZGVsZXRlRmFjZVZlcnRpY2VzKGZhY2UpO1xuICAgICAgZmFjZS5tYXJrID0gRGVsZXRlZDtcbiAgICAgIHZhciBlZGdlO1xuXG4gICAgICBpZiAoY3Jvc3NFZGdlID09PSBudWxsKSB7XG4gICAgICAgIGVkZ2UgPSBjcm9zc0VkZ2UgPSBmYWNlLmdldEVkZ2UoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdGFydCBmcm9tIHRoZSBuZXh0IGVkZ2Ugc2luY2UgJ2Nyb3NzRWRnZScgd2FzIGFscmVhZHkgYW5hbHl6ZWRcbiAgICAgICAgLy8gKGFjdHVhbGx5ICdjcm9zc0VkZ2UudHdpbicgd2FzIHRoZSBlZGdlIHdobyBjYWxsZWQgdGhpcyBtZXRob2QgcmVjdXJzaXZlbHkpXG4gICAgICAgIGVkZ2UgPSBjcm9zc0VkZ2UubmV4dDtcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICB2YXIgdHdpbkVkZ2UgPSBlZGdlLnR3aW47XG4gICAgICAgIHZhciBvcHBvc2l0ZUZhY2UgPSB0d2luRWRnZS5mYWNlO1xuXG4gICAgICAgIGlmIChvcHBvc2l0ZUZhY2UubWFyayA9PT0gVmlzaWJsZSkge1xuICAgICAgICAgIGlmIChvcHBvc2l0ZUZhY2UuZGlzdGFuY2VUb1BvaW50KGV5ZVBvaW50KSA+IHRoaXMudG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3Bwb3NpdGUgZmFjZSBjYW4gc2VlIHRoZSB2ZXJ0ZXgsIHNvIHByb2NlZWQgd2l0aCBuZXh0IGVkZ2VcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUhvcml6b24oZXllUG9pbnQsIHR3aW5FZGdlLCBvcHBvc2l0ZUZhY2UsIGhvcml6b24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgb3Bwb3NpdGUgZmFjZSBjYW4ndCBzZWUgdGhlIHZlcnRleCwgc28gdGhpcyBlZGdlIGlzIHBhcnQgb2YgdGhlIGhvcml6b25cbiAgICAgICAgICAgIGhvcml6b24ucHVzaChlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfSB3aGlsZSAoZWRnZSAhPT0gY3Jvc3NFZGdlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBDcmVhdGVzIGEgZmFjZSB3aXRoIHRoZSB2ZXJ0aWNlcyAnZXllVmVydGV4LnBvaW50JywgJ2hvcml6b25FZGdlLnRhaWwnIGFuZCAnaG9yaXpvbkVkZ2UuaGVhZCcgaW4gQ0NXIG9yZGVyXG4gICAgYWRkQWRqb2luaW5nRmFjZTogZnVuY3Rpb24gKGV5ZVZlcnRleCwgaG9yaXpvbkVkZ2UpIHtcbiAgICAgIC8vIGFsbCB0aGUgaGFsZiBlZGdlcyBhcmUgY3JlYXRlZCBpbiBjY3cgb3JkZXIgdGh1cyB0aGUgZmFjZSBpcyBhbHdheXMgcG9pbnRpbmcgb3V0c2lkZSB0aGUgaHVsbFxuICAgICAgdmFyIGZhY2UgPSBGYWNlLmNyZWF0ZShleWVWZXJ0ZXgsIGhvcml6b25FZGdlLnRhaWwoKSwgaG9yaXpvbkVkZ2UuaGVhZCgpKTtcbiAgICAgIHRoaXMuZmFjZXMucHVzaChmYWNlKTsgLy8gam9pbiBmYWNlLmdldEVkZ2UoIC0gMSApIHdpdGggdGhlIGhvcml6b24ncyBvcHBvc2l0ZSBlZGdlIGZhY2UuZ2V0RWRnZSggLSAxICkgPSBmYWNlLmdldEVkZ2UoIDIgKVxuXG4gICAgICBmYWNlLmdldEVkZ2UoLTEpLnNldFR3aW4oaG9yaXpvbkVkZ2UudHdpbik7XG4gICAgICByZXR1cm4gZmFjZS5nZXRFZGdlKDApOyAvLyB0aGUgaGFsZiBlZGdlIHdob3NlIHZlcnRleCBpcyB0aGUgZXllVmVydGV4XG4gICAgfSxcbiAgICAvLyAgQWRkcyAnaG9yaXpvbi5sZW5ndGgnIGZhY2VzIHRvIHRoZSBodWxsLCBlYWNoIGZhY2Ugd2lsbCBiZSBsaW5rZWQgd2l0aCB0aGVcbiAgICAvLyAgaG9yaXpvbiBvcHBvc2l0ZSBmYWNlIGFuZCB0aGUgZmFjZSBvbiB0aGUgbGVmdC9yaWdodFxuICAgIGFkZE5ld0ZhY2VzOiBmdW5jdGlvbiAoZXllVmVydGV4LCBob3Jpem9uKSB7XG4gICAgICB0aGlzLm5ld0ZhY2VzID0gW107XG4gICAgICB2YXIgZmlyc3RTaWRlRWRnZSA9IG51bGw7XG4gICAgICB2YXIgcHJldmlvdXNTaWRlRWRnZSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9yaXpvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaG9yaXpvbkVkZ2UgPSBob3Jpem9uW2ldOyAvLyByZXR1cm5zIHRoZSByaWdodCBzaWRlIGVkZ2VcblxuICAgICAgICB2YXIgc2lkZUVkZ2UgPSB0aGlzLmFkZEFkam9pbmluZ0ZhY2UoZXllVmVydGV4LCBob3Jpem9uRWRnZSk7XG5cbiAgICAgICAgaWYgKGZpcnN0U2lkZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFNpZGVFZGdlID0gc2lkZUVkZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gam9pbnMgZmFjZS5nZXRFZGdlKCAxICkgd2l0aCBwcmV2aW91c0ZhY2UuZ2V0RWRnZSggMCApXG4gICAgICAgICAgc2lkZUVkZ2UubmV4dC5zZXRUd2luKHByZXZpb3VzU2lkZUVkZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXdGYWNlcy5wdXNoKHNpZGVFZGdlLmZhY2UpO1xuICAgICAgICBwcmV2aW91c1NpZGVFZGdlID0gc2lkZUVkZ2U7XG4gICAgICB9IC8vIHBlcmZvcm0gZmluYWwgam9pbiBvZiBuZXcgZmFjZXNcblxuXG4gICAgICBmaXJzdFNpZGVFZGdlLm5leHQuc2V0VHdpbihwcmV2aW91c1NpZGVFZGdlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQWRkcyBhIHZlcnRleCB0byB0aGUgaHVsbFxuICAgIGFkZFZlcnRleFRvSHVsbDogZnVuY3Rpb24gKGV5ZVZlcnRleCkge1xuICAgICAgdmFyIGhvcml6b24gPSBbXTtcbiAgICAgIHRoaXMudW5hc3NpZ25lZC5jbGVhcigpOyAvLyByZW1vdmUgJ2V5ZVZlcnRleCcgZnJvbSAnZXllVmVydGV4LmZhY2UnIHNvIHRoYXQgaXQgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlICd1bmFzc2lnbmVkJyB2ZXJ0ZXggbGlzdFxuXG4gICAgICB0aGlzLnJlbW92ZVZlcnRleEZyb21GYWNlKGV5ZVZlcnRleCwgZXllVmVydGV4LmZhY2UpO1xuICAgICAgdGhpcy5jb21wdXRlSG9yaXpvbihleWVWZXJ0ZXgucG9pbnQsIG51bGwsIGV5ZVZlcnRleC5mYWNlLCBob3Jpem9uKTtcbiAgICAgIHRoaXMuYWRkTmV3RmFjZXMoZXllVmVydGV4LCBob3Jpem9uKTsgLy8gcmVhc3NpZ24gJ3VuYXNzaWduZWQnIHZlcnRpY2VzIHRvIHRoZSBuZXcgZmFjZXNcblxuICAgICAgdGhpcy5yZXNvbHZlVW5hc3NpZ25lZFBvaW50cyh0aGlzLm5ld0ZhY2VzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xlYW51cDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hc3NpZ25lZC5jbGVhcigpO1xuICAgICAgdGhpcy51bmFzc2lnbmVkLmNsZWFyKCk7XG4gICAgICB0aGlzLm5ld0ZhY2VzID0gW107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNvbXB1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXg7XG4gICAgICB0aGlzLmNvbXB1dGVJbml0aWFsSHVsbCgpOyAvLyBhZGQgYWxsIGF2YWlsYWJsZSB2ZXJ0aWNlcyBncmFkdWFsbHkgdG8gdGhlIGh1bGxcblxuICAgICAgd2hpbGUgKCh2ZXJ0ZXggPSB0aGlzLm5leHRWZXJ0ZXhUb0FkZCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYWRkVmVydGV4VG9IdWxsKHZlcnRleCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVpbmRleEZhY2VzKCk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7IC8vXG5cbiAgZnVuY3Rpb24gRmFjZSgpIHtcbiAgICB0aGlzLm5vcm1hbCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgdGhpcy5taWRwb2ludCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgdGhpcy5hcmVhID0gMDtcbiAgICB0aGlzLmNvbnN0YW50ID0gMDsgLy8gc2lnbmVkIGRpc3RhbmNlIGZyb20gZmFjZSB0byB0aGUgb3JpZ2luXG5cbiAgICB0aGlzLm91dHNpZGUgPSBudWxsOyAvLyByZWZlcmVuY2UgdG8gYSB2ZXJ0ZXggaW4gYSB2ZXJ0ZXggbGlzdCB0aGlzIGZhY2UgY2FuIHNlZVxuXG4gICAgdGhpcy5tYXJrID0gVmlzaWJsZTtcbiAgICB0aGlzLmVkZ2UgPSBudWxsO1xuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihGYWNlLCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgdmFyIGZhY2UgPSBuZXcgRmFjZSgpO1xuICAgICAgdmFyIGUwID0gbmV3IEhhbGZFZGdlKGEsIGZhY2UpO1xuICAgICAgdmFyIGUxID0gbmV3IEhhbGZFZGdlKGIsIGZhY2UpO1xuICAgICAgdmFyIGUyID0gbmV3IEhhbGZFZGdlKGMsIGZhY2UpOyAvLyBqb2luIGVkZ2VzXG5cbiAgICAgIGUwLm5leHQgPSBlMi5wcmV2ID0gZTE7XG4gICAgICBlMS5uZXh0ID0gZTAucHJldiA9IGUyO1xuICAgICAgZTIubmV4dCA9IGUxLnByZXYgPSBlMDsgLy8gbWFpbiBoYWxmIGVkZ2UgcmVmZXJlbmNlXG5cbiAgICAgIGZhY2UuZWRnZSA9IGUwO1xuICAgICAgcmV0dXJuIGZhY2UuY29tcHV0ZSgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5hc3NpZ24oRmFjZS5wcm90b3R5cGUsIHtcbiAgICBnZXRFZGdlOiBmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2U7XG5cbiAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpIDwgMCkge1xuICAgICAgICBlZGdlID0gZWRnZS5wcmV2O1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlO1xuICAgIH0sXG4gICAgY29tcHV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyaWFuZ2xlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGUoKSB7XG4gICAgICAgIGlmICh0cmlhbmdsZSA9PT0gdW5kZWZpbmVkKSB0cmlhbmdsZSA9IG5ldyB0aHJlZS5UcmlhbmdsZSgpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuZWRnZS50YWlsKCk7XG4gICAgICAgIHZhciBiID0gdGhpcy5lZGdlLmhlYWQoKTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmVkZ2UubmV4dC5oZWFkKCk7XG4gICAgICAgIHRyaWFuZ2xlLnNldChhLnBvaW50LCBiLnBvaW50LCBjLnBvaW50KTtcbiAgICAgICAgdHJpYW5nbGUuZ2V0Tm9ybWFsKHRoaXMubm9ybWFsKTtcbiAgICAgICAgdHJpYW5nbGUuZ2V0TWlkcG9pbnQodGhpcy5taWRwb2ludCk7XG4gICAgICAgIHRoaXMuYXJlYSA9IHRyaWFuZ2xlLmdldEFyZWEoKTtcbiAgICAgICAgdGhpcy5jb25zdGFudCA9IHRoaXMubm9ybWFsLmRvdCh0aGlzLm1pZHBvaW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0oKSxcbiAgICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdChwb2ludCkgLSB0aGlzLmNvbnN0YW50O1xuICAgIH1cbiAgfSk7IC8vIEVudGl0eSBmb3IgYSBEb3VibHktQ29ubmVjdGVkIEVkZ2UgTGlzdCAoRENFTCkuXG5cbiAgZnVuY3Rpb24gSGFsZkVkZ2UodmVydGV4LCBmYWNlKSB7XG4gICAgdGhpcy52ZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMudHdpbiA9IG51bGw7XG4gICAgdGhpcy5mYWNlID0gZmFjZTtcbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oSGFsZkVkZ2UucHJvdG90eXBlLCB7XG4gICAgaGVhZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGV4O1xuICAgIH0sXG4gICAgdGFpbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldiA/IHRoaXMucHJldi52ZXJ0ZXggOiBudWxsO1xuICAgIH0sXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCgpO1xuICAgICAgdmFyIHRhaWwgPSB0aGlzLnRhaWwoKTtcblxuICAgICAgaWYgKHRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwucG9pbnQuZGlzdGFuY2VUbyhoZWFkLnBvaW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgbGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQoKTtcbiAgICAgIHZhciB0YWlsID0gdGhpcy50YWlsKCk7XG5cbiAgICAgIGlmICh0YWlsICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0YWlsLnBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKGhlYWQucG9pbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBzZXRUd2luOiBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgdGhpcy50d2luID0gZWRnZTtcbiAgICAgIGVkZ2UudHdpbiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pOyAvLyBBIHZlcnRleCBhcyBhIGRvdWJsZSBsaW5rZWQgbGlzdCBub2RlLlxuXG4gIGZ1bmN0aW9uIFZlcnRleE5vZGUocG9pbnQpIHtcbiAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMuZmFjZSA9IG51bGw7IC8vIHRoZSBmYWNlIHRoYXQgaXMgYWJsZSB0byBzZWUgdGhpcyB2ZXJ0ZXhcbiAgfSAvLyBBIGRvdWJsZSBsaW5rZWQgbGlzdCB0aGF0IGNvbnRhaW5zIHZlcnRleCBub2Rlcy5cblxuXG4gIGZ1bmN0aW9uIFZlcnRleExpc3QoKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihWZXJ0ZXhMaXN0LnByb3RvdHlwZSwge1xuICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkO1xuICAgIH0sXG4gICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFpbDtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBJbnNlcnRzIGEgdmVydGV4IGJlZm9yZSB0aGUgdGFyZ2V0IHZlcnRleFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHRhcmdldCwgdmVydGV4KSB7XG4gICAgICB2ZXJ0ZXgucHJldiA9IHRhcmdldC5wcmV2O1xuICAgICAgdmVydGV4Lm5leHQgPSB0YXJnZXQ7XG5cbiAgICAgIGlmICh2ZXJ0ZXgucHJldiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB2ZXJ0ZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJ0ZXgucHJldi5uZXh0ID0gdmVydGV4O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQucHJldiA9IHZlcnRleDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gSW5zZXJ0cyBhIHZlcnRleCBhZnRlciB0aGUgdGFyZ2V0IHZlcnRleFxuICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbiAodGFyZ2V0LCB2ZXJ0ZXgpIHtcbiAgICAgIHZlcnRleC5wcmV2ID0gdGFyZ2V0O1xuICAgICAgdmVydGV4Lm5leHQgPSB0YXJnZXQubmV4dDtcblxuICAgICAgaWYgKHZlcnRleC5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGFpbCA9IHZlcnRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnRleC5uZXh0LnByZXYgPSB2ZXJ0ZXg7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5uZXh0ID0gdmVydGV4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBBcHBlbmRzIGEgdmVydGV4IHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0XG4gICAgYXBwZW5kOiBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHZlcnRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gdmVydGV4O1xuICAgICAgfVxuXG4gICAgICB2ZXJ0ZXgucHJldiA9IHRoaXMudGFpbDtcbiAgICAgIHZlcnRleC5uZXh0ID0gbnVsbDsgLy8gdGhlIHRhaWwgaGFzIG5vIHN1YnNlcXVlbnQgdmVydGV4XG5cbiAgICAgIHRoaXMudGFpbCA9IHZlcnRleDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQXBwZW5kcyBhIGNoYWluIG9mIHZlcnRpY2VzIHdoZXJlICd2ZXJ0ZXgnIGlzIHRoZSBoZWFkLlxuICAgIGFwcGVuZENoYWluOiBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHZlcnRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gdmVydGV4O1xuICAgICAgfVxuXG4gICAgICB2ZXJ0ZXgucHJldiA9IHRoaXMudGFpbDsgLy8gZW5zdXJlIHRoYXQgdGhlICd0YWlsJyByZWZlcmVuY2UgcG9pbnRzIHRvIHRoZSBsYXN0IHZlcnRleCBvZiB0aGUgY2hhaW5cblxuICAgICAgd2hpbGUgKHZlcnRleC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHZlcnRleCA9IHZlcnRleC5uZXh0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhaWwgPSB2ZXJ0ZXg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFJlbW92ZXMgYSB2ZXJ0ZXggZnJvbSB0aGUgbGlua2VkIGxpc3RcbiAgICByZW1vdmU6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIGlmICh2ZXJ0ZXgucHJldiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB2ZXJ0ZXgubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnRleC5wcmV2Lm5leHQgPSB2ZXJ0ZXgubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRleC5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGFpbCA9IHZlcnRleC5wcmV2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydGV4Lm5leHQucHJldiA9IHZlcnRleC5wcmV2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFJlbW92ZXMgYSBsaXN0IG9mIHZlcnRpY2VzIHdob3NlICdoZWFkJyBpcyAnYScgYW5kIHdob3NlICd0YWlsJyBpcyBiXG4gICAgcmVtb3ZlU3ViTGlzdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhLnByZXYgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gYi5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYS5wcmV2Lm5leHQgPSBiLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChiLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy50YWlsID0gYS5wcmV2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5uZXh0LnByZXYgPSBhLnByZXY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZCA9PT0gbnVsbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQ29udmV4SHVsbDtcbn0oKTtcblxuY29uc3QgX3YxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuY29uc3QgX3YyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuY29uc3QgX3ExID0gbmV3IHRocmVlLlF1YXRlcm5pb24oKTtcbi8qKlxyXG4qIFJldHVybnMgYSBzaW5nbGUgZ2VvbWV0cnkgZm9yIHRoZSBnaXZlbiBvYmplY3QuIElmIHRoZSBvYmplY3QgaXMgY29tcG91bmQsXHJcbiogaXRzIGdlb21ldHJpZXMgYXJlIGF1dG9tYXRpY2FsbHkgbWVyZ2VkLiBCYWtlIHdvcmxkIHNjYWxlIGludG8gZWFjaFxyXG4qIGdlb21ldHJ5LCBiZWNhdXNlIHdlIGNhbid0IGVhc2lseSBhcHBseSB0aGF0IHRvIHRoZSBjYW5ub25qcyBzaGFwZXMgbGF0ZXIuXHJcbiovXG5cblxuZnVuY3Rpb24gZ2V0R2VvbWV0cnkob2JqZWN0KSB7XG4gIGNvbnN0IG1lc2hlcyA9IGdldE1lc2hlcyhvYmplY3QpO1xuICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIFNpbmdsZSBtZXNoLiBSZXR1cm4sIHByZXNlcnZpbmcgb3JpZ2luYWwgdHlwZS5cblxuICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub3JtYWxpemVHZW9tZXRyeShtZXNoZXNbMF0pO1xuICB9IC8vIE11bHRpcGxlIG1lc2hlcy4gTWVyZ2UgYW5kIHJldHVybi5cblxuXG4gIGxldCBtZXNoO1xuICBjb25zdCBnZW9tZXRyaWVzID0gW107XG5cbiAgd2hpbGUgKG1lc2ggPSBtZXNoZXMucG9wKCkpIHtcbiAgICBnZW9tZXRyaWVzLnB1c2goc2ltcGxpZnlHZW9tZXRyeShub3JtYWxpemVHZW9tZXRyeShtZXNoKSkpO1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlQnVmZmVyR2VvbWV0cmllcyhnZW9tZXRyaWVzKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplR2VvbWV0cnkobWVzaCkge1xuICBsZXQgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXG4gIGlmIChnZW9tZXRyeS50b0J1ZmZlckdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS50b0J1ZmZlckdlb21ldHJ5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJlc2VydmUgb3JpZ2luYWwgdHlwZSwgZS5nLiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LlxuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgfVxuXG4gIG1lc2gudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgbWVzaC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3YxLCBfcTEsIF92Mik7XG4gIGdlb21ldHJ5LnNjYWxlKF92Mi54LCBfdjIueSwgX3YyLnopO1xuICByZXR1cm4gZ2VvbWV0cnk7XG59XG4vKipcclxuICogR3JlYXRseSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMuXHJcbiAqIEJlY2F1c2Ugd2Ugb25seSBjYXJlIGFib3V0IHRoZSB2ZXJ0ZXggcG9zaXRpb25zLCBhbmQgbm90IHRoZSBpbmRpY2VzIG9yXHJcbiAqIG90aGVyIGF0dHJpYnV0ZXMsIHdlIHRocm93IGV2ZXJ5dGhpbmcgZWxzZSBhd2F5LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUJ1ZmZlckdlb21ldHJpZXMoZ2VvbWV0cmllcykge1xuICBsZXQgdmVydGV4Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cmllc1tpXS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLml0ZW1TaXplID09PSAzKSB7XG4gICAgICB2ZXJ0ZXhDb3VudCArPSBwb3NpdGlvbi5jb3VudDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwb3NpdGlvbkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDMpO1xuICBsZXQgcG9zaXRpb25PZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cmllc1tpXS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLml0ZW1TaXplID09PSAzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvc2l0aW9uLmNvdW50OyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25BcnJheVtwb3NpdGlvbk9mZnNldCsrXSA9IHBvc2l0aW9uLmdldFgoaik7XG4gICAgICAgIHBvc2l0aW9uQXJyYXlbcG9zaXRpb25PZmZzZXQrK10gPSBwb3NpdGlvbi5nZXRZKGopO1xuICAgICAgICBwb3NpdGlvbkFycmF5W3Bvc2l0aW9uT2Zmc2V0KytdID0gcG9zaXRpb24uZ2V0WihqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyB0aHJlZS5CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BcnJheSwgMykpO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJ0aWNlcyhnZW9tZXRyeSkge1xuICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbi5jb3VudCAqIDMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkrKykge1xuICAgIHZlcnRpY2VzW2kgKiAzXSA9IHBvc2l0aW9uLmdldFgoaSk7XG4gICAgdmVydGljZXNbaSAqIDMgKyAxXSA9IHBvc2l0aW9uLmdldFkoaSk7XG4gICAgdmVydGljZXNbaSAqIDMgKyAyXSA9IHBvc2l0aW9uLmdldFooaSk7XG4gIH1cblxuICByZXR1cm4gdmVydGljZXM7XG59XG4vKipcclxuKiBSZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBUSFJFRS5NZXNoIGluc3RhbmNlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3QuIElmXHJcbiogbmVzdGVkIHRyYW5zZm9ybWF0aW9ucyBhcmUgZm91bmQsIHRoZXkgYXJlIGFwcGxpZWQgdG8gY2hpbGQgbWVzaGVzXHJcbiogYXMgbWVzaC51c2VyRGF0YS5tYXRyaXgsIHNvIHRoYXQgZWFjaCBtZXNoIGhhcyBpdHMgcG9zaXRpb24vcm90YXRpb24vc2NhbGVcclxuKiBpbmRlcGVuZGVudGx5IG9mIGFsbCBvZiBpdHMgcGFyZW50cyBleGNlcHQgdGhlIHRvcC1sZXZlbCBvYmplY3QuXHJcbiovXG5cbmZ1bmN0aW9uIGdldE1lc2hlcyhvYmplY3QpIHtcbiAgY29uc3QgbWVzaGVzID0gW107XG4gIG9iamVjdC50cmF2ZXJzZShmdW5jdGlvbiAobykge1xuICAgIGlmIChvLmlzTWVzaCkge1xuICAgICAgbWVzaGVzLnB1c2gobyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1lc2hlcztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50KHYsIGNvbXBvbmVudCkge1xuICBzd2l0Y2ggKGNvbXBvbmVudCkge1xuICAgIGNhc2UgJ3gnOlxuICAgICAgcmV0dXJuIHYueDtcblxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIHYueTtcblxuICAgIGNhc2UgJ3onOlxuICAgICAgcmV0dXJuIHYuejtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY29tcG9uZW50IFwiICsgY29tcG9uZW50KTtcbn1cbi8qKlxyXG4qIE1vZGlmaWVkIHZlcnNpb24gb2YgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZVZlcnRpY2VzLCBpZ25vcmluZyB2ZXJ0ZXhcclxuKiBhdHRyaWJ1dGVzIG90aGVyIHRoYW4gcG9zaXRpb24uXHJcbipcclxuKiBAcGFyYW0ge1RIUkVFLkJ1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxyXG4qIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2VcclxuKiBAcmV0dXJuIHtUSFJFRS5CdWZmZXJHZW9tZXRyeT59XHJcbiovXG5cbmZ1bmN0aW9uIHNpbXBsaWZ5R2VvbWV0cnkoZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQpIHtcbiAgdG9sZXJhbmNlID0gTWF0aC5tYXgodG9sZXJhbmNlLCBOdW1iZXIuRVBTSUxPTik7IC8vIEdlbmVyYXRlIGFuIGluZGV4IGJ1ZmZlciBpZiB0aGUgZ2VvbWV0cnkgZG9lc24ndCBoYXZlIG9uZSwgb3Igb3B0aW1pemUgaXRcbiAgLy8gaWYgaXQncyBhbHJlYWR5IGF2YWlsYWJsZS5cblxuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50OyAvLyBOZXh0IHZhbHVlIGZvciB0cmlhbmdsZSBpbmRpY2VzLlxuXG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IFtdOyAvLyBDb252ZXJ0IHRoZSBlcnJvciB0b2xlcmFuY2UgdG8gYW4gYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIHRvIHRydW5jYXRlIHRvLlxuXG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7IC8vIEdlbmVyYXRlIGEgaGFzaCBmb3IgdGhlIHZlcnRleCBhdHRyaWJ1dGVzIGF0IHRoZSBjdXJyZW50IGluZGV4ICdpJy5cblxuICAgIGxldCBoYXNoID0gJyc7IC8vIERvdWJsZSB0aWxkZSB0cnVuY2F0ZXMgdGhlIGRlY2ltYWwgdmFsdWUuXG5cbiAgICBoYXNoICs9IH5+KHBvc2l0aW9ucy5nZXRYKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcikgKyBcIixcIjtcbiAgICBoYXNoICs9IH5+KHBvc2l0aW9ucy5nZXRZKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcikgKyBcIixcIjtcbiAgICBoYXNoICs9IH5+KHBvc2l0aW9ucy5nZXRaKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcikgKyBcIixcIjsgLy8gQWRkIGFub3RoZXIgcmVmZXJlbmNlIHRvIHRoZSB2ZXJ0ZXggaWYgaXQncyBhbHJlYWR5XG4gICAgLy8gdXNlZCBieSBhbm90aGVyIGluZGV4LlxuXG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Bvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5nZXRYKGluZGV4KSk7XG4gICAgICBuZXdQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMuZ2V0WShpbmRleCkpO1xuICAgICAgbmV3UG9zaXRpb25zLnB1c2gocG9zaXRpb25zLmdldFooaW5kZXgpKTtcbiAgICAgIGhhc2hUb0luZGV4W2hhc2hdID0gbmV4dEluZGV4O1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKG5leHRJbmRleCk7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH0gLy8gQ29uc3RydWN0IG1lcmdlZCBCdWZmZXJHZW9tZXRyeS5cblxuXG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gbmV3IHRocmVlLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KG5ld1Bvc2l0aW9ucyksIHBvc2l0aW9ucy5pdGVtU2l6ZSwgcG9zaXRpb25zLm5vcm1hbGl6ZWQpO1xuICBjb25zdCByZXN1bHQgPSBuZXcgdGhyZWUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgcmVzdWx0LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSk7XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgUElfMiA9IE1hdGguUEkgLyAyO1xuZXhwb3J0cy5TaGFwZVR5cGUgPSB2b2lkIDA7XG5cbihmdW5jdGlvbiAoU2hhcGVUeXBlKSB7XG4gIFNoYXBlVHlwZVtcIkJPWFwiXSA9IFwiQm94XCI7XG4gIFNoYXBlVHlwZVtcIkNZTElOREVSXCJdID0gXCJDeWxpbmRlclwiO1xuICBTaGFwZVR5cGVbXCJTUEhFUkVcIl0gPSBcIlNwaGVyZVwiO1xuICBTaGFwZVR5cGVbXCJIVUxMXCJdID0gXCJDb252ZXhQb2x5aGVkcm9uXCI7XG4gIFNoYXBlVHlwZVtcIk1FU0hcIl0gPSBcIlRyaW1lc2hcIjtcbn0pKGV4cG9ydHMuU2hhcGVUeXBlIHx8IChleHBvcnRzLlNoYXBlVHlwZSA9IHt9KSk7XG4vKipcclxuICogR2l2ZW4gYSBUSFJFRS5PYmplY3QzRCBpbnN0YW5jZSwgY3JlYXRlcyBwYXJhbWV0ZXJzIGZvciBhIENBTk5PTiBzaGFwZS5cclxuICovXG5cblxuY29uc3QgZ2V0U2hhcGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBnZW9tZXRyeTtcblxuICBpZiAob3B0aW9ucy50eXBlID09PSBleHBvcnRzLlNoYXBlVHlwZS5CT1gpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdCb3hQYXJhbWV0ZXJzKG9iamVjdCk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSBleHBvcnRzLlNoYXBlVHlwZS5DWUxJTkRFUikge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ0N5bGluZGVyUGFyYW1ldGVycyhvYmplY3QsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gZXhwb3J0cy5TaGFwZVR5cGUuU1BIRVJFKSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nU3BoZXJlUGFyYW1ldGVycyhvYmplY3QsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gZXhwb3J0cy5TaGFwZVR5cGUuSFVMTCkge1xuICAgIHJldHVybiBnZXRDb252ZXhQb2x5aGVkcm9uUGFyYW1ldGVycyhvYmplY3QpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gZXhwb3J0cy5TaGFwZVR5cGUuTUVTSCkge1xuICAgIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkob2JqZWN0KTtcbiAgICByZXR1cm4gZ2VvbWV0cnkgPyBnZXRUcmltZXNoUGFyYW1ldGVycyhnZW9tZXRyeSkgOiBudWxsO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltDQU5OT04uZ2V0U2hhcGVQYXJhbWV0ZXJzXSBJbnZhbGlkIHR5cGUgXFxcIlwiICsgb3B0aW9ucy50eXBlICsgXCJcXFwiLlwiKTtcbiAgfVxuXG4gIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkob2JqZWN0KTtcbiAgaWYgKCFnZW9tZXRyeSkgcmV0dXJuIG51bGw7XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnQm94R2VvbWV0cnknOlxuICAgIGNhc2UgJ0JveEJ1ZmZlckdlb21ldHJ5JzpcbiAgICAgIHJldHVybiBnZXRCb3hQYXJhbWV0ZXJzKGdlb21ldHJ5KTtcblxuICAgIGNhc2UgJ0N5bGluZGVyR2VvbWV0cnknOlxuICAgIGNhc2UgJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknOlxuICAgICAgcmV0dXJuIGdldEN5bGluZGVyUGFyYW1ldGVycyhnZW9tZXRyeSk7XG5cbiAgICBjYXNlICdQbGFuZUdlb21ldHJ5JzpcbiAgICBjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcbiAgICAgIHJldHVybiBnZXRQbGFuZVBhcmFtZXRlcnMoZ2VvbWV0cnkpO1xuXG4gICAgY2FzZSAnU3BoZXJlR2VvbWV0cnknOlxuICAgIGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcbiAgICAgIHJldHVybiBnZXRTcGhlcmVQYXJhbWV0ZXJzKGdlb21ldHJ5KTtcblxuICAgIGNhc2UgJ1R1YmVHZW9tZXRyeSc6XG4gICAgY2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuICAgICAgcmV0dXJuIGdldEJvdW5kaW5nQm94UGFyYW1ldGVycyhvYmplY3QpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybignVW5yZWNvZ25pemVkIGdlb21ldHJ5OiBcIiVzXCIuIFVzaW5nIGJvdW5kaW5nIGJveCBhcyBzaGFwZS4nLCBnZW9tZXRyeS50eXBlKTtcbiAgICAgIHJldHVybiBnZXRCb3hQYXJhbWV0ZXJzKGdlb21ldHJ5KTtcbiAgfVxufTtcbi8qKlxyXG4gKiBHaXZlbiBhIFRIUkVFLk9iamVjdDNEIGluc3RhbmNlLCBjcmVhdGVzIGEgY29ycmVzcG9uZGluZyBDQU5OT04gc2hhcGUuXHJcbiAqL1xuXG5jb25zdCB0aHJlZVRvQ2Fubm9uID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHNoYXBlUGFyYW1ldGVycyA9IGdldFNoYXBlUGFyYW1ldGVycyhvYmplY3QsIG9wdGlvbnMpO1xuXG4gIGlmICghc2hhcGVQYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwYXJhbXMsXG4gICAgb2Zmc2V0LFxuICAgIG9yaWVudGF0aW9uXG4gIH0gPSBzaGFwZVBhcmFtZXRlcnM7XG4gIGxldCBzaGFwZTtcblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5TaGFwZVR5cGUuQk9YKSB7XG4gICAgc2hhcGUgPSBjcmVhdGVCb3gocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBleHBvcnRzLlNoYXBlVHlwZS5DWUxJTkRFUikge1xuICAgIHNoYXBlID0gY3JlYXRlQ3lsaW5kZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBleHBvcnRzLlNoYXBlVHlwZS5TUEhFUkUpIHtcbiAgICBzaGFwZSA9IGNyZWF0ZVNwaGVyZShwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IGV4cG9ydHMuU2hhcGVUeXBlLkhVTEwpIHtcbiAgICBzaGFwZSA9IGNyZWF0ZUNvbnZleFBvbHloZWRyb24ocGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBzaGFwZSA9IGNyZWF0ZVRyaW1lc2gocGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2hhcGUsXG4gICAgb2Zmc2V0LFxuICAgIG9yaWVudGF0aW9uXG4gIH07XG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBTaGFwZSBjb25zdHJ1Y3Rpb25cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJveChwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB6XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHNoYXBlID0gbmV3IGNhbm5vbkVzLkJveChuZXcgY2Fubm9uRXMuVmVjMyh4LCB5LCB6KSk7XG4gIHJldHVybiBzaGFwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXIocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICByYWRpdXNUb3AsXG4gICAgcmFkaXVzQm90dG9tLFxuICAgIGhlaWdodCxcbiAgICBzZWdtZW50c1xuICB9ID0gcGFyYW1zO1xuICBjb25zdCBzaGFwZSA9IG5ldyBjYW5ub25Fcy5DeWxpbmRlcihyYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCBzZWdtZW50cyk7IC8vIEluY2x1ZGUgbWV0YWRhdGEgZm9yIHNlcmlhbGl6YXRpb24uXG4gIC8vIFRPRE8oY2xlYW51cCk6IElzIHRoaXMgc3RpbGwgbmVjZXNzYXJ5P1xuXG4gIHNoYXBlLnJhZGl1c1RvcCA9IHJhZGl1c0JvdHRvbTtcbiAgc2hhcGUucmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tO1xuICBzaGFwZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNoYXBlLm51bVNlZ21lbnRzID0gc2VnbWVudHM7XG4gIHJldHVybiBzaGFwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3BoZXJlKHBhcmFtcykge1xuICBjb25zdCBzaGFwZSA9IG5ldyBjYW5ub25Fcy5TcGhlcmUocGFyYW1zLnJhZGl1cyk7XG4gIHJldHVybiBzaGFwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udmV4UG9seWhlZHJvbihwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGZhY2VzLFxuICAgIHZlcnRpY2VzOiB2ZXJ0aWNlc0FycmF5XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHZlcnRpY2VzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmVydGljZXMucHVzaChuZXcgY2Fubm9uRXMuVmVjMyh2ZXJ0aWNlc0FycmF5W2ldLCB2ZXJ0aWNlc0FycmF5W2kgKyAxXSwgdmVydGljZXNBcnJheVtpICsgMl0pKTtcbiAgfVxuXG4gIGNvbnN0IHNoYXBlID0gbmV3IGNhbm5vbkVzLkNvbnZleFBvbHloZWRyb24oe1xuICAgIGZhY2VzLFxuICAgIHZlcnRpY2VzXG4gIH0pO1xuICByZXR1cm4gc2hhcGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyaW1lc2gocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICB2ZXJ0aWNlcyxcbiAgICBpbmRpY2VzXG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHNoYXBlID0gbmV3IGNhbm5vbkVzLlRyaW1lc2godmVydGljZXMsIGluZGljZXMpO1xuICByZXR1cm4gc2hhcGU7XG59XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqIFNoYXBlIHBhcmFtZXRlcnNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Qm94UGFyYW1ldGVycyhnZW9tZXRyeSkge1xuICBjb25zdCB2ZXJ0aWNlcyA9IGdldFZlcnRpY2VzKGdlb21ldHJ5KTtcbiAgaWYgKCF2ZXJ0aWNlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgY29uc3QgYm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3g7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5TaGFwZVR5cGUuQk9YLFxuICAgIHBhcmFtczoge1xuICAgICAgeDogKGJveC5tYXgueCAtIGJveC5taW4ueCkgLyAyLFxuICAgICAgeTogKGJveC5tYXgueSAtIGJveC5taW4ueSkgLyAyLFxuICAgICAgejogKGJveC5tYXgueiAtIGJveC5taW4ueikgLyAyXG4gICAgfVxuICB9O1xufVxuLyoqIEJvdW5kaW5nIGJveCBuZWVkcyB0byBiZSBjb21wdXRlZCB3aXRoIHRoZSBlbnRpcmUgc3VidHJlZSwgbm90IGp1c3QgZ2VvbWV0cnkuICovXG5cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hQYXJhbWV0ZXJzKG9iamVjdCkge1xuICBjb25zdCBjbG9uZSA9IG9iamVjdC5jbG9uZSgpO1xuICBjbG9uZS5xdWF0ZXJuaW9uLnNldCgwLCAwLCAwLCAxKTtcbiAgY2xvbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgY29uc3QgYm94ID0gbmV3IHRocmVlLkJveDMoKS5zZXRGcm9tT2JqZWN0KGNsb25lKTtcbiAgaWYgKCFpc0Zpbml0ZShib3gubWluLmxlbmd0aFNxKCkpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG9jYWxQb3NpdGlvbiA9IGJveC50cmFuc2xhdGUoY2xvbmUucG9zaXRpb24ubmVnYXRlKCkpLmdldENlbnRlcihuZXcgdGhyZWUuVmVjdG9yMygpKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLlNoYXBlVHlwZS5CT1gsXG4gICAgcGFyYW1zOiB7XG4gICAgICB4OiAoYm94Lm1heC54IC0gYm94Lm1pbi54KSAvIDIsXG4gICAgICB5OiAoYm94Lm1heC55IC0gYm94Lm1pbi55KSAvIDIsXG4gICAgICB6OiAoYm94Lm1heC56IC0gYm94Lm1pbi56KSAvIDJcbiAgICB9LFxuICAgIG9mZnNldDogbG9jYWxQb3NpdGlvbi5sZW5ndGhTcSgpID8gbmV3IGNhbm5vbkVzLlZlYzMobG9jYWxQb3NpdGlvbi54LCBsb2NhbFBvc2l0aW9uLnksIGxvY2FsUG9zaXRpb24ueikgOiB1bmRlZmluZWRcbiAgfTtcbn1cbi8qKiBDb21wdXRlcyAzRCBjb252ZXggaHVsbCBhcyBhIENBTk5PTi5Db252ZXhQb2x5aGVkcm9uLiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbnZleFBvbHloZWRyb25QYXJhbWV0ZXJzKG9iamVjdCkge1xuICBjb25zdCBnZW9tZXRyeSA9IGdldEdlb21ldHJ5KG9iamVjdCk7XG4gIGlmICghZ2VvbWV0cnkpIHJldHVybiBudWxsOyAvLyBQZXJ0dXJiLlxuXG4gIGNvbnN0IGVwcyA9IDFlLTQ7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWihpLCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmdldFgoaSkgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBlcHMsIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uZ2V0WShpKSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGVwcywgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5nZXRaKGkpICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogZXBzKTtcbiAgfSAvLyBDb21wdXRlIHRoZSAzRCBjb252ZXggaHVsbC5cblxuXG4gIGNvbnN0IGh1bGwgPSBuZXcgQ29udmV4SHVsbCgpLnNldEZyb21PYmplY3QobmV3IHRocmVlLk1lc2goZ2VvbWV0cnkpKTtcbiAgY29uc3QgaHVsbEZhY2VzID0gaHVsbC5mYWNlcztcbiAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgY29uc3QgZmFjZXMgPSBbXTtcbiAgbGV0IGN1cnJlbnRGYWNlVmVydGV4ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bGxGYWNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGh1bGxGYWNlID0gaHVsbEZhY2VzW2ldO1xuICAgIGNvbnN0IGZhY2UgPSBbXTtcbiAgICBmYWNlcy5wdXNoKGZhY2UpO1xuICAgIGxldCBlZGdlID0gaHVsbEZhY2UuZWRnZTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gZWRnZS5oZWFkKCkucG9pbnQ7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKHBvaW50LngsIHBvaW50LnksIHBvaW50LnopO1xuICAgICAgZmFjZS5wdXNoKGN1cnJlbnRGYWNlVmVydGV4KTtcbiAgICAgIGN1cnJlbnRGYWNlVmVydGV4Kys7XG4gICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgIH0gd2hpbGUgKGVkZ2UgIT09IGh1bGxGYWNlLmVkZ2UpO1xuICB9XG5cbiAgY29uc3QgdmVydGljZXNUeXBlZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGgpO1xuICB2ZXJ0aWNlc1R5cGVkQXJyYXkuc2V0KHZlcnRpY2VzKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLlNoYXBlVHlwZS5IVUxMLFxuICAgIHBhcmFtczoge1xuICAgICAgdmVydGljZXM6IHZlcnRpY2VzVHlwZWRBcnJheSxcbiAgICAgIGZhY2VzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDeWxpbmRlclBhcmFtZXRlcnMoZ2VvbWV0cnkpIHtcbiAgY29uc3QgcGFyYW1zID0gZ2VvbWV0cnkucGFyYW1ldGVycztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLlNoYXBlVHlwZS5DWUxJTkRFUixcbiAgICBwYXJhbXM6IHtcbiAgICAgIHJhZGl1c1RvcDogcGFyYW1zLnJhZGl1c1RvcCxcbiAgICAgIHJhZGl1c0JvdHRvbTogcGFyYW1zLnJhZGl1c0JvdHRvbSxcbiAgICAgIGhlaWdodDogcGFyYW1zLmhlaWdodCxcbiAgICAgIHNlZ21lbnRzOiBwYXJhbXMucmFkaWFsU2VnbWVudHNcbiAgICB9LFxuICAgIG9yaWVudGF0aW9uOiBuZXcgY2Fubm9uRXMuUXVhdGVybmlvbigpLnNldEZyb21FdWxlcih0aHJlZS5NYXRoVXRpbHMuZGVnVG9SYWQoLTkwKSwgMCwgMCwgJ1hZWicpLm5vcm1hbGl6ZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ3lsaW5kZXJQYXJhbWV0ZXJzKG9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBheGVzID0gWyd4JywgJ3knLCAneiddO1xuICBjb25zdCBtYWpvckF4aXMgPSBvcHRpb25zLmN5bGluZGVyQXhpcyB8fCAneSc7XG4gIGNvbnN0IG1pbm9yQXhlcyA9IGF4ZXMuc3BsaWNlKGF4ZXMuaW5kZXhPZihtYWpvckF4aXMpLCAxKSAmJiBheGVzO1xuICBjb25zdCBib3ggPSBuZXcgdGhyZWUuQm94MygpLnNldEZyb21PYmplY3Qob2JqZWN0KTtcbiAgaWYgKCFpc0Zpbml0ZShib3gubWluLmxlbmd0aFNxKCkpKSByZXR1cm4gbnVsbDsgLy8gQ29tcHV0ZSBjeWxpbmRlciBkaW1lbnNpb25zLlxuXG4gIGNvbnN0IGhlaWdodCA9IGJveC5tYXhbbWFqb3JBeGlzXSAtIGJveC5taW5bbWFqb3JBeGlzXTtcbiAgY29uc3QgcmFkaXVzID0gMC41ICogTWF0aC5tYXgoZ2V0Q29tcG9uZW50KGJveC5tYXgsIG1pbm9yQXhlc1swXSkgLSBnZXRDb21wb25lbnQoYm94Lm1pbiwgbWlub3JBeGVzWzBdKSwgZ2V0Q29tcG9uZW50KGJveC5tYXgsIG1pbm9yQXhlc1sxXSkgLSBnZXRDb21wb25lbnQoYm94Lm1pbiwgbWlub3JBeGVzWzFdKSk7XG4gIGNvbnN0IGV1bGVyWCA9IG1ham9yQXhpcyA9PT0gJ3knID8gUElfMiA6IDA7XG4gIGNvbnN0IGV1bGVyWSA9IG1ham9yQXhpcyA9PT0gJ3onID8gUElfMiA6IDA7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5TaGFwZVR5cGUuQ1lMSU5ERVIsXG4gICAgcGFyYW1zOiB7XG4gICAgICByYWRpdXNUb3A6IHJhZGl1cyxcbiAgICAgIHJhZGl1c0JvdHRvbTogcmFkaXVzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2VnbWVudHM6IDEyXG4gICAgfSxcbiAgICBvcmllbnRhdGlvbjogbmV3IGNhbm5vbkVzLlF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoZXVsZXJYLCBldWxlclksIDAsICdYWVonKS5ub3JtYWxpemUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQbGFuZVBhcmFtZXRlcnMoZ2VvbWV0cnkpIHtcbiAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gIGNvbnN0IGJveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuU2hhcGVUeXBlLkJPWCxcbiAgICBwYXJhbXM6IHtcbiAgICAgIHg6IChib3gubWF4LnggLSBib3gubWluLngpIC8gMiB8fCAwLjEsXG4gICAgICB5OiAoYm94Lm1heC55IC0gYm94Lm1pbi55KSAvIDIgfHwgMC4xLFxuICAgICAgejogKGJveC5tYXgueiAtIGJveC5taW4ueikgLyAyIHx8IDAuMVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BoZXJlUGFyYW1ldGVycyhnZW9tZXRyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuU2hhcGVUeXBlLlNQSEVSRSxcbiAgICBwYXJhbXM6IHtcbiAgICAgIHJhZGl1czogZ2VvbWV0cnkucGFyYW1ldGVycy5yYWRpdXNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nU3BoZXJlUGFyYW1ldGVycyhvYmplY3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3BoZXJlUmFkaXVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGV4cG9ydHMuU2hhcGVUeXBlLlNQSEVSRSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICByYWRpdXM6IG9wdGlvbnMuc3BoZXJlUmFkaXVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkob2JqZWN0KTtcbiAgaWYgKCFnZW9tZXRyeSkgcmV0dXJuIG51bGw7XG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuU2hhcGVUeXBlLlNQSEVSRSxcbiAgICBwYXJhbXM6IHtcbiAgICAgIHJhZGl1czogZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUcmltZXNoUGFyYW1ldGVycyhnZW9tZXRyeSkge1xuICBjb25zdCB2ZXJ0aWNlcyA9IGdldFZlcnRpY2VzKGdlb21ldHJ5KTtcbiAgaWYgKCF2ZXJ0aWNlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgIGluZGljZXNbaV0gPSBpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLlNoYXBlVHlwZS5NRVNILFxuICAgIHBhcmFtczoge1xuICAgICAgdmVydGljZXMsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmdldFNoYXBlUGFyYW1ldGVycyA9IGdldFNoYXBlUGFyYW1ldGVycztcbmV4cG9ydHMudGhyZWVUb0Nhbm5vbiA9IHRocmVlVG9DYW5ub247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlZS10by1jYW5ub24uY2pzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIiLCIvLyBtb2R1bGUgZmFjdG9yaWVzIGFyZSB1c2VkIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXguanNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=